var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
import Plotly from "https://cdn.jsdelivr.net/npm/plotly.js-dist-min@2.26.0/+esm";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    const e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (const k in e) {
        if (k !== "default" && !(k in n)) {
          const d2 = Object.getOwnPropertyDescriptor(e, k);
          if (d2) {
            Object.defineProperty(n, k, d2.get ? d2 : {
              enumerable: true,
              get: () => e[k]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal$1 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReact_production_min;
function requireReact_production_min() {
  if (hasRequiredReact_production_min) return react_production_min;
  hasRequiredReact_production_min = 1;
  var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r2 = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x2 = Symbol.for("react.memo"), y2 = Symbol.for("react.lazy"), z = Symbol.iterator;
  function A(a) {
    if (null === a || "object" !== typeof a) return null;
    a = z && a[z] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var B = { isMounted: function() {
    return false;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, D = {};
  function E(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  E.prototype.isReactComponent = {};
  E.prototype.setState = function(a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, a, b, "setState");
  };
  E.prototype.forceUpdate = function(a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };
  function F() {
  }
  F.prototype = E.prototype;
  function G(a, b, e) {
    this.props = a;
    this.context = b;
    this.refs = D;
    this.updater = e || B;
  }
  var H = G.prototype = new F();
  H.constructor = G;
  C(H, E.prototype);
  H.isPureReactComponent = true;
  var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
  function M(a, b, e) {
    var d2, c = {}, k = null, h = null;
    if (null != b) for (d2 in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d2) && !L.hasOwnProperty(d2) && (c[d2] = b[d2]);
    var g = arguments.length - 2;
    if (1 === g) c.children = e;
    else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
      c.children = f;
    }
    if (a && a.defaultProps) for (d2 in g = a.defaultProps, g) void 0 === c[d2] && (c[d2] = g[d2]);
    return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
  }
  function N(a, b) {
    return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
  }
  function O(a) {
    return "object" === typeof a && null !== a && a.$$typeof === l;
  }
  function escape(a) {
    var b = { "=": "=0", ":": "=2" };
    return "$" + a.replace(/[=:]/g, function(a2) {
      return b[a2];
    });
  }
  var P = /\/+/g;
  function Q(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
  }
  function R(a, b, e, d2, c) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = false;
    if (null === a) h = true;
    else switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case l:
          case n:
            h = true;
        }
    }
    if (h) return h = a, c = c(h), a = "" === d2 ? "." + Q(h, 0) : d2, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
      return a2;
    })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
    h = 0;
    d2 = "" === d2 ? "." : d2 + ":";
    if (I(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = d2 + Q(k, g);
      h += R(k, b, e, f, c);
    }
    else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d2 + Q(k, g++), h += R(k, b, e, f, c);
    else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
    return h;
  }
  function S(a, b, e) {
    if (null == a) return a;
    var d2 = [], c = 0;
    R(a, d2, "", "", function(a2) {
      return b.call(e, a2, c++);
    });
    return d2;
  }
  function T(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      b.then(function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
      }, function(b2) {
        if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
      });
      -1 === a._status && (a._status = 0, a._result = b);
    }
    if (1 === a._status) return a._result.default;
    throw a._result;
  }
  var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
  function X() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  react_production_min.Children = { map: S, forEach: function(a, b, e) {
    S(a, function() {
      b.apply(this, arguments);
    }, e);
  }, count: function(a) {
    var b = 0;
    S(a, function() {
      b++;
    });
    return b;
  }, toArray: function(a) {
    return S(a, function(a2) {
      return a2;
    }) || [];
  }, only: function(a) {
    if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
    return a;
  } };
  react_production_min.Component = E;
  react_production_min.Fragment = p;
  react_production_min.Profiler = r2;
  react_production_min.PureComponent = G;
  react_production_min.StrictMode = q;
  react_production_min.Suspense = w;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
  react_production_min.act = X;
  react_production_min.cloneElement = function(a, b, e) {
    if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
    var d2 = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = K.current);
      void 0 !== b.key && (c = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
      for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d2[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
    var f = arguments.length - 2;
    if (1 === f) d2.children = e;
    else if (1 < f) {
      g = Array(f);
      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
      d2.children = g;
    }
    return { $$typeof: l, type: a.type, key: c, ref: k, props: d2, _owner: h };
  };
  react_production_min.createContext = function(a) {
    a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
    a.Provider = { $$typeof: t, _context: a };
    return a.Consumer = a;
  };
  react_production_min.createElement = M;
  react_production_min.createFactory = function(a) {
    var b = M.bind(null, a);
    b.type = a;
    return b;
  };
  react_production_min.createRef = function() {
    return { current: null };
  };
  react_production_min.forwardRef = function(a) {
    return { $$typeof: v, render: a };
  };
  react_production_min.isValidElement = O;
  react_production_min.lazy = function(a) {
    return { $$typeof: y2, _payload: { _status: -1, _result: a }, _init: T };
  };
  react_production_min.memo = function(a, b) {
    return { $$typeof: x2, type: a, compare: void 0 === b ? null : b };
  };
  react_production_min.startTransition = function(a) {
    var b = V.transition;
    V.transition = {};
    try {
      a();
    } finally {
      V.transition = b;
    }
  };
  react_production_min.unstable_act = X;
  react_production_min.useCallback = function(a, b) {
    return U.current.useCallback(a, b);
  };
  react_production_min.useContext = function(a) {
    return U.current.useContext(a);
  };
  react_production_min.useDebugValue = function() {
  };
  react_production_min.useDeferredValue = function(a) {
    return U.current.useDeferredValue(a);
  };
  react_production_min.useEffect = function(a, b) {
    return U.current.useEffect(a, b);
  };
  react_production_min.useId = function() {
    return U.current.useId();
  };
  react_production_min.useImperativeHandle = function(a, b, e) {
    return U.current.useImperativeHandle(a, b, e);
  };
  react_production_min.useInsertionEffect = function(a, b) {
    return U.current.useInsertionEffect(a, b);
  };
  react_production_min.useLayoutEffect = function(a, b) {
    return U.current.useLayoutEffect(a, b);
  };
  react_production_min.useMemo = function(a, b) {
    return U.current.useMemo(a, b);
  };
  react_production_min.useReducer = function(a, b, e) {
    return U.current.useReducer(a, b, e);
  };
  react_production_min.useRef = function(a) {
    return U.current.useRef(a);
  };
  react_production_min.useState = function(a) {
    return U.current.useState(a);
  };
  react_production_min.useSyncExternalStore = function(a, b, e) {
    return U.current.useSyncExternalStore(a, b, e);
  };
  react_production_min.useTransition = function() {
    return U.current.useTransition();
  };
  react_production_min.version = "18.3.1";
  return react_production_min;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production_min();
  }
  return react.exports;
}
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  if (hasRequiredScheduler_production_min) return scheduler_production_min;
  hasRequiredScheduler_production_min = 1;
  (function(exports) {
    function f(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d2 = c - 1 >>> 1, e = a[d2];
        if (0 < g(e, b)) a[d2] = b, a[c] = e, c = d2;
        else break a;
      }
    }
    function h(a) {
      return 0 === a.length ? null : a[0];
    }
    function k(a) {
      if (0 === a.length) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d2 = 0, e = a.length, w = e >>> 1; d2 < w; ) {
          var m = 2 * (d2 + 1) - 1, C = a[m], n = m + 1, x2 = a[n];
          if (0 > g(C, c)) n < e && 0 > g(x2, C) ? (a[d2] = x2, a[n] = c, d2 = n) : (a[d2] = C, a[m] = c, d2 = m);
          else if (n < e && 0 > g(x2, c)) a[d2] = x2, a[n] = c, d2 = n;
          else break a;
        }
      }
      return b;
    }
    function g(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return 0 !== c ? c : a.id - b.id;
    }
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var l = performance;
      exports.unstable_now = function() {
        return l.now();
      };
    } else {
      var p = Date, q = p.now();
      exports.unstable_now = function() {
        return p.now() - q;
      };
    }
    var r2 = [], t = [], u = 1, v = null, y2 = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
    "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G(a) {
      for (var b = h(t); null !== b; ) {
        if (null === b.callback) k(t);
        else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r2, b);
        else break;
        b = h(t);
      }
    }
    function H(a) {
      B = false;
      G(a);
      if (!A) if (null !== h(r2)) A = true, I(J);
      else {
        var b = h(t);
        null !== b && K(H, b.startTime - a);
      }
    }
    function J(a, b) {
      A = false;
      B && (B = false, E(L), L = -1);
      z = true;
      var c = y2;
      try {
        G(b);
        for (v = h(r2); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
          var d2 = v.callback;
          if ("function" === typeof d2) {
            v.callback = null;
            y2 = v.priorityLevel;
            var e = d2(v.expirationTime <= b);
            b = exports.unstable_now();
            "function" === typeof e ? v.callback = e : v === h(r2) && k(r2);
            G(b);
          } else k(r2);
          v = h(r2);
        }
        if (null !== v) var w = true;
        else {
          var m = h(t);
          null !== m && K(H, m.startTime - b);
          w = false;
        }
        return w;
      } finally {
        v = null, y2 = c, z = false;
      }
    }
    var N = false, O = null, L = -1, P = 5, Q = -1;
    function M() {
      return exports.unstable_now() - Q < P ? false : true;
    }
    function R() {
      if (null !== O) {
        var a = exports.unstable_now();
        Q = a;
        var b = true;
        try {
          b = O(true, a);
        } finally {
          b ? S() : (N = false, O = null);
        }
      } else N = false;
    }
    var S;
    if ("function" === typeof F) S = function() {
      F(R);
    };
    else if ("undefined" !== typeof MessageChannel) {
      var T = new MessageChannel(), U = T.port2;
      T.port1.onmessage = R;
      S = function() {
        U.postMessage(null);
      };
    } else S = function() {
      D(R, 0);
    };
    function I(a) {
      O = a;
      N || (N = true, S());
    }
    function K(a, b) {
      L = D(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    };
    exports.unstable_continueExecution = function() {
      A || z || (A = true, I(J));
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    };
    exports.unstable_getFirstCallbackNode = function() {
      return h(r2);
    };
    exports.unstable_next = function(a) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y2;
      }
      var c = y2;
      y2 = b;
      try {
        return a();
      } finally {
        y2 = c;
      }
    };
    exports.unstable_pauseExecution = function() {
    };
    exports.unstable_requestPaint = function() {
    };
    exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y2;
      y2 = a;
      try {
        return b();
      } finally {
        y2 = c;
      }
    };
    exports.unstable_scheduleCallback = function(a, b, c) {
      var d2 = exports.unstable_now();
      "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d2 + c : d2) : c = d2;
      switch (a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      e = c + e;
      a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
      c > d2 ? (a.sortIndex = c, f(t, a), null === h(r2) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d2))) : (a.sortIndex = e, f(r2, a), A || z || (A = true, I(J)));
      return a;
    };
    exports.unstable_shouldYield = M;
    exports.unstable_wrapCallback = function(a) {
      var b = y2;
      return function() {
        var c = y2;
        y2 = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y2 = c;
        }
      };
    };
  })(scheduler_production_min);
  return scheduler_production_min;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production_min();
  }
  return scheduler.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = requireReact(), ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b);
    ha(a + "Capture", b);
  }
  function ha(a, b) {
    ea[a] = b;
    for (a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    if (ja.call(ma, a)) return true;
    if (ja.call(la, a)) return false;
    if (ka.test(a)) return ma[a] = true;
    la[a] = true;
    return false;
  }
  function pa(a, b, c, d2) {
    if (null !== c && 0 === c.type) return false;
    switch (typeof b) {
      case "function":
      case "symbol":
        return true;
      case "boolean":
        if (d2) return false;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;
      default:
        return false;
    }
  }
  function qa(a, b, c, d2) {
    if (null === b || "undefined" === typeof b || pa(a, b, c, d2)) return true;
    if (d2) return false;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return false === b;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return false;
  }
  function v(a, b, c, d2, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d2;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }
  var z = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z[a] = new v(a, 0, false, a, null, false, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z[b] = new v(b, 1, false, a[1], null, false, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z[a] = new v(a, 2, false, a, null, false, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z[a] = new v(a, 3, true, a, null, false, false);
  });
  ["capture", "download"].forEach(function(a) {
    z[a] = new v(a, 4, false, a, null, false, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(a) {
    z[a] = new v(a, 6, false, a, null, false, false);
  });
  ["rowSpan", "start"].forEach(function(a) {
    z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z[b] = new v(b, 1, false, a, null, false, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
  });
  z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
  ["src", "href", "action", "formAction"].forEach(function(a) {
    z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
  });
  function ta(a, b, c, d2) {
    var e = z.hasOwnProperty(b) ? z[b] : null;
    if (null !== e ? 0 !== e.type : d2 || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d2) && (c = null), d2 || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d2 = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d2 ? a.setAttributeNS(d2, b, c) : a.setAttribute(b, c)));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
  var Ia = Symbol.for("react.offscreen");
  var Ja = Symbol.iterator;
  function Ka(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ja && a[Ja] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }
  var A = Object.assign, La;
  function Ma(a) {
    if (void 0 === La) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return "\n" + La + a;
  }
  var Na = false;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = true;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l) {
          var d2 = l;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l) {
          d2 = l;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l) {
          d2 = l;
        }
        a();
      }
    } catch (l) {
      if (l && d2 && "string" === typeof l.stack) {
        for (var e = l.stack.split("\n"), f = d2.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h]) {
                var k = "\n" + e[g].replace(" at new ", " at ");
                a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                return k;
              }
            while (1 <= g && 0 <= h);
          }
          break;
        }
      }
    } finally {
      Na = false, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, false), a;
      case 11:
        return a = Oa(a.type.render, false), a;
      case 1:
        return a = Oa(a.type, true), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if ("object" === typeof a) switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        a = a.displayName;
        a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
        return a;
      case Ga:
        return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload;
        a = a._init;
        try {
          return Qa(a(b));
        } catch (c) {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if ("function" === typeof b) return b.displayName || b.name || null;
        if ("string" === typeof b) return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d2 = "" + a[b];
    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get, f = c.set;
      Object.defineProperty(a, b, { configurable: true, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d2 = "" + a2;
        f.call(this, a2);
      } });
      Object.defineProperty(a, b, { enumerable: c.enumerable });
      return { getValue: function() {
        return d2;
      }, setValue: function(a2) {
        d2 = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null;
        delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return false;
    var b = a._valueTracker;
    if (!b) return true;
    var c = b.getValue();
    var d2 = "";
    a && (d2 = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d2;
    return a !== c ? (b.setValue(a), true) : false;
  }
  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;
    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue, d2 = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = { initialChecked: d2, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
  }
  function ab(a, b) {
    b = b.checked;
    null != b && ta(a, "checked", b, false);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d2 = b.type;
    if (null != c) if ("number" === d2) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
    else if ("submit" === d2 || "reset" === d2) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d2 = b.type;
      if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }
    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }
  function cb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }
  var eb = Array.isArray;
  function fb(a, b, c, d2) {
    a = a.options;
    if (b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d2 && (a[c].defaultSelected = true);
    } else {
      c = "" + Sa(c);
      b = null;
      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = true;
          d2 && (a[e].defaultSelected = true);
          return;
        }
        null !== b || a[e].disabled || (b = a[e]);
      }
      null !== b && (b.selected = true);
    }
  }
  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
    return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (null == c) {
      c = b.children;
      b = b.defaultValue;
      if (null != c) {
        if (null != b) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      null == b && (b = "");
      c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d2 = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d2 && (a.defaultValue = "" + d2);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d2, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d2, e);
      });
    } : a;
  }(function(a, b) {
    if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
    else {
      mb = mb || document.createElement("div");
      mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
      for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: true,
    aspectRatio: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridArea: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d2 = 0 === c.indexOf("--"), e = rb(c, b[c], d2);
      "float" === c && (c = "cssFloat");
      d2 ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(p(60));
        if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var wb = null;
  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = false;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = true;
    try {
      return Gb(a, b, c);
    } finally {
      if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d2 = Db(c);
    if (null === d2) return null;
    c = d2[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a = a.type, d2 = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d2;
        break a;
      default:
        a = false;
    }
    if (a) return null;
    if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = false;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a) {
    Lb = false;
  }
  function Nb(a, b, c, d2, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l);
    } catch (m) {
      this.onError(m);
    }
  }
  var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
    Ob = true;
    Pb = a;
  } };
  function Tb(a, b, c, d2, e, f, g, h, k) {
    Ob = false;
    Pb = null;
    Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d2, e, f, g, h, k) {
    Tb.apply(this, arguments);
    if (Ob) {
      if (Ob) {
        var l = Pb;
        Ob = false;
        Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = true, Rb = l);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
      while (a);
    }
    return 3 === b.tag ? c : null;
  }
  function Wb(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      b = Vb(a);
      if (null === b) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d2 = b; ; ) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;
      if (null === f) {
        d2 = e.return;
        if (null !== d2) {
          c = d2;
          continue;
        }
        break;
      }
      if (e.child === f.child) {
        for (f = e.child; f; ) {
          if (f === c) return Xb(e), a;
          if (f === d2) return Xb(e), b;
          f = f.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d2.return) c = e, d2 = f;
      else {
        for (var g = false, h = e.child; h; ) {
          if (h === c) {
            g = true;
            c = e;
            d2 = f;
            break;
          }
          if (h === d2) {
            g = true;
            d2 = e;
            c = f;
            break;
          }
          h = h.sibling;
        }
        if (!g) {
          for (h = f.child; h; ) {
            if (h === c) {
              g = true;
              c = f;
              d2 = e;
              break;
            }
            if (h === d2) {
              g = true;
              d2 = f;
              c = e;
              break;
            }
            h = h.sibling;
          }
          if (!g) throw Error(p(189));
        }
      }
      if (c.alternate !== d2) throw Error(p(190));
    }
    if (3 !== c.tag) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    a = Yb(a);
    return null !== a ? $b(a) : null;
  }
  function $b(a) {
    if (5 === a.tag || 6 === a.tag) return a;
    for (a = a.child; null !== a; ) {
      var b = $b(a);
      if (null !== b) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && "function" === typeof lc.onCommitFiberRoot) try {
      lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
    } catch (b) {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    a >>>= 0;
    return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return 0;
    var d2 = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
    if (0 !== g) {
      var h = g & ~e;
      0 !== h ? d2 = tc(h) : (f &= g, 0 !== f && (d2 = tc(f)));
    } else g = c & ~e, 0 !== g ? d2 = tc(g) : 0 !== f && (d2 = tc(f));
    if (0 === d2) return 0;
    if (0 !== b && b !== d2 && 0 === (b & e) && (e = d2 & -d2, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
    0 !== (d2 & 4) && (d2 |= c & 16);
    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d2; 0 < b; ) c = 31 - oc(b), e = 1 << c, d2 |= a[c], b &= ~e;
    return d2;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d2 = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
      var g = 31 - oc(f), h = 1 << g, k = e[g];
      if (-1 === k) {
        if (0 === (h & c) || 0 !== (h & d2)) e[g] = vc(h, b);
      } else k <= b && (a.expiredLanes |= h);
      f &= ~h;
    }
  }
  function xc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    rc <<= 1;
    0 === (rc & 4194240) && (rc = 64);
    return a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b;
    536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
    a = a.eventTimes;
    b = 31 - oc(b);
    a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= b;
    a.mutableReadLanes &= b;
    a.entangledLanes &= b;
    b = a.entanglements;
    var d2 = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f = 1 << e;
      b[e] = 0;
      d2[e] = -1;
      a[e] = -1;
      c &= ~f;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d2 = 31 - oc(c), e = 1 << d2;
      e & b | a[d2] & b && (a[d2] |= b);
      c &= ~e;
    }
  }
  var C = 0;
  function Dc(a) {
    a &= -a;
    return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d2, e, f) {
    if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d2, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
    a.eventSystemFlags |= d2;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }
  function Uc(a, b, c, d2, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d2, e), true;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d2, e), true;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d2, e), true;
      case "pointerover":
        var f = e.pointerId;
        Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d2, e));
        return true;
      case "gotpointercapture":
        return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d2, e)), true;
    }
    return false;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (null !== b) {
      var c = Vb(b);
      if (null !== c) {
        if (b = c.tag, 13 === b) {
          if (b = Wb(c), null !== b) {
            a.blockedOn = b;
            Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (null !== a.blockedOn) return false;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null === c) {
        c = a.nativeEvent;
        var d2 = new c.constructor(c.type, c);
        wb = d2;
        c.target.dispatchEvent(d2);
        wb = null;
      } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
      b.shift();
    }
    return true;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = false;
    null !== Lc && Xc(Lc) && (Lc = null);
    null !== Mc && Xc(Mc) && (Mc = null);
    null !== Nc && Xc(Nc) && (Nc = null);
    Oc.forEach(Zc);
    Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d2 = Kc[c];
        d2.blockedOn === a && (d2.blockedOn = null);
      }
    }
    null !== Lc && ad(Lc, a);
    null !== Mc && ad(Mc, a);
    null !== Nc && ad(Nc, a);
    Oc.forEach(b);
    Pc.forEach(b);
    for (c = 0; c < Qc.length; c++) d2 = Qc[c], d2.blockedOn === a && (d2.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd = true;
  function ed(a, b, c, d2) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 1, fd(a, b, c, d2);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function gd(a, b, c, d2) {
    var e = C, f = cd.transition;
    cd.transition = null;
    try {
      C = 4, fd(a, b, c, d2);
    } finally {
      C = e, cd.transition = f;
    }
  }
  function fd(a, b, c, d2) {
    if (dd) {
      var e = Yc(a, b, c, d2);
      if (null === e) hd(a, b, d2, id2, c), Sc(a, d2);
      else if (Uc(e, a, b, c, d2)) d2.stopPropagation();
      else if (Sc(a, d2), b & 4 && -1 < Rc.indexOf(a)) {
        for (; null !== e; ) {
          var f = Cb(e);
          null !== f && Ec(f);
          f = Yc(a, b, c, d2);
          null === f && hd(a, b, d2, id2, c);
          if (f === e) break;
          e = f;
        }
        null !== e && d2.stopPropagation();
      } else hd(a, b, d2, null, c);
    }
  }
  var id2 = null;
  function Yc(a, b, c, d2) {
    id2 = null;
    a = xb(d2);
    a = Wc(a);
    if (null !== a) if (b = Vb(a), null === b) a = null;
    else if (c = b.tag, 13 === c) {
      a = Wb(b);
      if (null !== a) return a;
      a = null;
    } else if (3 === c) {
      if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    id2 = a;
    return null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d2, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g = c - a;
    for (d2 = 1; d2 <= g && b[c - d2] === e[f - d2]; d2++) ;
    return md = e.slice(a, 1 < d2 ? 1 - d2 : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }
  function pd() {
    return true;
  }
  function qd() {
    return false;
  }
  function rd(a) {
    function b(b2, d2, e, f, g) {
      this._reactName = b2;
      this._targetInst = e;
      this.type = d2;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }
    A(b.prototype, { preventDefault: function() {
      this.defaultPrevented = true;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd });
    return b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
  }
  function zd() {
    return Pd;
  }
  var Qd = A({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }
    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return "keypress" === a.type ? od(a) : 0;
  }, keyCode: function(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
  ia && "documentMode" in document && (be = document.documentMode);
  var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);
      case "keydown":
        return 229 !== b.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }
  var ie = false;
  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);
      case "keypress":
        if (32 !== b.which) return null;
        fe = true;
        return ee;
      case "textInput":
        return a = b.data, a === ee && fe ? null : a;
      default:
        return null;
    }
  }
  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;
      default:
        return null;
    }
  }
  var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
  }
  function ne(a, b, c, d2) {
    Eb(d2);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d2), a.push({ event: c, listeners: b }));
  }
  var pe = null, qe = null;
  function re(a) {
    se(a, 0);
  }
  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }
  function ve(a, b) {
    if ("change" === a) return b;
  }
  var we = false;
  if (ia) {
    var xe;
    if (ia) {
      var ye = "oninput" in document;
      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }
      xe = ye;
    } else xe = false;
    we = xe && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }
  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      Jb(re, b);
    }
  }
  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }
  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }
  function Ee(a, b) {
    if ("click" === a) return te(b);
  }
  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }
  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He = "function" === typeof Object.is ? Object.is : Ge;
  function Ie(a, b) {
    if (He(a, b)) return true;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
    var c = Object.keys(a), d2 = Object.keys(b);
    if (c.length !== d2.length) return false;
    for (d2 = 0; d2 < c.length; d2++) {
      var e = c[d2];
      if (!ja.call(b, e) || !He(a[e], b[e])) return false;
    }
    return true;
  }
  function Je(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke(a, b) {
    var c = Je(a);
    a = 0;
    for (var d2; c; ) {
      if (3 === c.nodeType) {
        d2 = a + c.textContent.length;
        if (a <= b && d2 >= b) return { node: c, offset: b - a };
        a = d2;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
  }
  function Me() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d2) {
        c = false;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }
  function Oe(a) {
    var b = Me(), c = a.focusedElem, d2 = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (null !== d2 && Ne(c)) {
        if (b = d2.start, a = d2.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f = Math.min(d2.start, e);
          d2 = void 0 === d2.end ? f : Math.min(d2.end, e);
          !a.extend && f > d2 && (e = d2, d2 = f, f = e);
          e = Ke(c, f);
          var g = Ke(
            c,
            d2
          );
          e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d2 ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
        }
      }
      b = [];
      for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      "function" === typeof c.focus && c.focus();
      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
  function Ue(a, b, c) {
    var d2 = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d2 }), b.target = Qe)));
  }
  function Ve(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }
  var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
  function Ze(a) {
    if (Xe[a]) return Xe[a];
    if (!We[a]) return a;
    var b = We[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
    return a;
  }
  var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b);
    fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e, "onAnimationEnd");
  ff(af, "onAnimationIteration");
  ff(bf, "onAnimationStart");
  ff("dblclick", "onDoubleClick");
  ff("focusin", "onFocus");
  ff("focusout", "onBlur");
  ff(cf, "onTransitionEnd");
  ha("onMouseEnter", ["mouseout", "mouseover"]);
  ha("onMouseLeave", ["mouseout", "mouseover"]);
  ha("onPointerEnter", ["pointerout", "pointerover"]);
  ha("onPointerLeave", ["pointerout", "pointerover"]);
  fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d2 = a.type || "unknown-event";
    a.currentTarget = c;
    Ub(d2, b, void 0, a);
    a.currentTarget = null;
  }
  function se(a, b) {
    b = 0 !== (b & 4);
    for (var c = 0; c < a.length; c++) {
      var d2 = a[c], e = d2.event;
      d2 = d2.listeners;
      a: {
        var f = void 0;
        if (b) for (var g = d2.length - 1; 0 <= g; g--) {
          var h = d2[g], k = h.instance, l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
        else for (g = 0; g < d2.length; g++) {
          h = d2[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          nf(e, h, l);
          f = k;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = false, Rb = null, a;
  }
  function D(a, b) {
    var c = b[of];
    void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
    var d2 = a + "__bubble";
    c.has(d2) || (pf(b, a, 2, false), c.add(d2));
  }
  function qf(a, b, c) {
    var d2 = 0;
    b && (d2 |= 4);
    pf(c, a, d2, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = true;
      da.forEach(function(b2) {
        "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
      });
      var b = 9 === a.nodeType ? a : a.ownerDocument;
      null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
    }
  }
  function pf(a, b, c, d2) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a);
    e = void 0;
    !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
    d2 ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
  }
  function hd(a, b, c, d2, e) {
    var f = d2;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d2) a: for (; ; ) {
      if (null === d2) return;
      var g = d2.tag;
      if (3 === g || 4 === g) {
        var h = d2.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d2.return; null !== g; ) {
          var k = g.tag;
          if (3 === k || 4 === k) {
            if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          }
          g = g.return;
        }
        for (; null !== h; ) {
          g = Wc(h);
          if (null === g) return;
          k = g.tag;
          if (5 === k || 6 === k) {
            d2 = f = g;
            continue a;
          }
          h = h.parentNode;
        }
      }
      d2 = d2.return;
    }
    Jb(function() {
      var d3 = f, e2 = xb(c), g2 = [];
      a: {
        var h2 = df.get(a);
        if (void 0 !== h2) {
          var k2 = td, n = a;
          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;
            case "keydown":
            case "keyup":
              k2 = Rd;
              break;
            case "focusin":
              n = "focus";
              k2 = Fd;
              break;
            case "focusout":
              n = "blur";
              k2 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k2 = Fd;
              break;
            case "click":
              if (2 === c.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k2 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k2 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k2 = Vd;
              break;
            case $e:
            case af:
            case bf:
              k2 = Hd;
              break;
            case cf:
              k2 = Xd;
              break;
            case "scroll":
              k2 = vd;
              break;
            case "wheel":
              k2 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k2 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k2 = Td;
          }
          var t = 0 !== (b & 4), J = !t && "scroll" === a, x2 = t ? null !== h2 ? h2 + "Capture" : null : h2;
          t = [];
          for (var w = d3, u; null !== w; ) {
            u = w;
            var F = u.stateNode;
            5 === u.tag && null !== F && (u = F, null !== x2 && (F = Kb(w, x2), null != F && t.push(tf(w, F, u))));
            if (J) break;
            w = w.return;
          }
          0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
        }
      }
      if (0 === (b & 7)) {
        a: {
          h2 = "mouseover" === a || "pointerover" === a;
          k2 = "mouseout" === a || "pointerout" === a;
          if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if (k2 || h2) {
            h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
            if (k2) {
              if (n = c.relatedTarget || c.toElement, k2 = d3, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
            } else k2 = null, n = d3;
            if (k2 !== n) {
              t = Bd;
              F = "onMouseLeave";
              x2 = "onMouseEnter";
              w = "mouse";
              if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x2 = "onPointerEnter", w = "pointer";
              J = null == k2 ? h2 : ue(k2);
              u = null == n ? h2 : ue(n);
              h2 = new t(F, w + "leave", k2, c, e2);
              h2.target = J;
              h2.relatedTarget = u;
              F = null;
              Wc(e2) === d3 && (t = new t(x2, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
              J = F;
              if (k2 && n) b: {
                t = k2;
                x2 = n;
                w = 0;
                for (u = t; u; u = vf(u)) w++;
                u = 0;
                for (F = x2; F; F = vf(F)) u++;
                for (; 0 < w - u; ) t = vf(t), w--;
                for (; 0 < u - w; ) x2 = vf(x2), u--;
                for (; w--; ) {
                  if (t === x2 || null !== x2 && t === x2.alternate) break b;
                  t = vf(t);
                  x2 = vf(x2);
                }
                t = null;
              }
              else t = null;
              null !== k2 && wf(g2, h2, k2, t, false);
              null !== n && null !== J && wf(g2, J, n, t, true);
            }
          }
        }
        a: {
          h2 = d3 ? ue(d3) : window;
          k2 = h2.nodeName && h2.nodeName.toLowerCase();
          if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
          else if (me(h2)) if (we) na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
          else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
          if (na && (na = na(a, d3))) {
            ne(g2, na, c, e2);
            break a;
          }
          xa && xa(a, h2, d3);
          "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
        }
        xa = d3 ? ue(d3) : window;
        switch (a) {
          case "focusin":
            if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
            break;
          case "focusout":
            Se = Re = Qe = null;
            break;
          case "mousedown":
            Te = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = false;
            Ue(g2, c, e2);
            break;
          case "selectionchange":
            if (Pe) break;
          case "keydown":
          case "keyup":
            Ue(g2, c, e2);
        }
        var $a;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
        ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
        if ($a = ce ? je(a, c) : ke(a, c)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d3 }), e2.data = $a);
      }
      se(g2, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe(a, b) {
    for (var c = b + "Capture", d2 = []; null !== a; ) {
      var e = a, f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d2.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d2.push(tf(a, f, e)));
      a = a.return;
    }
    return d2;
  }
  function vf(a) {
    if (null === a) return null;
    do
      a = a.return;
    while (a && 5 !== a.tag);
    return a ? a : null;
  }
  function wf(a, b, c, d2, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d2; ) {
      var h = c, k = h.alternate, l = h.stateNode;
      if (null !== k && k === d2) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
      c = c.return;
    }
    0 !== g.length && a.push({ event: b, listeners: g });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
  }
  function Af(a, b, c) {
    b = zf(b);
    if (zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }
  var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d2 = 0;
    do {
      var e = c.nextSibling;
      a.removeChild(c);
      if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
        if (0 === d2) {
          a.removeChild(e);
          bd(b);
          return;
        }
        d2--;
      } else "$" !== c && "$?" !== c && "$!" !== c || d2++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
      if (8 === b) {
        b = a.data;
        if ("$" === b || "$!" === b || "$?" === b) break;
        if ("/$" === b) return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (8 === a.nodeType) {
        var c = a.data;
        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c;
      c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    a = a[Of] || a[uf];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }
  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G(a, b) {
    Tf++;
    Sf[Tf] = a.current;
    a.current = b;
  }
  var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d2 = a.stateNode;
    if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b) return d2.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f;
    for (f in c) e[f] = b[f];
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }
  function Zf(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }
  function $f() {
    E(Wf);
    E(H);
  }
  function ag(a, b, c) {
    if (H.current !== Vf) throw Error(p(168));
    G(H, b);
    G(Wf, c);
  }
  function bg(a, b, c) {
    var d2 = a.stateNode;
    b = b.childContextTypes;
    if ("function" !== typeof d2.getChildContext) return c;
    d2 = d2.getChildContext();
    for (var e in d2) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A({}, c, d2);
  }
  function cg(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
    Xf = H.current;
    G(H, a);
    G(Wf, Wf.current);
    return true;
  }
  function dg(a, b, c) {
    var d2 = a.stateNode;
    if (!d2) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d2.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
    G(Wf, c);
  }
  var eg = null, fg = false, gg = false;
  function hg(a) {
    null === eg ? eg = [a] : eg.push(a);
  }
  function ig(a) {
    fg = true;
    hg(a);
  }
  function jg() {
    if (!gg && null !== eg) {
      gg = true;
      var a = 0, b = C;
      try {
        var c = eg;
        for (C = 1; a < c.length; a++) {
          var d2 = c[a];
          do
            d2 = d2(true);
          while (null !== d2);
        }
        eg = null;
        fg = false;
      } catch (e) {
        throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
      } finally {
        C = b, gg = false;
      }
    }
    return null;
  }
  var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg++] = ng;
    kg[lg++] = mg;
    mg = a;
    ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg;
    og[pg++] = sg;
    og[pg++] = qg;
    qg = a;
    var d2 = rg;
    a = sg;
    var e = 32 - oc(d2) - 1;
    d2 &= ~(1 << e);
    c += 1;
    var f = 32 - oc(b) + e;
    if (30 < f) {
      var g = e - e % 5;
      f = (d2 & (1 << g) - 1).toString(32);
      d2 >>= g;
      e -= g;
      rg = 1 << 32 - oc(b) + e | c << e | d2;
      sg = f + a;
    } else rg = 1 << f | c << e | d2, sg = a;
  }
  function vg(a) {
    null !== a.return && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I = false, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED";
    c.stateNode = b;
    c.return = a;
    b = a.deletions;
    null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
      case 13:
        return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
      default:
        return false;
    }
  }
  function Dg(a) {
    return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
  }
  function Eg(a) {
    if (I) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d2 = xg;
          b && Cg(a, b) ? Ag(d2, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2;
        I = false;
        xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
    xg = a;
  }
  function Gg(a) {
    if (a !== xg) return false;
    if (!I) return Fg(a), I = true, false;
    var b;
    (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
    if (b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    Fg(a);
    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(p(317));
      a: {
        a = a.nextSibling;
        for (b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("/$" === c) {
              if (0 === b) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return true;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null;
    I = false;
  }
  function Jg(a) {
    null === zg ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    a = c.ref;
    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;
        if (c) {
          if (1 !== c.tag) throw Error(p(309));
          var d2 = c.stateNode;
        }
        if (!d2) throw Error(p(147, a));
        var e = d2, f = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
        b = function(a2) {
          var b2 = e.refs;
          null === a2 ? delete b2[f] : b2[f] = a2;
        };
        b._stringRef = f;
        return b;
      }
      if ("string" !== typeof a) throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    a = Object.prototype.toString.call(b);
    throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d3 = b2.deletions;
        null === d3 ? (b2.deletions = [c2], b2.flags |= 16) : d3.push(c2);
      }
    }
    function c(c2, d3) {
      if (!a) return null;
      for (; null !== d3; ) b(c2, d3), d3 = d3.sibling;
      return null;
    }
    function d2(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      a2 = Pg(a2, b2);
      a2.index = 0;
      a2.sibling = null;
      return a2;
    }
    function f(b2, c2, d3) {
      b2.index = d3;
      if (!a) return b2.flags |= 1048576, c2;
      d3 = b2.alternate;
      if (null !== d3) return d3 = d3.index, d3 < c2 ? (b2.flags |= 2, c2) : d3;
      b2.flags |= 2;
      return c2;
    }
    function g(b2) {
      a && null === b2.alternate && (b2.flags |= 2);
      return b2;
    }
    function h(a2, b2, c2, d3) {
      if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d3), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function k(a2, b2, c2, d3) {
      var f2 = c2.type;
      if (f2 === ya) return m(a2, b2, c2.props.children, d3, c2.key);
      if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d3 = e(b2, c2.props), d3.ref = Lg(a2, b2, c2), d3.return = a2, d3;
      d3 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d3);
      d3.ref = Lg(a2, b2, c2);
      d3.return = a2;
      return d3;
    }
    function l(a2, b2, c2, d3) {
      if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d3), b2.return = a2, b2;
      b2 = e(b2, c2.children || []);
      b2.return = a2;
      return b2;
    }
    function m(a2, b2, c2, d3, f2) {
      if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d3, f2), b2.return = a2, b2;
      b2 = e(b2, c2);
      b2.return = a2;
      return b2;
    }
    function q(a2, b2, c2) {
      if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if ("object" === typeof b2 && null !== b2) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d3 = b2._init;
            return q(a2, d3(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r2(a2, b2, c2, d3) {
      var e2 = null !== b2 ? b2.key : null;
      if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d3);
      if ("object" === typeof c2 && null !== c2) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k(a2, b2, c2, d3) : null;
          case wa:
            return c2.key === e2 ? l(a2, b2, c2, d3) : null;
          case Ha:
            return e2 = c2._init, r2(
              a2,
              b2,
              e2(c2._payload),
              d3
            );
        }
        if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d3, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y2(a2, b2, c2, d3, e2) {
      if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a2 = a2.get(c2) || null, h(b2, a2, "" + d3, e2);
      if ("object" === typeof d3 && null !== d3) {
        switch (d3.$$typeof) {
          case va:
            return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, k(b2, a2, d3, e2);
          case wa:
            return a2 = a2.get(null === d3.key ? c2 : d3.key) || null, l(b2, a2, d3, e2);
          case Ha:
            var f2 = d3._init;
            return y2(a2, b2, c2, f2(d3._payload), e2);
        }
        if (eb(d3) || Ka(d3)) return a2 = a2.get(c2) || null, m(b2, a2, d3, e2, null);
        Mg(b2, d3);
      }
      return null;
    }
    function n(e2, g2, h2, k2) {
      for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x2 = null; null !== u && w < h2.length; w++) {
        u.index > w ? (x2 = u, u = null) : x2 = u.sibling;
        var n2 = r2(e2, u, h2[w], k2);
        if (null === n2) {
          null === u && (u = x2);
          break;
        }
        a && u && null === n2.alternate && b(e2, u);
        g2 = f(n2, g2, w);
        null === m2 ? l2 = n2 : m2.sibling = n2;
        m2 = n2;
        u = x2;
      }
      if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
      if (null === u) {
        for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
        I && tg(e2, w);
        return l2;
      }
      for (u = d2(e2, u); w < h2.length; w++) x2 = y2(u, e2, w, h2[w], k2), null !== x2 && (a && null !== x2.alternate && u.delete(null === x2.key ? w : x2.key), g2 = f(x2, g2, w), null === m2 ? l2 = x2 : m2.sibling = x2, m2 = x2);
      a && u.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function t(e2, g2, h2, k2) {
      var l2 = Ka(h2);
      if ("function" !== typeof l2) throw Error(p(150));
      h2 = l2.call(h2);
      if (null == h2) throw Error(p(151));
      for (var u = l2 = null, m2 = g2, w = g2 = 0, x2 = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
        m2.index > w ? (x2 = m2, m2 = null) : x2 = m2.sibling;
        var t2 = r2(e2, m2, n2.value, k2);
        if (null === t2) {
          null === m2 && (m2 = x2);
          break;
        }
        a && m2 && null === t2.alternate && b(e2, m2);
        g2 = f(t2, g2, w);
        null === u ? l2 = t2 : u.sibling = t2;
        u = t2;
        m2 = x2;
      }
      if (n2.done) return c(
        e2,
        m2
      ), I && tg(e2, w), l2;
      if (null === m2) {
        for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
        I && tg(e2, w);
        return l2;
      }
      for (m2 = d2(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y2(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
      a && m2.forEach(function(a2) {
        return b(e2, a2);
      });
      I && tg(e2, w);
      return l2;
    }
    function J(a2, d3, f2, h2) {
      "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
      if ("object" === typeof f2 && null !== f2) {
        switch (f2.$$typeof) {
          case va:
            a: {
              for (var k2 = f2.key, l2 = d3; null !== l2; ) {
                if (l2.key === k2) {
                  k2 = f2.type;
                  if (k2 === ya) {
                    if (7 === l2.tag) {
                      c(a2, l2.sibling);
                      d3 = e(l2, f2.props.children);
                      d3.return = a2;
                      a2 = d3;
                      break a;
                    }
                  } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                    c(a2, l2.sibling);
                    d3 = e(l2, f2.props);
                    d3.ref = Lg(a2, l2, f2);
                    d3.return = a2;
                    a2 = d3;
                    break a;
                  }
                  c(a2, l2);
                  break;
                } else b(a2, l2);
                l2 = l2.sibling;
              }
              f2.type === ya ? (d3 = Tg(f2.props.children, a2.mode, h2, f2.key), d3.return = a2, a2 = d3) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d3, f2), h2.return = a2, a2 = h2);
            }
            return g(a2);
          case wa:
            a: {
              for (l2 = f2.key; null !== d3; ) {
                if (d3.key === l2) if (4 === d3.tag && d3.stateNode.containerInfo === f2.containerInfo && d3.stateNode.implementation === f2.implementation) {
                  c(a2, d3.sibling);
                  d3 = e(d3, f2.children || []);
                  d3.return = a2;
                  a2 = d3;
                  break a;
                } else {
                  c(a2, d3);
                  break;
                }
                else b(a2, d3);
                d3 = d3.sibling;
              }
              d3 = Sg(f2, a2.mode, h2);
              d3.return = a2;
              a2 = d3;
            }
            return g(a2);
          case Ha:
            return l2 = f2._init, J(a2, d3, l2(f2._payload), h2);
        }
        if (eb(f2)) return n(a2, d3, f2, h2);
        if (Ka(f2)) return t(a2, d3, f2, h2);
        Mg(a2, f2);
      }
      return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d3 && 6 === d3.tag ? (c(a2, d3.sibling), d3 = e(d3, f2), d3.return = a2, a2 = d3) : (c(a2, d3), d3 = Qg(f2, a2.mode, h2), d3.return = a2, a2 = d3), g(a2)) : c(a2, d3);
    }
    return J;
  }
  var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E(Wg);
    a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; null !== a; ) {
      var d2 = a.alternate;
      (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d2 && (d2.childLanes |= b)) : null !== d2 && (d2.childLanes & b) !== b && (d2.childLanes |= b);
      if (a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a;
    Zg = Yg = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
      if (null === Xg) throw Error(p(308));
      Yg = a;
      Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    null === fh ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d2) {
    var e = b.interleaved;
    null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
    b.interleaved = c;
    return ih(a, d2);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;
    for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
    return 3 === c.tag ? c.stateNode : null;
  }
  var jh = false;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d2 = a.updateQueue;
    if (null === d2) return null;
    d2 = d2.shared;
    if (0 !== (K & 2)) {
      var e = d2.pending;
      null === e ? b.next = b : (b.next = e.next, e.next = b);
      d2.pending = b;
      return ih(a, c);
    }
    e = d2.interleaved;
    null === e ? (b.next = b, gh(d2)) : (b.next = e.next, e.next = b);
    d2.interleaved = b;
    return ih(a, c);
  }
  function oh(a, b, c) {
    b = b.updateQueue;
    if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
      var d2 = b.lanes;
      d2 &= a.pendingLanes;
      c |= d2;
      b.lanes = c;
      Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d2 = a.alternate;
    if (null !== d2 && (d2 = d2.updateQueue, c === d2)) {
      var e = null, f = null;
      c = c.firstBaseUpdate;
      if (null !== c) {
        do {
          var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);
        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;
      c = { baseState: d2.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d2.shared, effects: d2.effects };
      a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d2) {
    var e = a.updateQueue;
    jh = false;
    var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
    if (null !== h) {
      e.shared.pending = null;
      var k = h, l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var m = a.alternate;
      null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
    }
    if (null !== f) {
      var q = e.baseState;
      g = 0;
      m = l = k = null;
      h = f;
      do {
        var r2 = h.lane, y2 = h.eventTime;
        if ((d2 & r2) === r2) {
          null !== m && (m = m.next = {
            eventTime: y2,
            lane: 0,
            tag: h.tag,
            payload: h.payload,
            callback: h.callback,
            next: null
          });
          a: {
            var n = a, t = h;
            r2 = b;
            y2 = c;
            switch (t.tag) {
              case 1:
                n = t.payload;
                if ("function" === typeof n) {
                  q = n.call(y2, q, r2);
                  break a;
                }
                q = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                n = t.payload;
                r2 = "function" === typeof n ? n.call(y2, q, r2) : n;
                if (null === r2 || void 0 === r2) break a;
                q = A({}, q, r2);
                break a;
              case 2:
                jh = true;
            }
          }
          null !== h.callback && 0 !== h.lane && (a.flags |= 64, r2 = e.effects, null === r2 ? e.effects = [h] : r2.push(h));
        } else y2 = { eventTime: y2, lane: r2, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y2, k = q) : m = m.next = y2, g |= r2;
        h = h.next;
        if (null === h) if (h = e.shared.pending, null === h) break;
        else r2 = h, h = r2.next, r2.next = null, e.lastBaseUpdate = r2, e.shared.pending = null;
      } while (1);
      null === m && (k = q);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = m;
      b = e.shared.interleaved;
      if (null !== b) {
        e = b;
        do
          g |= e.lane, e = e.next;
        while (e !== b);
      } else null === f && (e.shared.lanes = 0);
      rh |= g;
      a.lanes = g;
      a.memoizedState = q;
    }
  }
  function sh(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d2 = a[b], e = d2.callback;
      if (null !== e) {
        d2.callback = null;
        d2 = c;
        if ("function" !== typeof e) throw Error(p(191, e));
        e.call(d2);
      }
    }
  }
  var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    G(wh, b);
    G(vh, a);
    G(uh, th);
    a = b.nodeType;
    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E(uh);
    G(uh, b);
  }
  function zh() {
    E(uh);
    E(vh);
    E(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current);
    var c = lb(b, a.type);
    b !== c && (G(vh, a), G(uh, c));
  }
  function Bh(a) {
    vh.current === a && (E(uh), E(vh));
  }
  var L = Uf(0);
  function Ch(a) {
    for (var b = a; null !== b; ) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 128)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }
      if (b === a) break;
      for (; null === b.sibling; ) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
  function P() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (null === b) return false;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
    return true;
  }
  function Nh(a, b, c, d2, e, f) {
    Hh = f;
    M = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
    a = c(d2, e);
    if (Jh) {
      f = 0;
      do {
        Jh = false;
        Kh = 0;
        if (25 <= f) throw Error(p(301));
        f += 1;
        O = N = null;
        b.updateQueue = null;
        Fh.current = Qh;
        a = c(d2, e);
      } while (Jh);
    }
    Fh.current = Rh;
    b = null !== N && null !== N.next;
    Hh = 0;
    O = N = M = null;
    Ih = false;
    if (b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = 0 !== Kh;
    Kh = 0;
    return a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    null === O ? M.memoizedState = O = a : O = O.next = a;
    return O;
  }
  function Uh() {
    if (null === N) {
      var a = M.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = N.next;
    var b = null === O ? M.memoizedState : O.next;
    if (null !== b) O = b, N = a;
    else {
      if (null === a) throw Error(p(310));
      N = a;
      a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
      null === O ? M.memoizedState = O = a : O = O.next = a;
    }
    return O;
  }
  function Vh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d2 = N, e = d2.baseQueue, f = c.pending;
    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }
      d2.baseQueue = e = f;
      c.pending = null;
    }
    if (null !== e) {
      f = e.next;
      d2 = d2.baseState;
      var h = g = null, k = null, l = f;
      do {
        var m = l.lane;
        if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d2 = l.hasEagerState ? l.eagerState : a(d2, l.action);
        else {
          var q = {
            lane: m,
            action: l.action,
            hasEagerState: l.hasEagerState,
            eagerState: l.eagerState,
            next: null
          };
          null === k ? (h = k = q, g = d2) : k = k.next = q;
          M.lanes |= m;
          rh |= m;
        }
        l = l.next;
      } while (null !== l && l !== f);
      null === k ? g = d2 : k.next = h;
      He(d2, b.memoizedState) || (dh = true);
      b.memoizedState = d2;
      b.baseState = g;
      b.baseQueue = k;
      c.lastRenderedState = d2;
    }
    a = c.interleaved;
    if (null !== a) {
      e = a;
      do
        f = e.lane, M.lanes |= f, rh |= f, e = e.next;
      while (e !== a);
    } else null === e && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (null === c) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d2 = c.dispatch, e = c.pending, f = b.memoizedState;
    if (null !== e) {
      c.pending = null;
      var g = e = e.next;
      do
        f = a(f, g.action), g = g.next;
      while (g !== e);
      He(f, b.memoizedState) || (dh = true);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }
    return [f, d2];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M, d2 = Uh(), e = b(), f = !He(d2.memoizedState, e);
    f && (d2.memoizedState = e, dh = true);
    d2 = d2.queue;
    $h(ai.bind(null, c, d2, a), [a]);
    if (d2.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
      c.flags |= 2048;
      bi(9, ci.bind(null, c, d2, e, b), void 0, null);
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384;
    a = { getSnapshot: b, value: c };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d2) {
    b.value = c;
    b.getSnapshot = d2;
    ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He(a, c);
    } catch (d2) {
      return true;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    null !== b && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
    b.queue = a;
    a = a.dispatch = ii.bind(null, M, a);
    return [b.memoizedState, a];
  }
  function bi(a, b, c, d2) {
    a = { tag: a, create: b, destroy: c, deps: d2, next: null };
    b = M.updateQueue;
    null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d2 = c.next, c.next = a, a.next = d2, b.lastEffect = a));
    return a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d2) {
    var e = Th();
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, void 0, void 0 === d2 ? null : d2);
  }
  function li(a, b, c, d2) {
    var e = Uh();
    d2 = void 0 === d2 ? null : d2;
    var f = void 0;
    if (null !== N) {
      var g = N.memoizedState;
      f = g.destroy;
      if (null !== d2 && Mh(d2, g.deps)) {
        e.memoizedState = bi(b, c, f, d2);
        return;
      }
    }
    M.flags |= a;
    e.memoizedState = bi(1 | b, c, f, d2);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi2(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function() {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return li(4, 4, pi2.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d2 = c.memoizedState;
    if (null !== d2 && null !== b && Mh(b, d2[1])) return d2[0];
    c.memoizedState = [a, b];
    return a;
  }
  function ti(a, b) {
    var c = Uh();
    b = void 0 === b ? null : b;
    var d2 = c.memoizedState;
    if (null !== d2 && null !== b && Mh(b, d2[1])) return d2[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }
  function ui(a, b, c) {
    if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
    He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
    return b;
  }
  function vi(a, b) {
    var c = C;
    C = 0 !== c && 4 > c ? c : 4;
    a(true);
    var d2 = Gh.transition;
    Gh.transition = {};
    try {
      a(false), b();
    } finally {
      C = c, Gh.transition = d2;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi(a, b, c) {
    var d2 = yi(a);
    c = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d2), null !== c) {
      var e = R();
      gi(c, a, d2, e);
      Bi(c, b, d2);
    }
  }
  function ii(a, b, c) {
    var d2 = yi(a), e = { lane: d2, action: c, hasEagerState: false, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f = a.alternate;
      if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
        var g = b.lastRenderedState, h = f(g, c);
        e.hasEagerState = true;
        e.eagerState = h;
        if (He(h, g)) {
          var k = b.interleaved;
          null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
          b.interleaved = e;
          return;
        }
      } catch (l) {
      } finally {
      }
      c = hh(a, b, e, d2);
      null !== c && (e = R(), gi(c, a, d2, e), Bi(c, b, d2));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M || null !== b && b === M;
  }
  function Ai(a, b) {
    Jh = Ih = true;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
  function Bi(a, b, c) {
    if (0 !== (c & 4194240)) {
      var d2 = b.lanes;
      d2 &= a.pendingLanes;
      c |= d2;
      b.lanes = c;
      Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
    Th().memoizedState = [a, void 0 === b ? null : b];
    return a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return ki(
      4194308,
      4,
      pi2.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  }, useReducer: function(a, b, c) {
    var d2 = Th();
    b = void 0 !== c ? c(b) : b;
    d2.memoizedState = d2.baseState = b;
    a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
    d2.queue = a;
    a = a.dispatch = xi.bind(null, M, a);
    return [d2.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    a = { current: a };
    return b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(false), b = a[0];
    a = vi.bind(null, a[1]);
    Th().memoizedState = a;
    return [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d2 = M, e = Th();
    if (I) {
      if (void 0 === c) throw Error(p(407));
      c = c();
    } else {
      c = b();
      if (null === Q) throw Error(p(349));
      0 !== (Hh & 30) || di(d2, b, c);
    }
    e.memoizedState = c;
    var f = { value: c, getSnapshot: b };
    e.queue = f;
    mi(ai.bind(
      null,
      d2,
      f,
      a
    ), [a]);
    d2.flags |= 2048;
    bi(9, ci.bind(null, d2, f, c, b), void 0, null);
    return c;
  }, useId: function() {
    var a = Th(), b = Q.identifierPrefix;
    if (I) {
      var c = sg;
      var d2 = rg;
      c = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c;
      b = ":" + b + "R" + c;
      c = Kh++;
      0 < c && (b += "H" + c.toString(32));
      b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: false }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: false
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A({}, b);
      a = a.defaultProps;
      for (var c in a) void 0 === b[c] && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d2) {
    b = a.memoizedState;
    c = c(d2, b);
    c = null === c || void 0 === c ? b : A({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : false;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d2 = R(), e = yi(a), f = mh(d2, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d2), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d2 = R(), e = yi(a), f = mh(d2, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    b = nh(a, f, e);
    null !== b && (gi(b, a, e, d2), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R(), d2 = yi(a), e = mh(c, d2);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    b = nh(a, e, d2);
    null !== b && (gi(b, a, d2, c), oh(b, a, d2));
  } };
  function Fi(a, b, c, d2, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d2, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d2) || !Ie(e, f) : true;
  }
  function Gi(a, b, c) {
    var d2 = false, e = Vf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d2 = b.contextTypes, f = (d2 = null !== d2 && void 0 !== d2) ? Yf(a, e) : Vf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Ei;
    a.stateNode = b;
    b._reactInternals = a;
    d2 && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }
  function Hi(a, b, c, d2) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d2);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d2);
    b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d2) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = {};
    kh(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d2), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d2 = b;
      do
        c += Pa(d2), d2 = d2.return;
      while (d2);
      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = "function" === typeof WeakMap ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    c.payload = { element: null };
    var d2 = b.value;
    c.callback = function() {
      Oi || (Oi = true, Pi = d2);
      Li(a, b);
    };
    return c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c);
    c.tag = 3;
    var d2 = a.type.getDerivedStateFromError;
    if ("function" === typeof d2) {
      var e = b.value;
      c.payload = function() {
        return d2(e);
      };
      c.callback = function() {
        Li(a, b);
      };
    }
    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
      Li(a, b);
      "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
    });
    return c;
  }
  function Si(a, b, c) {
    var d2 = a.pingCache;
    if (null === d2) {
      d2 = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d2.set(b, e);
    } else e = d2.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d2.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
      if (b) return a;
      a = a.return;
    } while (null !== a);
    return null;
  }
  function Vi(a, b, c, d2, e) {
    if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
    a.flags |= 65536;
    a.lanes = e;
    return a;
  }
  var Wi = ua.ReactCurrentOwner, dh = false;
  function Xi(a, b, c, d2) {
    b.child = null === a ? Vg(b, null, c, d2) : Ug(b, a.child, c, d2);
  }
  function Yi(a, b, c, d2, e) {
    c = c.render;
    var f = b.ref;
    ch(b, e);
    d2 = Nh(a, b, c, d2, f, e);
    c = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && c && vg(b);
    b.flags |= 1;
    Xi(a, b, d2, e);
    return b.child;
  }
  function $i(a, b, c, d2, e) {
    if (null === a) {
      var f = c.type;
      if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d2, e);
      a = Rg(c.type, null, d2, b, b.mode, e);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }
    f = a.child;
    if (0 === (a.lanes & e)) {
      var g = f.memoizedProps;
      c = c.compare;
      c = null !== c ? c : Ie;
      if (c(g, d2) && a.ref === b.ref) return Zi(a, b, e);
    }
    b.flags |= 1;
    a = Pg(f, d2);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  function bj(a, b, c, d2, e) {
    if (null !== a) {
      var f = a.memoizedProps;
      if (Ie(f, d2) && a.ref === b.ref) if (dh = false, b.pendingProps = d2 = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d2, e);
  }
  function dj(a, b, c) {
    var d2 = b.pendingProps, e = d2.children, f = null !== a ? a.memoizedState : null;
    if ("hidden" === d2.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
    else {
      if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f ? f.baseLanes : c;
      G(ej, fj);
      fj |= d2;
    }
    else null !== f ? (d2 = f.baseLanes | c, b.memoizedState = null) : d2 = c, G(ej, fj), fj |= d2;
    Xi(a, b, e, c);
    return b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
  }
  function cj(a, b, c, d2, e) {
    var f = Zf(c) ? Xf : H.current;
    f = Yf(b, f);
    ch(b, e);
    c = Nh(a, b, c, d2, f, e);
    d2 = Sh();
    if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
    I && d2 && vg(b);
    b.flags |= 1;
    Xi(a, b, c, e);
    return b.child;
  }
  function hj(a, b, c, d2, e) {
    if (Zf(c)) {
      var f = true;
      cg(b);
    } else f = false;
    ch(b, e);
    if (null === b.stateNode) ij(a, b), Gi(b, c, d2), Ii(b, c, d2, e), d2 = true;
    else if (null === a) {
      var g = b.stateNode, h = b.memoizedProps;
      g.props = h;
      var k = g.context, l = c.contextType;
      "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
      var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
      q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d2 || k !== l) && Hi(b, g, d2, l);
      jh = false;
      var r2 = b.memoizedState;
      g.state = r2;
      qh(b, d2, g, e);
      k = b.memoizedState;
      h !== d2 || r2 !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d2), k = b.memoizedState), (h = jh || Fi(b, c, h, d2, r2, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d2, b.memoizedState = k), g.props = d2, g.state = k, g.context = l, d2 = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d2 = false);
    } else {
      g = b.stateNode;
      lh(a, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : Ci(b.type, h);
      g.props = l;
      q = b.pendingProps;
      r2 = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
      var y2 = c.getDerivedStateFromProps;
      (m = "function" === typeof y2 || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r2 !== k) && Hi(b, g, d2, k);
      jh = false;
      r2 = b.memoizedState;
      g.state = r2;
      qh(b, d2, g, e);
      var n = b.memoizedState;
      h !== q || r2 !== n || Wf.current || jh ? ("function" === typeof y2 && (Di(b, c, y2, d2), n = b.memoizedState), (l = jh || Fi(b, c, l, d2, r2, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d2, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d2, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d2, b.memoizedState = n), g.props = d2, g.state = n, g.context = k, d2 = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r2 === a.memoizedState || (b.flags |= 1024), d2 = false);
    }
    return jj(a, b, c, d2, f, e);
  }
  function jj(a, b, c, d2, e, f) {
    gj(a, b);
    var g = 0 !== (b.flags & 128);
    if (!d2 && !g) return e && dg(b, c, false), Zi(a, b, f);
    d2 = b.stateNode;
    Wi.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d2.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
    b.memoizedState = d2.state;
    e && dg(b, c, true);
    return b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
    yh(a, b.containerInfo);
  }
  function lj(a, b, c, d2, e) {
    Ig();
    Jg(e);
    b.flags |= 256;
    Xi(a, b, c, d2);
    return b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d2 = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
    (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
    if (h) f = true, b.flags &= -129;
    else if (null === a || null !== a.memoizedState) e |= 1;
    G(L, e & 1);
    if (null === a) {
      Eg(b);
      a = b.memoizedState;
      if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
      g = d2.children;
      a = d2.fallback;
      return f ? (d2 = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d2 & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d2, 0, null), a = Tg(a, d2, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
    }
    e = a.memoizedState;
    if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d2, h, e, c);
    if (f) {
      f = d2.fallback;
      g = b.mode;
      e = a.child;
      h = e.sibling;
      var k = { mode: "hidden", children: d2.children };
      0 === (g & 1) && b.child !== e ? (d2 = b.child, d2.childLanes = 0, d2.pendingProps = k, b.deletions = null) : (d2 = Pg(e, k), d2.subtreeFlags = e.subtreeFlags & 14680064);
      null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
      f.return = b;
      d2.return = b;
      d2.sibling = f;
      b.child = d2;
      d2 = f;
      f = b.child;
      g = a.child.memoizedState;
      g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
      f.memoizedState = g;
      f.childLanes = a.childLanes & ~c;
      b.memoizedState = mj;
      return d2;
    }
    f = a.child;
    a = f.sibling;
    d2 = Pg(f, { mode: "visible", children: d2.children });
    0 === (b.mode & 1) && (d2.lanes = c);
    d2.return = b;
    d2.sibling = null;
    null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
    b.child = d2;
    b.memoizedState = null;
    return d2;
  }
  function qj(a, b) {
    b = pj({ mode: "visible", children: b }, a.mode, 0, null);
    b.return = a;
    return a.child = b;
  }
  function sj(a, b, c, d2) {
    null !== d2 && Jg(d2);
    Ug(b, a.child, null, c);
    a = qj(b, b.pendingProps.children);
    a.flags |= 2;
    b.memoizedState = null;
    return a;
  }
  function rj(a, b, c, d2, e, f, g) {
    if (c) {
      if (b.flags & 256) return b.flags &= -257, d2 = Ki(Error(p(422))), sj(a, b, g, d2);
      if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
      f = d2.fallback;
      e = b.mode;
      d2 = pj({ mode: "visible", children: d2.children }, e, 0, null);
      f = Tg(f, e, g, null);
      f.flags |= 2;
      d2.return = b;
      f.return = b;
      d2.sibling = f;
      b.child = d2;
      0 !== (b.mode & 1) && Ug(b, a.child, null, g);
      b.child.memoizedState = nj(g);
      b.memoizedState = mj;
      return f;
    }
    if (0 === (b.mode & 1)) return sj(a, b, g, null);
    if ("$!" === e.data) {
      d2 = e.nextSibling && e.nextSibling.dataset;
      if (d2) var h = d2.dgst;
      d2 = h;
      f = Error(p(419));
      d2 = Ki(f, d2, void 0);
      return sj(a, b, g, d2);
    }
    h = 0 !== (g & a.childLanes);
    if (dh || h) {
      d2 = Q;
      if (null !== d2) {
        switch (g & -g) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = 0 !== (e & (d2.suspendedLanes | g)) ? 0 : e;
        0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d2, a, e, -1));
      }
      tj();
      d2 = Ki(Error(p(421)));
      return sj(a, b, g, d2);
    }
    if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
    a = f.treeContext;
    yg = Lf(e.nextSibling);
    xg = b;
    I = true;
    zg = null;
    null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
    b = qj(b, d2.children);
    b.flags |= 4096;
    return b;
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d2 = a.alternate;
    null !== d2 && (d2.lanes |= b);
    bh(a.return, b, c);
  }
  function wj(a, b, c, d2, e) {
    var f = a.memoizedState;
    null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d2, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d2, f.tail = c, f.tailMode = e);
  }
  function xj(a, b, c) {
    var d2 = b.pendingProps, e = d2.revealOrder, f = d2.tail;
    Xi(a, b, d2.children, c);
    d2 = L.current;
    if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b.flags |= 128;
    else {
      if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
        if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
        else if (19 === a.tag) vj(a, c, b);
        else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; null === a.sibling; ) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return;
        a = a.sibling;
      }
      d2 &= 1;
    }
    G(L, d2);
    if (0 === (b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        wj(b, false, e, c, f);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; null !== e; ) {
          a = e.alternate;
          if (null !== a && null === Ch(a)) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        wj(b, true, c, null, f);
        break;
      case "together":
        wj(b, false, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    rh |= b.lanes;
    if (0 === (c & b.childLanes)) return null;
    if (null !== a && b.child !== a.child) throw Error(p(153));
    if (null !== b.child) {
      a = b.child;
      c = Pg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b);
        Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d2 = b.type._context, e = b.memoizedProps.value;
        G(Wg, d2._currentValue);
        d2._currentValue = e;
        break;
      case 13:
        d2 = b.memoizedState;
        if (null !== d2) {
          if (null !== d2.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
          if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
          G(L, L.current & 1);
          a = Zi(a, b, c);
          return null !== a ? a.sibling : null;
        }
        G(L, L.current & 1);
        break;
      case 19:
        d2 = 0 !== (c & b.childLanes);
        if (0 !== (a.flags & 128)) {
          if (d2) return xj(a, b, c);
          b.flags |= 128;
        }
        e = b.memoizedState;
        null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
        G(L, L.current);
        if (d2) break;
        else return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; null !== c; ) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
      else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;
      for (; null === c.sibling; ) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return;
      c = c.sibling;
    }
  };
  Aj = function() {
  };
  Bj = function(a, b, c, d2) {
    var e = a.memoizedProps;
    if (e !== d2) {
      a = b.stateNode;
      xh(uh.current);
      var f = null;
      switch (c) {
        case "input":
          e = Ya(a, e);
          d2 = Ya(a, d2);
          f = [];
          break;
        case "select":
          e = A({}, e, { value: void 0 });
          d2 = A({}, d2, { value: void 0 });
          f = [];
          break;
        case "textarea":
          e = gb(a, e);
          d2 = gb(a, d2);
          f = [];
          break;
        default:
          "function" !== typeof e.onClick && "function" === typeof d2.onClick && (a.onclick = Bf);
      }
      ub(c, d2);
      var g;
      c = null;
      for (l in e) if (!d2.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];
        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
      for (l in d2) {
        var k = d2[l];
        h = null != e ? e[l] : void 0;
        if (d2.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
          for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
        } else c || (f || (f = []), f.push(
          l,
          c
        )), c = k;
        else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
      }
      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };
  Cj = function(a, b, c, d2) {
    c !== d2 && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
        null === c ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d2 = null; null !== c; ) null !== c.alternate && (d2 = c), c = c.sibling;
        null === d2 ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d2.sibling = null;
    }
  }
  function S(a) {
    var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d2 = 0;
    if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags & 14680064, d2 |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d2 |= e.subtreeFlags, d2 |= e.flags, e.return = a, e = e.sibling;
    a.subtreeFlags |= d2;
    a.childLanes = c;
    return b;
  }
  function Ej(a, b, c) {
    var d2 = b.pendingProps;
    wg(b);
    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S(b), null;
      case 1:
        return Zf(b.type) && $f(), S(b), null;
      case 3:
        d2 = b.stateNode;
        zh();
        E(Wf);
        E(H);
        Eh();
        d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
        if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
        Aj(a, b);
        S(b);
        return null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Bj(a, b, c, d2, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d2) {
            if (null === b.stateNode) throw Error(p(166));
            S(b);
            return null;
          }
          a = xh(uh.current);
          if (Gg(b)) {
            d2 = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d2[Of] = b;
            d2[Pf] = f;
            a = 0 !== (b.mode & 1);
            switch (c) {
              case "dialog":
                D("cancel", d2);
                D("close", d2);
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", d2);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D(lf[e], d2);
                break;
              case "source":
                D("error", d2);
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  d2
                );
                D("load", d2);
                break;
              case "details":
                D("toggle", d2);
                break;
              case "input":
                Za(d2, f);
                D("invalid", d2);
                break;
              case "select":
                d2._wrapperState = { wasMultiple: !!f.multiple };
                D("invalid", d2);
                break;
              case "textarea":
                hb(d2, f), D("invalid", d2);
            }
            ub(c, f);
            e = null;
            for (var g in f) if (f.hasOwnProperty(g)) {
              var h = f[g];
              "children" === g ? "string" === typeof h ? d2.textContent !== h && (true !== f.suppressHydrationWarning && Af(d2.textContent, h, a), e = ["children", h]) : "number" === typeof h && d2.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                d2.textContent,
                h,
                a
              ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d2);
            }
            switch (c) {
              case "input":
                Va(d2);
                db(d2, f, true);
                break;
              case "textarea":
                Va(d2);
                jb(d2);
                break;
              case "select":
              case "option":
                break;
              default:
                "function" === typeof f.onClick && (d2.onclick = Bf);
            }
            d2 = e;
            b.updateQueue = d2;
            null !== d2 && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
            "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d2.is ? a = g.createElement(c, { is: d2.is }) : (a = g.createElement(c), "select" === c && (g = a, d2.multiple ? g.multiple = true : d2.size && (g.size = d2.size))) : a = g.createElementNS(a, c);
            a[Of] = b;
            a[Pf] = d2;
            zj(a, b, false, false);
            b.stateNode = a;
            a: {
              g = vb(c, d2);
              switch (c) {
                case "dialog":
                  D("cancel", a);
                  D("close", a);
                  e = d2;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D("load", a);
                  e = d2;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D(lf[e], a);
                  e = d2;
                  break;
                case "source":
                  D("error", a);
                  e = d2;
                  break;
                case "img":
                case "image":
                case "link":
                  D(
                    "error",
                    a
                  );
                  D("load", a);
                  e = d2;
                  break;
                case "details":
                  D("toggle", a);
                  e = d2;
                  break;
                case "input":
                  Za(a, d2);
                  e = Ya(a, d2);
                  D("invalid", a);
                  break;
                case "option":
                  e = d2;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d2.multiple };
                  e = A({}, d2, { value: void 0 });
                  D("invalid", a);
                  break;
                case "textarea":
                  hb(a, d2);
                  e = gb(a, d2);
                  D("invalid", a);
                  break;
                default:
                  e = d2;
              }
              ub(c, e);
              h = e;
              for (f in h) if (h.hasOwnProperty(f)) {
                var k = h[f];
                "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
              }
              switch (c) {
                case "input":
                  Va(a);
                  db(a, d2, false);
                  break;
                case "textarea":
                  Va(a);
                  jb(a);
                  break;
                case "option":
                  null != d2.value && a.setAttribute("value", "" + Sa(d2.value));
                  break;
                case "select":
                  a.multiple = !!d2.multiple;
                  f = d2.value;
                  null != f ? fb(a, !!d2.multiple, f, false) : null != d2.defaultValue && fb(
                    a,
                    !!d2.multiple,
                    d2.defaultValue,
                    true
                  );
                  break;
                default:
                  "function" === typeof e.onClick && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d2 = !!d2.autoFocus;
                  break a;
                case "img":
                  d2 = true;
                  break a;
                default:
                  d2 = false;
              }
            }
            d2 && (b.flags |= 4);
          }
          null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        }
        S(b);
        return null;
      case 6:
        if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d2);
        else {
          if ("string" !== typeof d2 && null === b.stateNode) throw Error(p(166));
          c = xh(wh.current);
          xh(uh.current);
          if (Gg(b)) {
            d2 = b.stateNode;
            c = b.memoizedProps;
            d2[Of] = b;
            if (f = d2.nodeValue !== c) {
              if (a = xg, null !== a) switch (a.tag) {
                case 3:
                  Af(d2.nodeValue, c, 0 !== (a.mode & 1));
                  break;
                case 5:
                  true !== a.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c, 0 !== (a.mode & 1));
              }
            }
            f && (b.flags |= 4);
          } else d2 = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d2), d2[Of] = b, b.stateNode = d2;
        }
        S(b);
        return null;
      case 13:
        E(L);
        d2 = b.memoizedState;
        if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
          if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
          else if (f = Gg(b), null !== d2 && null !== d2.dehydrated) {
            if (null === a) {
              if (!f) throw Error(p(318));
              f = b.memoizedState;
              f = null !== f ? f.dehydrated : null;
              if (!f) throw Error(p(317));
              f[Of] = b;
            } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S(b);
            f = false;
          } else null !== zg && (Fj(zg), zg = null), f = true;
          if (!f) return b.flags & 65536 ? b : null;
        }
        if (0 !== (b.flags & 128)) return b.lanes = c, b;
        d2 = null !== d2;
        d2 !== (null !== a && null !== a.memoizedState) && d2 && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
        null !== b.updateQueue && (b.flags |= 4);
        S(b);
        return null;
      case 4:
        return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
      case 10:
        return ah(b.type._context), S(b), null;
      case 17:
        return Zf(b.type) && $f(), S(b), null;
      case 19:
        E(L);
        f = b.memoizedState;
        if (null === f) return S(b), null;
        d2 = 0 !== (b.flags & 128);
        g = f.rendering;
        if (null === g) if (d2) Dj(f, false);
        else {
          if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
            g = Ch(a);
            if (null !== g) {
              b.flags |= 128;
              Dj(f, false);
              d2 = g.updateQueue;
              null !== d2 && (b.updateQueue = d2, b.flags |= 4);
              b.subtreeFlags = 0;
              d2 = c;
              for (c = b.child; null !== c; ) f = c, a = d2, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              G(L, L.current & 1 | 2);
              return b.child;
            }
            a = a.sibling;
          }
          null !== f.tail && B() > Gj && (b.flags |= 128, d2 = true, Dj(f, false), b.lanes = 4194304);
        }
        else {
          if (!d2) if (a = Ch(g), null !== a) {
            if (b.flags |= 128, d2 = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
          } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d2 = true, Dj(f, false), b.lanes = 4194304);
          f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
        }
        if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d2 ? c & 1 | 2 : c & 1), b;
        S(b);
        return null;
      case 22:
      case 23:
        return Hj(), d2 = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d2 && (b.flags |= 8192), d2 && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    wg(b);
    switch (b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        E(L);
        a = b.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          if (null === b.alternate) throw Error(p(340));
          Ig();
        }
        a = b.flags;
        return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E(L), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
  function Lj(a, b) {
    var c = a.ref;
    if (null !== c) if ("function" === typeof c) try {
      c(null);
    } catch (d2) {
      W(a, b, d2);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d2) {
      W(a, b, d2);
    }
  }
  var Nj = false;
  function Oj(a, b) {
    Cf = dd;
    a = Me();
    if (Ne(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d2 = c.getSelection && c.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c = d2.anchorNode;
          var e = d2.anchorOffset, f = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c.nodeType, f.nodeType;
          } catch (F) {
            c = null;
            break a;
          }
          var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r2 = null;
          b: for (; ; ) {
            for (var y2; ; ) {
              q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
              q !== f || 0 !== d2 && 3 !== q.nodeType || (k = g + d2);
              3 === q.nodeType && (g += q.nodeValue.length);
              if (null === (y2 = q.firstChild)) break;
              r2 = q;
              q = y2;
            }
            for (; ; ) {
              if (q === a) break b;
              r2 === c && ++l === e && (h = g);
              r2 === f && ++m === d2 && (k = g);
              if (null !== (y2 = q.nextSibling)) break;
              q = r2;
              r2 = q.parentNode;
            }
            q = y2;
          }
          c = -1 === h || -1 === k ? null : { start: h, end: k };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    Df = { focusedElem: a, selectionRange: c };
    dd = false;
    for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
    else for (; null !== V; ) {
      b = V;
      try {
        var n = b.alternate;
        if (0 !== (b.flags & 1024)) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (null !== n) {
              var t = n.memoizedProps, J = n.memoizedState, x2 = b.stateNode, w = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
              x2.__reactInternalSnapshotBeforeUpdate = w;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F) {
        W(b, b.return, F);
      }
      a = b.sibling;
      if (null !== a) {
        a.return = b.return;
        V = a;
        break;
      }
      V = b.return;
    }
    n = Nj;
    Nj = false;
    return n;
  }
  function Pj(a, b, c) {
    var d2 = b.updateQueue;
    d2 = null !== d2 ? d2.lastEffect : null;
    if (null !== d2) {
      var e = d2 = d2.next;
      do {
        if ((e.tag & a) === a) {
          var f = e.destroy;
          e.destroy = void 0;
          void 0 !== f && Mj(b, c, f);
        }
        e = e.next;
      } while (e !== d2);
    }
  }
  function Qj(a, b) {
    b = b.updateQueue;
    b = null !== b ? b.lastEffect : null;
    if (null !== b) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d2 = c.create;
          c.destroy = d2();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (null !== b) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      "function" === typeof b ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    null !== b && (a.alternate = null, Sj(b));
    a.child = null;
    a.deletions = null;
    a.sibling = null;
    5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
    a.stateNode = null;
    a.return = null;
    a.dependencies = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.stateNode = null;
    a.updateQueue = null;
  }
  function Tj(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; null === a.sibling; ) {
        if (null === a.return || Tj(a.return)) return null;
        a = a.return;
      }
      a.sibling.return = a.return;
      for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
        if (a.flags & 2) continue a;
        if (null === a.child || 4 === a.tag) continue a;
        else a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
    else if (4 !== d2 && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d2 = a.tag;
    if (5 === d2 || 6 === d2) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (4 !== d2 && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
  }
  var X = null, Xj = false;
  function Yj(a, b, c) {
    for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
      lc.onCommitFiberUnmount(kc, c);
    } catch (h) {
    }
    switch (c.tag) {
      case 5:
        U || Lj(c, b);
      case 6:
        var d2 = X, e = Xj;
        X = null;
        Yj(a, b, c);
        X = d2;
        Xj = e;
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
        break;
      case 18:
        null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
        break;
      case 4:
        d2 = X;
        e = Xj;
        X = c.stateNode.containerInfo;
        Xj = true;
        Yj(a, b, c);
        X = d2;
        Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U && (d2 = c.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
          e = d2 = d2.next;
          do {
            var f = e, g = f.destroy;
            f = f.tag;
            void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
            e = e.next;
          } while (e !== d2);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U && (Lj(c, b), d2 = c.stateNode, "function" === typeof d2.componentWillUnmount)) try {
          d2.props = c.memoizedProps, d2.state = c.memoizedState, d2.componentWillUnmount();
        } catch (h) {
          W(c, b, h);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U = (d2 = U) || null !== c.memoizedState, Yj(a, b, c), U = d2) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Kj());
      b.forEach(function(b2) {
        var d2 = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d2, d2));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (null !== c) for (var d2 = 0; d2 < c.length; d2++) {
      var e = c[d2];
      try {
        var f = a, g = b, h = g;
        a: for (; null !== h; ) {
          switch (h.tag) {
            case 5:
              X = h.stateNode;
              Xj = false;
              break a;
            case 3:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
            case 4:
              X = h.stateNode.containerInfo;
              Xj = true;
              break a;
          }
          h = h.return;
        }
        if (null === X) throw Error(p(160));
        Zj(f, g, e);
        X = null;
        Xj = false;
        var k = e.alternate;
        null !== k && (k.return = null);
        e.return = null;
      } catch (l) {
        W(e, b, l);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d2 = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ck(b, a);
        ek(a);
        if (d2 & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t) {
            W(a, a.return, t);
          }
          try {
            Pj(5, a, a.return);
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 1:
        ck(b, a);
        ek(a);
        d2 & 512 && null !== c && Lj(c, c.return);
        break;
      case 5:
        ck(b, a);
        ek(a);
        d2 & 512 && null !== c && Lj(c, c.return);
        if (a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W(a, a.return, t);
          }
        }
        if (d2 & 4 && (e = a.stateNode, null != e)) {
          var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
          a.updateQueue = null;
          if (null !== k) try {
            "input" === h && "radio" === f.type && null != f.name && ab(e, f);
            vb(h, g);
            var l = vb(h, f);
            for (g = 0; g < k.length; g += 2) {
              var m = k[g], q = k[g + 1];
              "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
            }
            switch (h) {
              case "input":
                bb(e, f);
                break;
              case "textarea":
                ib(e, f);
                break;
              case "select":
                var r2 = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f.multiple;
                var y2 = f.value;
                null != y2 ? fb(e, !!f.multiple, y2, false) : r2 !== !!f.multiple && (null != f.defaultValue ? fb(
                  e,
                  !!f.multiple,
                  f.defaultValue,
                  true
                ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
            }
            e[Pf] = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 6:
        ck(b, a);
        ek(a);
        if (d2 & 4) {
          if (null === a.stateNode) throw Error(p(162));
          e = a.stateNode;
          f = a.memoizedProps;
          try {
            e.nodeValue = f;
          } catch (t) {
            W(a, a.return, t);
          }
        }
        break;
      case 3:
        ck(b, a);
        ek(a);
        if (d2 & 4 && null !== c && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t) {
          W(a, a.return, t);
        }
        break;
      case 4:
        ck(b, a);
        ek(a);
        break;
      case 13:
        ck(b, a);
        ek(a);
        e = a.child;
        e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
        d2 & 4 && ak(a);
        break;
      case 22:
        m = null !== c && null !== c.memoizedState;
        a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
        ek(a);
        if (d2 & 8192) {
          l = null !== a.memoizedState;
          if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
            for (q = V = m; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r2, r2.return);
                  break;
                case 1:
                  Lj(r2, r2.return);
                  var n = r2.stateNode;
                  if ("function" === typeof n.componentWillUnmount) {
                    d2 = r2;
                    c = r2.return;
                    try {
                      b = d2, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W(d2, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    gk(q);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : gk(q);
            }
            m = m.sibling;
          }
          a: for (m = null, q = a; ; ) {
            if (5 === q.tag) {
              if (null === m) {
                m = q;
                try {
                  e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                } catch (t) {
                  W(a, a.return, t);
                }
              }
            } else if (6 === q.tag) {
              if (null === m) try {
                q.stateNode.nodeValue = l ? "" : q.memoizedProps;
              } catch (t) {
                W(a, a.return, t);
              }
            } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
              q.child.return = q;
              q = q.child;
              continue;
            }
            if (q === a) break a;
            for (; null === q.sibling; ) {
              if (null === q.return || q.return === a) break a;
              m === q && (m = null);
              q = q.return;
            }
            m === q && (m = null);
            q.sibling.return = q.return;
            q = q.sibling;
          }
        }
        break;
      case 19:
        ck(b, a);
        ek(a);
        d2 & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; null !== c; ) {
            if (Tj(c)) {
              var d2 = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d2.tag) {
          case 5:
            var e = d2.stateNode;
            d2.flags & 32 && (ob(e, ""), d2.flags &= -33);
            var f = Uj(a);
            Wj(a, f, e);
            break;
          case 3:
          case 4:
            var g = d2.stateNode.containerInfo, h = Uj(a);
            Vj(a, h, g);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k) {
        W(a, a.return, k);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V = a;
    ik(a);
  }
  function ik(a, b, c) {
    for (var d2 = 0 !== (a.mode & 1); null !== V; ) {
      var e = V, f = e.child;
      if (22 === e.tag && d2) {
        var g = null !== e.memoizedState || Jj;
        if (!g) {
          var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
          h = Jj;
          var l = U;
          Jj = g;
          if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
          for (; null !== f; ) V = f, ik(f), f = f.sibling;
          V = e;
          Jj = h;
          U = l;
        }
        kk(a);
      } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
    }
  }
  function kk(a) {
    for (; null !== V; ) {
      var b = V;
      if (0 !== (b.flags & 8772)) {
        var c = b.alternate;
        try {
          if (0 !== (b.flags & 8772)) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U || Qj(5, b);
              break;
            case 1:
              var d2 = b.stateNode;
              if (b.flags & 4 && !U) if (null === c) d2.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d2.componentDidUpdate(e, c.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
              }
              var f = b.updateQueue;
              null !== f && sh(b, f, d2);
              break;
            case 3:
              var g = b.updateQueue;
              if (null !== g) {
                c = null;
                if (null !== b.child) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh(b, g, c);
              }
              break;
            case 5:
              var h = b.stateNode;
              if (null === c && b.flags & 4) {
                c = h;
                var k = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k.autoFocus && c.focus();
                    break;
                  case "img":
                    k.src && (c.src = k.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b.memoizedState) {
                var l = b.alternate;
                if (null !== l) {
                  var m = l.memoizedState;
                  if (null !== m) {
                    var q = m.dehydrated;
                    null !== q && bd(q);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U || b.flags & 512 && Rj(b);
        } catch (r2) {
          W(b, b.return, r2);
        }
      }
      if (b === a) {
        V = null;
        break;
      }
      c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function gk(a) {
    for (; null !== V; ) {
      var b = V;
      if (b === a) {
        V = null;
        break;
      }
      var c = b.sibling;
      if (null !== c) {
        c.return = b.return;
        V = c;
        break;
      }
      V = b.return;
    }
  }
  function jk(a) {
    for (; null !== V; ) {
      var b = V;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k) {
              W(b, c, k);
            }
            break;
          case 1:
            var d2 = b.stateNode;
            if ("function" === typeof d2.componentDidMount) {
              var e = b.return;
              try {
                d2.componentDidMount();
              } catch (k) {
                W(b, e, k);
              }
            }
            var f = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, f, k);
            }
            break;
          case 5:
            var g = b.return;
            try {
              Rj(b);
            } catch (k) {
              W(b, g, k);
            }
        }
      } catch (k) {
        W(b, b.return, k);
      }
      if (b === a) {
        V = null;
        break;
      }
      var h = b.sibling;
      if (null !== h) {
        h.return = b.return;
        V = h;
        break;
      }
      V = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R() {
    return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
  }
  function yi(a) {
    if (0 === (a.mode & 1)) return 1;
    if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
    if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
    a = C;
    if (0 !== a) return a;
    a = window.event;
    a = void 0 === a ? 16 : jd(a.type);
    return a;
  }
  function gi(a, b, c, d2) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d2);
    if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d2), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d2 & -d2, a.callbackPriority !== b) {
      null != c && bc(c);
      if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        0 === (K & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d2)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    Ak = -1;
    Bk = 0;
    if (0 !== (K & 6)) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d2 = uc(a, a === Q ? Z : 0);
    if (0 === d2) return null;
    if (0 !== (d2 & 30) || 0 !== (d2 & a.expiredLanes) || b) b = Ik(a, d2);
    else {
      b = d2;
      var e = K;
      K |= 2;
      var f = Jk();
      if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
      do
        try {
          Lk();
          break;
        } catch (h) {
          Mk(a, h);
        }
      while (1);
      $g();
      mk.current = f;
      K = e;
      null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
    }
    if (0 !== b) {
      2 === b && (e = xc(a), 0 !== e && (d2 = e, b = Nk(a, e)));
      if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c;
      if (6 === b) Ck(a, d2);
      else {
        e = a.current.alternate;
        if (0 === (d2 & 30) && !Ok(e) && (b = Ik(a, d2), 2 === b && (f = xc(a), 0 !== f && (d2 = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d2), Dk(a, B()), c;
        a.finishedWork = e;
        a.finishedLanes = d2;
        switch (b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            Ck(a, d2);
            if ((d2 & 130023424) === d2 && (b = fk + 500 - B(), 10 < b)) {
              if (0 !== uc(a, 0)) break;
              e = a.suspendedLanes;
              if ((e & d2) !== d2) {
                R();
                a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            Ck(a, d2);
            if ((d2 & 4194240) === d2) break;
            b = a.eventTimes;
            for (e = -1; 0 < d2; ) {
              var g = 31 - oc(d2);
              f = 1 << g;
              g = b[g];
              g > e && (e = g);
              d2 &= ~f;
            }
            d2 = e;
            d2 = B() - d2;
            d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
            if (10 < d2) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d2);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    Dk(a, B());
    return a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
    a = Ik(a, b);
    2 !== a && (b = tk, tk = c, null !== b && Fj(b));
    return a;
  }
  function Fj(a) {
    null === tk ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (null !== c && (c = c.stores, null !== c)) for (var d2 = 0; d2 < c.length; d2++) {
          var e = c[d2], f = e.getSnapshot;
          e = e.value;
          try {
            if (!He(f(), e)) return false;
          } catch (g) {
            return false;
          }
        }
      }
      c = b.child;
      if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; null === b.sibling; ) {
          if (null === b.return || b.return === a) return true;
          b = b.return;
        }
        b.sibling.return = b.return;
        b = b.sibling;
      }
    }
    return true;
  }
  function Ck(a, b) {
    b &= ~rk;
    b &= ~qk;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;
    for (a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d2 = 1 << c;
      a[c] = -1;
      b &= ~d2;
    }
  }
  function Ek(a) {
    if (0 !== (K & 6)) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (0 === (b & 1)) return Dk(a, B()), null;
    var c = Ik(a, b);
    if (0 !== a.tag && 2 === c) {
      var d2 = xc(a);
      0 !== d2 && (b = d2, c = Nk(a, d2));
    }
    if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
    if (6 === c) throw Error(p(345));
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Pk(a, tk, uk);
    Dk(a, B());
    return null;
  }
  function Qk(a, b) {
    var c = K;
    K |= 1;
    try {
      return a(b);
    } finally {
      K = c, 0 === K && (Gj = B() + 500, fg && jg());
    }
  }
  function Rk(a) {
    null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
    var b = K;
    K |= 1;
    var c = ok.transition, d2 = C;
    try {
      if (ok.transition = null, C = 1, a) return a();
    } finally {
      C = d2, ok.transition = c, K = b, 0 === (K & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current;
    E(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, Gf(c));
    if (null !== Y) for (c = Y.return; null !== c; ) {
      var d2 = c;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          zh();
          E(Wf);
          E(H);
          Eh();
          break;
        case 5:
          Bh(d2);
          break;
        case 4:
          zh();
          break;
        case 13:
          E(L);
          break;
        case 19:
          E(L);
          break;
        case 10:
          ah(d2.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    Q = a;
    Y = a = Pg(a.current, null);
    Z = fj = b;
    T = 0;
    pk = null;
    rk = qk = rh = 0;
    tk = sk = null;
    if (null !== fh) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d2 = c.interleaved, null !== d2) {
        c.interleaved = null;
        var e = d2.next, f = c.pending;
        if (null !== f) {
          var g = f.next;
          f.next = e;
          d2.next = g;
        }
        c.pending = d2;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y;
      try {
        $g();
        Fh.current = Rh;
        if (Ih) {
          for (var d2 = M.memoizedState; null !== d2; ) {
            var e = d2.queue;
            null !== e && (e.pending = null);
            d2 = d2.next;
          }
          Ih = false;
        }
        Hh = 0;
        O = N = M = null;
        Jh = false;
        Kh = 0;
        nk.current = null;
        if (null === c || null === c.return) {
          T = 1;
          pk = b;
          Y = null;
          break;
        }
        a: {
          var f = a, g = c.return, h = c, k = b;
          b = Z;
          h.flags |= 32768;
          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k, m = h, q = m.tag;
            if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
              var r2 = m.alternate;
              r2 ? (m.updateQueue = r2.updateQueue, m.memoizedState = r2.memoizedState, m.lanes = r2.lanes) : (m.updateQueue = null, m.memoizedState = null);
            }
            var y2 = Ui(g);
            if (null !== y2) {
              y2.flags &= -257;
              Vi(y2, g, h, f, b);
              y2.mode & 1 && Si(f, l, b);
              b = y2;
              k = l;
              var n = b.updateQueue;
              if (null === n) {
                var t = /* @__PURE__ */ new Set();
                t.add(k);
                b.updateQueue = t;
              } else n.add(k);
              break a;
            } else {
              if (0 === (b & 1)) {
                Si(f, l, b);
                tj();
                break a;
              }
              k = Error(p(426));
            }
          } else if (I && h.mode & 1) {
            var J = Ui(g);
            if (null !== J) {
              0 === (J.flags & 65536) && (J.flags |= 256);
              Vi(J, g, h, f, b);
              Jg(Ji(k, h));
              break a;
            }
          }
          f = k = Ji(k, h);
          4 !== T && (T = 2);
          null === sk ? sk = [f] : sk.push(f);
          f = g;
          do {
            switch (f.tag) {
              case 3:
                f.flags |= 65536;
                b &= -b;
                f.lanes |= b;
                var x2 = Ni(f, k, b);
                ph(f, x2);
                break a;
              case 1:
                h = k;
                var w = f.type, u = f.stateNode;
                if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                  f.flags |= 65536;
                  b &= -b;
                  f.lanes |= b;
                  var F = Qi(f, h, b);
                  ph(f, F);
                  break a;
                }
            }
            f = f.return;
          } while (null !== f);
        }
        Sk(c);
      } catch (na) {
        b = na;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }
      break;
    } while (1);
  }
  function Jk() {
    var a = mk.current;
    mk.current = Rh;
    return null === a ? Rh : a;
  }
  function tj() {
    if (0 === T || 3 === T || 2 === T) T = 4;
    null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
  }
  function Ik(a, b) {
    var c = K;
    K |= 2;
    var d2 = Jk();
    if (Q !== a || Z !== b) uk = null, Kk(a, b);
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (1);
    $g();
    K = c;
    mk.current = d2;
    if (null !== Y) throw Error(p(261));
    Q = null;
    Z = 0;
    return T;
  }
  function Tk() {
    for (; null !== Y; ) Uk(Y);
  }
  function Lk() {
    for (; null !== Y && !cc(); ) Uk(Y);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps;
    null === b ? Sk(a) : Y = b;
    nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      a = b.return;
      if (0 === (b.flags & 32768)) {
        if (c = Ej(c, b, fj), null !== c) {
          Y = c;
          return;
        }
      } else {
        c = Ij(c, b);
        if (null !== c) {
          c.flags &= 32767;
          Y = c;
          return;
        }
        if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T = 6;
          Y = null;
          return;
        }
      }
      b = b.sibling;
      if (null !== b) {
        Y = b;
        return;
      }
      Y = b = a;
    } while (null !== b);
    0 === T && (T = 5);
  }
  function Pk(a, b, c) {
    var d2 = C, e = ok.transition;
    try {
      ok.transition = null, C = 1, Wk(a, b, c, d2);
    } finally {
      ok.transition = e, C = d2;
    }
    return null;
  }
  function Wk(a, b, c, d2) {
    do
      Hk();
    while (null !== wk);
    if (0 !== (K & 6)) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(p(177));
    a.callbackNode = null;
    a.callbackPriority = 0;
    var f = c.lanes | c.childLanes;
    Bc(a, f);
    a === Q && (Y = Q = null, Z = 0);
    0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
      Hk();
      return null;
    }));
    f = 0 !== (c.flags & 15990);
    if (0 !== (c.subtreeFlags & 15990) || f) {
      f = ok.transition;
      ok.transition = null;
      var g = C;
      C = 1;
      var h = K;
      K |= 4;
      nk.current = null;
      Oj(a, c);
      dk(c, a);
      Oe(Df);
      dd = !!Cf;
      Df = Cf = null;
      a.current = c;
      hk(c);
      dc();
      K = h;
      C = g;
      ok.transition = f;
    } else a.current = c;
    vk && (vk = false, wk = a, xk = e);
    f = a.pendingLanes;
    0 === f && (Ri = null);
    mc(c.stateNode);
    Dk(a, B());
    if (null !== b) for (d2 = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d2(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = false, a = Pi, Pi = null, a;
    0 !== (xk & 1) && 0 !== a.tag && Hk();
    f = a.pendingLanes;
    0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
    jg();
    return null;
  }
  function Hk() {
    if (null !== wk) {
      var a = Dc(xk), b = ok.transition, c = C;
      try {
        ok.transition = null;
        C = 16 > a ? 16 : a;
        if (null === wk) var d2 = false;
        else {
          a = wk;
          wk = null;
          xk = 0;
          if (0 !== (K & 6)) throw Error(p(331));
          var e = K;
          K |= 4;
          for (V = a.current; null !== V; ) {
            var f = V, g = f.child;
            if (0 !== (V.flags & 16)) {
              var h = f.deletions;
              if (null !== h) {
                for (var k = 0; k < h.length; k++) {
                  var l = h[k];
                  for (V = l; null !== V; ) {
                    var m = V;
                    switch (m.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m, f);
                    }
                    var q = m.child;
                    if (null !== q) q.return = m, V = q;
                    else for (; null !== V; ) {
                      m = V;
                      var r2 = m.sibling, y2 = m.return;
                      Sj(m);
                      if (m === l) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                  }
                }
                var n = f.alternate;
                if (null !== n) {
                  var t = n.child;
                  if (null !== t) {
                    n.child = null;
                    do {
                      var J = t.sibling;
                      t.sibling = null;
                      t = J;
                    } while (null !== t);
                  }
                }
                V = f;
              }
            }
            if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
            else b: for (; null !== V; ) {
              f = V;
              if (0 !== (f.flags & 2048)) switch (f.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f, f.return);
              }
              var x2 = f.sibling;
              if (null !== x2) {
                x2.return = f.return;
                V = x2;
                break b;
              }
              V = f.return;
            }
          }
          var w = a.current;
          for (V = w; null !== V; ) {
            g = V;
            var u = g.child;
            if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
            else b: for (g = w; null !== V; ) {
              h = V;
              if (0 !== (h.flags & 2048)) try {
                switch (h.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h);
                }
              } catch (na) {
                W(h, h.return, na);
              }
              if (h === g) {
                V = null;
                break b;
              }
              var F = h.sibling;
              if (null !== F) {
                F.return = h.return;
                V = F;
                break b;
              }
              V = h.return;
            }
          }
          K = e;
          jg();
          if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch (na) {
          }
          d2 = true;
        }
        return d2;
      } finally {
        C = c, ok.transition = b;
      }
    }
    return false;
  }
  function Xk(a, b, c) {
    b = Ji(c, b);
    b = Ni(a, b, 1);
    a = nh(a, b, 1);
    b = R();
    null !== a && (Ac(a, 1, b), Dk(a, b));
  }
  function W(a, b, c) {
    if (3 === a.tag) Xk(a, a, c);
    else for (; null !== b; ) {
      if (3 === b.tag) {
        Xk(b, a, c);
        break;
      } else if (1 === b.tag) {
        var d2 = b.stateNode;
        if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
          a = Ji(c, a);
          a = Qi(b, a, 1);
          b = nh(b, a, 1);
          a = R();
          null !== b && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d2 = a.pingCache;
    null !== d2 && d2.delete(b);
    b = R();
    a.pingedLanes |= a.suspendedLanes & c;
    Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
    Dk(a, b);
  }
  function Yk(a, b) {
    0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
    var c = R();
    a = ih(a, b);
    null !== a && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    null !== b && (c = b.retryLane);
    Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d2 = a.stateNode;
        var e = a.memoizedState;
        null !== e && (c = e.retryLane);
        break;
      case 19:
        d2 = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    null !== d2 && d2.delete(b);
    Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
    else {
      if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
      dh = 0 !== (a.flags & 131072) ? true : false;
    }
    else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
    b.lanes = 0;
    switch (b.tag) {
      case 2:
        var d2 = b.type;
        ij(a, b);
        a = b.pendingProps;
        var e = Yf(b, H.current);
        ch(b, c);
        e = Nh(null, b, d2, a, e, c);
        var f = Sh();
        b.flags |= 1;
        "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d2) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d2, a, c), b = jj(null, b, d2, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
        return b;
      case 16:
        d2 = b.elementType;
        a: {
          ij(a, b);
          a = b.pendingProps;
          e = d2._init;
          d2 = e(d2._payload);
          b.type = d2;
          e = b.tag = Zk(d2);
          a = Ci(d2, a);
          switch (e) {
            case 0:
              b = cj(null, b, d2, a, c);
              break a;
            case 1:
              b = hj(null, b, d2, a, c);
              break a;
            case 11:
              b = Yi(null, b, d2, a, c);
              break a;
            case 14:
              b = $i(null, b, d2, Ci(d2.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d2,
            ""
          ));
        }
        return b;
      case 0:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci(d2, e), cj(a, b, d2, e, c);
      case 1:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci(d2, e), hj(a, b, d2, e, c);
      case 3:
        a: {
          kj(b);
          if (null === a) throw Error(p(387));
          d2 = b.pendingProps;
          f = b.memoizedState;
          e = f.element;
          lh(a, b);
          qh(b, d2, null, c);
          var g = b.memoizedState;
          d2 = g.element;
          if (f.isDehydrated) if (f = { element: d2, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
            e = Ji(Error(p(423)), b);
            b = lj(a, b, d2, c, e);
            break a;
          } else if (d2 !== e) {
            e = Ji(Error(p(424)), b);
            b = lj(a, b, d2, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d2, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            Ig();
            if (d2 === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi(a, b, d2, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), null === a && Eg(b), d2 = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d2, e) ? g = null : null !== f && Ef(d2, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
      case 6:
        return null === a && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d2 = b.pendingProps, null === a ? b.child = Ug(b, null, d2, c) : Xi(a, b, d2, c), b.child;
      case 11:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci(d2, e), Yi(a, b, d2, e, c);
      case 7:
        return Xi(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          d2 = b.type._context;
          e = b.pendingProps;
          f = b.memoizedProps;
          g = e.value;
          G(Wg, d2._currentValue);
          d2._currentValue = g;
          if (null !== f) if (He(f.value, g)) {
            if (f.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
            var h = f.dependencies;
            if (null !== h) {
              g = f.child;
              for (var k = h.firstContext; null !== k; ) {
                if (k.context === d2) {
                  if (1 === f.tag) {
                    k = mh(-1, c & -c);
                    k.tag = 2;
                    var l = f.updateQueue;
                    if (null !== l) {
                      l = l.shared;
                      var m = l.pending;
                      null === m ? k.next = k : (k.next = m.next, m.next = k);
                      l.pending = k;
                    }
                  }
                  f.lanes |= c;
                  k = f.alternate;
                  null !== k && (k.lanes |= c);
                  bh(
                    f.return,
                    c,
                    b
                  );
                  h.lanes |= c;
                  break;
                }
                k = k.next;
              }
            } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
            else if (18 === f.tag) {
              g = f.return;
              if (null === g) throw Error(p(341));
              g.lanes |= c;
              h = g.alternate;
              null !== h && (h.lanes |= c);
              bh(g, c, b);
              g = f.sibling;
            } else g = f.child;
            if (null !== g) g.return = f;
            else for (g = f; null !== g; ) {
              if (g === b) {
                g = null;
                break;
              }
              f = g.sibling;
              if (null !== f) {
                f.return = g.return;
                g = f;
                break;
              }
              g = g.return;
            }
            f = g;
          }
          Xi(a, b, e.children, c);
          b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d2 = b.pendingProps.children, ch(b, c), e = eh(e), d2 = d2(e), b.flags |= 1, Xi(a, b, d2, c), b.child;
      case 14:
        return d2 = b.type, e = Ci(d2, b.pendingProps), e = Ci(d2.type, e), $i(a, b, d2, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d2 = b.type, e = b.pendingProps, e = b.elementType === d2 ? e : Ci(d2, e), ij(a, b), b.tag = 1, Zf(d2) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d2, e), Ii(b, d2, e, c), jj(null, b, d2, true, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac(a, b);
  }
  function $k(a, b, c, d2) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d2;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function Bg(a, b, c, d2) {
    return new $k(a, b, c, d2);
  }
  function aj(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if ("function" === typeof a) return aj(a) ? 1 : 0;
    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
    c.flags = a.flags & 14680064;
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }
  function Rg(a, b, c, d2, e, f) {
    var g = 2;
    d2 = a;
    if ("function" === typeof a) aj(a) && (g = 1);
    else if ("string" === typeof a) g = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f, b);
      case za:
        g = 8;
        e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
      case Ia:
        return pj(c, e, f, b);
      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case Ba:
            g = 10;
            break a;
          case Ca:
            g = 9;
            break a;
          case Da:
            g = 11;
            break a;
          case Ga:
            g = 14;
            break a;
          case Ha:
            g = 16;
            d2 = null;
            break a;
        }
        throw Error(p(130, null == a ? a : typeof a, ""));
    }
    b = Bg(g, c, b, e);
    b.elementType = a;
    b.type = d2;
    b.lanes = f;
    return b;
  }
  function Tg(a, b, c, d2) {
    a = Bg(7, a, d2, b);
    a.lanes = c;
    return a;
  }
  function pj(a, b, c, d2) {
    a = Bg(22, a, d2, b);
    a.elementType = Ia;
    a.lanes = c;
    a.stateNode = { isHidden: false };
    return a;
  }
  function Qg(a, b, c) {
    a = Bg(6, a, null, b);
    a.lanes = c;
    return a;
  }
  function Sg(a, b, c) {
    b = Bg(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
    return b;
  }
  function al(a, b, c, d2, e) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.pendingContext = this.context = null;
    this.callbackPriority = 0;
    this.eventTimes = zc(0);
    this.expirationTimes = zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = zc(0);
    this.identifierPrefix = d2;
    this.onRecoverableError = e;
    this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d2, e, f, g, h, k) {
    a = new al(a, b, c, h, k);
    1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
    f = Bg(3, null, null, b);
    a.current = f;
    f.stateNode = a;
    f.memoizedState = { element: d2, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
    kh(f);
    return a;
  }
  function cl(a, b, c) {
    var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (null !== b);
      throw Error(p(171));
    }
    if (1 === a.tag) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el(a, b, c, d2, e, f, g, h, k) {
    a = bl(c, d2, true, a, e, f, g, h, k);
    a.context = dl(null);
    c = a.current;
    d2 = R();
    e = yi(c);
    f = mh(d2, e);
    f.callback = void 0 !== b && null !== b ? b : null;
    nh(c, f, e);
    a.current.lanes = e;
    Ac(a, e, d2);
    Dk(a, d2);
    return a;
  }
  function fl(a, b, c, d2) {
    var e = b.current, f = R(), g = yi(e);
    c = dl(c);
    null === b.context ? b.context = c : b.pendingContext = c;
    b = mh(f, g);
    b.payload = { element: a };
    d2 = void 0 === d2 ? null : d2;
    null !== d2 && (b.callback = d2);
    a = nh(e, b, g);
    null !== a && (gi(a, e, g, f), oh(a, e, g));
    return g;
  }
  function gl(a) {
    a = a.current;
    if (!a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    a = a.memoizedState;
    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b);
    (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = "function" === typeof reportError ? reportError : function(a) {
    console.error(a);
  };
  function ll(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll.prototype.render = function(a) {
    var b = this._internalRoot;
    if (null === b) throw Error(p(409));
    fl(a, b, null, null);
  };
  ml.prototype.unmount = ll.prototype.unmount = function() {
    var a = this._internalRoot;
    if (null !== a) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      });
      b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a);
      0 === c && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
  }
  function ol(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }
  function pl() {
  }
  function ql(a, b, c, d2, e) {
    if (e) {
      if ("function" === typeof d2) {
        var f = d2;
        d2 = function() {
          var a2 = gl(g);
          f.call(a2);
        };
      }
      var g = el(b, d2, a, 0, null, false, false, "", pl);
      a._reactRootContainer = g;
      a[uf] = g.current;
      sf(8 === a.nodeType ? a.parentNode : a);
      Rk();
      return g;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if ("function" === typeof d2) {
      var h = d2;
      d2 = function() {
        var a2 = gl(k);
        h.call(a2);
      };
    }
    var k = bl(a, 0, false, null, null, false, false, "", pl);
    a._reactRootContainer = k;
    a[uf] = k.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    Rk(function() {
      fl(b, k, c, d2);
    });
    return k;
  }
  function rl(a, b, c, d2, e) {
    var f = c._reactRootContainer;
    if (f) {
      var g = f;
      if ("function" === typeof e) {
        var h = e;
        e = function() {
          var a2 = gl(g);
          h.call(a2);
        };
      }
      fl(b, g, a, e);
    } else g = ql(c, b, a, e, d2);
    return gl(g);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (null !== b2) {
            var c2 = R();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  };
  Fc = function(a) {
    if (13 === a.tag) {
      var b = ih(a, 134217728);
      if (null !== b) {
        var c = R();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  };
  Gc = function(a) {
    if (13 === a.tag) {
      var b = yi(a), c = ih(a, b);
      if (null !== c) {
        var d2 = R();
        gi(c, a, b, d2);
      }
      il(a, b);
    }
  };
  Hc = function() {
    return C;
  };
  Ic = function(a, b) {
    var c = C;
    try {
      return C = a, b();
    } finally {
      C = c;
    }
  };
  yb = function(a, b, c) {
    switch (b) {
      case "input":
        bb(a, c);
        b = c.name;
        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
          for (b = 0; b < c.length; b++) {
            var d2 = c[b];
            if (d2 !== a && d2.form === a.form) {
              var e = Db(d2);
              if (!e) throw Error(p(90));
              Wa(d2);
              bb(d2, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, false);
    }
  };
  Gb = Qk;
  Hb = Rk;
  var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
  var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    a = Zb(a);
    return null === a ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch (a) {
    }
  }
  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
  reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  };
  reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = false, d2 = "", e = kl;
    null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d2 = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
    b = bl(a, 1, false, null, null, c, false, d2, e);
    a[uf] = b.current;
    sf(8 === a.nodeType ? a.parentNode : a);
    return new ll(b);
  };
  reactDom_production_min.findDOMNode = function(a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;
    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(p(188));
      a = Object.keys(a).join(",");
      throw Error(p(268, a));
    }
    a = Zb(b);
    a = null === a ? null : a.stateNode;
    return a;
  };
  reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  };
  reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, true, c);
  };
  reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d2 = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
    null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
    b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
    a[uf] = b.current;
    sf(a);
    if (d2) for (a = 0; a < d2.length; a++) c = d2[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  };
  reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, false, c);
  };
  reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, false, function() {
        a._reactRootContainer = null;
        a[uf] = null;
      });
    }), true) : false;
  };
  reactDom_production_min.unstable_batchedUpdates = Qk;
  reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d2) {
    if (!ol(c)) throw Error(p(200));
    if (null == a || void 0 === a._reactInternals) throw Error(p(38));
    return rl(a, b, c, false, d2);
  };
  reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
  return reactDom_production_min;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production_min();
  }
  return reactDom.exports;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client;
  hasRequiredClient = 1;
  var m = requireReactDom();
  {
    client.createRoot = m.createRoot;
    client.hydrateRoot = m.hydrateRoot;
  }
  return client;
}
var clientExports = requireClient();
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
  function q(c, a, g) {
    var b, d2 = {}, e = null, h = null;
    void 0 !== g && (e = "" + g);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (h = a.ref);
    for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d2[b] = a[b]);
    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d2[b] && (d2[b] = a[b]);
    return { $$typeof: k, type: c, key: e, ref: h, props: d2, _owner: n.current };
  }
  reactJsxRuntime_production_min.Fragment = l;
  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;
  return reactJsxRuntime_production_min;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production_min();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var propTypes = { exports: {} };
var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  ReactPropTypesSecret_1 = ReactPropTypesSecret;
  return ReactPropTypesSecret_1;
}
var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
  function emptyFunction() {
  }
  function emptyFunctionWithReset() {
  }
  emptyFunctionWithReset.resetWarningCache = emptyFunction;
  factoryWithThrowingShims = function() {
    function shim2(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        return;
      }
      var err = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      err.name = "Invariant Violation";
      throw err;
    }
    shim2.isRequired = shim2;
    function getShim() {
      return shim2;
    }
    var ReactPropTypes = {
      array: shim2,
      bigint: shim2,
      bool: shim2,
      func: shim2,
      number: shim2,
      object: shim2,
      string: shim2,
      symbol: shim2,
      any: shim2,
      arrayOf: getShim,
      element: shim2,
      elementType: shim2,
      instanceOf: getShim,
      node: shim2,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };
  return factoryWithThrowingShims;
}
var hasRequiredPropTypes;
function requirePropTypes() {
  if (hasRequiredPropTypes) return propTypes.exports;
  hasRequiredPropTypes = 1;
  {
    propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
  }
  return propTypes.exports;
}
var propTypesExports = /* @__PURE__ */ requirePropTypes();
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs2 = "function" === typeof Object.is ? Object.is : is2, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs2(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
var shimExports = requireShim();
var withSelector = { exports: {} };
var withSelector_production = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is2(x2, y2) {
    return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
  }
  var objectIs2 = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore2 = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector2, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector2(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs2(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector2(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector2, isEqual]
    );
    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ContextKey = Symbol.for(`react-redux-context`);
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _gT$ContextKey;
  if (!reactExports.createContext) return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(null);
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = /* @__PURE__ */ getContext();
function createReduxContextHook(context2 = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context2);
    return contextValue;
  };
}
const useReduxContext = /* @__PURE__ */ createReduxContextHook();
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn) => {
  useSyncExternalStoreWithSelector = fn;
};
const refEquality = (a, b) => a === b;
function createSelectorHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = context2 === ReactReduxContext ? useReduxContext : createReduxContextHook(context2);
  return function useSelector2(selector2, equalityFnOrOptions = {}) {
    const {
      equalityFn = refEquality,
      stabilityCheck = void 0,
      noopCheck = void 0
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    const {
      store,
      subscription,
      getServerState,
      stabilityCheck: globalStabilityCheck,
      noopCheck: globalNoopCheck
    } = useReduxContext$1();
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback({
      [selector2.name](state) {
        const selected = selector2(state);
        return selected;
      }
    }[selector2.name], [selector2, globalStabilityCheck, stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store.getState, getServerState || store.getState, wrappedSelector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends$2.apply(null, arguments);
}
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r2[n];
  }
  return t;
}
var reactIs$3 = { exports: {} };
var reactIs_production_min$2 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$2;
function requireReactIs_production_min$2() {
  if (hasRequiredReactIs_production_min$2) return reactIs_production_min$2;
  hasRequiredReactIs_production_min$2 = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x2 = b ? Symbol.for("react.responder") : 60118, y2 = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r2:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d2:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min$2.AsyncMode = l;
  reactIs_production_min$2.ConcurrentMode = m;
  reactIs_production_min$2.ContextConsumer = k;
  reactIs_production_min$2.ContextProvider = h;
  reactIs_production_min$2.Element = c;
  reactIs_production_min$2.ForwardRef = n;
  reactIs_production_min$2.Fragment = e;
  reactIs_production_min$2.Lazy = t;
  reactIs_production_min$2.Memo = r2;
  reactIs_production_min$2.Portal = d2;
  reactIs_production_min$2.Profiler = g;
  reactIs_production_min$2.StrictMode = f;
  reactIs_production_min$2.Suspense = p;
  reactIs_production_min$2.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min$2.isConcurrentMode = A;
  reactIs_production_min$2.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min$2.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min$2.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min$2.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min$2.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min$2.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min$2.isMemo = function(a) {
    return z(a) === r2;
  };
  reactIs_production_min$2.isPortal = function(a) {
    return z(a) === d2;
  };
  reactIs_production_min$2.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min$2.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min$2.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min$2.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x2 || a.$$typeof === y2 || a.$$typeof === v);
  };
  reactIs_production_min$2.typeOf = z;
  return reactIs_production_min$2;
}
var hasRequiredReactIs$3;
function requireReactIs$3() {
  if (hasRequiredReactIs$3) return reactIs$3.exports;
  hasRequiredReactIs$3 = 1;
  {
    reactIs$3.exports = requireReactIs_production_min$2();
  }
  return reactIs$3.exports;
}
var hoistNonReactStatics_cjs;
var hasRequiredHoistNonReactStatics_cjs;
function requireHoistNonReactStatics_cjs() {
  if (hasRequiredHoistNonReactStatics_cjs) return hoistNonReactStatics_cjs;
  hasRequiredHoistNonReactStatics_cjs = 1;
  var reactIs2 = requireReactIs$3();
  var REACT_STATICS = {
    childContextTypes: true,
    contextType: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromError: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
  };
  var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
  };
  var FORWARD_REF_STATICS = {
    "$$typeof": true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    "$$typeof": true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs2.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs2.Memo] = MEMO_STATICS;
  function getStatics(component) {
    if (reactIs2.isMemo(component)) {
      return MEMO_STATICS;
    }
    return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
  }
  var defineProperty = Object.defineProperty;
  var getOwnPropertyNames = Object.getOwnPropertyNames;
  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectPrototype = Object.prototype;
  function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== "string") {
      if (objectPrototype) {
        var inheritedComponent = getPrototypeOf(sourceComponent);
        if (inheritedComponent && inheritedComponent !== objectPrototype) {
          hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
        }
      }
      var keys = getOwnPropertyNames(sourceComponent);
      if (getOwnPropertySymbols) {
        keys = keys.concat(getOwnPropertySymbols(sourceComponent));
      }
      var targetStatics = getStatics(targetComponent);
      var sourceStatics = getStatics(sourceComponent);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
          var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
          try {
            defineProperty(targetComponent, key, descriptor);
          } catch (e) {
          }
        }
      }
    }
    return targetComponent;
  }
  hoistNonReactStatics_cjs = hoistNonReactStatics;
  return hoistNonReactStatics_cjs;
}
var hoistNonReactStatics_cjsExports = requireHoistNonReactStatics_cjs();
const hoistNonReactStatics$1 = /* @__PURE__ */ getDefaultExportFromCjs(hoistNonReactStatics_cjsExports);
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min$1;
function requireReactIs_production_min$1() {
  if (hasRequiredReactIs_production_min$1) return reactIs_production_min$1;
  hasRequiredReactIs_production_min$1 = 1;
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d2 = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if ("object" === typeof a && null !== a) {
      var r2 = a.$$typeof;
      switch (r2) {
        case b:
          switch (a = a.type, a) {
            case d2:
            case f:
            case e:
            case m:
            case n:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  reactIs_production_min$1.ContextConsumer = h;
  reactIs_production_min$1.ContextProvider = g;
  reactIs_production_min$1.Element = b;
  reactIs_production_min$1.ForwardRef = l;
  reactIs_production_min$1.Fragment = d2;
  reactIs_production_min$1.Lazy = q;
  reactIs_production_min$1.Memo = p;
  reactIs_production_min$1.Portal = c;
  reactIs_production_min$1.Profiler = f;
  reactIs_production_min$1.StrictMode = e;
  reactIs_production_min$1.Suspense = m;
  reactIs_production_min$1.SuspenseList = n;
  reactIs_production_min$1.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min$1.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min$1.isContextConsumer = function(a) {
    return v(a) === h;
  };
  reactIs_production_min$1.isContextProvider = function(a) {
    return v(a) === g;
  };
  reactIs_production_min$1.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };
  reactIs_production_min$1.isForwardRef = function(a) {
    return v(a) === l;
  };
  reactIs_production_min$1.isFragment = function(a) {
    return v(a) === d2;
  };
  reactIs_production_min$1.isLazy = function(a) {
    return v(a) === q;
  };
  reactIs_production_min$1.isMemo = function(a) {
    return v(a) === p;
  };
  reactIs_production_min$1.isPortal = function(a) {
    return v(a) === c;
  };
  reactIs_production_min$1.isProfiler = function(a) {
    return v(a) === f;
  };
  reactIs_production_min$1.isStrictMode = function(a) {
    return v(a) === e;
  };
  reactIs_production_min$1.isSuspense = function(a) {
    return v(a) === m;
  };
  reactIs_production_min$1.isSuspenseList = function(a) {
    return v(a) === n;
  };
  reactIs_production_min$1.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d2 || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? true : false;
  };
  reactIs_production_min$1.typeOf = v;
  return reactIs_production_min$1;
}
var hasRequiredReactIs$2;
function requireReactIs$2() {
  if (hasRequiredReactIs$2) return reactIs$2.exports;
  hasRequiredReactIs$2 = 1;
  {
    reactIs$2.exports = requireReactIs_production_min$1();
  }
  return reactIs$2.exports;
}
var reactIsExports$1 = requireReactIs$2();
const _excluded$f = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function pureFinalPropsSelectorFactory(mapStateToProps2, mapDispatchToProps2, mergeProps, dispatch2, {
  areStatesEqual,
  areOwnPropsEqual,
  areStatePropsEqual
}) {
  let hasRunAtLeastOnce = false;
  let state;
  let ownProps;
  let stateProps;
  let dispatchProps;
  let mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps2(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch2, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps2(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps) dispatchProps = mapDispatchToProps2(dispatch2, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps2.dependsOnOwnProps) stateProps = mapStateToProps2(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps) dispatchProps = mapDispatchToProps2(dispatch2, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    const nextStateProps = mapStateToProps2(state, ownProps);
    const statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    const propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    const stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch2, _ref) {
  let {
    initMapStateToProps,
    initMapDispatchToProps,
    initMergeProps
  } = _ref, options = _objectWithoutPropertiesLoose(_ref, _excluded$f);
  const mapStateToProps2 = initMapStateToProps(dispatch2, options);
  const mapDispatchToProps2 = initMapDispatchToProps(dispatch2, options);
  const mergeProps = initMergeProps(dispatch2, options);
  return pureFinalPropsSelectorFactory(mapStateToProps2, mapDispatchToProps2, mergeProps, dispatch2, options);
}
function bindActionCreators(actionCreators, dispatch2) {
  const boundActionCreators = {};
  for (const key in actionCreators) {
    const actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = (...args) => dispatch2(actionCreator(...args));
    }
  }
  return boundActionCreators;
}
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch2) {
    const constant2 = getConstant(dispatch2);
    function constantSelector() {
      return constant2;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch2, {
    displayName
  }) {
    const proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch, void 0);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      let props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      return props;
    };
    return proxy;
  };
}
function createInvalidArgFactory(arg, name) {
  return (dispatch2, options) => {
    throw new Error(`Invalid value of type ${typeof arg} for ${name} argument when connecting component ${options.wrappedComponentName}.`);
  };
}
function mapDispatchToPropsFactory(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant((dispatch2) => (
    // @ts-ignore
    bindActionCreators(mapDispatchToProps2, dispatch2)
  )) : !mapDispatchToProps2 ? wrapMapToPropsConstant((dispatch2) => ({
    dispatch: dispatch2
  })) : typeof mapDispatchToProps2 === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapDispatchToProps2)
  ) : createInvalidArgFactory(mapDispatchToProps2, "mapDispatchToProps");
}
function mapStateToPropsFactory(mapStateToProps2) {
  return !mapStateToProps2 ? wrapMapToPropsConstant(() => ({})) : typeof mapStateToProps2 === "function" ? (
    // @ts-ignore
    wrapMapToPropsFunc(mapStateToProps2)
  ) : createInvalidArgFactory(mapStateToProps2, "mapStateToProps");
}
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends$2({}, ownProps, stateProps, dispatchProps);
}
function mergePropsFactory(mergeProps) {
  return () => defaultMergeProps;
}
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect = canUseDOM$1 ? reactExports.useLayoutEffect : reactExports.useEffect;
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
const _excluded$e = ["reactReduxForwardedRef"];
let useSyncExternalStore = notInitialized;
const initializeConnect = (fn) => {
  useSyncExternalStore = fn;
};
const NO_SUBSCRIPTION_ARRAY = [null, null];
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect(() => effectFunc(...effectArgs), dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, isMounted, childPropsFromStoreUpdate, notifyNestedSubs, additionalSubscribeListener) {
  if (!shouldHandleStateChanges) return () => {
  };
  let didUnsubscribe = false;
  let lastThrownError = null;
  const checkForUpdates = () => {
    if (didUnsubscribe || !isMounted.current) {
      return;
    }
    const latestStoreState = store.getState();
    let newChildProps, error;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }
    if (!error) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      additionalSubscribeListener();
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  const unsubscribeWrapper = () => {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
function strictEqual(a, b) {
  return a === b;
}
function connect(mapStateToProps2, mapDispatchToProps2, mergeProps, {
  // The `pure` option has been removed, so TS doesn't like us destructuring this to check its existence.
  // @ts-ignore
  pure,
  areStatesEqual = strictEqual,
  areOwnPropsEqual = shallowEqual,
  areStatePropsEqual = shallowEqual,
  areMergedPropsEqual = shallowEqual,
  // use React's forwardRef to expose a ref of the wrapped component
  forwardRef: forwardRef2 = false,
  // the context consumer to use
  context: context2 = ReactReduxContext
} = {}) {
  const Context = context2;
  const initMapStateToProps = mapStateToPropsFactory(mapStateToProps2);
  const initMapDispatchToProps = mapDispatchToPropsFactory(mapDispatchToProps2);
  const initMergeProps = mergePropsFactory();
  const shouldHandleStateChanges = Boolean(mapStateToProps2);
  const wrapWithConnect = (WrappedComponent) => {
    const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    const displayName = `Connect(${wrappedComponentName})`;
    const selectorFactoryOptions = {
      shouldHandleStateChanges,
      displayName,
      wrappedComponentName,
      WrappedComponent,
      // @ts-ignore
      initMapStateToProps,
      // @ts-ignore
      initMapDispatchToProps,
      initMergeProps,
      areStatesEqual,
      areStatePropsEqual,
      areOwnPropsEqual,
      areMergedPropsEqual
    };
    function ConnectFunction(props) {
      const [propsContext, reactReduxForwardedRef, wrapperProps] = reactExports.useMemo(() => {
        const {
          reactReduxForwardedRef: reactReduxForwardedRef2
        } = props, wrapperProps2 = _objectWithoutPropertiesLoose(props, _excluded$e);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]);
      const ContextToUse = reactExports.useMemo(() => {
        return propsContext && propsContext.Consumer && // @ts-ignore
        reactIsExports$1.isContextConsumer(/* @__PURE__ */ reactExports.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      const contextValue = reactExports.useContext(ContextToUse);
      const didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      const didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      const store = didStoreComeFromProps ? props.store : contextValue.store;
      const getServerState = didStoreComeFromContext ? contextValue.getServerState : store.getState;
      const childPropsSelector = reactExports.useMemo(() => {
        return finalPropsSelectorFactory(store.dispatch, selectorFactoryOptions);
      }, [store]);
      const [subscription, notifyNestedSubs] = reactExports.useMemo(() => {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY;
        const subscription2 = createSubscription(store, didStoreComeFromProps ? void 0 : contextValue.subscription);
        const notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]);
      const overriddenContextValue = reactExports.useMemo(() => {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends$2({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      const lastChildProps = reactExports.useRef();
      const lastWrapperProps = reactExports.useRef(wrapperProps);
      const childPropsFromStoreUpdate = reactExports.useRef();
      const renderIsScheduled = reactExports.useRef(false);
      reactExports.useRef(false);
      const isMounted = reactExports.useRef(false);
      const latestSubscriptionCallbackError = reactExports.useRef();
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      const actualChildPropsSelector = reactExports.useMemo(() => {
        const selector2 = () => {
          if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
            return childPropsFromStoreUpdate.current;
          }
          return childPropsSelector(store.getState(), wrapperProps);
        };
        return selector2;
      }, [store, wrapperProps]);
      const subscribeForReact = reactExports.useMemo(() => {
        const subscribe = (reactListener) => {
          if (!subscription) {
            return () => {
            };
          }
          return subscribeUpdates(
            shouldHandleStateChanges,
            store,
            subscription,
            // @ts-ignore
            childPropsSelector,
            lastWrapperProps,
            lastChildProps,
            renderIsScheduled,
            isMounted,
            childPropsFromStoreUpdate,
            notifyNestedSubs,
            reactListener
          );
        };
        return subscribe;
      }, [subscription]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      let actualChildProps;
      try {
        actualChildProps = useSyncExternalStore(
          // TODO We're passing through a big wrapper that does a bunch of extra side effects besides subscribing
          subscribeForReact,
          // TODO This is incredibly hacky. We've already processed the store update and calculated new child props,
          // TODO and we're just passing that through so it triggers a re-render for us rather than relying on `uSES`.
          actualChildPropsSelector,
          getServerState ? () => childPropsSelector(getServerState(), wrapperProps) : actualChildPropsSelector
        );
      } catch (err) {
        if (latestSubscriptionCallbackError.current) {
          err.message += `
The error may be correlated with this previous error:
${latestSubscriptionCallbackError.current.stack}

`;
        }
        throw err;
      }
      useIsomorphicLayoutEffect(() => {
        latestSubscriptionCallbackError.current = void 0;
        childPropsFromStoreUpdate.current = void 0;
        lastChildProps.current = actualChildProps;
      });
      const renderedWrappedComponent = reactExports.useMemo(() => {
        return (
          // @ts-ignore
          /* @__PURE__ */ reactExports.createElement(WrappedComponent, _extends$2({}, actualChildProps, {
            ref: reactReduxForwardedRef
          }))
        );
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      const renderedChild = reactExports.useMemo(() => {
        if (shouldHandleStateChanges) {
          return /* @__PURE__ */ reactExports.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    const _Connect = reactExports.memo(ConnectFunction);
    const Connect = _Connect;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef2) {
      const _forwarded = reactExports.forwardRef(function forwardConnectRef(props, ref) {
        return /* @__PURE__ */ reactExports.createElement(Connect, _extends$2({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      const forwarded = _forwarded;
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoistNonReactStatics$1(forwarded, WrappedComponent);
    }
    return hoistNonReactStatics$1(Connect, WrappedComponent);
  };
  return wrapWithConnect;
}
function Provider({
  store,
  context: context2,
  children: children2,
  serverState,
  stabilityCheck = "once",
  noopCheck = "once"
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store);
    return {
      store,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      noopCheck
    };
  }, [store, serverState, stabilityCheck, noopCheck]);
  const previousState = reactExports.useMemo(() => store.getState(), [store]);
  useIsomorphicLayoutEffect(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context2 || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
    value: contextValue
  }, children2);
}
function createStoreHook(context2 = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context2)
    )
  );
  return function useStore2() {
    const {
      store
    } = useReduxContext$1();
    return store;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context2 = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context2 === ReactReduxContext ? useStore : createStoreHook(context2)
  );
  return function useDispatch2() {
    const store = useStore$1();
    return store.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
initializeConnect(shimExports.useSyncExternalStore);
setBatch(reactDomExports.unstable_batchedUpdates);
var whatInput$1 = { exports: {} };
/**
 * what-input - A global utility for tracking the current input method (mouse, keyboard or touch).
 * @version v5.2.12
 * @link https://github.com/ten1seven/what-input
 * @license MIT
 */
var whatInput = whatInput$1.exports;
var hasRequiredWhatInput;
function requireWhatInput() {
  if (hasRequiredWhatInput) return whatInput$1.exports;
  hasRequiredWhatInput = 1;
  (function(module, exports) {
    (function webpackUniversalModuleDefinition(root2, factory2) {
      module.exports = factory2();
    })(whatInput, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module2 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        }([
          /* 0 */
          /***/
          function(module2, exports2) {
            module2.exports = function() {
              if (typeof document === "undefined" || typeof window === "undefined") {
                return {
                  // always return "initial" because no interaction will ever be detected
                  ask: function ask() {
                    return "initial";
                  },
                  // always return null
                  element: function element() {
                    return null;
                  },
                  // no-op
                  ignoreKeys: function ignoreKeys() {
                  },
                  // no-op
                  specificKeys: function specificKeys() {
                  },
                  // no-op
                  registerOnChange: function registerOnChange() {
                  },
                  // no-op
                  unRegisterOnChange: function unRegisterOnChange() {
                  }
                };
              }
              var docElem = document.documentElement;
              var currentElement = null;
              var currentInput = "initial";
              var currentIntent = currentInput;
              var currentTimestamp = Date.now();
              var shouldPersist = false;
              var formInputs = ["button", "input", "select", "textarea"];
              var functionList = [];
              var ignoreMap = [
                16,
                // shift
                17,
                // control
                18,
                // alt
                91,
                // Windows key / left Apple cmd
                93
                // Windows menu / right Apple cmd
              ];
              var specificMap = [];
              var inputMap = {
                keydown: "keyboard",
                keyup: "keyboard",
                mousedown: "mouse",
                mousemove: "mouse",
                MSPointerDown: "pointer",
                MSPointerMove: "pointer",
                pointerdown: "pointer",
                pointermove: "pointer",
                touchstart: "touch",
                touchend: "touch"
                // boolean: true if the page is being scrolled
              };
              var isScrolling = false;
              var mousePos = {
                x: null,
                y: null
                // map of IE 10 pointer events
              };
              var pointerMap = {
                2: "touch",
                3: "touch",
                // treat pen like touch
                4: "mouse"
                // check support for passive event listeners
              };
              var supportsPassive = false;
              try {
                var opts = Object.defineProperty({}, "passive", {
                  get: function get2() {
                    supportsPassive = true;
                  }
                });
                window.addEventListener("test", null, opts);
              } catch (e) {
              }
              var setUp = function setUp2() {
                inputMap[detectWheel()] = "mouse";
                addListeners();
              };
              var addListeners = function addListeners2() {
                var options = supportsPassive ? { passive: true, capture: true } : true;
                document.addEventListener("DOMContentLoaded", setPersist, true);
                if (window.PointerEvent) {
                  window.addEventListener("pointerdown", setInput, true);
                  window.addEventListener("pointermove", setIntent, true);
                } else if (window.MSPointerEvent) {
                  window.addEventListener("MSPointerDown", setInput, true);
                  window.addEventListener("MSPointerMove", setIntent, true);
                } else {
                  window.addEventListener("mousedown", setInput, true);
                  window.addEventListener("mousemove", setIntent, true);
                  if ("ontouchstart" in window) {
                    window.addEventListener("touchstart", setInput, options);
                    window.addEventListener("touchend", setInput, true);
                  }
                }
                window.addEventListener(detectWheel(), setIntent, options);
                window.addEventListener("keydown", setInput, true);
                window.addEventListener("keyup", setInput, true);
                window.addEventListener("focusin", setElement, true);
                window.addEventListener("focusout", clearElement, true);
              };
              var setPersist = function setPersist2() {
                shouldPersist = !(docElem.getAttribute("data-whatpersist") === "false" || document.body.getAttribute("data-whatpersist") === "false");
                if (shouldPersist) {
                  try {
                    if (window.sessionStorage.getItem("what-input")) {
                      currentInput = window.sessionStorage.getItem("what-input");
                    }
                    if (window.sessionStorage.getItem("what-intent")) {
                      currentIntent = window.sessionStorage.getItem("what-intent");
                    }
                  } catch (e) {
                  }
                }
                doUpdate("input");
                doUpdate("intent");
              };
              var setInput = function setInput2(event) {
                var eventKey = event.which;
                var value = inputMap[event.type];
                if (value === "pointer") {
                  value = pointerType(event);
                }
                var ignoreMatch = !specificMap.length && ignoreMap.indexOf(eventKey) === -1;
                var specificMatch = specificMap.length && specificMap.indexOf(eventKey) !== -1;
                var shouldUpdate = value === "keyboard" && eventKey && (ignoreMatch || specificMatch) || value === "mouse" || value === "touch";
                if (validateTouch(value)) {
                  shouldUpdate = false;
                }
                if (shouldUpdate && currentInput !== value) {
                  currentInput = value;
                  persistInput("input", currentInput);
                  doUpdate("input");
                }
                if (shouldUpdate && currentIntent !== value) {
                  var activeElem = document.activeElement;
                  var notFormInput = activeElem && activeElem.nodeName && (formInputs.indexOf(activeElem.nodeName.toLowerCase()) === -1 || activeElem.nodeName.toLowerCase() === "button" && !checkClosest(activeElem, "form"));
                  if (notFormInput) {
                    currentIntent = value;
                    persistInput("intent", currentIntent);
                    doUpdate("intent");
                  }
                }
              };
              var doUpdate = function doUpdate2(which) {
                docElem.setAttribute("data-what" + which, which === "input" ? currentInput : currentIntent);
                fireFunctions(which);
              };
              var setIntent = function setIntent2(event) {
                var value = inputMap[event.type];
                if (value === "pointer") {
                  value = pointerType(event);
                }
                detectScrolling(event);
                if ((!isScrolling && !validateTouch(value) || isScrolling && event.type === "wheel" || event.type === "mousewheel" || event.type === "DOMMouseScroll") && currentIntent !== value) {
                  currentIntent = value;
                  persistInput("intent", currentIntent);
                  doUpdate("intent");
                }
              };
              var setElement = function setElement2(event) {
                if (!event.target.nodeName) {
                  clearElement();
                  return;
                }
                currentElement = event.target.nodeName.toLowerCase();
                docElem.setAttribute("data-whatelement", currentElement);
                if (event.target.classList && event.target.classList.length) {
                  docElem.setAttribute("data-whatclasses", event.target.classList.toString().replace(" ", ","));
                }
              };
              var clearElement = function clearElement2() {
                currentElement = null;
                docElem.removeAttribute("data-whatelement");
                docElem.removeAttribute("data-whatclasses");
              };
              var persistInput = function persistInput2(which, value) {
                if (shouldPersist) {
                  try {
                    window.sessionStorage.setItem("what-" + which, value);
                  } catch (e) {
                  }
                }
              };
              var pointerType = function pointerType2(event) {
                if (typeof event.pointerType === "number") {
                  return pointerMap[event.pointerType];
                } else {
                  return event.pointerType === "pen" ? "touch" : event.pointerType;
                }
              };
              var validateTouch = function validateTouch2(value) {
                var timestamp = Date.now();
                var touchIsValid = value === "mouse" && currentInput === "touch" && timestamp - currentTimestamp < 200;
                currentTimestamp = timestamp;
                return touchIsValid;
              };
              var detectWheel = function detectWheel2() {
                var wheelType = null;
                if ("onwheel" in document.createElement("div")) {
                  wheelType = "wheel";
                } else {
                  wheelType = document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
                }
                return wheelType;
              };
              var fireFunctions = function fireFunctions2(type) {
                for (var i = 0, len = functionList.length; i < len; i++) {
                  if (functionList[i].type === type) {
                    functionList[i].fn.call(void 0, type === "input" ? currentInput : currentIntent);
                  }
                }
              };
              var objPos = function objPos2(match2) {
                for (var i = 0, len = functionList.length; i < len; i++) {
                  if (functionList[i].fn === match2) {
                    return i;
                  }
                }
              };
              var detectScrolling = function detectScrolling2(event) {
                if (mousePos.x !== event.screenX || mousePos.y !== event.screenY) {
                  isScrolling = false;
                  mousePos.x = event.screenX;
                  mousePos.y = event.screenY;
                } else {
                  isScrolling = true;
                }
              };
              var checkClosest = function checkClosest2(elem, tag) {
                var ElementPrototype = window.Element.prototype;
                if (!ElementPrototype.matches) {
                  ElementPrototype.matches = ElementPrototype.msMatchesSelector || ElementPrototype.webkitMatchesSelector;
                }
                if (!ElementPrototype.closest) {
                  do {
                    if (elem.matches(tag)) {
                      return elem;
                    }
                    elem = elem.parentElement || elem.parentNode;
                  } while (elem !== null && elem.nodeType === 1);
                  return null;
                } else {
                  return elem.closest(tag);
                }
              };
              if ("addEventListener" in window && Array.prototype.indexOf) {
                setUp();
              }
              return {
                // returns string: the current input type
                // opt: 'intent'|'input'
                // 'input' (default): returns the same value as the `data-whatinput` attribute
                // 'intent': includes `data-whatintent` value if it's different than `data-whatinput`
                ask: function ask(opt) {
                  return opt === "intent" ? currentIntent : currentInput;
                },
                // returns string: the currently focused element or null
                element: function element() {
                  return currentElement;
                },
                // overwrites ignored keys with provided array
                ignoreKeys: function ignoreKeys(arr) {
                  ignoreMap = arr;
                },
                // overwrites specific char keys to update on
                specificKeys: function specificKeys(arr) {
                  specificMap = arr;
                },
                // attach functions to input and intent "events"
                // funct: function to fire on change
                // eventType: 'input'|'intent'
                registerOnChange: function registerOnChange(fn, eventType) {
                  functionList.push({
                    fn,
                    type: eventType || "input"
                  });
                },
                unRegisterOnChange: function unRegisterOnChange(fn) {
                  var position2 = objPos(fn);
                  if (position2 || position2 === 0) {
                    functionList.splice(position2, 1);
                  }
                },
                clearStorage: function clearStorage() {
                  window.sessionStorage.clear();
                }
              };
            }();
          }
          /******/
        ])
      );
    });
  })(whatInput$1);
  return whatInput$1.exports;
}
requireWhatInput();
function _typeof$1(o) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof$1(o);
}
function toPrimitive(t, r2) {
  if ("object" != _typeof$1(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2);
    if ("object" != _typeof$1(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof$1(i) ? i : i + "";
}
function _defineProperty$2(e, r2, t) {
  return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}
function ownKeys$1(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2$1(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys$1(Object(t), true).forEach(function(r3) {
      _defineProperty$2(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$1(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch2(action) {
    if (!isPlainObject$1(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch2({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch2({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch2,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose$1() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a, b) {
    return function() {
      return a(b.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch2() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch2() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware2) {
        return middleware2(middlewareAPI);
      });
      _dispatch = compose$1.apply(void 0, chain)(store.dispatch);
      return _objectSpread2$1(_objectSpread2$1({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}
function createThunkMiddleware(extraArgument) {
  var middleware2 = function middleware3(_ref) {
    var dispatch2 = _ref.dispatch, getState = _ref.getState;
    return function(next2) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch2, getState, extraArgument);
        }
        return next2(action);
      };
    };
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
var objectPath$1 = { exports: {} };
var objectPath = objectPath$1.exports;
var hasRequiredObjectPath;
function requireObjectPath() {
  if (hasRequiredObjectPath) return objectPath$1.exports;
  hasRequiredObjectPath = 1;
  (function(module) {
    (function(root2, factory2) {
      {
        module.exports = factory2();
      }
    })(objectPath, function() {
      var toStr = Object.prototype.toString;
      function hasOwnProperty(obj, prop) {
        if (obj == null) {
          return false;
        }
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
      function isEmpty2(value) {
        if (!value) {
          return true;
        }
        if (isArray(value) && value.length === 0) {
          return true;
        } else if (typeof value !== "string") {
          for (var i in value) {
            if (hasOwnProperty(value, i)) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function toString(type) {
        return toStr.call(type);
      }
      function isObject(obj) {
        return typeof obj === "object" && toString(obj) === "[object Object]";
      }
      var isArray = Array.isArray || function(obj) {
        return toStr.call(obj) === "[object Array]";
      };
      function isBoolean(obj) {
        return typeof obj === "boolean" || toString(obj) === "[object Boolean]";
      }
      function getKey(key) {
        var intKey = parseInt(key);
        if (intKey.toString() === key) {
          return intKey;
        }
        return key;
      }
      function factory2(options) {
        options = options || {};
        var objectPath2 = function(obj) {
          return Object.keys(objectPath2).reduce(function(proxy, prop) {
            if (prop === "create") {
              return proxy;
            }
            if (typeof objectPath2[prop] === "function") {
              proxy[prop] = objectPath2[prop].bind(objectPath2, obj);
            }
            return proxy;
          }, {});
        };
        var hasShallowProperty;
        if (options.includeInheritedProps) {
          hasShallowProperty = function() {
            return true;
          };
        } else {
          hasShallowProperty = function(obj, prop) {
            return typeof prop === "number" && Array.isArray(obj) || hasOwnProperty(obj, prop);
          };
        }
        function getShallowProperty(obj, prop) {
          if (hasShallowProperty(obj, prop)) {
            return obj[prop];
          }
        }
        var getShallowPropertySafely;
        if (options.includeInheritedProps) {
          getShallowPropertySafely = function(obj, currentPath) {
            if (typeof currentPath !== "string" && typeof currentPath !== "number") {
              currentPath = String(currentPath);
            }
            var currentValue = getShallowProperty(obj, currentPath);
            if (currentPath === "__proto__" || currentPath === "prototype" || currentPath === "constructor" && typeof currentValue === "function") {
              throw new Error("For security reasons, object's magic properties cannot be set");
            }
            return currentValue;
          };
        } else {
          getShallowPropertySafely = function(obj, currentPath) {
            return getShallowProperty(obj, currentPath);
          };
        }
        function set2(obj, path2, value, doNotReplace) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (!path2 || path2.length === 0) {
            return obj;
          }
          if (typeof path2 === "string") {
            return set2(obj, path2.split(".").map(getKey), value, doNotReplace);
          }
          var currentPath = path2[0];
          var currentValue = getShallowPropertySafely(obj, currentPath);
          if (path2.length === 1) {
            if (currentValue === void 0 || !doNotReplace) {
              obj[currentPath] = value;
            }
            return currentValue;
          }
          if (currentValue === void 0) {
            if (typeof path2[1] === "number") {
              obj[currentPath] = [];
            } else {
              obj[currentPath] = {};
            }
          }
          return set2(obj[currentPath], path2.slice(1), value, doNotReplace);
        }
        objectPath2.has = function(obj, path2) {
          if (typeof path2 === "number") {
            path2 = [path2];
          } else if (typeof path2 === "string") {
            path2 = path2.split(".");
          }
          if (!path2 || path2.length === 0) {
            return !!obj;
          }
          for (var i = 0; i < path2.length; i++) {
            var j = getKey(path2[i]);
            if (typeof j === "number" && isArray(obj) && j < obj.length || (options.includeInheritedProps ? j in Object(obj) : hasOwnProperty(obj, j))) {
              obj = obj[j];
            } else {
              return false;
            }
          }
          return true;
        };
        objectPath2.ensureExists = function(obj, path2, value) {
          return set2(obj, path2, value, true);
        };
        objectPath2.set = function(obj, path2, value, doNotReplace) {
          return set2(obj, path2, value, doNotReplace);
        };
        objectPath2.insert = function(obj, path2, value, at) {
          var arr = objectPath2.get(obj, path2);
          at = ~~at;
          if (!isArray(arr)) {
            arr = [];
            objectPath2.set(obj, path2, arr);
          }
          arr.splice(at, 0, value);
        };
        objectPath2.empty = function(obj, path2) {
          if (isEmpty2(path2)) {
            return void 0;
          }
          if (obj == null) {
            return void 0;
          }
          var value, i;
          if (!(value = objectPath2.get(obj, path2))) {
            return void 0;
          }
          if (typeof value === "string") {
            return objectPath2.set(obj, path2, "");
          } else if (isBoolean(value)) {
            return objectPath2.set(obj, path2, false);
          } else if (typeof value === "number") {
            return objectPath2.set(obj, path2, 0);
          } else if (isArray(value)) {
            value.length = 0;
          } else if (isObject(value)) {
            for (i in value) {
              if (hasShallowProperty(value, i)) {
                delete value[i];
              }
            }
          } else {
            return objectPath2.set(obj, path2, null);
          }
        };
        objectPath2.push = function(obj, path2) {
          var arr = objectPath2.get(obj, path2);
          if (!isArray(arr)) {
            arr = [];
            objectPath2.set(obj, path2, arr);
          }
          arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));
        };
        objectPath2.coalesce = function(obj, paths2, defaultValue) {
          var value;
          for (var i = 0, len = paths2.length; i < len; i++) {
            if ((value = objectPath2.get(obj, paths2[i])) !== void 0) {
              return value;
            }
          }
          return defaultValue;
        };
        objectPath2.get = function(obj, path2, defaultValue) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (!path2 || path2.length === 0) {
            return obj;
          }
          if (obj == null) {
            return defaultValue;
          }
          if (typeof path2 === "string") {
            return objectPath2.get(obj, path2.split("."), defaultValue);
          }
          var currentPath = getKey(path2[0]);
          var nextObj = getShallowPropertySafely(obj, currentPath);
          if (nextObj === void 0) {
            return defaultValue;
          }
          if (path2.length === 1) {
            return nextObj;
          }
          return objectPath2.get(obj[currentPath], path2.slice(1), defaultValue);
        };
        objectPath2.del = function del(obj, path2) {
          if (typeof path2 === "number") {
            path2 = [path2];
          }
          if (obj == null) {
            return obj;
          }
          if (isEmpty2(path2)) {
            return obj;
          }
          if (typeof path2 === "string") {
            return objectPath2.del(obj, path2.split("."));
          }
          var currentPath = getKey(path2[0]);
          getShallowPropertySafely(obj, currentPath);
          if (!hasShallowProperty(obj, currentPath)) {
            return obj;
          }
          if (path2.length === 1) {
            if (isArray(obj)) {
              obj.splice(currentPath, 1);
            } else {
              delete obj[currentPath];
            }
          } else {
            return objectPath2.del(obj[currentPath], path2.slice(1));
          }
          return obj;
        };
        return objectPath2;
      }
      var mod = factory2();
      mod.create = factory2;
      mod.withInheritedProps = factory2({ includeInheritedProps: true });
      return mod;
    });
  })(objectPath$1);
  return objectPath$1.exports;
}
var reduxWatch;
var hasRequiredReduxWatch;
function requireReduxWatch() {
  if (hasRequiredReduxWatch) return reduxWatch;
  hasRequiredReduxWatch = 1;
  var getValue2 = requireObjectPath().get;
  function defaultCompare(a, b) {
    return a === b;
  }
  function watch2(getState, objectPath2, compare) {
    compare = compare || defaultCompare;
    var currentValue = getValue2(getState(), objectPath2);
    return function w(fn) {
      return function() {
        var newValue = getValue2(getState(), objectPath2);
        if (!compare(currentValue, newValue)) {
          var oldValue = currentValue;
          currentValue = newValue;
          fn(newValue, oldValue, objectPath2);
        }
      };
    };
  }
  reduxWatch = watch2;
  return reduxWatch;
}
var reduxWatchExports = requireReduxWatch();
const watch = /* @__PURE__ */ getDefaultExportFromCjs(reduxWatchExports);
const RESET_DATA = "RESET_DATA";
function resetData(data) {
  return {
    type: RESET_DATA,
    data
  };
}
const TOGGLE_LAYERS = "TOGGLE_LAYERS";
function toggleLayers(visible) {
  return {
    type: TOGGLE_LAYERS,
    visible
  };
}
const TOGGLE_ORIENTATION = "TOGGLE_ORIENTATION";
function toggleOrientation(orientation) {
  return {
    type: TOGGLE_ORIENTATION,
    orientation
  };
}
const TOGGLE_EXPAND_ALL_PIPELINES = "TOGGLE_EXPAND_ALL_PIPELINES";
function toggleExpandAllPipelines(shouldExpandAllPipelines) {
  return {
    type: TOGGLE_EXPAND_ALL_PIPELINES,
    shouldExpandAllPipelines
  };
}
const TOGGLE_EXPORT_MODAL = "TOGGLE_EXPORT_MODAL";
function toggleExportModal(visible) {
  return {
    type: TOGGLE_EXPORT_MODAL,
    visible
  };
}
const TOGGLE_SHAREABLE_URL_MODAL = "TOGGLE_SHAREABLE_URL_MODAL";
function toggleShareableUrlModal(visible) {
  return {
    type: TOGGLE_SHAREABLE_URL_MODAL,
    visible
  };
}
const TOGGLE_SETTINGS_MODAL = "TOGGLE_SETTINGS_MODAL";
function toggleSettingsModal(visible) {
  return {
    type: TOGGLE_SETTINGS_MODAL,
    visible
  };
}
const TOGGLE_METADATA_MODAL = "TOGGLE_METADATA_MODAL";
function togglePlotModal(visible) {
  return {
    type: TOGGLE_METADATA_MODAL,
    visible
  };
}
const TOGGLE_GRAPH = "TOGGLE_GRAPH";
function toggleGraph(visible) {
  return {
    type: TOGGLE_GRAPH,
    visible
  };
}
const TOGGLE_TEXT_LABELS = "TOGGLE_TEXT_LABELS";
function toggleTextLabels(textLabels) {
  return {
    type: TOGGLE_TEXT_LABELS,
    textLabels
  };
}
const SHOW_PIPELINE_FILTER = "SHOW_PIPELINE_FILTER";
function togglePipelineFilter() {
  return {
    type: SHOW_PIPELINE_FILTER
  };
}
const TOGGLE_IS_PRETTY_NAME = "TOGGLE_IS_PRETTY_NAME";
function toggleIsPrettyName(isPrettyName) {
  return {
    type: TOGGLE_IS_PRETTY_NAME,
    isPrettyName
  };
}
const TOGGLE_SHOW_FEATURE_HINTS = "TOGGLE_SHOW_FEATURE_HINTS";
function toggleShowFeatureHints(showFeatureHints) {
  return {
    type: TOGGLE_SHOW_FEATURE_HINTS,
    showFeatureHints
  };
}
const TOGGLE_SHOW_DATASET_PREVIEWS = "TOGGLE_SHOW_DATASET_PREVIEWS";
function toggleShowDatasetPreviews(showDatasetPreviews) {
  return {
    type: TOGGLE_SHOW_DATASET_PREVIEWS,
    showDatasetPreviews
  };
}
const TOGGLE_SIDEBAR = "TOGGLE_SIDEBAR";
function toggleSidebar(visible) {
  return {
    type: TOGGLE_SIDEBAR,
    visible
  };
}
const TOGGLE_THEME = "TOGGLE_THEME";
function toggleTheme(theme) {
  return {
    type: TOGGLE_THEME,
    theme
  };
}
const UPDATE_CHART_SIZE = "UPDATE_CHART_SIZE";
function updateChartSize(chartSize) {
  return {
    type: UPDATE_CHART_SIZE,
    chartSize
  };
}
const UPDATE_ZOOM = "UPDATE_ZOOM";
function updateZoom(zoom) {
  return {
    type: UPDATE_ZOOM,
    zoom
  };
}
const TOGGLE_MINIMAP = "TOGGLE_MINIMAP";
function toggleMiniMap(visible) {
  return {
    type: TOGGLE_MINIMAP,
    visible
  };
}
const CHANGE_FLAG = "CHANGE_FLAG";
function changeFlag(name, value) {
  return {
    type: CHANGE_FLAG,
    name,
    value
  };
}
const SET_BANNER = "SET_BANNER";
function setBanner(name, value) {
  return {
    type: SET_BANNER,
    name,
    value
  };
}
const TOGGLE_IGNORE_LARGE_WARNING = "TOGGLE_IGNORE_LARGE_WARNING";
function toggleIgnoreLargeWarning(ignoreLargeWarning) {
  return {
    type: TOGGLE_IGNORE_LARGE_WARNING,
    ignoreLargeWarning
  };
}
const TOGGLE_CODE = "TOGGLE_CODE";
function toggleCode(visible) {
  return {
    type: TOGGLE_CODE,
    visible
  };
}
const TOGGLE_TRACEBACK = "TOGGLE_TRACEBACK";
function toggleTraceback(visible) {
  return {
    type: TOGGLE_TRACEBACK,
    visible
  };
}
const TOGGLE_PARAMETERS_HOVERED = "TOGGLE_PARAMETERS_HOVERED";
const TOGGLE_MODULAR_PIPELINE_FOCUS_MODE = "TOGGLE_MODULAR_PIPELINE_FOCUS_MODE";
function toggleFocusMode(modularPipeline) {
  return {
    type: TOGGLE_MODULAR_PIPELINE_FOCUS_MODE,
    modularPipeline
  };
}
const TOGGLE_HOVERED_FOCUS_MODE = "TOGGLE_HOVERED_FOCUS_MODE";
function toggleHoveredFocusMode(hoveredFocusMode) {
  return {
    type: TOGGLE_HOVERED_FOCUS_MODE,
    hoveredFocusMode
  };
}
const UPDATE_STATE_FROM_OPTIONS = "UPDATE_STATE_FROM_OPTIONS";
const updateStateFromOptions = (updatedOptions) => {
  return {
    type: UPDATE_STATE_FROM_OPTIONS,
    payload: updatedOptions
  };
};
const SET_VIEW = "SET_VIEW";
function setView(view) {
  return {
    type: SET_VIEW,
    view
  };
}
const RESET_STATE_FOR_WORKFLOW_VIEW = "RESET_STATE_FOR_WORKFLOW_VIEW";
function resetStateForWorkflowView(expandAllPipelines = true) {
  return {
    type: RESET_STATE_FOR_WORKFLOW_VIEW,
    expandAllPipelines
  };
}
function flagsReducer(flagsState = {}, action) {
  switch (action.type) {
    case CHANGE_FLAG: {
      return Object.assign({}, flagsState, {
        [action.name]: action.value
      });
    }
    default:
      return flagsState;
  }
}
const jsContent = '!function(){"use strict";const t=.5*Math.PI,e=(t,e)=>Math.round(t/e)*e,r=(t,e)=>Math.abs(t-e),o=(t,e,r)=>"vertical"===r?Math.atan2(t.y-e.y,t.x-e.x):Math.atan2(t.x-e.x,t.y-e.y),n=t=>t.x-.5*t.width,i=t=>t.x+.5*t.width,s=t=>t.y-.5*t.height,a=t=>t.y+.5*t.height,c=(t,e)=>{const r={},o="vertical"===e?"y":"x",n="vertical"===e?"x":"y";for(const a of t){const t=a[o];r[t]=r[t]||[],r[t].push(a)}const i=Object.keys(r).map(t=>parseFloat(t));i.sort((t,e)=>t-e);const s=i.map(t=>r[t]);for(let a=0;a<s.length;a+=1){s[a].sort((t,e)=>p(t[n],e[n],t.id,e.id));for(const t of s[a])t.row=a}return s},p=(t,e,...r)=>{const o="string"==typeof t?t.localeCompare(e):t-e;return 0!==o||0===r.length?o:p(...r)},u=(t,e,r,o,n,i)=>{const s=n-r,a=i-o,c=(h=1,(p=((t-r)*s+(e-o)*a)/(s*s+a*a||1))<(u=0)?u:p>h?h:p);var p,u,h;return{x:r+s*c,y:o+a*c,ax:r,ay:o,bx:n,by:i}};function h(){return new f}var f=function(){function t(){this.index={},this.array=[]}return t.prototype.size=function(){return this.array.length},t.prototype.empty=function(){return 0===this.array.length},t.prototype.itemAt=function(t){return this.array[t]},t.prototype.contains=function(t){return void 0!==this.index[t.id()]},t.prototype.find=function(t){var e=this.index[t.id()];return void 0===e?void 0:this.array[e]},t.prototype.setDefault=function(t,e){var r=this.index[t.id()];if(void 0===r){var o=new d(t,e());return this.index[t.id()]=this.array.length,this.array.push(o),o}return this.array[r]},t.prototype.insert=function(t,e){var r=new d(t,e),o=this.index[t.id()];return void 0===o?(this.index[t.id()]=this.array.length,this.array.push(r)):this.array[o]=r,r},t.prototype.erase=function(t){var e=this.index[t.id()];if(void 0!==e){this.index[t.id()]=void 0;var r=this.array[e],o=this.array.pop();return r!==o&&(this.array[e]=o,this.index[o.first.id()]=e),r}},t.prototype.copy=function(){for(var e=new t,r=0;r<this.array.length;r++){var o=this.array[r].copy();e.array[r]=o,e.index[o.first.id()]=r}return e},t}(),d=function(){function t(t,e){this.first=t,this.second=e}return t.prototype.copy=function(){return new t(this.first,this.second)},t}(),l=function(){function t(t){void 0===t&&(t=""),this._value=0,this._context=null,this._id=y++,this._name=t}return t.prototype.id=function(){return this._id},t.prototype.name=function(){return this._name},t.prototype.setName=function(t){this._name=t},t.prototype.context=function(){return this._context},t.prototype.setContext=function(t){this._context=t},t.prototype.value=function(){return this._value},t.prototype.setValue=function(t){this._value=t},t.prototype.plus=function(t){return new m(this,t)},t.prototype.minus=function(t){return new m(this,"number"==typeof t?-t:[-1,t])},t.prototype.multiply=function(t){return new m([t,this])},t.prototype.divide=function(t){return new m([1/t,this])},t.prototype.toJSON=function(){return{name:this._name,value:this._value}},t.prototype.toString=function(){return this._context+"["+this._name+":"+this._value+"]"},t}(),y=0,m=function(){function t(){var t=function(t){for(var e=0,r=function(){return 0},o=h(),n=0,i=t.length;n<i;++n){var s=t[n];if("number"==typeof s)e+=s;else if(s instanceof l)o.setDefault(s,r).second+=1;else if(s instanceof m){e+=s.constant();for(var a=0,c=(d=s.terms()).size();a<c;a++){var p=d.itemAt(a);o.setDefault(p.first,r).second+=p.second}}else{if(!(s instanceof Array))throw new Error("invalid Expression argument: "+s);if(2!==s.length)throw new Error("array must have length 2");var u=s[0],f=s[1];if("number"!=typeof u)throw new Error("array item 0 must be a number");if(f instanceof l)o.setDefault(f,r).second+=u;else{if(!(f instanceof m))throw new Error("array item 1 must be a variable or expression");e+=f.constant()*u;var d;for(a=0,c=(d=f.terms()).size();a<c;a++){p=d.itemAt(a);o.setDefault(p.first,r).second+=p.second*u}}}}return{terms:o,constant:e}}(arguments);this._terms=t.terms,this._constant=t.constant}return t.prototype.terms=function(){return this._terms},t.prototype.constant=function(){return this._constant},t.prototype.value=function(){for(var t=this._constant,e=0,r=this._terms.size();e<r;e++){var o=this._terms.itemAt(e);t+=o.first.value()*o.second}return t},t.prototype.plus=function(e){return new t(this,e)},t.prototype.minus=function(e){return new t(this,"number"==typeof e?-e:[-1,e])},t.prototype.multiply=function(e){return new t([e,this])},t.prototype.divide=function(e){return new t([1/e,this])},t.prototype.isConstant=function(){return 0==this._terms.size()},t.prototype.toString=function(){var t=this._terms.array.map(function(t){return t.second+"*"+t.first.toString()}).join(" + ");return this.isConstant()||0===this._constant||(t+=" + "),t+=this._constant},t}();var v,_,g=function(){function t(){}return t.create=function(t,e,r,o){void 0===o&&(o=1);var n=0;return n+=1e6*Math.max(0,Math.min(1e3,t*o)),n+=1e3*Math.max(0,Math.min(1e3,e*o)),n+=Math.max(0,Math.min(1e3,r*o))},t.clip=function(e){return Math.max(0,Math.min(t.required,e))},t.required=t.create(1e3,1e3,1e3),t.strong=t.create(1,0,0),t.medium=t.create(0,1,0),t.weak=t.create(0,0,1),t}();(_=v||(v={}))[_.Le=0]="Le",_[_.Ge=1]="Ge",_[_.Eq=2]="Eq";var w,x,b=function(){function t(t,e,r,o){void 0===o&&(o=g.required),this._id=M++,this._operator=e,this._strength=g.clip(o),this._expression=void 0===r&&t instanceof m?t:t.minus(r)}return t.prototype.id=function(){return this._id},t.prototype.expression=function(){return this._expression},t.prototype.op=function(){return this._operator},t.prototype.strength=function(){return this._strength},t.prototype.toString=function(){return this._expression.toString()+" "+["<=",">=","="][this._operator]+" 0 ("+this._strength.toString()+")"},t}(),M=0,S=function(){function t(){this._cnMap=h(),this._rowMap=h(),this._varMap=h(),this._editMap=h(),this._infeasibleRows=[],this._objective=new z,this._artificial=null,this._idTick=0}return t.prototype.createConstraint=function(t,e,r,o){void 0===o&&(o=g.required);var n=new b(t,e,r,o);return this.addConstraint(n),n},t.prototype.addConstraint=function(t){if(void 0!==this._cnMap.find(t))throw new Error("duplicate constraint");var e=this._createRow(t),r=e.row,o=e.tag,n=this._chooseSubject(r,o);if(n.type()===w.Invalid&&r.allDummies()){if(!E(r.constant()))throw new Error("unsatisfiable constraint");n=o.marker}if(n.type()===w.Invalid){if(!this._addWithArtificialVariable(r))throw new Error("unsatisfiable constraint")}else r.solveFor(n),this._substitute(n,r),this._rowMap.insert(n,r);this._cnMap.insert(t,o),this._optimize(this._objective)},t.prototype.removeConstraint=function(t){var e=this._cnMap.erase(t);if(void 0===e)throw new Error("unknown constraint");this._removeConstraintEffects(t,e.second);var r=e.second.marker,o=this._rowMap.erase(r);if(void 0===o){var n=this._getMarkerLeavingSymbol(r);if(n.type()===w.Invalid)throw new Error("failed to find leaving row");(o=this._rowMap.erase(n)).second.solveForEx(n,r),this._substitute(r,o.second)}this._optimize(this._objective)},t.prototype.hasConstraint=function(t){return this._cnMap.contains(t)},t.prototype.addEditVariable=function(t,e){if(void 0!==this._editMap.find(t))throw new Error("duplicate edit variable");if((e=g.clip(e))===g.required)throw new Error("bad required strength");var r=new m(t),o=new b(r,v.Eq,void 0,e);this.addConstraint(o);var n={tag:this._cnMap.find(o).second,constraint:o,constant:0};this._editMap.insert(t,n)},t.prototype.removeEditVariable=function(t){var e=this._editMap.erase(t);if(void 0===e)throw new Error("unknown edit variable");this.removeConstraint(e.second.constraint)},t.prototype.hasEditVariable=function(t){return this._editMap.contains(t)},t.prototype.suggestValue=function(t,e){var r=this._editMap.find(t);if(void 0===r)throw new Error("unknown edit variable");var o=this._rowMap,n=r.second,i=e-n.constant;n.constant=e;var s=n.tag.marker,a=o.find(s);if(void 0!==a)return a.second.add(-i)<0&&this._infeasibleRows.push(s),void this._dualOptimize();var c=n.tag.other;if(void 0!==(a=o.find(c)))return a.second.add(i)<0&&this._infeasibleRows.push(c),void this._dualOptimize();for(var p=0,u=o.size();p<u;++p){var h=o.itemAt(p),f=h.second,d=f.coefficientFor(s);0!==d&&f.add(i*d)<0&&h.first.type()!==w.External&&this._infeasibleRows.push(h.first)}this._dualOptimize()},t.prototype.updateVariables=function(){for(var t=this._varMap,e=this._rowMap,r=0,o=t.size();r<o;++r){var n=t.itemAt(r),i=e.find(n.second);void 0!==i?n.first.setValue(i.second.constant()):n.first.setValue(0)}},t.prototype._getVarSymbol=function(t){var e=this;return this._varMap.setDefault(t,function(){return e._makeSymbol(w.External)}).second},t.prototype._createRow=function(t){for(var e=t.expression(),r=new z(e.constant()),o=e.terms(),n=0,i=o.size();n<i;++n){var s=o.itemAt(n);if(!E(s.second)){var a=this._getVarSymbol(s.first),c=this._rowMap.find(a);void 0!==c?r.insertRow(c.second,s.second):r.insertSymbol(a,s.second)}}var p=this._objective,u=t.strength(),h={marker:k,other:k};switch(t.op()){case v.Le:case v.Ge:var f=t.op()===v.Le?1:-1,d=this._makeSymbol(w.Slack);if(h.marker=d,r.insertSymbol(d,f),u<g.required){var l=this._makeSymbol(w.Error);h.other=l,r.insertSymbol(l,-f),p.insertSymbol(l,u)}break;case v.Eq:if(u<g.required){var y=this._makeSymbol(w.Error),m=this._makeSymbol(w.Error);h.marker=y,h.other=m,r.insertSymbol(y,-1),r.insertSymbol(m,1),p.insertSymbol(y,u),p.insertSymbol(m,u)}else{var _=this._makeSymbol(w.Dummy);h.marker=_,r.insertSymbol(_)}}return r.constant()<0&&r.reverseSign(),{row:r,tag:h}},t.prototype._chooseSubject=function(t,e){for(var r=t.cells(),o=0,n=r.size();o<n;++o){var i=r.itemAt(o);if(i.first.type()===w.External)return i.first}var s=e.marker.type();return(s===w.Slack||s===w.Error)&&t.coefficientFor(e.marker)<0?e.marker:((s=e.other.type())===w.Slack||s===w.Error)&&t.coefficientFor(e.other)<0?e.other:k},t.prototype._addWithArtificialVariable=function(t){var e=this._makeSymbol(w.Slack);this._rowMap.insert(e,t.copy()),this._artificial=t.copy(),this._optimize(this._artificial);var r=E(this._artificial.constant());this._artificial=null;var o=this._rowMap.erase(e);if(void 0!==o){var n=o.second;if(n.isConstant())return r;var i=this._anyPivotableSymbol(n);if(i.type()===w.Invalid)return!1;n.solveForEx(e,i),this._substitute(i,n),this._rowMap.insert(i,n)}for(var s=this._rowMap,a=0,c=s.size();a<c;++a)s.itemAt(a).second.removeSymbol(e);return this._objective.removeSymbol(e),r},t.prototype._substitute=function(t,e){for(var r=this._rowMap,o=0,n=r.size();o<n;++o){var i=r.itemAt(o);i.second.substitute(t,e),i.second.constant()<0&&i.first.type()!==w.External&&this._infeasibleRows.push(i.first)}this._objective.substitute(t,e),this._artificial&&this._artificial.substitute(t,e)},t.prototype._optimize=function(t){for(;;){var e=this._getEnteringSymbol(t);if(e.type()===w.Invalid)return;var r=this._getLeavingSymbol(e);if(r.type()===w.Invalid)throw new Error("the objective is unbounded");var o=this._rowMap.erase(r).second;o.solveForEx(r,e),this._substitute(e,o),this._rowMap.insert(e,o)}},t.prototype._dualOptimize=function(){for(var t=this._rowMap,e=this._infeasibleRows;0!==e.length;){var r=e.pop(),o=t.find(r);if(void 0!==o&&o.second.constant()<0){var n=this._getDualEnteringSymbol(o.second);if(n.type()===w.Invalid)throw new Error("dual optimize failed");var i=o.second;t.erase(r),i.solveForEx(r,n),this._substitute(n,i),t.insert(n,i)}}},t.prototype._getEnteringSymbol=function(t){for(var e=t.cells(),r=0,o=e.size();r<o;++r){var n=e.itemAt(r),i=n.first;if(n.second<0&&i.type()!==w.Dummy)return i}return k},t.prototype._getDualEnteringSymbol=function(t){for(var e=Number.MAX_VALUE,r=k,o=t.cells(),n=0,i=o.size();n<i;++n){var s=o.itemAt(n),a=s.first,c=s.second;if(c>0&&a.type()!==w.Dummy){var p=this._objective.coefficientFor(a)/c;p<e&&(e=p,r=a)}}return r},t.prototype._getLeavingSymbol=function(t){for(var e=Number.MAX_VALUE,r=k,o=this._rowMap,n=0,i=o.size();n<i;++n){var s=o.itemAt(n),a=s.first;if(a.type()!==w.External){var c=s.second,p=c.coefficientFor(t);if(p<0){var u=-c.constant()/p;u<e&&(e=u,r=a)}}}return r},t.prototype._getMarkerLeavingSymbol=function(t){for(var e=Number.MAX_VALUE,r=e,o=e,n=k,i=n,s=n,a=n,c=this._rowMap,p=0,u=c.size();p<u;++p){var h=c.itemAt(p),f=h.second,d=f.coefficientFor(t);if(0!==d){var l=h.first;if(l.type()===w.External)a=l;else if(d<0){(y=-f.constant()/d)<r&&(r=y,i=l)}else{var y;(y=f.constant()/d)<o&&(o=y,s=l)}}}return i!==n?i:s!==n?s:a},t.prototype._removeConstraintEffects=function(t,e){e.marker.type()===w.Error&&this._removeMarkerEffects(e.marker,t.strength()),e.other.type()===w.Error&&this._removeMarkerEffects(e.other,t.strength())},t.prototype._removeMarkerEffects=function(t,e){var r=this._rowMap.find(t);void 0!==r?this._objective.insertRow(r.second,-e):this._objective.insertSymbol(t,-e)},t.prototype._anyPivotableSymbol=function(t){for(var e=t.cells(),r=0,o=e.size();r<o;++r){var n=e.itemAt(r),i=n.first.type();if(i===w.Slack||i===w.Error)return n.first}return k},t.prototype._makeSymbol=function(t){return new N(t,this._idTick++)},t}();function E(t){return t<0?-t<1e-8:t<1e-8}(x=w||(w={}))[x.Invalid=0]="Invalid",x[x.External=1]="External",x[x.Slack=2]="Slack",x[x.Error=3]="Error",x[x.Dummy=4]="Dummy";var N=function(){function t(t,e){this._id=e,this._type=t}return t.prototype.id=function(){return this._id},t.prototype.type=function(){return this._type},t}(),k=new N(w.Invalid,-1),z=function(){function t(t){void 0===t&&(t=0),this._cellMap=h(),this._constant=t}return t.prototype.cells=function(){return this._cellMap},t.prototype.constant=function(){return this._constant},t.prototype.isConstant=function(){return this._cellMap.empty()},t.prototype.allDummies=function(){for(var t=this._cellMap,e=0,r=t.size();e<r;++e){if(t.itemAt(e).first.type()!==w.Dummy)return!1}return!0},t.prototype.copy=function(){var e=new t(this._constant);return e._cellMap=this._cellMap.copy(),e},t.prototype.add=function(t){return this._constant+=t},t.prototype.insertSymbol=function(t,e){void 0===e&&(e=1),E(this._cellMap.setDefault(t,function(){return 0}).second+=e)&&this._cellMap.erase(t)},t.prototype.insertRow=function(t,e){void 0===e&&(e=1),this._constant+=t._constant*e;for(var r=t._cellMap,o=0,n=r.size();o<n;++o){var i=r.itemAt(o);this.insertSymbol(i.first,i.second*e)}},t.prototype.removeSymbol=function(t){this._cellMap.erase(t)},t.prototype.reverseSign=function(){this._constant=-this._constant;for(var t=this._cellMap,e=0,r=t.size();e<r;++e){var o=t.itemAt(e);o.second=-o.second}},t.prototype.solveFor=function(t){var e=this._cellMap,r=-1/e.erase(t).second;this._constant*=r;for(var o=0,n=e.size();o<n;++o)e.itemAt(o).second*=r},t.prototype.solveForEx=function(t,e){this.insertSymbol(t,-1),this.solveFor(e)},t.prototype.coefficientFor=function(t){var e=this._cellMap.find(t);return void 0!==e?e.second:0},t.prototype.substitute=function(t,e){var r=this._cellMap.erase(t);void 0!==r&&this.insertRow(e,r.second)},t}();const A=(t,e,r)=>{for(let o=0;o<e;o+=1)for(const e of t)e.base.solve(e,r)},V=(t,e)=>{const r=new S,o={},n=(t,e)=>`${t.id}_${e}`,i=(t,e)=>{const r=n(t,e);if(!o[r]){const n=o[r]=new l;n.property=e,n.obj=t}};for(const p of t){const t=p.property;i(p.a,t),i(p.b,t)}let s=0;for(const p of t){const t=p.property;try{r.addConstraint(p.base.strict(p,e,o[n(p.a,t)],o[n(p.b,t)]))}catch(c){s+=1}}r.updateVariables();const a=Object.values(o);for(const p of a)p.obj[p.property]=p.value()},j={strict:(t,e,r,o)=>new b(r.minus(o),v.Ge,t.separation,g.required)},F={strict:(t,e,r,o)=>new b(r.minus(o),v.Ge,e.layerSpace,g.required)},D={solve:(t,e)=>{const{a:r,b:o,strength:n}=t,i=n*(r[t.property]-o[t.property]);r[t.property]-=i,o[t.property]+=i},strict:(t,e,r,o)=>new b(r.minus(o),v.Eq,0,g.create(1,0,0,t.strength))},q={solve:(t,e)=>{const{edgeA:r,edgeB:o,separationA:n,separationB:i,strength:s}=t,a=s*((r.sourceNode[t.property]-o.sourceNode[t.property]-n)/n),c=s*((r.targetNode[t.property]-o.targetNode[t.property]-i)/i);r.sourceNode[t.property]-=a,o.sourceNode[t.property]+=a,r.targetNode[t.property]-=c,o.targetNode[t.property]+=c}},C={strict:(t,e,r,o)=>new b(o.minus(r),v.Ge,t.separation,g.required)};(()=>{if("undefined"==typeof window||!window.location)return"/";const{pathname:t}=window.location,e=t.replace(/\\/(workflow).*$/,"");e.endsWith("/")})();const O="workflow",X=(t,e)=>t.map(t=>({base:j,property:e.coordSecondary,a:t.targetNode,b:t.sourceNode,separation:"vertical"===e.orientation?e.spaceY+e.extraVerticalGap:e.spaceY})),I=(t,e,r)=>{const o=[];if(!e)return o;const n=e.map(e=>t.filter(t=>t.nearestLayer===e));for(let i=0;i<n.length-1;i+=1){const t=n[i],e=n[i+1],s={id:`layer-${i}`,x:0,y:0};for(const n of t)o.push({base:F,property:r.coordSecondary,a:s,b:n});for(const n of e)o.push({base:F,property:r.coordSecondary,a:n,b:s})}return o},L=(t,e)=>{const{spaceX:r,coordPrimary:o}=e,n=[];for(let i=0;i<t.length;i+=1){const e=t[i],{sourceNode:s,targetNode:a}=e,c=s.sources.length+s.targets.length+a.sources.length+a.targets.length;for(let p=i+1;p<t.length;p+=1){const i=t[p],{sourceNode:u,targetNode:h}=i;if(s.row>=h.row||a.row<=u.row)continue;const f=u.sources.length+u.targets.length+h.sources.length+h.targets.length;n.push({base:q,property:o,edgeA:e,edgeB:i,separationA:.5*s.width+r+.5*u.width,separationB:.5*a.width+r+.5*h.width,strength:1/Math.max(1,(c+f)/4)})}}return n},R=(t,e)=>t.map(({sourceNode:t,targetNode:r})=>({base:D,property:e.coordPrimary,a:t,b:r,strength:.6/Math.max(1,t.targets.length+r.sources.length-2)})),G=(t,r)=>{const{spaceX:o,coordPrimary:n,spreadX:i,orientation:s,extraVerticalGap:a}=r,c=[];for(let u=0;u<t.length;u+=1){const r=t[u];r.sort((t,e)=>p(t[n],e[n],t.id,e.id));for(let t=0;t<r.length-1;t+=1){const p=r[t],u=r[t+1],h=Math.max(1,p.targets.length+p.sources.length-2),f=Math.max(1,u.targets.length+u.sources.length-2),d=Math.min(10,h*f*i),l=e(d*o,o),y="horizontal"===s?p.height+u.height+a:.5*p.width+l+.5*u.width+a;c.push({base:C,property:n,a:p,b:u,separation:y})}}return c},P=(t,r,o,n,i,s=1.25,a=.25)=>{const c=Y(t,i),p=Math.round(n*a);let u=0;for(let h=0;h<r.length-1;h+=1){const t=c[h]||0,a=e(t*s*n,p);if("horizontal"===i){u+=a+.5*Math.max(...r[h].map(t=>t.width))+.5*Math.max(...r[h+1].map(t=>t.width))}else u+=a;for(const e of r[h+1])e[o]+=u}},Y=(e,r)=>{const n={};for(const i of e){const e=Math.abs(o(i.targetNode,i.sourceNode,r)-t)/t,s=i.sourceNode.row,a=i.targetNode.row-1;n[s]=n[s]||[0,0],n[s][0]+=e,n[s][1]+=1,a!==s&&(n[a]=n[a]||[0,0],n[a][0]+=e,n[a][1]+=1)}for(const t in n)n[t]=n[t][0]/(n[t][1]||1);return Object.values(n)},T={layout:{spaceX:14,spaceY:110,layerSpaceY:100,spreadX:2.2,padding:100,iterations:25},routing:{spaceX:26,spaceY:28,minPassageGap:40,stemUnit:8,stemMinSource:0,stemMinTarget:15,stemMax:10,stemSpaceSource:6,stemSpaceTarget:10}},B=(t,e,h,f,d,l=T)=>{U(t,e),$(t,h),(({nodes:t,edges:e,layers:r,spaceX:o,spaceY:n,spreadX:i,layerSpaceY:s,iterations:a,orientation:p,view:u})=>{const h="workflow"===u?60:0;let f="x",d="y";"horizontal"===p&&(f="y",d="x");for(const c of t)c[f]=0,c[d]=0;const l={orientation:p,spaceX:o,spaceY:n,spreadX:i,layerSpace:.5*(n+s),coordPrimary:f,coordSecondary:d,extraVerticalGap:h},y=X(e,l),m=I(t,r,l);V([...y,...m],l);const v=c(t,p),_=L(e,l),g=R(e,l);for(let c=0;c<a;c+=1)A(_,1,l),A(g,50,l);const w=G(v,l);V([...w,...g],l),P(e,v,d,n,p)})({nodes:t,edges:e,layers:h,orientation:f,view:d,...l.layout}),(({nodes:t,edges:e,spaceX:h,spaceY:f,minPassageGap:d,stemUnit:l,stemMinSource:y,stemMinTarget:m,stemMax:v,stemSpaceSource:_,stemSpaceTarget:g,orientation:w})=>{const x=c(t,w);for(const r of t)r.targets.sort((t,e)=>p(o(e.sourceNode,e.targetNode,w),o(t.sourceNode,t.targetNode,w)));for(const o of e){const t=o.sourceNode,e=o.targetNode;o.points=[];const a=Math.min((t.width-_)/t.targets.length,_)*(t.targets.indexOf(o)-.5*(t.targets.length-1));let c={x:t.x,y:t.y};for(let p=t.row+1;p<e.row;p+=1){const t=x[p][0];let e={x:n(t)-h,y:t.y},l=1/0;const y=[{...t,x:Number.MIN_SAFE_INTEGER},...x[p],{...t,x:Number.MAX_SAFE_INTEGER}];for(let o=0;o<y.length-1;o+=1){const t=y[o],a=y[o+1],p=n(a)-i(t);if(p<d)continue;const m=Math.min(h,.5*p);let v,_,g,x;"vertical"===w&&(v=i(t)+m,_=s(t)-f,g=n(a)-m,x=s(a)-f);const b=u(c.x,c.y,v,_,g,x),M=r(c.x,b.x);if(M>l)break;M<l&&(l=M,e=b)}const m=t.height+f;o.points.push({x:e.x+a,y:e.y}),o.points.push({x:e.x+a,y:e.y+m}),c={x:e.x,y:e.y+m}}}for(const r of t)r.targets.sort((t,e)=>p(o(e.sourceNode,e.points[0]||e.targetNode,w),o(t.sourceNode,t.points[0]||t.targetNode,w))),r.sources.sort((t,e)=>p(o(t.points[t.points.length-1]||t.sourceNode,t.targetNode,w),o(e.points[e.points.length-1]||e.sourceNode,e.targetNode,w)));for(const r of e){const t=r.sourceNode,e=r.targetNode,o=t.targets.indexOf(r)-.5*(t.targets.length-1),c=e.sources.indexOf(r)-.5*(e.sources.length-1),p=l*t.targets.length*(1-Math.abs(o)/t.targets.length),u=l*e.sources.length*(1-Math.abs(c)/e.sources.length);let h,f;"vertical"===w?(h=[{x:t.x,y:a(t)},{x:t.x,y:a(t)+y},{x:t.x,y:a(t)+y+Math.min(p,v)}],f=[{x:e.x,y:s(e)-m-Math.min(u,v)},{x:e.x,y:s(e)-m},{x:e.x,y:s(e)}]):(h=[{x:i(t),y:t.y},{y:t.y,x:i(t)+y},{y:t.y,x:i(t)+y+Math.min(p,v)}],f=[{y:e.y,x:n(e)-m-Math.min(u,v)},{y:e.y,x:n(e)-m},{y:e.y,x:n(e)}]);const d=[...h,...r.points,...f],_="vertical"===w?"y":"x";let g=d[0][_];for(const r of d)r[_]<g?r[_]=g:g=r[_];r.points=d}})({nodes:t,edges:e,orientation:f,...l.routing});const y=K(t,l.layout.padding);return t.forEach(t=>((t,e)=>(t.x=t.x-e.x,t.y=t.y-e.y,t.order=t.x+9999*t.y,t))(t,y.min)),e.forEach(t=>((t,e)=>(t.points.forEach(t=>{t.x=t.x-e.x,t.y=t.y-e.y}),t))(t,y.min)),{nodes:t,edges:e,layers:h,size:y}},U=(t,e)=>{const r={};for(const o of t)r[o.id]=o,o.targets=[],o.sources=[];for(const o of e)o.sourceNode=r[o.source],o.targetNode=r[o.target],o.sourceNode.targets.push(o),o.targetNode.sources.push(o)},$=(t,e)=>{if(e&&e.length>0){const r={};for(const t of e)r[t]=!0;const o=t=>Boolean(t&&t.layer in r),n=e[e.length-1];for(const e of t){const t=H(e,W,J,o);e.nearestLayer=t?t.layer:n}}},W=t=>t.targets.map(t=>t.targetNode),J=(t,e)=>t.rank-e.rank,H=(t,e,r,o,n)=>{if(o(t))return t;(n=n||{})[t.id]=!0;return e(t).filter(t=>!n[t.id]).sort(r).map(t=>H(t,e,r,o,n)).filter(o).sort(r)[0]},K=(t,e)=>{const r={min:{x:1/0,y:1/0},max:{x:-1/0,y:-1/0}};for(const o of t){const t=o.x,e=o.y;t<r.min.x&&(r.min.x=t),t>r.max.x&&(r.max.x=t),e<r.min.y&&(r.min.y=e),e>r.max.y&&(r.max.y=e)}return r.width=r.max.x-r.min.x+2*e,r.height=r.max.y-r.min.y+2*e,r.min.x-=e,r.min.y-=e,r};self.addEventListener("message",t=>{const e=(({nodes:t,edges:e,layers:r,orientation:o,view:n})=>{for(const s of t){s.iconSize=s.iconSize||24,s.icon=s.icon||"node";const t={x:20,y:10},e=7*(s&&s.fullName&&s.fullName.length||s&&s.name&&s.name.length),r=6,o=s.iconSize+e+r;let i=s.width||o+2*t.x;s.width=n===O?Math.max(i,180):i,s.height=s.height||s.iconSize+2*t.y,s.textOffset=s.textOffset||(o-e)/2,s.iconOffset=s.iconOffset||-o/2}const i=B(t,e,r,o,n);return{...i,size:{...i.size,marginx:100,marginy:100}}})(t.data);self.postMessage(e)})}();\n';
const blob = typeof self !== "undefined" && self.Blob && new Blob([jsContent], { type: "text/javascript;charset=utf-8" });
function WorkerWrapper(options) {
  let objURL;
  try {
    objURL = blob && (self.URL || self.webkitURL).createObjectURL(blob);
    if (!objURL) throw "";
    const worker = new Worker(objURL, {
      name: options == null ? void 0 : options.name
    });
    worker.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(objURL);
    });
    return worker;
  } catch (e) {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(jsContent),
      {
        name: options == null ? void 0 : options.name
      }
    );
  } finally {
    objURL && (self.URL || self.webkitURL).revokeObjectURL(objURL);
  }
}
const isTest = typeof jest !== "undefined";
const createWorker = () => new WorkerWrapper({ name: "graph-worker" });
const createMockWorker = (workerModule) => {
  if (!isTest) {
    return workerModule;
  }
  return () => {
    const mockWorker = {
      terminate: () => {
      },
      postMessage: async (payload) => {
        const impl = require("./graph-worker.js");
        const fn = impl.graph || impl.default || (() => {
        });
        const result = await fn(payload);
        setTimeout(() => {
          if (typeof mockWorker.onmessage === "function") {
            mockWorker.onmessage({ data: result });
          }
        }, 0);
      },
      onmessage: null
    };
    return mockWorker;
  };
};
const graph = createMockWorker(createWorker);
function preventWorkerQueues(worker) {
  let instance = worker();
  let running = false;
  return (payload) => {
    if (running) {
      instance.terminate();
      instance = worker();
    }
    running = true;
    return new Promise((resolve) => {
      instance.onmessage = (event) => {
        running = false;
        resolve(event.data);
      };
      instance.postMessage(payload);
    });
  };
}
const TOGGLE_GRAPH_LOADING = "TOGGLE_GRAPH_LOADING";
function toggleLoading$1(loading) {
  return {
    type: TOGGLE_GRAPH_LOADING,
    loading
  };
}
const UPDATE_GRAPH_LAYOUT = "UPDATE_GRAPH_LAYOUT";
function updateGraph(graph2) {
  return {
    type: UPDATE_GRAPH_LAYOUT,
    graph: graph2
  };
}
const layoutWorker = preventWorkerQueues(graph);
function calculateGraph(graphState) {
  if (!graphState) {
    return updateGraph(graphState);
  }
  return async function(dispatch2) {
    dispatch2(toggleLoading$1(true));
    const graph2 = await layoutWorker(graphState);
    dispatch2(toggleGraph(true));
    dispatch2(toggleLoading$1(false));
    return dispatch2(updateGraph(graph2));
  };
}
function nodeReducer$1(graphState = {}, action) {
  const updateState = (newState) => Object.assign({}, graphState, newState);
  switch (action.type) {
    case UPDATE_GRAPH_LAYOUT: {
      return updateState(action.graph);
    }
    default:
      return graphState;
  }
}
function layerReducer(layerState = {}, action) {
  switch (action.type) {
    case TOGGLE_LAYERS: {
      return Object.assign({}, layerState, {
        visible: action.visible
      });
    }
    default:
      return layerState;
  }
}
const pathRoot = "./api";
const arrayToObject = (array2, callback) => {
  const newObject = {};
  array2.forEach((key) => {
    newObject[key] = callback(key);
  });
  return newObject;
};
const getUrl = (type, id2) => {
  switch (type) {
    case "main":
      return [pathRoot, "main"].join("/");
    case "pipeline":
      if (!id2) {
        throw new Error("No pipeline ID provided");
      }
      return [pathRoot, "pipelines", id2].join("/");
    case "nodes":
      if (!id2) {
        throw new Error("No node ID provided");
      }
      return [pathRoot, "nodes", id2].join("/");
    default:
      throw new Error("Unknown URL type");
  }
};
const replaceAngleBracketMatches = (str) => {
  if ((str == null ? void 0 : str.length) > 0) {
    const strWithoutBTag = str.replaceAll("<b>", "@$1$@").replaceAll("</b>", "@$2$@");
    const replacedWithAngleBracket = strWithoutBTag.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
    const result = replacedWithAngleBracket.replaceAll("@$1$@", "<b>").replaceAll("@$2$@", "</b>");
    return result;
  } else {
    return str;
  }
};
const stripNamespace = (str) => {
  const lastDotIndex = str.lastIndexOf(".");
  return lastDotIndex >= 0 ? str.substring(lastDotIndex + 1) : str;
};
const prettifyName = (str) => {
  if (!str) {
    return "";
  }
  const replacedString = str.replace(/-/g, " ").replace(/_/g, " ").replace(/:/g, ": ").trim();
  return replacedString.replace(/(^|\s)\S/g, (match2) => match2.toUpperCase());
};
const prettifyModularPipelineNames = (modularPipelines) => {
  for (const key in modularPipelines) {
    if (modularPipelines.hasOwnProperty(key)) {
      const modularPipeline = modularPipelines[key];
      if (modularPipeline.hasOwnProperty("name")) {
        modularPipelines[key] = {
          ...modularPipeline,
          name: prettifyName(modularPipeline["name"])
        };
      }
    }
  }
  return modularPipelines;
};
const formatFileSize = (fileSizeInBytes) => {
  const conversionUnit = 1e3;
  if (!fileSizeInBytes) {
    return "N/A";
  } else if (fileSizeInBytes < conversionUnit) {
    return `${fileSizeInBytes} bytes`;
  } else if (fileSizeInBytes < conversionUnit * conversionUnit) {
    const sizeInKB = fileSizeInBytes / conversionUnit;
    return `${sizeInKB.toFixed(1)}KB`;
  } else {
    const sizeInMB = fileSizeInBytes / (conversionUnit * conversionUnit);
    return `${sizeInMB.toFixed(1)}MB`;
  }
};
const formatNumberWithCommas = (number) => {
  return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
};
const isRunningLocally = () => {
  if (typeof window === "undefined" || !window.location) {
    return false;
  }
  const hosts = [
    "localhost",
    "127.0.0.1",
    "0.0.0.0",
    "demo.kedro.org",
    "gitpod",
    "kedro-org"
  ];
  const hostname = window.location.hostname.toLowerCase();
  if (hosts.some((host) => hostname.includes(host))) {
    return true;
  }
  const privateIpRanges = [
    // 10.0.0.0  10.255.255.255
    /^10\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
    // 172.16.0.0  172.31.255.255
    /^172\.(1[6-9]|2[0-9]|3[0-1])\.\d{1,3}\.\d{1,3}$/,
    // 192.168.0.0  192.168.255.255
    /^192\.168\.\d{1,3}\.\d{1,3}$/
  ];
  return privateIpRanges.some((regex) => regex.test(hostname));
};
const sanitizedPathname = () => {
  if (typeof window === "undefined" || !window.location) {
    return "/";
  }
  const { pathname: pathname2 } = window.location;
  const basePath = pathname2.replace(/\/(workflow).*$/, "");
  const pathnameWithTrailingSlash = basePath.endsWith("/") ? basePath : `${basePath}/`;
  return pathnameWithTrailingSlash;
};
async function fetchMetadata() {
  const request = await fetch(`${pathRoot}/metadata`, {
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    }
  });
  return request;
}
async function deployViz(inputValues) {
  const request = await fetch(`${pathRoot}/deploy`, {
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST",
    body: JSON.stringify(inputValues)
  });
  return request;
}
async function getVersion() {
  const request = await fetch(`${pathRoot}/version`, {
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    }
  });
  return request;
}
const nodeTypeMapObj = {
  nodes: "task",
  task: "nodes",
  datasets: "data",
  data: "datasets"
};
const mapNodeType = (nodeType) => nodeTypeMapObj[nodeType] || nodeType;
const mapNodeTypes = (nodeTypes) => {
  return nodeTypes.replace(/task|data/g, (matched) => mapNodeType(matched));
};
const isValidBoolean = (inputString) => {
  return /^(true|false)$/i.test(inputString);
};
function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205) return;
  return response.json();
}
function json(input, init2) {
  return fetch(input, init2).then(responseJson);
}
const loadJsonData = (path2 = getUrl("main"), fallback = {}) => json(path2).catch(() => {
  const fullPath = `/public${path2.substr(1)}`;
  if (path2 === getUrl("main")) {
    throw new Error(
      `Unable to load data from ${path2}. If you're running Kedro-Viz as a standalone (e.g. for JavaScript development), please check that you have placed a data file at ${fullPath}.`
    );
  }
  return new Promise((resolve) => resolve(fallback));
});
var cjs;
var hasRequiredCjs;
function requireCjs() {
  if (hasRequiredCjs) return cjs;
  hasRequiredCjs = 1;
  var isMergeableObject = function isMergeableObject2(value) {
    return isNonNullObject(value) && !isSpecial(value);
  };
  function isNonNullObject(value) {
    return !!value && typeof value === "object";
  }
  function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
  }
  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
  function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
  }
  function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
  }
  function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
  }
  function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
      return cloneUnlessOtherwiseSpecified(element, options);
    });
  }
  function getMergeFunction(key, options) {
    if (!options.customMerge) {
      return deepmerge2;
    }
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge2;
  }
  function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
      return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
  }
  function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
  }
  function propertyIsOnObject(object2, property) {
    try {
      return property in object2;
    } catch (_) {
      return false;
    }
  }
  function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
  }
  function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) {
      getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
      });
    }
    getKeys(source).forEach(function(key) {
      if (propertyIsUnsafe(target, key)) {
        return;
      }
      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
      } else {
        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
      }
    });
    return destination;
  }
  function deepmerge2(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) {
      return cloneUnlessOtherwiseSpecified(source, options);
    } else if (sourceIsArray) {
      return options.arrayMerge(target, source, options);
    } else {
      return mergeObject(target, source, options);
    }
  }
  deepmerge2.all = function deepmergeAll(array2, options) {
    if (!Array.isArray(array2)) {
      throw new Error("first argument should be an array");
    }
    return array2.reduce(function(prev2, next2) {
      return deepmerge2(prev2, next2, options);
    }, {});
  };
  var deepmerge_1 = deepmerge2;
  cjs = deepmerge_1;
  return cjs;
}
var cjsExports = requireCjs();
const deepmerge$2 = /* @__PURE__ */ getDefaultExportFromCjs(cjsExports);
const localStorageName = "KedroViz";
const localStorageShareableUrl = "KedroViz-shareable-url";
const localStorageFeedbackSeen = "KedroViz-feedback-seen";
const localStorageBannerStatus = "KedroViz-banners";
const localStorageLastRunEndTime = "KedroViz-workflow-last-run-end-time";
const globalToolbarWidth = 80;
const metaSidebarWidth = {
  closed: 0,
  open: 400
};
const sidebarWidth = {
  breakpoint: 700,
  closed: 56 + globalToolbarWidth,
  open: 400 + globalToolbarWidth
};
const codeSidebarWidth = {
  closed: 0,
  open: 480
};
const workflowNodeDetailsHeight = 60;
const workFlowStatuses = ["success", "failed"];
const nodeListRowHeight = 32;
const chartMinWidthScale = 0.25;
const largeGraphThreshold = 1e3;
const flags = {
  sizewarning: {
    name: "Size warning",
    description: "Show a warning before rendering very large graphs",
    default: true,
    icon: ""
  }
};
const settings = {
  isPrettyName: {
    name: "Pretty name",
    description: "Display a formatted name for the kedro nodes",
    default: false
  },
  showFeatureHints: {
    name: "New feature hints",
    description: "Enable or disable all new feature hints in the interface.",
    default: true
  },
  showDatasetPreviews: {
    name: "Dataset previews",
    description: "Display preview data for all datasets.",
    default: true
  }
};
const sidebarGroups = {
  elementType: "Element types",
  tag: "Tags"
};
const sidebarElementTypes = {
  task: "Nodes",
  data: "Datasets",
  parameters: "Parameters"
};
const shortTypeMapping = {
  "plotly.plotly_dataset.PlotlyDataset": "plotly",
  "plotly.json_dataset.JSONDataset": "plotly",
  "matplotlib.matplotlib_writer.MatplotlibWriter": "image",
  "plotly.plotly_dataset.PlotlyDataSet": "plotly",
  "plotly.json_dataset.JSONDataSet": "plotly"
};
const params = {
  focused: "fid",
  selected: "sid",
  selectedName: "sn",
  pipeline: "pid",
  types: "types",
  tags: "tags",
  expandAll: "expandAllPipelines"
};
const pathname = sanitizedPathname();
const routes = {
  flowchart: {
    main: pathname
  }
};
const errorMessages = {
  node: 'Please check the value of "selected_id"/"sid" or "selected_name"/"sn" in the URL',
  modularPipeline: 'Please check the value of "focused_id"/"fid" in the URL',
  pipeline: 'Please check the value of "pipeline_id"/"pid" in the URL'
};
const datasetStatLabels = ["rows", "columns", "file_size"];
const statsRowLen = 33;
const hostingPlatforms = {
  aws: "Amazon Web Services",
  gcp: "Google Cloud",
  azure: "Microsoft Azure"
};
const shareableUrlMessages = (status, info = "") => {
  const messages = {
    failure: "Something went wrong. Please try again later.",
    loading: "Shooting your files through space. Sit tight...",
    success: "The deployment has been successful and Kedro-Viz is hosted via the link below..",
    incompatible: `Publishing Kedro-Viz is only supported with fsspec>=2023.9.0. You are currently on version ${info}.

Please upgrade fsspec to a supported version and ensure you're using Kedro 0.18.2 or above.`
  };
  return messages[status];
};
const inputKeyToStateKeyMap = {
  // eslint-disable-next-line camelcase
  bucket_name: "hasBucketName",
  platform: "hasPlatform",
  endpoint: "hasEndpoint"
};
const PACKAGE_FSSPEC = "fsspec";
const KEDRO_VIZ_DOCS_URL = "https://docs.kedro.org/projects/kedro-viz/en/stable/";
const KEDRO_VIZ_PUBLISH_DOCS_URL = `${KEDRO_VIZ_DOCS_URL}share_kedro_viz/`;
const KEDRO_VIZ_PUBLISH_AWS_DOCS_URL = `${KEDRO_VIZ_DOCS_URL}publish_and_share_kedro_viz_on_aws/#set-up-endpoint`;
const KEDRO_VIZ_PUBLISH_AZURE_DOCS_URL = `${KEDRO_VIZ_DOCS_URL}publish_and_share_kedro_viz_on_azure/#set-up-endpoint`;
const KEDRO_VIZ_PUBLISH_GCP_DOCS_URL = `${KEDRO_VIZ_DOCS_URL}publish_and_share_kedro_viz_on_gcp/#set-up-endpoint`;
const defaultQueryParams = [
  params.types,
  params.tags,
  params.expandAll,
  params.pipeline
];
const NODE_TYPES = {
  task: { name: "nodes", defaultState: false },
  data: { name: "datasets", defaultState: false },
  parameters: { name: "parameters", defaultState: true }
};
const BANNER_METADATA = {
  liteModeWarning: {
    title: "Lite mode enabled",
    body: "Some features might be disabled in --lite mode due to missing dependencies. You can find more information about lite mode in our docs.",
    docsLink: "https://docs.kedro.org/projects/kedro-viz/en/stable/kedro-viz_visualisation/#visualise-a-kedro-project-without-installing-project-dependencies"
  }
};
const BANNER_KEYS = {
  LITE: "lite"
};
const VIEW = {
  WORKFLOW: "workflow",
  FLOWCHART: "flowchart"
};
const PIPELINE = {
  DEFAULT: "__default__"
};
const noWindow = typeof window === "undefined";
const loadLocalStorage = (itemKey = localStorageName) => {
  if (noWindow) {
    return {};
  }
  try {
    const serializedState = window.localStorage.getItem(itemKey);
    if (serializedState === null) {
      return {};
    }
    return JSON.parse(serializedState);
  } catch (err) {
    console.error(err);
    return {};
  }
};
const saveLocalStorage = (itemKey = localStorageName, state) => {
  if (noWindow) {
    return;
  }
  try {
    const newState = Object.assign(loadLocalStorage(itemKey), state);
    if (newState.hasOwnProperty("nodeTypeDisabled")) {
      delete newState.nodeTypeDisabled;
    }
    const serializedState = JSON.stringify(newState);
    window.localStorage.setItem(itemKey, serializedState);
  } catch (err) {
    console.error(err);
  }
};
const pruneFalseyKeys = (obj) => {
  const newObj = {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key) && obj[key]) {
      newObj[key] = obj[key];
    }
  }
  return newObj;
};
const createInitialPipelineState = () => ({
  pipeline: {
    ids: [],
    name: {}
  },
  modularPipeline: {
    ids: [],
    tree: {},
    visible: {},
    expanded: [],
    active: {},
    disabled: {}
  },
  node: {
    ids: [],
    name: {},
    fullName: {},
    type: {},
    tags: {},
    layer: {},
    disabled: {},
    pipelines: {},
    clicked: null,
    hovered: null,
    fetched: {},
    code: {},
    parameters: {},
    filepath: {},
    inputs: {},
    outputs: {},
    plot: {},
    image: {},
    datasetType: {},
    originalType: {},
    transcodedTypes: {},
    runCommand: {},
    modularPipelines: {},
    extras: {}
  },
  nodeType: {
    ids: ["task", "data", "parameters", "modularPipeline"],
    name: {
      data: "Datasets",
      task: "Nodes",
      parameters: "Parameters",
      modularPipeline: "Modular Pipelines"
    },
    disabled: {
      parameters: true,
      task: false,
      data: false
    }
  },
  edge: {
    ids: [],
    sources: {},
    targets: {}
  },
  layer: {
    ids: [],
    name: {},
    visible: true
  },
  tag: {
    ids: [],
    name: {},
    active: {},
    enabled: {}
  },
  slice: {
    from: null,
    to: null,
    apply: false
  },
  hoveredParameters: false,
  hoveredFocusMode: false
});
const validateInput = (data) => {
  if (!data) {
    throw new Error("No data provided to Kedro-Viz");
  }
  if (data === "json") {
    return false;
  }
  if (!Array.isArray(data.edges) || !Array.isArray(data.nodes)) {
    if (typeof jest === "undefined") {
      console.error("Invalid Kedro-Viz data:", data);
    }
    throw new Error(
      "Invalid Kedro-Viz data input. Please ensure that your pipeline data includes arrays of nodes and edges"
    );
  }
  return true;
};
const createEdgeID = (source, target) => [source, target].join("|");
const addPipeline = (state) => (pipeline) => {
  const { id: id2 } = pipeline;
  if (state.pipeline.name[id2]) {
    return;
  }
  state.pipeline.ids.push(id2);
  state.pipeline.name[id2] = prettifyName(pipeline.name || "");
};
const addNode = (state) => (node2) => {
  const { id: id2 } = node2;
  if (state.node.name[id2]) {
    return;
  }
  state.node.ids.push(id2);
  state.node.name[id2] = prettifyName(stripNamespace(node2.name || ""));
  state.node.fullName[id2] = node2.name;
  state.node.type[id2] = node2.type;
  state.node.layer[id2] = node2.layer;
  state.node.pipelines[id2] = node2.pipelines ? arrayToObject(node2.pipelines, () => true) : {};
  state.node.tags[id2] = node2.tags || [];
  state.node.code[id2] = node2.code;
  state.node.parameters[id2] = node2.parameters;
  state.node.filepath[id2] = node2.filepath;
  state.node.datasetType[id2] = node2.dataset_type;
  state.node.originalType[id2] = node2.original_type;
  state.node.transcodedTypes[id2] = node2.transcoded_types;
  state.node.runCommand[id2] = node2.runCommand;
  state.node.modularPipelines[id2] = node2.modular_pipelines || [];
  state.node.extras[id2] = node2.node_extras || {};
};
const addEdge = (state) => ({ source, target }) => {
  const id2 = createEdgeID(source, target);
  if (state.edge.ids.includes(id2)) {
    return;
  }
  state.edge.ids.push(id2);
  state.edge.sources[id2] = source;
  state.edge.targets[id2] = target;
};
const addTag = (state) => (tag) => {
  const { id: id2 } = tag;
  state.tag.ids.push(id2);
  state.tag.name[id2] = prettifyName(tag.name || "");
};
const addLayer = (state) => (layer) => {
  state.layer.ids.push(layer);
  state.layer.name[layer] = layer;
};
const splitQueryParams = (queryParams) => queryParams ? queryParams.split(",").filter((item) => item !== "") : [];
const getNodeTagsFiltersFromUrl = (state, tagsQueryParam, allNodeTags = []) => {
  const queryParamsTagsArray = splitQueryParams(tagsQueryParam);
  if (queryParamsTagsArray.length !== 0) {
    const queryParamsTagsSet = new Set(queryParamsTagsArray);
    const enabledTags = allNodeTags.reduce((result, tag) => {
      result[tag.id] = queryParamsTagsSet.has(tag.id);
      return result;
    }, {});
    state.tag.enabled = enabledTags;
  }
  return state;
};
const getNodeTypesFromUrl = (state, typeQueryParams) => {
  const nodeTypes = splitQueryParams(typeQueryParams);
  if (nodeTypes.length !== 0) {
    Object.keys(state.nodeType.disabled).forEach((key) => {
      state.nodeType.disabled[key] = !nodeTypes.includes(key);
    });
  }
  return state;
};
const sortNodesEdges = (state) => {
  var _a, _b, _c, _d;
  (_b = (_a = state.edge) == null ? void 0 : _a.ids) == null ? void 0 : _b.sort((a, b) => a.localeCompare(b));
  (_d = (_c = state.node) == null ? void 0 : _c.ids) == null ? void 0 : _d.sort((a, b) => a.localeCompare(b));
};
const updateStateWithFilters = (state, NodeTags) => {
  const search = new URLSearchParams(window.location.search);
  const typeQueryParams = search.get(params.types);
  const tagQueryParams = search.get(params.tags);
  const updatedStateWithTags = getNodeTagsFiltersFromUrl(
    state,
    tagQueryParams,
    NodeTags
  );
  const updatedStateWithTypes = getNodeTypesFromUrl(state, typeQueryParams);
  return { ...state, ...updatedStateWithTags, ...updatedStateWithTypes };
};
const normalizeData = (data, expandAllPipelines) => {
  const state = createInitialPipelineState();
  if (data === "json") {
    state.dataSource = "json";
  } else if (data.source) {
    state.dataSource = data.source;
  }
  if (!validateInput(data)) {
    return state;
  }
  data.nodes.forEach(addNode(state));
  data.edges.forEach(addEdge(state));
  if (data.pipelines) {
    data.pipelines.forEach(addPipeline(state));
    if (state.pipeline.ids.length) {
      state.pipeline.main = data.selected_pipeline || state.pipeline.ids[0];
      state.pipeline.active = state.pipeline.main;
    }
  }
  if (data.modular_pipelines) {
    state.modularPipeline.ids = Object.keys(data.modular_pipelines);
    state.modularPipeline.tree = prettifyModularPipelineNames(
      data.modular_pipelines
    );
    if (expandAllPipelines) {
      state.modularPipeline.expanded = state.modularPipeline.ids;
      const nodeIds = state.node.ids;
      nodeIds.forEach((nodeId) => {
        if (!state.modularPipeline.ids.includes(nodeId)) {
          state.modularPipeline.visible[nodeId] = true;
        }
      });
    } else {
      if (data.modular_pipelines && data.modular_pipelines["__root__"]) {
        for (const child of data.modular_pipelines["__root__"].children || []) {
          state.modularPipeline.visible[child.id] = true;
        }
      }
    }
  }
  if (data.tags) {
    data.tags.forEach(addTag(state));
  }
  if (data.layers) {
    data.layers.forEach(addLayer(state));
  }
  sortNodesEdges(state);
  const updatedState = updateStateWithFilters(state, data.tags);
  return updatedState;
};
const createInitialRunStatusState = () => ({
  nodes: {},
  datasets: {},
  pipeline: {}
});
const validateRunStatusInput = (data) => {
  if (!data) {
    return;
  }
  const isValidNodes = data.nodes && typeof data.nodes === "object" && !Array.isArray(data.nodes);
  const isValidDatasets = data.datasets && typeof data.datasets === "object" && !Array.isArray(data.datasets);
  const isValidPipeline = data.pipeline && typeof data.pipeline === "object" && !Array.isArray(data.pipeline);
  if (!isValidNodes || !isValidDatasets || !isValidPipeline) {
    throw new Error(
      "Invalid Kedro-Viz run data input. Please ensure that your pipeline run data includes nodes, datasets, and pipeline"
    );
  }
  return true;
};
function normalizeTimestamp(timestamp) {
  if (!timestamp) {
    return;
  }
  let timestampStr = timestamp;
  if (typeof timestampStr === "string") {
    timestampStr = timestampStr.replace(
      /T(\d{2})\.(\d{2})\.(\d{2})/,
      "T$1:$2:$3"
    );
    if (!/[zZ]|[+-]\d{2}:?\d{2}$/.test(timestampStr)) {
      timestampStr += "Z";
    }
  }
  return timestampStr;
}
const processRunStatus = (data) => {
  const state = createInitialRunStatusState();
  Object.entries(data.nodes || {}).forEach(([nodeId, nodeInfo]) => {
    state.nodes[nodeId] = {
      status: nodeInfo.status,
      duration: nodeInfo.duration,
      error: nodeInfo.error
    };
  });
  Object.entries(data.datasets || {}).forEach(([datasetId, datasetInfo]) => {
    state.datasets[datasetId] = {
      name: datasetInfo.name,
      size: datasetInfo.size,
      status: datasetInfo.status,
      error: datasetInfo.error
    };
  });
  if (data.pipeline) {
    state.pipeline = {
      runId: data.pipeline.run_id,
      startTime: normalizeTimestamp(data.pipeline.start_time),
      endTime: normalizeTimestamp(data.pipeline.end_time),
      duration: data.pipeline.duration,
      status: data.pipeline.status,
      error: data.pipeline.error
    };
  } else {
    state.pipeline = {
      ...state.pipeline,
      runId: `run-${Date.now()}`
    };
  }
  return state;
};
const normalizeRunStatusData = (data) => {
  const state = createInitialRunStatusState();
  if (!validateRunStatusInput(data)) {
    return state;
  }
  const updatedState = processRunStatus(data);
  return updatedState;
};
const Flags = {
  /**
   * Returns `true` if the flag is defined otherwise `false`
   * @param {String} name The flag name to test
   * @returns {Boolean} The result
   */
  isDefined: (name) => Flags.names().includes(name),
  /**
   * Returns an array of defined flag names
   * @returns {Array} The defined flag names
   */
  names: () => Object.keys(flags),
  /**
   * Returns an object mapping flag names to their default values
   * @returns {Object} The defined flag defaults
   */
  defaults: () => Flags.names().reduce(
    (result, flag) => Object.assign(result, { [flag]: flags[flag].default }),
    {}
  )
};
const getFlagsFromUrl = (url) => {
  const flags2 = {};
  let urlParams;
  try {
    urlParams = new URL(url || document.location.href).searchParams;
  } catch (e) {
    console.warn("Feature flags are not supported in this browser");
    return flags2;
  }
  [...urlParams].forEach(
    ([name, value]) => Flags.isDefined(name) ? flags2[name] = value === "true" || value === "1" || value === "" : null
  );
  return flags2;
};
const getFlagsMessage = (flagsEnabled) => {
  const allNames = Flags.names();
  if (allNames.length > 0) {
    let info = "Experimental features \n";
    allNames.forEach((name) => {
      if (flags[name].private) {
        return;
      }
      const isEnabled = flagsEnabled[name];
      const status = isEnabled ? "Enabled" : "Disabled";
      const statusIcon = isEnabled ? "" : "";
      const icon = flags[name].icon;
      const description = flags[name].description;
      info += `
${statusIcon} ${icon} "${name}"  ${description}  ${status}`;
    });
    info += `

See docs on flags for more info `;
    info += `
https://github.com/kedro-org/kedro-viz#flags`;
    return info;
  }
};
const getFlagsState = () => {
  const allNames = Flags.names();
  return allNames.map((flag) => {
    return {
      name: flags[flag].name,
      value: flag,
      description: flags[flag].description
    };
  });
};
const createInitialState = () => ({
  chartSize: {},
  flags: Flags.defaults(),
  textLabels: true,
  theme: "dark",
  expandAllPipelines: false,
  orientation: "vertical",
  // 'horizontal' or 'vertical'
  view: "flowchart",
  // 'flowchart' (default), or 'workflow'
  isPrettyName: settings.isPrettyName.default,
  showFeatureHints: settings.showFeatureHints.default,
  showDatasetPreviews: settings.showDatasetPreviews.default,
  ignoreLargeWarning: false,
  showBanner: {
    [BANNER_KEYS.LITE]: false
  },
  loading: {
    graph: false,
    pipeline: false,
    node: false
  },
  visible: {
    code: false,
    exportModal: false,
    graph: true,
    metadataModal: false,
    miniMap: true,
    modularPipelineFocusMode: null,
    settingsModal: false,
    shareableUrlModal: false,
    sidebar: window.innerWidth > sidebarWidth.breakpoint,
    slicing: true,
    traceback: false
  },
  display: {
    globalNavigation: true,
    sidebar: true,
    miniMap: true,
    expandPipelinesBtn: true,
    exportBtn: true,
    labelBtn: true,
    layerBtn: true,
    orientationBtn: true,
    zoomToolbar: true,
    metadataPanel: true,
    filterBtn: false
  },
  behaviour: {
    reFocus: true
  },
  zoom: {}
});
const parseUrlParameters = () => {
  const search = new URLSearchParams(window.location.search);
  return {
    pipelineIdFromURL: search.get(params.pipeline),
    nodeIdFromUrl: search.get(params.selected),
    nodeNameFromUrl: search.get(params.selectedName),
    nodeTypeInUrl: search.get(params.types) ? search.get(params.types).split(",") : [],
    nodeTagInUrl: search.get(params.tags) ? search.get(params.tags).split(",") : [],
    expandAllPipelinesInUrl: search.get(params.expandAll)
  };
};
const applyUrlParametersToPipelineState = (state, urlParams) => {
  const {
    pipelineIdFromURL,
    nodeIdFromUrl,
    nodeNameFromUrl,
    nodeTypeInUrl,
    nodeTagInUrl
  } = urlParams;
  let newState = { ...state };
  const nodeTypes = ["parameters", "task", "data"];
  if (pipelineIdFromURL) {
    newState.pipeline.active = newState.pipeline.ids.includes(pipelineIdFromURL) ? pipelineIdFromURL : newState.pipeline.main;
  }
  if (nodeNameFromUrl) {
    newState.nodeType.disabled.data = false;
  }
  if (nodeTypeInUrl.length) {
    Object.keys(newState.nodeType.disabled).forEach((key) => {
      newState.nodeType.disabled[key] = true;
    });
    nodeTypeInUrl.forEach((key) => {
      newState.nodeType.disabled[mapNodeType(key)] = false;
    });
  }
  if (nodeIdFromUrl && nodeTypes.includes(state.node.type[nodeIdFromUrl])) {
    newState.nodeType.disabled[newState.node.type[nodeIdFromUrl]] = false;
  }
  if (nodeTagInUrl.length) {
    Object.keys(newState.tag.enabled).forEach((key) => {
      newState.tag.enabled[key] = false;
    });
    nodeTagInUrl.forEach((tag) => {
      newState.tag.enabled[tag] = true;
    });
  }
  return newState;
};
const applyUrlParametersToNonPipelineState = (state, urlParams) => {
  const { expandAllPipelinesInUrl } = urlParams;
  let newState = { ...state };
  if (expandAllPipelinesInUrl && isValidBoolean(expandAllPipelinesInUrl)) {
    newState.expandAllPipelines = JSON.parse(expandAllPipelinesInUrl);
  }
  return newState;
};
const mergeLocalStorage = (state) => {
  const localStorageState = loadLocalStorage(localStorageName);
  Object.keys(localStorageState).forEach((key) => {
    if (!(key in state)) {
      delete localStorageState[key];
    }
  });
  return deepmerge$2(state, localStorageState);
};
const preparePipelineState = (data, applyFixes, expandAllPipelines, urlParams) => {
  let state = mergeLocalStorage(normalizeData(data, expandAllPipelines));
  if (applyFixes) {
    if (!state.pipeline.ids.includes(state.pipeline.active)) {
      state.pipeline.active = state.pipeline.main;
    }
  }
  if (urlParams) {
    state = applyUrlParametersToPipelineState(state, urlParams);
  }
  if (state.view === VIEW.WORKFLOW) {
    state.pipeline.active = PIPELINE.DEFAULT;
  }
  return state;
};
const prepareRunStatusState = (runData) => {
  let state = normalizeRunStatusData(runData);
  return state;
};
const prepareNonPipelineState = (urlParams) => {
  let state = mergeLocalStorage(createInitialState());
  if (urlParams) {
    state = applyUrlParametersToNonPipelineState(state, urlParams);
  }
  return {
    ...state,
    flags: { ...state.flags, ...getFlagsFromUrl() }
  };
};
const getInitialState = (props = {}) => {
  const urlParams = parseUrlParameters();
  const nonPipelineState = prepareNonPipelineState(urlParams);
  let expandAllPipelines = nonPipelineState.expandAllPipelines;
  if (props.options) {
    expandAllPipelines = props.options.expandAllPipelines || nonPipelineState.expandAllPipelines;
  }
  const pipelineState = preparePipelineState(
    props.data,
    props.data !== "json",
    expandAllPipelines
  );
  const runStatusState = prepareRunStatusState(props.runData);
  const initialState = {
    ...nonPipelineState,
    ...pipelineState,
    runStatus: runStatusState
  };
  return props.options ? deepmerge$2(initialState, props.options) : initialState;
};
const UPDATE_ACTIVE_PIPELINE = "UPDATE_ACTIVE_PIPELINE";
function updateActivePipeline(pipeline) {
  return {
    type: UPDATE_ACTIVE_PIPELINE,
    pipeline
  };
}
const TOGGLE_PIPELINE_LOADING = "TOGGLE_PIPELINE_LOADING";
function toggleLoading(loading) {
  return {
    type: TOGGLE_PIPELINE_LOADING,
    loading
  };
}
const getPipelineUrl = (pipeline) => {
  if (pipeline.active === pipeline.main) {
    return getUrl("main");
  }
  return getUrl("pipeline", pipeline.active);
};
const requiresSecondRequest = (pipeline) => {
  if (!pipeline.ids.length || !pipeline.main) {
    return false;
  }
  if (!pipeline.active) {
    return false;
  }
  return pipeline.active !== pipeline.main;
};
function loadInitialPipelineData() {
  return async function(dispatch2, getState) {
    const state = getState();
    if (state.dataSource !== "json") {
      return;
    }
    dispatch2(toggleLoading(true));
    const url = getUrl("main");
    const expandAllPipelines = state.expandAllPipelines;
    const urlParams = parseUrlParameters();
    let newState = await loadJsonData(url).then(
      (data) => preparePipelineState(data, true, expandAllPipelines, urlParams)
    );
    if (requiresSecondRequest(newState.pipeline)) {
      const url2 = getPipelineUrl(newState.pipeline);
      newState = await loadJsonData(url2).then(
        (data) => preparePipelineState(data, false, expandAllPipelines, urlParams)
      );
    }
    dispatch2(resetData(newState));
    dispatch2(toggleLoading(false));
  };
}
function loadPipelineData(pipelineID) {
  return async function(dispatch2, getState) {
    const { dataSource, pipeline, expandAllPipelines } = getState();
    if (pipelineID && pipelineID === pipeline.active) {
      return;
    }
    if (dataSource === "json") {
      dispatch2(toggleLoading(true));
      const url = getPipelineUrl({
        main: pipeline.main,
        active: pipelineID
      });
      const newState = await loadJsonData(url).then(
        (data) => preparePipelineState(data, false, expandAllPipelines)
      );
      newState.pipeline.active = pipelineID;
      dispatch2(resetData(newState));
      dispatch2(toggleLoading(false));
    } else {
      dispatch2(updateActivePipeline(pipelineID));
    }
  };
}
const TOGGLE_NODE_CLICKED = "TOGGLE_NODE_CLICKED";
function toggleNodeClicked(nodeClicked) {
  return {
    type: TOGGLE_NODE_CLICKED,
    nodeClicked
  };
}
const TOGGLE_NODES_DISABLED = "TOGGLE_NODES_DISABLED";
function toggleNodesDisabled(nodeIDs, isDisabled) {
  return {
    type: TOGGLE_NODES_DISABLED,
    nodeIDs,
    isDisabled
  };
}
const TOGGLE_NODE_HOVERED = "TOGGLE_NODE_HOVERED";
function toggleNodeHovered(nodeHovered) {
  return {
    type: TOGGLE_NODE_HOVERED,
    nodeHovered
  };
}
const TOGGLE_NODE_DATA_LOADING = "TOGGLE_NODE_DATA_LOADING";
function toggleNodeDataLoading(loading) {
  return {
    type: TOGGLE_NODE_DATA_LOADING,
    loading
  };
}
const ADD_NODE_METADATA = "ADD_NODE_METADATA";
function addNodeMetadata(data) {
  return {
    type: ADD_NODE_METADATA,
    data
  };
}
function loadNodeData(nodeID) {
  return async function(dispatch2, getState) {
    const { dataSource, node: node2 } = getState();
    dispatch2(toggleNodeClicked(nodeID));
    if (dataSource === "json" && nodeID && !node2.fetched[nodeID]) {
      dispatch2(toggleNodeDataLoading(true));
      const url = getUrl("nodes", nodeID);
      const nodeData = await loadJsonData(url);
      dispatch2(addNodeMetadata({ id: nodeID, data: nodeData }));
      dispatch2(toggleNodeDataLoading(false));
    }
  };
}
function loadingReducer(loadingState = {}, action) {
  switch (action.type) {
    case TOGGLE_PIPELINE_LOADING: {
      return Object.assign({}, loadingState, {
        pipeline: action.loading
      });
    }
    case TOGGLE_GRAPH_LOADING: {
      return Object.assign({}, loadingState, {
        graph: action.loading
      });
    }
    case TOGGLE_NODE_DATA_LOADING: {
      return Object.assign({}, loadingState, {
        node: action.loading
      });
    }
    default:
      return loadingState;
  }
}
function nodeReducer(nodeState = {}, action) {
  const updateState = (newState) => Object.assign({}, nodeState, newState);
  switch (action.type) {
    case TOGGLE_NODE_CLICKED: {
      return updateState({
        clicked: action.nodeClicked
      });
    }
    case TOGGLE_NODES_DISABLED: {
      return updateState({
        clicked: action.nodeIDs.includes(nodeState.clicked) ? null : nodeState.clicked,
        disabled: action.nodeIDs.reduce(
          (disabled, id2) => Object.assign({}, disabled, {
            [id2]: action.isDisabled
          }),
          nodeState.disabled
        )
      });
    }
    case TOGGLE_NODE_HOVERED: {
      return updateState({
        hovered: action.nodeHovered
      });
    }
    case UPDATE_ACTIVE_PIPELINE: {
      return updateState({
        clicked: null,
        hovered: null
      });
    }
    case ADD_NODE_METADATA: {
      const { id: id2, data } = action.data;
      return updateState({
        fetched: Object.assign({}, nodeState.fetched, {
          [id2]: true
        }),
        code: Object.assign({}, nodeState.code, {
          [id2]: data.code
        }),
        filepath: Object.assign({}, nodeState.filepath, {
          [id2]: data.filepath
        }),
        parameters: Object.assign({}, nodeState.parameters, {
          [id2]: data.parameters
        }),
        inputs: Object.assign({}, nodeState.inputs, {
          [id2]: data.inputs
        }),
        outputs: Object.assign({}, nodeState.outputs, {
          [id2]: data.outputs
        }),
        // the data returned from the API under the field name 'type' for dataset type nodes
        datasetType: Object.assign({}, nodeState.datasetType, {
          [id2]: data.type
        }),
        originalType: Object.assign({}, nodeState.originalType, {
          [id2]: data.original_type
        }),
        transcodedTypes: Object.assign({}, nodeState.transcodedTypes, {
          [id2]: data.transcoded_types
        }),
        runCommand: Object.assign({}, nodeState.runCommand, {
          [id2]: data.run_command
        }),
        preview: Object.assign({}, nodeState.preview, {
          [id2]: data.preview
        }),
        previewType: Object.assign({}, nodeState.previewType, {
          [id2]: data.preview_type
        }),
        stats: Object.assign({}, nodeState.stats, {
          [id2]: data.stats
        })
      });
    }
    default:
      return nodeState;
  }
}
const TOGGLE_TYPE_DISABLED = "TOGGLE_TYPE_DISABLED";
const NODE_TYPE_DISABLED_UNSET = 0;
function toggleTypeDisabled(typeIDs, disabled) {
  return {
    type: TOGGLE_TYPE_DISABLED,
    typeIDs: typeof typeIDs === "string" ? { [typeIDs]: disabled } : typeIDs
  };
}
const allNodeTypesUnset = {
  parameters: NODE_TYPE_DISABLED_UNSET,
  task: NODE_TYPE_DISABLED_UNSET,
  data: NODE_TYPE_DISABLED_UNSET
};
const isNodeTypeUnset = (nodeTypeValue) => nodeTypeValue === NODE_TYPE_DISABLED_UNSET;
const isNodeTypeDisabled = (nodeTypeValue) => nodeTypeValue === true;
function nodeTypeReducer(nodeTypeState = {}, action) {
  switch (action.type) {
    case TOGGLE_TYPE_DISABLED: {
      const nextDisabledState = {
        ...nodeTypeState.disabled,
        ...action.typeIDs
      };
      const nextTypesDisabled = Object.values(nextDisabledState);
      if (nextTypesDisabled.every(isNodeTypeDisabled)) {
        return {
          ...nodeTypeState,
          disabled: { ...allNodeTypesUnset }
        };
      }
      for (const type in nextDisabledState) {
        if (isNodeTypeUnset(nextDisabledState[type])) {
          nextDisabledState[type] = true;
        }
      }
      return {
        ...nodeTypeState,
        disabled: nextDisabledState
      };
    }
    default:
      return nodeTypeState;
  }
}
function pipelineReducer(pipelineState = {}, action) {
  switch (action.type) {
    case UPDATE_ACTIVE_PIPELINE: {
      return Object.assign({}, pipelineState, {
        active: action.pipeline
      });
    }
    default:
      return pipelineState;
  }
}
const TOGGLE_TAG_ACTIVE = "TOGGLE_TAG_ACTIVE";
const TOGGLE_TAG_FILTER = "TOGGLE_TAG_FILTER";
function toggleTagFilter(tagIDs, enabled) {
  return {
    type: TOGGLE_TAG_FILTER,
    tagIDs: Array.isArray(tagIDs) ? tagIDs : [tagIDs],
    enabled
  };
}
function tagReducer(tagState = {}, action) {
  const updateState = (newState) => Object.assign({}, tagState, newState);
  const batchChanges = (key) => action.tagIDs.reduce((result, tagID) => {
    result[tagID] = action[key];
    return result;
  }, {});
  switch (action.type) {
    case TOGGLE_TAG_ACTIVE: {
      return updateState({
        active: Object.assign({}, tagState.active, batchChanges("active"))
      });
    }
    case TOGGLE_TAG_FILTER: {
      return updateState({
        enabled: Object.assign({}, tagState.enabled, batchChanges("enabled"))
      });
    }
    default:
      return tagState;
  }
}
const UPDATE_RUN_STATUS_DATA = "UPDATE_RUN_STATUS_DATA";
function updateRunStatusData(data) {
  return {
    type: UPDATE_RUN_STATUS_DATA,
    data
  };
}
const fetchRunStatus = async () => {
  try {
    const response = await fetch(`/api/run-status`);
    if (!response.ok) {
      throw new Error(`Error fetching run status: ${response.statusText}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error("Failed to load run status:", error);
    return { nodes: {}, datasets: {}, pipeline: {} };
  }
};
function loadInitialRunStatusData() {
  return async function(dispatch2) {
    const runData = await fetchRunStatus();
    const processedData = processRunStatus(runData);
    dispatch2(updateRunStatusData(processedData));
  };
}
function runStatusReducer(state = {
  nodes: {},
  datasets: {},
  pipeline: {}
}, action) {
  switch (action.type) {
    case UPDATE_RUN_STATUS_DATA:
      return {
        ...state,
        ...action.data
      };
    default:
      return state;
  }
}
var _listCacheClear;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear = listCacheClear;
  return _listCacheClear;
}
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq;
  return eq_1;
}
var _assocIndexOf;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var eq = requireEq();
  function assocIndexOf(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf = assocIndexOf;
  return _assocIndexOf;
}
var _listCacheDelete;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf = require_assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete = listCacheDelete;
  return _listCacheDelete;
}
var _listCacheGet;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  _listCacheGet = listCacheGet;
  return _listCacheGet;
}
var _listCacheHas;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  _listCacheHas = listCacheHas;
  return _listCacheHas;
}
var _listCacheSet;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var assocIndexOf = require_assocIndexOf();
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  _listCacheSet = listCacheSet;
  return _listCacheSet;
}
var _ListCache;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var listCacheClear = require_listCacheClear(), listCacheDelete = require_listCacheDelete(), listCacheGet = require_listCacheGet(), listCacheHas = require_listCacheHas(), listCacheSet = require_listCacheSet();
  function ListCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  _ListCache = ListCache;
  return _ListCache;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  _root = root2;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var root2 = require_root();
  var Symbol2 = root2.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var root2 = require_root();
  var coreJsData = root2["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue = getValue2;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue2 = require_getValue();
  function getNative(object2, key) {
    var value = getValue2(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative;
  return _getNative;
}
var _Map;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Map2 = getNative(root2, "Map");
  _Map = Map2;
  return _Map;
}
var _nativeCreate;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var getNative = require_getNative();
  var nativeCreate = getNative(Object, "create");
  _nativeCreate = nativeCreate;
  return _nativeCreate;
}
var _hashClear;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var nativeCreate = require_nativeCreate();
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  _hashClear = hashClear;
  return _hashClear;
}
var _hashDelete;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete = hashDelete;
  return _hashDelete;
}
var _hashGet;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  _hashGet = hashGet;
  return _hashGet;
}
var _hashHas;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var nativeCreate = require_nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  _hashHas = hashHas;
  return _hashHas;
}
var _hashSet;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var nativeCreate = require_nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  _hashSet = hashSet;
  return _hashSet;
}
var _Hash;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var hashClear = require_hashClear(), hashDelete = require_hashDelete(), hashGet = require_hashGet(), hashHas = require_hashHas(), hashSet = require_hashSet();
  function Hash(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  _Hash = Hash;
  return _Hash;
}
var _mapCacheClear;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var Hash = require_Hash(), ListCache = require_ListCache(), Map2 = require_Map();
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  _mapCacheClear = mapCacheClear;
  return _mapCacheClear;
}
var _isKeyable;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable = isKeyable;
  return _isKeyable;
}
var _getMapData;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var isKeyable = require_isKeyable();
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData = getMapData;
  return _getMapData;
}
var _mapCacheDelete;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var getMapData = require_getMapData();
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete = mapCacheDelete;
  return _mapCacheDelete;
}
var _mapCacheGet;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var getMapData = require_getMapData();
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  _mapCacheGet = mapCacheGet;
  return _mapCacheGet;
}
var _mapCacheHas;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var getMapData = require_getMapData();
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  _mapCacheHas = mapCacheHas;
  return _mapCacheHas;
}
var _mapCacheSet;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var getMapData = require_getMapData();
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet = mapCacheSet;
  return _mapCacheSet;
}
var _MapCache;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var mapCacheClear = require_mapCacheClear(), mapCacheDelete = require_mapCacheDelete(), mapCacheGet = require_mapCacheGet(), mapCacheHas = require_mapCacheHas(), mapCacheSet = require_mapCacheSet();
  function MapCache(entries) {
    var index = -1, length2 = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length2) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  _MapCache = MapCache;
  return _MapCache;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache = require_ListCache(), Map2 = require_Map(), MapCache = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var ListCache = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _defineProperty$1;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty$1;
  hasRequired_defineProperty = 1;
  var getNative = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty$1 = defineProperty;
  return _defineProperty$1;
}
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue) return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  function assignMergeValue(object2, key, value) {
    if (value !== void 0 && !eq(object2[key], value) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module, exports) {
    var root2 = require_root();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length2 = buffer.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
      buffer.copy(result);
      return result;
    }
    module.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root2 = require_root();
  var Uint8Array2 = root2.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray) return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array2) {
    var index = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index < length2) {
      array2[index] = source[index];
    }
    return array2;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate) return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject = requireIsObject();
  var objectCreate = Object.create;
  var baseCreate = /* @__PURE__ */ function() {
    function object2() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object2.prototype = proto;
      var result = new object2();
      object2.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject) return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype(), isPrototype = require_isPrototype();
  function initCloneObject(object2) {
    return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject) return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike = requireIsArrayLike(), isObjectLike = requireIsObjectLike();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer) return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module, exports) {
    var root2 = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject) return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject2(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject2;
  return isPlainObject_1;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil) return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module, exports) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet) return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object2, key) {
    if (key === "constructor" && typeof object2[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object2[key];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq = requireEq();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject) return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue(), baseAssignValue = require_baseAssignValue();
  function copyObject(source, props, object2, customizer) {
    var isNew = !object2;
    object2 || (object2 = {});
    var index = -1, length2 = props.length;
    while (++index < length2) {
      var key = props[index];
      var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object2, key, newValue);
      } else {
        assignValue(object2, key, newValue);
      }
    }
    return object2;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
      isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn) return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn) return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeysIn(object2) {
    if (!isObject(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn) return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject) return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep) return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments = requireIsArguments(), isArray = requireIsArray(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer(), isFunction = requireIsFunction(), isObject = requireIsObject(), isPlainObject2 = requireIsPlainObject(), isTypedArray = requireIsTypedArray(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object2, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object2, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge) return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor(), baseMergeDeep = require_baseMergeDeep(), isObject = requireIsObject(), keysIn = requireKeysIn(), safeGet = require_safeGet();
  function baseMerge(object2, source, srcIndex, customizer, stack) {
    if (object2 === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object2, key, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function identity2(value) {
    return value;
  }
  identity_1 = identity2;
  return identity_1;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply) return _apply;
  hasRequired_apply = 1;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest) return _overRest;
  hasRequired_overRest = 1;
  var apply = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index < length2) {
        array2[index] = args[start2 + index];
      }
      index = -1;
      var otherArgs = Array(start2 + 1);
      while (++index < start2) {
        otherArgs[index] = args[index];
      }
      otherArgs[start2] = transform2(array2);
      return apply(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString) return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut) return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString) return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest) return _baseRest;
  hasRequired_baseRest = 1;
  var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall) return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject = requireIsObject();
  function isIterateeCall(value, index, object2) {
    if (!isObject(object2)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
      return eq(object2[index], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner) return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  function createAssigner(assigner) {
    return baseRest(function(object2, sources) {
      var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object2 = Object(object2);
      while (++index < length2) {
        var source = sources[index];
        if (source) {
          assigner(object2, source, index, customizer);
        }
      }
      return object2;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge) return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge2 = createAssigner(function(object2, source, srcIndex) {
    baseMerge(object2, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}
var mergeExports = requireMerge();
const merge$1 = /* @__PURE__ */ getDefaultExportFromCjs(mergeExports);
const TOGGLE_MODULAR_PIPELINE_ACTIVE = "TOGGLE_MODULAR_PIPELINE_ACTIVE";
function toggleModularPipelineActive(modularPipelineIDs, active) {
  return {
    type: TOGGLE_MODULAR_PIPELINE_ACTIVE,
    modularPipelineIDs: Array.isArray(modularPipelineIDs) ? modularPipelineIDs : [modularPipelineIDs],
    active
  };
}
const TOGGLE_MODULAR_PIPELINE_DISABLED = "TOGGLE_MODULAR_PIPELINE_DISABLED";
function toggleModularPipelineDisabled(modularPipelineIDs, disabled) {
  return {
    type: TOGGLE_MODULAR_PIPELINE_DISABLED,
    modularPipelineIDs: Array.isArray(modularPipelineIDs) ? modularPipelineIDs : [modularPipelineIDs],
    disabled
  };
}
const TOGGLE_SINGLE_MODULAR_PIPELINE_EXPANDED = "TOGGLE_SINGLE_MODULAR_PIPELINE_EXPANDED";
function toggleSingleModularPipelineExpanded(modularPipelineID) {
  return {
    type: TOGGLE_SINGLE_MODULAR_PIPELINE_EXPANDED,
    modularPipelineID
  };
}
const TOGGLE_MODULAR_PIPELINES_EXPANDED = "TOGGLE_MODULAR_PIPELINES_EXPANDED";
function toggleModularPipelinesExpanded(expandedIDs) {
  return {
    type: TOGGLE_MODULAR_PIPELINES_EXPANDED,
    expandedIDs
  };
}
const TOGGLE_MODULAR_PIPELINES_VISIBILITY_STATE = "TOGGLE_MODULAR_PIPELINES_VISIBILITY_STATE";
function toggleModularPipelinesVisibilityState(expandAllPipelines) {
  return {
    type: TOGGLE_MODULAR_PIPELINES_VISIBILITY_STATE,
    expandAllPipelines
  };
}
function modularPipelineReducer(modularPipelineState = {}, action) {
  const updateState = (newState) => Object.assign({}, modularPipelineState, newState);
  const batchChanges = (key) => action.modularPipelineIDs.reduce((result, modularPipelineID) => {
    result[modularPipelineID] = action[key];
    return result;
  }, {});
  switch (action.type) {
    case TOGGLE_MODULAR_PIPELINE_ACTIVE: {
      return updateState({
        active: Object.assign(
          {},
          modularPipelineState.active,
          batchChanges("active")
        )
      });
    }
    case TOGGLE_MODULAR_PIPELINE_DISABLED: {
      return updateState({
        disabled: Object.assign(
          {},
          modularPipelineState.disabled,
          batchChanges("disabled")
        )
      });
    }
    case TOGGLE_SINGLE_MODULAR_PIPELINE_EXPANDED: {
      const newVisibleState = { ...modularPipelineState.visible };
      newVisibleState[action.modularPipelineID] = false;
      modularPipelineState.tree[action.modularPipelineID].children.forEach(
        (child) => newVisibleState[child.id] = true
      );
      return updateState({
        expanded: [...modularPipelineState.expanded, action.modularPipelineID],
        visible: newVisibleState
      });
    }
    // The expanded IDs for tree nodes directly emitted from modular pipelines
    // are not directly usable for our purpose. For example, for a tree a -> b -> c,
    // when a is collapsed, [b,c] are passed to the action payload as expanded.
    // What we care about, however, is not what is currently "expanded", but actually
    // what is currently "visible" on the tree.
    // Therefore there are 2 states here: expanded and visible.
    // We use expanded state and the action's payload to work out what's visible:
    // - When a modular pipeline is collapsed, we have to mark all of its children
    // as invisible recursively.
    // - When a modular pipeline is expanded, we have to mark all of its children
    // as visible, but not recursively.
    case TOGGLE_MODULAR_PIPELINES_EXPANDED: {
      const newVisibleState = { ...modularPipelineState.visible };
      const isExpanding = action.expandedIDs.length > modularPipelineState.expanded.length;
      let expandedIDs = action.expandedIDs;
      if (isExpanding && modularPipelineState.ids.length > 0) {
        const expandedModularPipelines = expandedIDs.filter(
          (expandedID) => !modularPipelineState.expanded.includes(expandedID)
        );
        expandedModularPipelines.forEach((expandedModularPipeline) => {
          newVisibleState[expandedModularPipeline] = false;
          modularPipelineState.tree[expandedModularPipeline].children.forEach(
            (child) => newVisibleState[child.id] = true
          );
        });
      } else {
        const collapsedModularPipelines = modularPipelineState.expanded.filter(
          (expandedID) => !expandedIDs.includes(expandedID)
        );
        const setChildrenInvisible = (node2) => {
          modularPipelineState.tree[node2].children.forEach((child) => {
            newVisibleState[child.id] = false;
            if (child.type === "modularPipeline") {
              setChildrenInvisible(child.id);
            }
          });
        };
        collapsedModularPipelines.forEach((collapsedModularPipeline) => {
          newVisibleState[collapsedModularPipeline] = true;
          setChildrenInvisible(collapsedModularPipeline);
          expandedIDs = expandedIDs.filter(
            (id2) => !id2.startsWith(collapsedModularPipeline)
          );
        });
      }
      return updateState({
        expanded: expandedIDs,
        visible: newVisibleState
      });
    }
    case TOGGLE_MODULAR_PIPELINES_VISIBILITY_STATE:
    case RESET_STATE_FOR_WORKFLOW_VIEW: {
      let newVisibleState = {};
      const expandedIDs = action.expandAllPipelines ? modularPipelineState.ids : [];
      if (action.expandAllPipelines) {
        modularPipelineState.ids.forEach((modularPipelineID) => {
          newVisibleState[modularPipelineID] = false;
          modularPipelineState.tree[modularPipelineID].children.forEach(
            (child) => newVisibleState[child.id] = true
          );
        });
      } else {
        if (modularPipelineState.tree["__root__"]) {
          for (const child of modularPipelineState.tree["__root__"].children || []) {
            newVisibleState[child.id] = true;
          }
        }
      }
      return updateState({
        expanded: expandedIDs,
        visible: newVisibleState
      });
    }
    default:
      return modularPipelineState;
  }
}
function visibleReducer(visibleState = {}, action) {
  switch (action.type) {
    case TOGGLE_GRAPH: {
      return Object.assign({}, visibleState, {
        graph: action.visible
      });
    }
    case TOGGLE_METADATA_MODAL: {
      return Object.assign({}, visibleState, {
        metadataModal: action.visible
      });
    }
    case TOGGLE_EXPORT_MODAL: {
      return Object.assign({}, visibleState, {
        exportModal: action.visible
      });
    }
    case TOGGLE_SHAREABLE_URL_MODAL: {
      return Object.assign({}, visibleState, {
        shareableUrlModal: action.visible
      });
    }
    case TOGGLE_SETTINGS_MODAL: {
      return Object.assign({}, visibleState, {
        settingsModal: action.visible
      });
    }
    case TOGGLE_SIDEBAR: {
      return Object.assign({}, visibleState, {
        sidebar: action.visible
      });
    }
    case TOGGLE_MINIMAP: {
      return Object.assign({}, visibleState, {
        miniMap: action.visible
      });
    }
    case TOGGLE_CODE: {
      return Object.assign({}, visibleState, {
        code: action.visible
      });
    }
    case TOGGLE_TRACEBACK: {
      return Object.assign({}, visibleState, {
        traceback: action.visible
      });
    }
    case TOGGLE_MODULAR_PIPELINE_FOCUS_MODE: {
      return Object.assign({}, visibleState, {
        modularPipelineFocusMode: action.modularPipeline
      });
    }
    default:
      return visibleState;
  }
}
const APPLY_SLICE_PIPELINE = "APPLY_SLICE_PIPELINE";
const applySlicePipeline = (apply) => {
  return async function(dispatch2) {
    dispatch2({
      type: APPLY_SLICE_PIPELINE,
      apply
    });
  };
};
const SET_SLICE_PIPELINE = "SET_SLICE_PIPELINE";
const setSlicePipeline = (from2, to) => {
  return async function(dispatch2) {
    dispatch2({
      type: SET_SLICE_PIPELINE,
      slice: { from: from2, to }
    });
  };
};
const RESET_SLICE_PIPELINE = "RESET_SLICE_PIPELINE";
const resetSlicePipeline = () => ({
  type: RESET_SLICE_PIPELINE,
  slice: { from: null, to: null }
});
const slicePipelineReducer = (sliceState = {}, action) => {
  const updateState = (newState) => Object.assign({}, sliceState, newState);
  switch (action.type) {
    case APPLY_SLICE_PIPELINE:
      return updateState({
        apply: action.apply
      });
    case SET_SLICE_PIPELINE:
      return updateState({
        from: action.slice.from,
        to: action.slice.to
      });
    case RESET_SLICE_PIPELINE:
      return {
        from: null,
        to: null,
        apply: false
      };
    default:
      return sliceState;
  }
};
function bannerReducer(bannerState = {}, action) {
  switch (action.type) {
    case SET_BANNER: {
      return Object.assign({}, bannerState, {
        [action.name]: action.value
      });
    }
    default:
      return bannerState;
  }
}
const resetDefaults = {
  shouldExpandAllPipelines: true,
  textLabels: true
};
const createReducer = (initialState, type, key) => (state = initialState, action) => {
  if (typeof key !== "undefined" && action.type === type) {
    return action[key];
  }
  if (action.type === RESET_STATE_FOR_WORKFLOW_VIEW) {
    if (resetDefaults.hasOwnProperty(key)) {
      return resetDefaults[key];
    }
  }
  return state;
};
function resetDataReducer(state = {}, action) {
  if (action.type === RESET_DATA) {
    return Object.assign({}, state, action.data);
  }
  return state;
}
function updateStateFromOptionsReducer(state = {}, action) {
  if (action.type === UPDATE_STATE_FROM_OPTIONS) {
    return merge$1({}, state, action.payload);
  }
  return state;
}
const combinedReducer = combineReducers({
  // These props have their own reducers in other files
  flags: flagsReducer,
  graph: nodeReducer$1,
  layer: layerReducer,
  loading: loadingReducer,
  node: nodeReducer,
  nodeType: nodeTypeReducer,
  pipeline: pipelineReducer,
  slice: slicePipelineReducer,
  tag: tagReducer,
  modularPipeline: modularPipelineReducer,
  visible: visibleReducer,
  runStatus: runStatusReducer,
  showBanner: bannerReducer,
  // These props don't have any actions associated with them
  display: createReducer(null),
  dataSource: createReducer(null),
  behaviour: createReducer({}),
  edge: createReducer({}),
  // These props have very simple non-nested actions
  chartSize: createReducer({}, UPDATE_CHART_SIZE, "chartSize"),
  zoom: createReducer({}, UPDATE_ZOOM, "zoom"),
  textLabels: createReducer(true, TOGGLE_TEXT_LABELS, "textLabels"),
  theme: createReducer("dark", TOGGLE_THEME, "theme"),
  orientation: createReducer("vertical", TOGGLE_ORIENTATION, "orientation"),
  view: createReducer(VIEW.FLOWCHART, SET_VIEW, "view"),
  isPrettyName: createReducer(false, TOGGLE_IS_PRETTY_NAME, "isPrettyName"),
  showFeatureHints: createReducer(
    true,
    TOGGLE_SHOW_FEATURE_HINTS,
    "showFeatureHints"
  ),
  hoveredParameters: createReducer(
    false,
    TOGGLE_PARAMETERS_HOVERED,
    "hoveredParameters"
  ),
  ignoreLargeWarning: createReducer(
    false,
    TOGGLE_IGNORE_LARGE_WARNING,
    "ignoreLargeWarning"
  ),
  hoveredFocusMode: createReducer(
    false,
    TOGGLE_HOVERED_FOCUS_MODE,
    "hoveredFocusMode"
  ),
  expandAllPipelines: createReducer(
    false,
    TOGGLE_EXPAND_ALL_PIPELINES,
    "shouldExpandAllPipelines"
  ),
  showDatasetPreviews: createReducer(
    true,
    TOGGLE_SHOW_DATASET_PREVIEWS,
    "showDatasetPreviews"
  )
});
const rootReducer = (state, action) => {
  let newState = resetDataReducer(state, action);
  newState = updateStateFromOptionsReducer(newState, action);
  return combinedReducer(newState, action);
};
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals) {
  var entry;
  return {
    get: function get2(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  var entries = [];
  function get2(key) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals(key, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get2(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get: get2,
    put,
    getEntries,
    clear
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a, b) {
  return a === b;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev2, next2) {
    if (prev2 === null || next2 === null || prev2.length !== next2.length) {
      return false;
    }
    var length2 = prev2.length;
    for (var i = 0; i < length2; i++) {
      if (!equalityCheck(prev2[i], next2[i])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache.clear();
  };
  return memoized;
}
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize2) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize2.apply(void 0, [function recomputationWrapper() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector2 = memoize2(function dependenciesChecker() {
      var params2 = [];
      var length2 = dependencies.length;
      for (var i = 0; i < length2; i++) {
        params2.push(dependencies[i].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params2);
      return _lastResult;
    });
    Object.assign(selector2, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector2;
  };
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix2 = name += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2) subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array$1(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    var group = select2.apply(this, arguments);
    return group == null ? [] : array$1(group);
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match2) {
  return function() {
    return find.call(this.children, match2);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match2) {
  return this.select(match2 == null ? childFirst : childFind(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
var filter = Array.prototype.filter;
function children() {
  return this.children;
}
function childrenFilter(match2) {
  return function() {
    return filter.call(this.children, match2);
  };
}
function selection_selectChildren(match2) {
  return this.selectAll(match2 == null ? children : childrenFilter(typeof match2 === "function" ? match2 : childMatcher(match2)));
}
function selection_filter(match2) {
  if (typeof match2 !== "function") match2 = matcher(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match2.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next2) {
    return this._parent.insertBefore(child, next2);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update[i] = node2;
      node2.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
      exit[i] = node2;
    }
  }
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant$3(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = array$1(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next2 || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(selection2) {
  if (!(selection2 instanceof Selection$1)) throw new Error("invalid merge");
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next2 = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next2 && node2.compareDocumentPosition(next2) ^ 4) next2.parentNode.insertBefore(node2, next2);
        next2 = node2;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2) return node2;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node2 of this) ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i]) callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  var list = classList(node2), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}
function classedRemove(node2, names) {
  var list = classList(node2), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o];
    else on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent(node2, type, params2) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params2);
  } else {
    event = window2.document.createEvent("Event");
    if (params2) event.initEvent(type, params2.bubbles, params2.cancelable), event.detail = params2.detail;
    else event.initEvent(type, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant(type, params2) {
  return function() {
    return dispatchEvent(this, type, params2);
  };
}
function dispatchFunction(type, params2) {
  return function() {
    return dispatchEvent(this, type, params2.apply(this, arguments));
  };
}
function selection_dispatch(type, params2) {
  return this.each((typeof params2 === "function" ? dispatchFunction : dispatchConstant)(type, params2));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i]) yield node2;
    }
  }
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent) event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  event = sourceEvent(event);
  if (node2 === void 0) node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point2 = svg.createSVGPoint();
      point2.x = event.clientX, point2.y = event.clientY;
      point2 = point2.matrixTransform(node2.getScreenCTM().inverse());
      return [point2.x, point2.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const getNodeIDs$4 = (state) => state.node.ids;
const getNodePipelines = (state) => state.node.pipelines;
const getActivePipeline = (state) => state.pipeline.active;
const getNodeTags$3 = (state) => state.node.tags;
const getNodeModularPipelines$3 = (state) => state.node.modularPipelines;
const getDataSource = (state) => state.dataSource;
const getModularPipelineIDs = (state) => state.modularPipeline.ids;
const getNodeDisabledPipeline = createSelector(
  [getNodeIDs$4, getNodePipelines, getActivePipeline, getDataSource],
  (nodeIDs, nodePipelines, activePipeline, dataSource) => {
    if (dataSource === "json" || !activePipeline) {
      return {};
    }
    return arrayToObject(
      nodeIDs,
      (nodeID) => !nodePipelines[nodeID][activePipeline]
    );
  }
);
const getPipelineNodeIDs = createSelector(
  [getNodeIDs$4, getNodeDisabledPipeline],
  (nodeIDs, nodeDisabledPipeline) => nodeIDs.filter((nodeID) => !nodeDisabledPipeline[nodeID])
);
const getPipelineTagIDs = createSelector(
  [getPipelineNodeIDs, getNodeTags$3],
  (nodeIDs, nodeTags) => {
    const visibleTags = {};
    nodeIDs.forEach((nodeID) => {
      nodeTags[nodeID].forEach((tagID) => {
        if (!visibleTags[tagID]) {
          visibleTags[tagID] = true;
        }
      });
    });
    return Object.keys(visibleTags);
  }
);
createSelector(
  [getPipelineNodeIDs, getNodeModularPipelines$3, getModularPipelineIDs],
  (nodeIDs, nodeModularPipelines, modularPipelineIDs) => {
    const visibleModularPipelines = {};
    if (modularPipelineIDs.length > 0) {
      nodeIDs.forEach((nodeID) => {
        nodeModularPipelines[nodeID].forEach((modularPipelineID) => {
          if (modularPipelineID && !visibleModularPipelines[modularPipelineID]) {
            visibleModularPipelines[modularPipelineID] = true;
          }
        });
      });
    }
    return Object.keys(visibleModularPipelines);
  }
);
const getEdgeIDs$3 = (state) => state.edge.ids;
const getEdgeSources$3 = (state) => state.edge.sources;
const getEdgeTargets$3 = (state) => state.edge.targets;
const getFromNodes = (state) => state.slice.from;
const getToNodes = (state) => state.slice.to;
const getEdges = createSelector(
  [getEdgeIDs$3, getEdgeSources$3, getEdgeTargets$3],
  (edgeIDs, edgeSources, edgeTargets) => edgeIDs.map((id2) => ({
    id: id2,
    source: edgeSources[id2],
    target: edgeTargets[id2]
  }))
);
const getEdgesByNode = createSelector([getEdges], (edges) => {
  const sourceEdges = {};
  const targetEdges = {};
  for (const edge of edges) {
    if (!sourceEdges[edge.target]) {
      sourceEdges[edge.target] = [];
    }
    sourceEdges[edge.target].push(edge.source);
    if (!targetEdges[edge.source]) {
      targetEdges[edge.source] = [];
    }
    targetEdges[edge.source].push(edge.target);
  }
  return { sourceEdges, targetEdges };
});
const findLinkedNodes$1 = (nodeID, edgesByNode, visited) => {
  if (!visited[nodeID]) {
    visited[nodeID] = true;
    if (edgesByNode[nodeID]) {
      edgesByNode[nodeID].forEach(
        (nodeID2) => findLinkedNodes$1(nodeID2, edgesByNode, visited)
      );
    }
  }
  return visited;
};
const findNodesInBetween = (sourceEdges, startID, endID) => {
  if (!startID || !endID) {
    return [startID, endID].filter(Boolean);
  }
  const linkedNodesBeforeEnd = {};
  findLinkedNodes$1(endID, sourceEdges, linkedNodesBeforeEnd);
  const linkedNodeBeforeStart = {};
  findLinkedNodes$1(startID, sourceEdges, linkedNodeBeforeStart);
  let filteredNodeIDs = Object.keys(linkedNodesBeforeEnd);
  if (filteredNodeIDs.includes(startID) && filteredNodeIDs.includes(endID)) {
    return filteredNodeIDs;
  } else {
    filteredNodeIDs = [];
  }
  return filteredNodeIDs;
};
const getSlicedPipeline = createSelector(
  [getEdgesByNode, getFromNodes, getToNodes],
  ({ sourceEdges, targetEdges }, startID, endID) => {
    return findNodesInBetween(sourceEdges, startID, endID);
  }
);
const getValueRegex = (value) => {
  if (!value) {
    return false;
  }
  return new RegExp(`(${escapeRegExp(value)})`, "gi");
};
const getWrappedMatch = (str) => `<b>${str}</b>`;
const getHighlightedText = (text, value) => {
  const valueRegex = getValueRegex(value);
  const matches = text.match(valueRegex);
  return value && matches ? text.replace(valueRegex, getWrappedMatch("$1")) : text;
};
const escapeRegExp = (str) => {
  return str.replace(/[.*+?^${}<>()|[\]\\]/g, "\\$&");
};
const getFocusedModularPipeline = (state) => state.visible.modularPipelineFocusMode;
const getModularPipelinesTree$1 = (state) => state.modularPipeline.tree;
const searchString = (searchValue, target) => {
  if (!searchValue || !target) {
    return false;
  }
  return new RegExp(escapeRegExp(target), "gi").test(searchValue);
};
const isTreeLeaf = (treeNode) => treeNode.type !== "modularPipeline";
const searchTree = (searchValue, tree, currentNodeID = "__root__", result = {}) => {
  var _a;
  const treeNode = tree[currentNodeID];
  if (!treeNode) {
    return false;
  }
  const foundChildren = [];
  for (const childNode of treeNode.children) {
    if (isTreeLeaf(childNode)) {
      const found = searchString(childNode.data.name, searchValue);
      const foundOpposite = searchString(
        childNode.data.oppositeForPrettyName,
        searchValue
      );
      if (found) {
        foundChildren.push({
          ...childNode,
          data: {
            ...childNode.data,
            highlightedLabel: getHighlightedText(
              childNode.data.name,
              searchValue
            )
          }
        });
      } else {
        if (foundOpposite) {
          foundChildren.push({
            ...childNode,
            data: {
              ...childNode.data,
              highlightedLabel: getHighlightedText(
                childNode.data.oppositeForPrettyName,
                searchValue
              )
            }
          });
        }
      }
    } else {
      const found = searchTree(searchValue, tree, childNode.id, result);
      if (found) {
        foundChildren.push({
          ...childNode,
          highlightedLabel: getHighlightedText(
            ((_a = result[childNode.id]) == null ? void 0 : _a.name) || "",
            searchValue
          )
        });
      }
    }
  }
  if (foundChildren.length > 0 || searchString(treeNode.name, searchValue)) {
    result[currentNodeID] = {
      ...treeNode,
      highlightedLabel: getHighlightedText(treeNode.name, searchValue),
      children: foundChildren
    };
    return true;
  }
  return false;
};
const getModularPipelinesSearchResult = (modularPipelinesTree, searchValue) => {
  if (!modularPipelinesTree) {
    return {};
  }
  const searchResult = {};
  searchTree(searchValue, modularPipelinesTree, "__root__", searchResult);
  return searchResult;
};
const getNodeTags$2 = (state) => state.node.tags;
const getTagName = (state) => state.tag.name;
const getTagActive$1 = (state) => state.tag.active;
const getTagEnabled$1 = (state) => state.tag.enabled;
const getTagData = createSelector(
  [getPipelineTagIDs, getTagName, getTagActive$1, getTagEnabled$1],
  (tagIDs, tagName, tagActive, tagEnabled) => tagIDs.sort().map((id2) => ({
    id: id2,
    name: tagName[id2] || prettifyName(id2),
    active: Boolean(tagActive[id2]),
    enabled: Boolean(tagEnabled[id2])
  }))
);
const getTagCount = createSelector(
  [getPipelineTagIDs, getTagEnabled$1],
  (tagIDs, tagEnabled) => ({
    total: tagIDs.length,
    enabled: tagIDs.filter((id2) => tagEnabled[id2]).length
  })
);
const getTagNodeCounts = createSelector([getNodeTags$2], (nodeTags) => {
  const counts = {};
  for (const tagIds of Object.values(nodeTags)) {
    for (const tagId of tagIds) {
      counts[tagId] = counts[tagId] + 1 || 1;
    }
  }
  return counts;
});
const getNodeIDs$3 = (state) => state.node.ids;
const getNodeDisabledNode$1 = (state) => state.node.disabled;
const getDisabledModularPipeline = (state) => state.modularPipeline.disabled;
const getNodeTags$1 = (state) => state.node.tags;
const getNodeType$2 = (state) => state.node.type;
const getTagEnabled = (state) => state.tag.enabled;
const getNodeTypeDisabled$2 = (state) => state.nodeType.disabled;
const getEdgeIDs$2 = (state) => state.edge.ids;
const getEdgeSources$2 = (state) => state.edge.sources;
const getEdgeTargets$2 = (state) => state.edge.targets;
const getLayerIDs = (state) => state.layer.ids;
const getLayersVisible = (state) => state.layer.visible;
const getNodeLayer$2 = (state) => state.node.layer;
const getNodeModularPipelines$2 = (state) => state.node.modularPipelines;
const getVisibleSidebarNodes$1 = (state) => state.modularPipeline.visible;
const getSliceApply = (state) => state.slice.apply;
const getVisibleModularPipelineInputsOutputs = createSelector(
  [getVisibleSidebarNodes$1, getModularPipelinesTree$1],
  (visibleSidebarNodes, modularPipelineData) => {
    const result = /* @__PURE__ */ new Set();
    for (const nodeID in visibleSidebarNodes) {
      if (visibleSidebarNodes[nodeID] && nodeID in modularPipelineData) {
        [
          ...modularPipelineData[nodeID].inputs,
          ...modularPipelineData[nodeID].outputs
        ].forEach((nodeID2) => result.add(nodeID2));
      }
    }
    return result;
  }
);
const getNodeDisabledTag = createSelector(
  [getNodeIDs$3, getTagEnabled, getTagCount, getNodeTags$1],
  (nodeIDs, tagEnabled, tagCount, nodeTags) => arrayToObject(nodeIDs, (nodeID) => {
    if (tagCount.enabled === 0) {
      return false;
    }
    if (nodeTags[nodeID].length) {
      return !nodeTags[nodeID].some((tag) => tagEnabled[tag]);
    }
    return true;
  })
);
const getnodesDisabledViaModularPipeline = createSelector(
  [
    getNodeIDs$3,
    getNodeType$2,
    getNodeModularPipelines$2,
    getModularPipelinesTree$1,
    getFocusedModularPipeline,
    getDisabledModularPipeline
  ],
  (nodeIDs, nodeType, nodeModularPipelines, modularPipelinesTree, focusedModularPipeline, disabledModularPipeline) => arrayToObject(nodeIDs, (id2) => {
    var _a;
    let isDisabledViaModularPipeline = disabledModularPipeline[nodeModularPipelines[id2]];
    let isDisabledViaFocusedModularPipeline = false;
    if (focusedModularPipeline) {
      const inputOutputNodeIDs = [
        ...modularPipelinesTree[focusedModularPipeline.id].inputs,
        ...modularPipelinesTree[focusedModularPipeline.id].outputs
      ];
      const isChildModularPipeline = (modularPipelineId, focusedPipelineId) => modularPipelineId.startsWith(`${focusedPipelineId}.`);
      const isParentModularPipeline = (modularPipelineId, focusedPipelineId) => focusedPipelineId.startsWith(`${modularPipelineId}.`);
      const isChildNode = (nodeId) => {
        var _a2;
        return (_a2 = nodeModularPipelines[nodeId]) == null ? void 0 : _a2.includes(focusedModularPipeline.id);
      };
      if (nodeType[id2] === "modularPipeline") {
        return id2 !== focusedModularPipeline.id && !isChildModularPipeline(id2, focusedModularPipeline.id) && !isParentModularPipeline(id2, focusedModularPipeline.id);
      }
      isDisabledViaFocusedModularPipeline = !isChildNode(id2) && !((_a = nodeModularPipelines[id2]) == null ? void 0 : _a.some(
        (pipelineId) => isChildModularPipeline(pipelineId, focusedModularPipeline.id)
      )) && !isParentModularPipeline(
        nodeModularPipelines[id2],
        focusedModularPipeline.id
      ) && !inputOutputNodeIDs.includes(id2);
    }
    return [
      isDisabledViaFocusedModularPipeline,
      isDisabledViaModularPipeline
    ].some(Boolean);
  })
);
const getNodeDisabled = createSelector(
  [
    getNodeIDs$3,
    getNodeDisabledNode$1,
    getNodeDisabledTag,
    getNodeDisabledPipeline,
    getnodesDisabledViaModularPipeline,
    getNodeType$2,
    getNodeTypeDisabled$2,
    getVisibleSidebarNodes$1,
    getVisibleModularPipelineInputsOutputs,
    getDisabledModularPipeline,
    getSlicedPipeline,
    getSliceApply
  ],
  (nodeIDs, nodeDisabledNode, nodeDisabledTag, nodeDisabledPipeline, nodesDisabledViaModularPipeline, nodeType, typeDisabled, visibleSidebarNodes, visibleModularPipelineInputsOutputs, disabledModularPipeline, slicedPipeline, isSliceApplied) => arrayToObject(nodeIDs, (id2) => {
    let isDisabledViaSlicedPipeline = false;
    if (isSliceApplied && slicedPipeline.length > 0) {
      isDisabledViaSlicedPipeline = !slicedPipeline.includes(id2);
    }
    const isDisabledViaSidebar = !visibleSidebarNodes[id2] && !visibleModularPipelineInputsOutputs.has(id2);
    const isDisabledViaModularPipeline = nodesDisabledViaModularPipeline[id2];
    return [
      nodeDisabledNode[id2],
      nodeDisabledTag[id2],
      nodeDisabledPipeline[id2],
      disabledModularPipeline[id2],
      typeDisabled[nodeType[id2]],
      isDisabledViaSidebar,
      isDisabledViaModularPipeline,
      isDisabledViaSlicedPipeline
    ].some(Boolean);
  })
);
const getVisibleNodeIDs = createSelector(
  [getPipelineNodeIDs, getNodeDisabled],
  (nodeIDs, nodeDisabled) => {
    return nodeIDs.filter((id2) => !nodeDisabled[id2]);
  }
);
const getVisibleLayerIDs = createSelector(
  [getVisibleNodeIDs, getNodeLayer$2, getLayerIDs, getLayersVisible],
  (nodeIDs, nodeLayer, layerIDs, layersVisible) => {
    if (!layersVisible) {
      return [];
    }
    const visibleLayerIDs = {};
    for (const nodeID of nodeIDs) {
      visibleLayerIDs[nodeLayer[nodeID]] = true;
    }
    return layerIDs.filter((layerID) => visibleLayerIDs[layerID]);
  }
);
const getEdgeDisabled = createSelector(
  [getEdgeIDs$2, getNodeDisabled, getEdgeSources$2, getEdgeTargets$2],
  (edgeIDs, nodeDisabled, edgeSources, edgeTargets) => arrayToObject(edgeIDs, (edgeID) => {
    const source = edgeSources[edgeID];
    const target = edgeTargets[edgeID];
    return Boolean(nodeDisabled[source] || nodeDisabled[target]);
  })
);
const getShortType = (longTypeName, fallback) => shortTypeMapping[longTypeName] || fallback;
var utils$1;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  const countInDegrees = (dag) => {
    const counts = {};
    Object.entries(dag).forEach(([vx, dependents]) => {
      counts[vx] = counts[vx] || 0;
      dependents.forEach((dependent) => {
        counts[dependent] = counts[dependent] || 0;
        counts[dependent]++;
      });
    });
    return counts;
  };
  const filterByDegree = (predicate) => (counts) => Object.entries(counts).filter(([_, deg]) => predicate(deg)).map(([id2, _]) => id2);
  const getRoots = filterByDegree((deg) => deg === 0);
  const getNonRoots = filterByDegree((deg) => deg !== 0);
  utils$1 = {
    countInDegrees,
    getRoots,
    getNonRoots
  };
  return utils$1;
}
var dist;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  const { countInDegrees, getRoots, getNonRoots } = requireUtils();
  const batchingToposort2 = (dag) => {
    const indegrees = countInDegrees(dag);
    const sorted = [];
    let roots = getRoots(indegrees);
    while (roots.length) {
      sorted.push(roots);
      const newRoots = [];
      roots.forEach((root2) => {
        dag[root2].forEach((dependent) => {
          indegrees[dependent]--;
          if (indegrees[dependent] === 0) {
            newRoots.push(dependent);
          }
        });
      });
      roots = newRoots;
    }
    if (getNonRoots(indegrees).length) {
      throw Error("Cycle(s) detected; toposort only works on acyclic graphs");
    }
    return sorted;
  };
  dist = batchingToposort2;
  return dist;
}
var distExports = requireDist();
const batchingToposort = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const getNodeIDs$2 = (state) => state.node.ids;
const getEdgeIDs$1 = (state) => state.edge.ids;
const getEdgeSources$1 = (state) => state.edge.sources;
const getEdgeTargets$1 = (state) => state.edge.targets;
const getNodeModularPipelines$1 = (state) => state.node.modularPipelines;
const getVisibleSidebarNodes = (state) => state.modularPipeline.visible;
const addNewEdge = (source, target, { edgeIDs, sources, targets }) => {
  const id2 = [source, target].join("|");
  if (!edgeIDs.includes(id2)) {
    edgeIDs.push(id2);
    sources[id2] = source;
    targets[id2] = target;
  }
};
const getTransitiveEdges = createSelector(
  [
    getNodeIDs$2,
    getEdgeIDs$1,
    getNodeDisabled,
    getEdgeSources$1,
    getEdgeTargets$1,
    getFocusedModularPipeline,
    getNodeModularPipelines$1,
    getVisibleSidebarNodes
  ],
  (nodeIDs, edgeIDs, nodeDisabled, edgeSources, edgeTargets, focusedModularPipeline, nodeModularPipelines, visibleModularPipelines) => {
    const transitiveEdges = {
      edgeIDs: [],
      sources: {},
      targets: {}
    };
    const walkGraphEdges = (path2) => {
      edgeIDs.forEach((edgeID) => {
        const source = path2[path2.length - 1];
        if (edgeSources[edgeID] !== source) {
          return;
        }
        const target = edgeTargets[edgeID];
        if (!visibleModularPipelines[target]) {
          return;
        }
        const isNotInputEdge = focusedModularPipeline !== null && !nodeModularPipelines[source].includes(focusedModularPipeline.id) && !nodeModularPipelines[target].includes(focusedModularPipeline.id);
        if (nodeDisabled[target]) {
          walkGraphEdges(path2.concat(target));
        } else if (path2.length > 1 && !isNotInputEdge) {
          addNewEdge(path2[0], target, transitiveEdges);
        }
      });
    };
    if (nodeIDs.some((nodeID) => nodeDisabled[nodeID])) {
      nodeIDs.forEach((nodeID) => {
        if (!nodeDisabled[nodeID]) {
          walkGraphEdges([nodeID]);
        }
      });
    }
    return transitiveEdges;
  }
);
const getVisibleEdges = createSelector(
  [
    getEdgeIDs$1,
    getEdgeDisabled,
    getEdgeSources$1,
    getEdgeTargets$1,
    getTransitiveEdges
  ],
  (edgeIDs, edgeDisabled, edgeSources, edgeTargets, transitiveEdges) => edgeIDs.filter((id2) => !edgeDisabled[id2]).concat(transitiveEdges.edgeIDs).map((id2) => ({
    id: id2,
    source: edgeSources[id2] || transitiveEdges.sources[id2],
    target: edgeTargets[id2] || transitiveEdges.targets[id2]
  }))
);
const getInputOutputDataEdges = createSelector(
  [getVisibleEdges, getNodeModularPipelines$1, getFocusedModularPipeline],
  (visibleEdges, nodeModularPipelines, focusedModularPipeline) => {
    const edgesList = {};
    if (focusedModularPipeline !== null) {
      visibleEdges.forEach((edge) => {
        var _a, _b;
        if (!((_a = nodeModularPipelines[edge.source]) == null ? void 0 : _a.includes(
          focusedModularPipeline.id
        )) || !((_b = nodeModularPipelines[edge.target]) == null ? void 0 : _b.includes(
          focusedModularPipeline.id
        ))) {
          edgesList[edge.id] = edge;
        }
      });
    }
    return edgesList;
  }
);
const getNodeLayer$1 = (state) => state.node.layer;
const getLayerNodes = createSelector(
  [getVisibleNodeIDs, getVisibleLayerIDs, getNodeLayer$1],
  (nodeIDs, layerIDs, nodeLayer) => {
    if (!layerIDs.length) {
      return [];
    }
    const layerNodes = {};
    for (const nodeID of nodeIDs) {
      const layer = nodeLayer[nodeID];
      if (!layerNodes[layer]) {
        layerNodes[layer] = [];
      }
      layerNodes[layer].push(nodeID);
    }
    return layerIDs.map((layerID) => layerNodes[layerID]);
  }
);
const getNodeRank = createSelector(
  [getVisibleNodeIDs, getVisibleEdges, getLayerNodes, getVisibleLayerIDs],
  (nodeIDs, edges, layerNodes, layerIDs) => {
    if (!layerIDs.length) {
      return {};
    }
    const nodeDeps = {};
    for (const nodeID of nodeIDs) {
      nodeDeps[nodeID] = [];
    }
    for (const edge of edges) {
      nodeDeps[edge.source].push(edge.target);
    }
    for (let i = 1; i < layerNodes.length; i++) {
      for (const sourceID of layerNodes[i - 1]) {
        for (const targetID of layerNodes[i]) {
          nodeDeps[sourceID].push(targetID);
        }
      }
    }
    const toposortedNodes = batchingToposort(nodeDeps);
    const nodeRanks = {};
    for (let rank = 0; rank < toposortedNodes.length; rank++) {
      for (const nodeID of toposortedNodes[rank]) {
        nodeRanks[nodeID] = rank;
      }
    }
    return nodeRanks;
  }
);
const getNodeName = (state) => state.node.name;
const getNodeFullName = (state) => state.node.fullName;
const getNodeDisabledNode = (state) => state.node.disabled;
const getModularPipelineDisabled = (state) => state.modularPipeline.disabled;
const getNodeTags = (state) => state.node.tags;
const getNodeModularPipelines = (state) => state.node.modularPipelines;
const getNodeType$1 = (state) => state.node.type;
const getNodeDatasetType = (state) => state.node.datasetType;
const getNodeLayer = (state) => state.node.layer;
const getHoveredNode = (state) => state.node.hovered;
const getIsPrettyName = (state) => state.isPrettyName;
const getTagActive = (state) => state.tag.active;
const getModularPipelineActive = (state) => state.modularPipeline.active;
const getTextLabels = (state) => state.textLabels;
const getNodeTypeDisabled$1 = (state) => state.nodeType.disabled;
const getClickedNode$2 = (state) => state.node.clicked;
const getEdgeIDs = (state) => state.edge.ids;
const getEdgeSources = (state) => state.edge.sources;
const getEdgeTargets = (state) => state.edge.targets;
const getNodeExtras = (state) => state.node.extras;
const getGraphNodes = createSelector(
  [(state) => state.graph.nodes],
  (nodes = []) => nodes.reduce((result, node2) => {
    result[node2.id] = node2;
    return result;
  }, {})
);
const filterNodesFromSlicingPipeline = (nodes, slicedPipeline) => Object.fromEntries(
  Object.entries(nodes).filter(([nodeId]) => slicedPipeline.includes(nodeId))
);
const getTagsForNodesAndModularPipelines = createSelector(
  [getNodeTags, getNodeModularPipelines],
  (nodeTags, nodeModularPipelines) => {
    const updatedNodeTags = { ...nodeTags };
    Object.entries(nodeTags).filter(([, tags2]) => tags2.length > 0).forEach(([nodeID, tags2]) => {
      const modularPipelineIDs = nodeModularPipelines[nodeID] || [];
      modularPipelineIDs.forEach((modularPipelineID) => {
        if (!updatedNodeTags[modularPipelineID]) {
          updatedNodeTags[modularPipelineID] = [];
        }
        tags2.forEach((tag) => {
          if (!updatedNodeTags[modularPipelineID].includes(tag)) {
            updatedNodeTags[modularPipelineID].push(tag);
          }
        });
      });
    });
    return updatedNodeTags;
  }
);
const getNodeActive = createSelector(
  [
    getPipelineNodeIDs,
    getHoveredNode,
    getTagsForNodesAndModularPipelines,
    getTagActive,
    getNodeModularPipelines,
    getModularPipelineActive,
    getModularPipelineDisabled,
    (state) => state.modularPipeline.tree
  ],
  (nodeIDs, hoveredNode, nodeTags, tagActive, nodeModularPipelines, modularPipelineActive, modularPipelineDisabled, modularPipelinesTree) => {
    const activeModularPipelines = Object.keys(modularPipelineActive).filter(
      (modularPipelineID) => modularPipelineActive[modularPipelineID]
    );
    const disabledModularPipelines = Object.entries(modularPipelineDisabled).filter(([key, value]) => value === true).map(([key]) => key);
    let activeViaModularPipeline = false;
    return arrayToObject(nodeIDs, (nodeID) => {
      if (nodeID === hoveredNode) {
        return true;
      }
      const activeViaTag = nodeTags[nodeID].some((tag) => tagActive[tag]);
      const activeModularPipeline = activeModularPipelines.includes(nodeID);
      if (!disabledModularPipelines.includes(activeModularPipelines[0])) {
        const nodesActiveViaModularPipeline = activeModularPipelines.flatMap(
          (id2) => modularPipelinesTree[id2].children.map((child) => child.id)
        );
        activeViaModularPipeline = nodesActiveViaModularPipeline.includes(nodeID) || nodeModularPipelines[nodeID] && nodeModularPipelines[nodeID].some(
          (modularPipeline) => modularPipelineActive[modularPipeline]
        );
      }
      return Boolean(activeViaTag) || Boolean(activeViaModularPipeline) || Boolean(activeModularPipeline);
    });
  }
);
const getNodeSelected = createSelector(
  [getPipelineNodeIDs, getClickedNode$2, getNodeDisabled],
  (nodeIDs, clickedNode, nodeDisabled) => arrayToObject(
    nodeIDs,
    (nodeID) => nodeID === clickedNode && !nodeDisabled[nodeID]
  )
);
const getNodeLabel = createSelector(
  [getIsPrettyName, getNodeName, getNodeFullName],
  (isPrettyName, nodeName, nodeFullName) => isPrettyName ? nodeName : nodeFullName
);
const getOppositeForPrettyName = createSelector(
  [getIsPrettyName, getNodeName, getNodeFullName],
  (isPrettyName, nodeName, nodeFullName) => isPrettyName ? nodeFullName : nodeName
);
const getNodeData = createSelector(
  [
    getPipelineNodeIDs,
    getNodeLabel,
    getNodeType$1,
    getNodeDatasetType,
    getNodeDisabled,
    getModularPipelineDisabled,
    getNodeDisabledNode,
    getNodeDisabledTag,
    getNodeTypeDisabled$1,
    getNodeModularPipelines,
    getNodeExtras
  ],
  (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeDisabled, modularPipelineDisabled, nodeDisabledNode, nodeDisabledTag, typeDisabled, nodeModularPipelines, nodeExtras) => nodeIDs.sort((a, b) => {
    if (nodeLabel[a] < nodeLabel[b]) {
      return -1;
    }
    if (nodeLabel[a] > nodeLabel[b]) {
      return 1;
    }
    return 0;
  }).map((id2) => ({
    id: id2,
    name: nodeLabel[id2],
    type: nodeType[id2],
    icon: getShortType(nodeDatasetType[id2], nodeType[id2]),
    modularPipelines: nodeModularPipelines[id2],
    disabled: nodeDisabled[id2],
    disabledModularPipeline: Boolean(modularPipelineDisabled[id2]),
    disabledNode: Boolean(nodeDisabledNode[id2]),
    disabledTag: nodeDisabledTag[id2],
    disabledType: Boolean(typeDisabled[nodeType[id2]]),
    extras: nodeExtras[id2]
  }))
);
const getNodeDataObject = createSelector(
  [
    getPipelineNodeIDs,
    getNodeLabel,
    getNodeType$1,
    getNodeDatasetType,
    getNodeDisabled,
    getModularPipelineDisabled,
    getNodeDisabledNode,
    getNodeDisabledTag,
    getNodeTypeDisabled$1,
    getNodeModularPipelines,
    getOppositeForPrettyName,
    getNodeExtras
  ],
  (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeDisabled, modularPipelineDisabled, nodeDisabledNode, nodeDisabledTag, typeDisabled, nodeModularPipelines, oppositeForPrettyName, nodeExtras) => nodeIDs.reduce((obj, id2) => {
    obj[id2] = {
      id: id2,
      name: nodeLabel[id2],
      oppositeForPrettyName: oppositeForPrettyName[id2],
      type: nodeType[id2],
      icon: getShortType(nodeDatasetType[id2], nodeType[id2]),
      modularPipelines: nodeModularPipelines[id2],
      disabled: nodeDisabled[id2],
      disabledModularPipeline: Boolean(modularPipelineDisabled[id2]),
      disabledNode: Boolean(nodeDisabledNode[id2]),
      disabledTag: Boolean(nodeDisabledTag[id2]),
      disabledType: Boolean(typeDisabled[nodeType[id2]]),
      extras: nodeExtras[id2]
    };
    return obj;
  }, {})
);
const getModularPipelinesTree = createSelector(
  [
    (state) => state.modularPipeline.tree,
    (state) => state.slice.apply,
    getNodeDataObject,
    getSlicedPipeline
  ],
  (modularPipelinesTree, isSlicingPipelineApplied, nodes, slicedPipeline) => {
    if (!modularPipelinesTree) {
      return {};
    }
    const relevantNodes = isSlicingPipelineApplied ? filterNodesFromSlicingPipeline(nodes, slicedPipeline) : nodes;
    for (const modularPipelineID in modularPipelinesTree) {
      modularPipelinesTree[modularPipelineID].data = {
        ...nodes[modularPipelineID]
      };
      for (const child of modularPipelinesTree[modularPipelineID].children) {
        child.data = { ...relevantNodes[child.id] };
      }
    }
    return modularPipelinesTree;
  }
);
const getGroupedNodes = createSelector(
  [getNodeData],
  (nodes) => nodes.reduce(function(obj, item) {
    const key = item.type;
    if (!obj.hasOwnProperty(key)) {
      obj[key] = [];
    }
    obj[key].push(item);
    return obj;
  }, {})
);
const getNodeTextWidth = createSelector(
  [getPipelineNodeIDs, getNodeLabel],
  (nodeIDs, nodeLabel) => {
    const nodeTextWidth = {};
    const svg = select(document.body).append("svg").attr("class", "kedro pipeline-node");
    svg.selectAll("text").data(nodeIDs).enter().append("text").text((nodeID) => nodeLabel[nodeID]).each(function(nodeID) {
      const width2 = this.getBBox ? this.getBBox().width : 0;
      nodeTextWidth[nodeID] = width2;
    });
    svg.remove();
    return nodeTextWidth;
  }
);
const getPadding = (showLabels, nodeType) => {
  if (showLabels) {
    switch (nodeType) {
      case "modularPipeline":
        return { x: 30, y: 22 };
      case "task":
        return { x: 16, y: 10 };
      default:
        return { x: 20, y: 10 };
    }
  }
  switch (nodeType) {
    case "modularPipeline":
      return { x: 25, y: 25 };
    case "task":
      return { x: 14, y: 14 };
    default:
      return { x: 16, y: 16 };
  }
};
const getNodeSize = createSelector(
  [getPipelineNodeIDs, getNodeTextWidth, getTextLabels, getNodeType$1],
  (nodeIDs, nodeTextWidth, textLabels, nodeType) => {
    return arrayToObject(nodeIDs, (nodeID) => {
      const iconSize = textLabels ? 24 : 28;
      const padding2 = getPadding(textLabels, nodeType[nodeID]);
      const textWidth = textLabels ? nodeTextWidth[nodeID] : 0;
      const textGap = textLabels ? 6 : 0;
      const innerWidth = iconSize + textWidth + textGap;
      return {
        showText: textLabels,
        width: innerWidth + padding2.x * 2,
        height: iconSize + padding2.y * 2,
        textOffset: (innerWidth - textWidth) / 2 - 1,
        iconOffset: -innerWidth / 2,
        iconSize
      };
    });
  }
);
const getVisibleNodes = createSelector(
  [
    getVisibleNodeIDs,
    getNodeLabel,
    getNodeType$1,
    getNodeDatasetType,
    getNodeFullName,
    getNodeSize,
    getNodeLayer,
    getNodeRank,
    getNodeExtras
  ],
  (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeFullName, nodeSize, nodeLayer, nodeRank, nodeExtras) => nodeIDs.map((id2) => ({
    id: id2,
    name: nodeLabel[id2],
    fullName: nodeFullName[id2],
    icon: getShortType(nodeDatasetType[id2], nodeType[id2]),
    type: nodeType[id2],
    layer: nodeLayer[id2],
    rank: nodeRank[id2],
    extras: nodeExtras[id2],
    ...nodeSize[id2]
  }))
);
const getNodesWithInputParams = createSelector(
  [
    getGraphNodes,
    getNodeName,
    getEdgeIDs,
    getNodeType$1,
    getEdgeSources,
    getEdgeTargets
  ],
  (nodes, nodeName, edgeIDs, nodeType, edgeSources, edgeTargets) => {
    const nodesList = {};
    for (const edgeID of edgeIDs) {
      const source = edgeSources[edgeID];
      const target = edgeTargets[edgeID];
      if (nodeType[source] === "parameters" && nodeType[target] === "task") {
        if (!nodesList[target]) {
          nodesList[target] = [];
        }
        nodesList[target].push(nodeName[source]);
      }
    }
    return nodesList;
  }
);
const getInputOutputNodesForFocusedModularPipeline = createSelector(
  [
    (state) => {
      var _a;
      return (_a = state.visible.modularPipelineFocusMode) == null ? void 0 : _a.id;
    },
    getGraphNodes,
    getModularPipelinesTree
  ],
  (focusedModularPipelineID, graphNodes, modularPipelinesTree) => {
    const focusedModularPipeline = focusedModularPipelineID ? modularPipelinesTree[focusedModularPipelineID] : null;
    const nodeIDs = focusedModularPipeline ? [...focusedModularPipeline.inputs, ...focusedModularPipeline.outputs] : [];
    const result = nodeIDs.reduce((result2, nodeID) => {
      result2[nodeID] = graphNodes[nodeID];
      return result2;
    }, {});
    return result;
  }
);
const getClickedNode$1 = (state) => state.node.clicked;
const getDisplayMetadataPanel = (state) => state.display.metadataPanel;
const sortAlpha = (a, b) => (a.name || a).localeCompare(b.name || b);
const getVisibleMetaSidebar = createSelector(
  [getClickedNode$1, getDisplayMetadataPanel],
  (nodeClicked, metadataPanel) => metadataPanel ? Boolean(nodeClicked) : false
);
const getClickedNodeMetaData = createSelector(
  [
    getClickedNode$1,
    getNodeLabel,
    getNodeFullName,
    getNodeName,
    (state) => state.node.type,
    (state) => state.node.tags,
    (state) => state.tag.name,
    (state) => state.pipeline,
    (state) => state.node.filepath,
    (state) => state.node.inputs,
    (state) => state.node.outputs,
    (state) => state.node.code,
    (state) => state.node.parameters,
    (state) => state.node.datasetType,
    (state) => state.node.originalType,
    (state) => state.node.transcodedTypes,
    (state) => state.node.runCommand,
    (state) => state.node.preview,
    (state) => state.node.previewType,
    (state) => state.node.stats,
    (state) => state.isPrettyName
  ],
  (nodeId, nodeLabel, nodeFullName, nodePrettyName, nodeType, nodeTags, tagNames, pipeline, nodeFilepaths, nodeInputs, nodeOutputs, nodeCodes, nodeParameters, nodeDatasetTypes, nodeOriginalTypes, nodeTranscodedTypes, nodeRunCommand, preview, previewType, stats, isPrettyName) => {
    if (!nodeId || Object.keys(nodeType).length === 0) {
      return null;
    }
    const metadata = {
      id: nodeId,
      name: nodeLabel[nodeId],
      fullName: nodeFullName[nodeId],
      prettyName: nodePrettyName[nodeId],
      type: nodeType[nodeId],
      tags: [...nodeTags[nodeId]].map((tagId) => tagNames[tagId]).sort(sortAlpha),
      pipeline: pipeline.name[pipeline.active],
      parameters: nodeParameters[nodeId],
      runCommand: nodeRunCommand[nodeId],
      code: nodeCodes[nodeId],
      filepath: nodeFilepaths[nodeId],
      datasetType: nodeDatasetTypes[nodeId],
      originalType: nodeOriginalTypes[nodeId],
      transcodedTypes: nodeTranscodedTypes[nodeId],
      inputs: isPrettyName ? nodeInputs[nodeId] && nodeInputs[nodeId].map(
        (nodeInput) => prettifyName(stripNamespace(nodeInput))
      ) : nodeInputs[nodeId] && nodeInputs[nodeId].map((nodeInput) => stripNamespace(nodeInput)),
      outputs: isPrettyName ? nodeOutputs[nodeId] && nodeOutputs[nodeId].map(
        (nodeOutput) => prettifyName(stripNamespace(nodeOutput))
      ) : nodeOutputs[nodeId] && nodeOutputs[nodeId].map((nodeOutput) => stripNamespace(nodeOutput)),
      preview: preview && preview[nodeId],
      previewType: previewType && previewType[nodeId],
      stats: stats && stats[nodeId]
    };
    return metadata;
  }
);
const getSizeWarningFlag = (state) => state.flags.sizewarning;
const getVisibleSidebar = (state) => state.visible.sidebar;
const getDisplayGlobalNavigation = (state) => state.display.globalNavigation;
const getDisplaySidebar = (state) => state.display.sidebar;
const getVisibleCode = (state) => state.visible.code;
const getIgnoreLargeWarning = (state) => state.ignoreLargeWarning;
const getGraphHasNodes = (state) => {
  var _a, _b;
  return Boolean((_b = (_a = state.graph) == null ? void 0 : _a.nodes) == null ? void 0 : _b.length);
};
const getChartSizeState = (state) => state.chartSize;
const getFlowChartOrientation$1 = (state) => state.orientation;
const getView = (state) => state.view;
const getTriggerLargeGraphWarning = createSelector(
  [
    getVisibleNodes,
    getVisibleEdges,
    getIgnoreLargeWarning,
    getGraphHasNodes,
    getSizeWarningFlag
  ],
  (nodes, edges, ignoreLargeWarning, graphHasNodes, sizeWarningFlag) => nodes.length + 1.5 * edges.length > largeGraphThreshold && !ignoreLargeWarning && !graphHasNodes && sizeWarningFlag
);
const getGraphInput = createSelector(
  [
    getVisibleNodes,
    getVisibleEdges,
    getVisibleLayerIDs,
    getFlowChartOrientation$1,
    getView,
    getTriggerLargeGraphWarning
  ],
  (nodes, edges, layers, orientation, view, triggerLargeGraphWarning) => {
    if (triggerLargeGraphWarning) {
      return null;
    }
    return { nodes, edges, layers, orientation, view };
  }
);
const getSidebarWidth = (visible, { open, closed }) => visible ? open : closed;
const getChartSize = createSelector(
  [
    getVisibleSidebar,
    getVisibleMetaSidebar,
    getVisibleCode,
    getChartSizeState,
    getDisplaySidebar,
    getDisplayGlobalNavigation
  ],
  (visibleSidebar, visibleMetaSidebar, visibleCodeSidebar, chartSize, displaySidebar, displayGlobalNavigation) => {
    const { left, top, width: width2, height: height2 } = chartSize;
    if (!width2 || !height2) {
      return {};
    }
    const isSidebarVisible = displaySidebar && visibleSidebar;
    const sidebarWidthActual = displaySidebar || displayGlobalNavigation ? getSidebarWidth(isSidebarVisible, sidebarWidth) : 0;
    const metaSidebarWidthActual = getSidebarWidth(
      visibleMetaSidebar,
      metaSidebarWidth
    );
    const codeSidebarWidthActual = getSidebarWidth(
      visibleCodeSidebar,
      codeSidebarWidth
    );
    let chartWidth = width2 - sidebarWidthActual - metaSidebarWidthActual - codeSidebarWidthActual;
    return {
      left,
      top,
      outerWidth: width2,
      outerHeight: height2,
      height: height2,
      width: chartWidth,
      minWidthScale: chartMinWidthScale,
      sidebarWidth: sidebarWidthActual,
      metaSidebarWidth: metaSidebarWidthActual,
      codeSidebarWidth: codeSidebarWidthActual
    };
  }
);
const getChartZoom = createSelector([(state) => state.zoom], (zoom) => ({
  ...zoom
}));
const createCallbackMiddleware = (callback) => (store) => (next2) => (action) => {
  var _a, _b;
  if (!callback) {
    return next2(action);
  }
  switch (action.type) {
    case TOGGLE_NODE_CLICKED:
      if (action.nodeClicked) {
        const state = store.getState();
        const node2 = (_b = (_a = state == null ? void 0 : state.graph) == null ? void 0 : _a.nodes) == null ? void 0 : _b.find(
          (node3) => node3.id === action.nodeClicked
        );
        if (node2) {
          const nodeClickAction = {
            type: TOGGLE_NODE_CLICKED,
            payload: node2
          };
          callback(nodeClickAction);
        }
      }
      break;
    case SHOW_PIPELINE_FILTER:
      const showPipelineFilterAction = {
        type: SHOW_PIPELINE_FILTER
      };
      callback(showPipelineFilterAction);
      break;
  }
  return next2(action);
};
const updateGraphOnChange = (store) => {
  const watchGraph = watch(() => getGraphInput(store.getState()));
  store.subscribe(
    watchGraph((graphInput) => {
      store.dispatch(calculateGraph(graphInput));
    })
  );
};
const saveStateToLocalStorage = (state) => {
  const {
    exportModal,
    metadataModal,
    settingsModal,
    shareableUrlModal,
    modularPipelineFocusMode,
    ...otherVisibleProps
  } = state.visible;
  saveLocalStorage(localStorageName, {
    node: {
      disabled: pruneFalseyKeys(state.node.disabled)
    },
    nodeType: {
      disabled: state.nodeType.disabled
    },
    pipeline: {
      active: state.pipeline.active
    },
    layer: {
      visible: state.layer.visible
    },
    tag: {
      enabled: state.tag.enabled
    },
    textLabels: state.textLabels,
    visible: otherVisibleProps,
    theme: state.theme,
    isPrettyName: state.isPrettyName,
    showFeatureHints: state.showFeatureHints,
    showDatasetPreviews: state.showDatasetPreviews,
    flags: state.flags,
    expandAllPipelines: state.expandAllPipelines,
    orientation: state.orientation
  });
};
function configureStore(initialState, dataType, onActionCallback) {
  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose$1;
  const callbackMiddleware = createCallbackMiddleware(onActionCallback);
  const store = createStore(
    rootReducer,
    initialState,
    composeEnhancers(applyMiddleware(thunk, callbackMiddleware))
  );
  if (dataType !== "json") {
    store.dispatch(calculateGraph(getGraphInput(store.getState())));
  }
  updateGraphOnChange(store);
  store.subscribe(() => {
    saveStateToLocalStorage(store.getState());
  });
  return store;
}
var lodash_min$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash_min = lodash_min$1.exports;
var hasRequiredLodash_min;
function requireLodash_min() {
  if (hasRequiredLodash_min) return lodash_min$1.exports;
  hasRequiredLodash_min = 1;
  (function(module, exports) {
    (function() {
      function n(n2, t2, r3) {
        switch (r3.length) {
          case 0:
            return n2.call(t2);
          case 1:
            return n2.call(t2, r3[0]);
          case 2:
            return n2.call(t2, r3[0], r3[1]);
          case 3:
            return n2.call(t2, r3[0], r3[1], r3[2]);
        }
        return n2.apply(t2, r3);
      }
      function t(n2, t2, r3, e2) {
        for (var u2 = -1, i2 = null == n2 ? 0 : n2.length; ++u2 < i2; ) {
          var o2 = n2[u2];
          t2(e2, o2, r3(o2), n2);
        }
        return e2;
      }
      function r2(n2, t2) {
        for (var r3 = -1, e2 = null == n2 ? 0 : n2.length; ++r3 < e2 && t2(n2[r3], r3, n2) !== false; ) ;
        return n2;
      }
      function e(n2, t2) {
        for (var r3 = null == n2 ? 0 : n2.length; r3-- && t2(n2[r3], r3, n2) !== false; ) ;
        return n2;
      }
      function u(n2, t2) {
        for (var r3 = -1, e2 = null == n2 ? 0 : n2.length; ++r3 < e2; ) if (!t2(n2[r3], r3, n2)) return false;
        return true;
      }
      function i(n2, t2) {
        for (var r3 = -1, e2 = null == n2 ? 0 : n2.length, u2 = 0, i2 = []; ++r3 < e2; ) {
          var o2 = n2[r3];
          t2(o2, r3, n2) && (i2[u2++] = o2);
        }
        return i2;
      }
      function o(n2, t2) {
        return !!(null == n2 ? 0 : n2.length) && y2(n2, t2, 0) > -1;
      }
      function f(n2, t2, r3) {
        for (var e2 = -1, u2 = null == n2 ? 0 : n2.length; ++e2 < u2; ) if (r3(t2, n2[e2])) return true;
        return false;
      }
      function c(n2, t2) {
        for (var r3 = -1, e2 = null == n2 ? 0 : n2.length, u2 = Array(e2); ++r3 < e2; ) u2[r3] = t2(n2[r3], r3, n2);
        return u2;
      }
      function a(n2, t2) {
        for (var r3 = -1, e2 = t2.length, u2 = n2.length; ++r3 < e2; ) n2[u2 + r3] = t2[r3];
        return n2;
      }
      function l(n2, t2, r3, e2) {
        var u2 = -1, i2 = null == n2 ? 0 : n2.length;
        for (e2 && i2 && (r3 = n2[++u2]); ++u2 < i2; ) r3 = t2(r3, n2[u2], u2, n2);
        return r3;
      }
      function s(n2, t2, r3, e2) {
        var u2 = null == n2 ? 0 : n2.length;
        for (e2 && u2 && (r3 = n2[--u2]); u2--; ) r3 = t2(r3, n2[u2], u2, n2);
        return r3;
      }
      function h(n2, t2) {
        for (var r3 = -1, e2 = null == n2 ? 0 : n2.length; ++r3 < e2; ) if (t2(n2[r3], r3, n2)) return true;
        return false;
      }
      function p(n2) {
        return n2.split("");
      }
      function _(n2) {
        return n2.match($t) || [];
      }
      function v(n2, t2, r3) {
        var e2;
        return r3(n2, function(n3, r4, u2) {
          if (t2(n3, r4, u2)) return e2 = r4, false;
        }), e2;
      }
      function g(n2, t2, r3, e2) {
        for (var u2 = n2.length, i2 = r3 + (e2 ? 1 : -1); e2 ? i2-- : ++i2 < u2; ) if (t2(n2[i2], i2, n2)) return i2;
        return -1;
      }
      function y2(n2, t2, r3) {
        return t2 === t2 ? Z(n2, t2, r3) : g(n2, b, r3);
      }
      function d2(n2, t2, r3, e2) {
        for (var u2 = r3 - 1, i2 = n2.length; ++u2 < i2; ) if (e2(n2[u2], t2)) return u2;
        return -1;
      }
      function b(n2) {
        return n2 !== n2;
      }
      function w(n2, t2) {
        var r3 = null == n2 ? 0 : n2.length;
        return r3 ? k(n2, t2) / r3 : Cn;
      }
      function m(n2) {
        return function(t2) {
          return null == t2 ? X : t2[n2];
        };
      }
      function x2(n2) {
        return function(t2) {
          return null == n2 ? X : n2[t2];
        };
      }
      function j(n2, t2, r3, e2, u2) {
        return u2(n2, function(n3, u3, i2) {
          r3 = e2 ? (e2 = false, n3) : t2(r3, n3, u3, i2);
        }), r3;
      }
      function A(n2, t2) {
        var r3 = n2.length;
        for (n2.sort(t2); r3--; ) n2[r3] = n2[r3].value;
        return n2;
      }
      function k(n2, t2) {
        for (var r3, e2 = -1, u2 = n2.length; ++e2 < u2; ) {
          var i2 = t2(n2[e2]);
          i2 !== X && (r3 = r3 === X ? i2 : r3 + i2);
        }
        return r3;
      }
      function O(n2, t2) {
        for (var r3 = -1, e2 = Array(n2); ++r3 < n2; ) e2[r3] = t2(r3);
        return e2;
      }
      function I(n2, t2) {
        return c(t2, function(t3) {
          return [t3, n2[t3]];
        });
      }
      function R(n2) {
        return n2 ? n2.slice(0, H(n2) + 1).replace(Lt, "") : n2;
      }
      function z(n2) {
        return function(t2) {
          return n2(t2);
        };
      }
      function E(n2, t2) {
        return c(t2, function(t3) {
          return n2[t3];
        });
      }
      function S(n2, t2) {
        return n2.has(t2);
      }
      function W(n2, t2) {
        for (var r3 = -1, e2 = n2.length; ++r3 < e2 && y2(t2, n2[r3], 0) > -1; ) ;
        return r3;
      }
      function L(n2, t2) {
        for (var r3 = n2.length; r3-- && y2(t2, n2[r3], 0) > -1; ) ;
        return r3;
      }
      function C(n2, t2) {
        for (var r3 = n2.length, e2 = 0; r3--; ) n2[r3] === t2 && ++e2;
        return e2;
      }
      function U(n2) {
        return "\\" + Yr[n2];
      }
      function B(n2, t2) {
        return null == n2 ? X : n2[t2];
      }
      function T(n2) {
        return Nr.test(n2);
      }
      function $(n2) {
        return Pr.test(n2);
      }
      function D(n2) {
        for (var t2, r3 = []; !(t2 = n2.next()).done; ) r3.push(t2.value);
        return r3;
      }
      function M(n2) {
        var t2 = -1, r3 = Array(n2.size);
        return n2.forEach(function(n3, e2) {
          r3[++t2] = [e2, n3];
        }), r3;
      }
      function F(n2, t2) {
        return function(r3) {
          return n2(t2(r3));
        };
      }
      function N(n2, t2) {
        for (var r3 = -1, e2 = n2.length, u2 = 0, i2 = []; ++r3 < e2; ) {
          var o2 = n2[r3];
          o2 !== t2 && o2 !== cn || (n2[r3] = cn, i2[u2++] = r3);
        }
        return i2;
      }
      function P(n2) {
        var t2 = -1, r3 = Array(n2.size);
        return n2.forEach(function(n3) {
          r3[++t2] = n3;
        }), r3;
      }
      function q(n2) {
        var t2 = -1, r3 = Array(n2.size);
        return n2.forEach(function(n3) {
          r3[++t2] = [n3, n3];
        }), r3;
      }
      function Z(n2, t2, r3) {
        for (var e2 = r3 - 1, u2 = n2.length; ++e2 < u2; ) if (n2[e2] === t2) return e2;
        return -1;
      }
      function K(n2, t2, r3) {
        for (var e2 = r3 + 1; e2--; ) if (n2[e2] === t2) return e2;
        return e2;
      }
      function V(n2) {
        return T(n2) ? J(n2) : _e(n2);
      }
      function G(n2) {
        return T(n2) ? Y(n2) : p(n2);
      }
      function H(n2) {
        for (var t2 = n2.length; t2-- && Ct.test(n2.charAt(t2)); ) ;
        return t2;
      }
      function J(n2) {
        for (var t2 = Mr.lastIndex = 0; Mr.test(n2); ) ++t2;
        return t2;
      }
      function Y(n2) {
        return n2.match(Mr) || [];
      }
      function Q(n2) {
        return n2.match(Fr) || [];
      }
      var X, nn = "4.17.21", tn = 200, rn = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", en = "Expected a function", un = "Invalid `variable` option passed into `_.template`", on = "__lodash_hash_undefined__", fn = 500, cn = "__lodash_placeholder__", an = 1, ln = 2, sn = 4, hn = 1, pn = 2, _n = 1, vn = 2, gn = 4, yn = 8, dn = 16, bn = 32, wn = 64, mn = 128, xn = 256, jn = 512, An = 30, kn = "...", On = 800, In = 16, Rn = 1, zn = 2, En = 3, Sn = 1 / 0, Wn = 9007199254740991, Ln = 17976931348623157e292, Cn = NaN, Un = 4294967295, Bn = Un - 1, Tn = Un >>> 1, $n = [["ary", mn], ["bind", _n], ["bindKey", vn], ["curry", yn], ["curryRight", dn], ["flip", jn], ["partial", bn], ["partialRight", wn], ["rearg", xn]], Dn = "[object Arguments]", Mn = "[object Array]", Fn = "[object AsyncFunction]", Nn = "[object Boolean]", Pn = "[object Date]", qn = "[object DOMException]", Zn = "[object Error]", Kn = "[object Function]", Vn = "[object GeneratorFunction]", Gn = "[object Map]", Hn = "[object Number]", Jn = "[object Null]", Yn = "[object Object]", Qn = "[object Promise]", Xn = "[object Proxy]", nt = "[object RegExp]", tt = "[object Set]", rt = "[object String]", et = "[object Symbol]", ut = "[object Undefined]", it = "[object WeakMap]", ot = "[object WeakSet]", ft = "[object ArrayBuffer]", ct = "[object DataView]", at = "[object Float32Array]", lt = "[object Float64Array]", st = "[object Int8Array]", ht = "[object Int16Array]", pt = "[object Int32Array]", _t = "[object Uint8Array]", vt = "[object Uint8ClampedArray]", gt = "[object Uint16Array]", yt = "[object Uint32Array]", dt = /\b__p \+= '';/g, bt = /\b(__p \+=) '' \+/g, wt = /(__e\(.*?\)|\b__t\)) \+\n'';/g, mt = /&(?:amp|lt|gt|quot|#39);/g, xt = /[&<>"']/g, jt = RegExp(mt.source), At = RegExp(xt.source), kt = /<%-([\s\S]+?)%>/g, Ot = /<%([\s\S]+?)%>/g, It = /<%=([\s\S]+?)%>/g, Rt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zt = /^\w*$/, Et = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, St = /[\\^$.*+?()[\]{}|]/g, Wt = RegExp(St.source), Lt = /^\s+/, Ct = /\s/, Ut = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Bt = /\{\n\/\* \[wrapped with (.+)\] \*/, Tt = /,? & /, $t = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Dt = /[()=,{}\[\]\/\s]/, Mt = /\\(\\)?/g, Ft = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Nt = /\w*$/, Pt = /^[-+]0x[0-9a-f]+$/i, qt = /^0b[01]+$/i, Zt = /^\[object .+?Constructor\]$/, Kt = /^0o[0-7]+$/i, Vt = /^(?:0|[1-9]\d*)$/, Gt = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ht = /($^)/, Jt = /['\n\r\u2028\u2029\\]/g, Yt = "\\ud800-\\udfff", Qt = "\\u0300-\\u036f", Xt = "\\ufe20-\\ufe2f", nr = "\\u20d0-\\u20ff", tr = Qt + Xt + nr, rr = "\\u2700-\\u27bf", er = "a-z\\xdf-\\xf6\\xf8-\\xff", ur = "\\xac\\xb1\\xd7\\xf7", ir = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", or = "\\u2000-\\u206f", fr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "A-Z\\xc0-\\xd6\\xd8-\\xde", ar = "\\ufe0e\\ufe0f", lr = ur + ir + or + fr, sr = "[']", hr = "[" + Yt + "]", pr = "[" + lr + "]", _r = "[" + tr + "]", vr = "\\d+", gr = "[" + rr + "]", yr = "[" + er + "]", dr = "[^" + Yt + lr + vr + rr + er + cr + "]", br = "\\ud83c[\\udffb-\\udfff]", wr = "(?:" + _r + "|" + br + ")", mr = "[^" + Yt + "]", xr = "(?:\\ud83c[\\udde6-\\uddff]){2}", jr = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ar = "[" + cr + "]", kr = "\\u200d", Or = "(?:" + yr + "|" + dr + ")", Ir = "(?:" + Ar + "|" + dr + ")", Rr = "(?:" + sr + "(?:d|ll|m|re|s|t|ve))?", zr = "(?:" + sr + "(?:D|LL|M|RE|S|T|VE))?", Er = wr + "?", Sr = "[" + ar + "]?", Wr = "(?:" + kr + "(?:" + [mr, xr, jr].join("|") + ")" + Sr + Er + ")*", Lr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Cr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Ur = Sr + Er + Wr, Br = "(?:" + [gr, xr, jr].join("|") + ")" + Ur, Tr = "(?:" + [mr + _r + "?", _r, xr, jr, hr].join("|") + ")", $r = RegExp(sr, "g"), Dr = RegExp(_r, "g"), Mr = RegExp(br + "(?=" + br + ")|" + Tr + Ur, "g"), Fr = RegExp([Ar + "?" + yr + "+" + Rr + "(?=" + [pr, Ar, "$"].join("|") + ")", Ir + "+" + zr + "(?=" + [pr, Ar + Or, "$"].join("|") + ")", Ar + "?" + Or + "+" + Rr, Ar + "+" + zr, Cr, Lr, vr, Br].join("|"), "g"), Nr = RegExp("[" + kr + Yt + tr + ar + "]"), Pr = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, qr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Zr = -1, Kr = {};
      Kr[at] = Kr[lt] = Kr[st] = Kr[ht] = Kr[pt] = Kr[_t] = Kr[vt] = Kr[gt] = Kr[yt] = true, Kr[Dn] = Kr[Mn] = Kr[ft] = Kr[Nn] = Kr[ct] = Kr[Pn] = Kr[Zn] = Kr[Kn] = Kr[Gn] = Kr[Hn] = Kr[Yn] = Kr[nt] = Kr[tt] = Kr[rt] = Kr[it] = false;
      var Vr = {};
      Vr[Dn] = Vr[Mn] = Vr[ft] = Vr[ct] = Vr[Nn] = Vr[Pn] = Vr[at] = Vr[lt] = Vr[st] = Vr[ht] = Vr[pt] = Vr[Gn] = Vr[Hn] = Vr[Yn] = Vr[nt] = Vr[tt] = Vr[rt] = Vr[et] = Vr[_t] = Vr[vt] = Vr[gt] = Vr[yt] = true, Vr[Zn] = Vr[Kn] = Vr[it] = false;
      var Gr = {
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      }, Hr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Jr = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Yr = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Qr = parseFloat, Xr = parseInt, ne = "object" == typeof commonjsGlobal$1 && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1, te = "object" == typeof self && self && self.Object === Object && self, re = ne || te || Function("return this")(), ee = exports && !exports.nodeType && exports, ue = ee && true && module && !module.nodeType && module, ie = ue && ue.exports === ee, oe = ie && ne.process, fe = function() {
        try {
          var n2 = ue && ue.require && ue.require("util").types;
          return n2 ? n2 : oe && oe.binding && oe.binding("util");
        } catch (n3) {
        }
      }(), ce = fe && fe.isArrayBuffer, ae = fe && fe.isDate, le = fe && fe.isMap, se = fe && fe.isRegExp, he = fe && fe.isSet, pe = fe && fe.isTypedArray, _e = m("length"), ve = x2(Gr), ge = x2(Hr), ye = x2(Jr), de = function p2(x3) {
        function Z2(n2) {
          if (cc(n2) && !bh(n2) && !(n2 instanceof Ct2)) {
            if (n2 instanceof Y2) return n2;
            if (bl.call(n2, "__wrapped__")) return eo(n2);
          }
          return new Y2(n2);
        }
        function J2() {
        }
        function Y2(n2, t2) {
          this.__wrapped__ = n2, this.__actions__ = [], this.__chain__ = !!t2, this.__index__ = 0, this.__values__ = X;
        }
        function Ct2(n2) {
          this.__wrapped__ = n2, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Un, this.__views__ = [];
        }
        function $t2() {
          var n2 = new Ct2(this.__wrapped__);
          return n2.__actions__ = Tu(this.__actions__), n2.__dir__ = this.__dir__, n2.__filtered__ = this.__filtered__, n2.__iteratees__ = Tu(this.__iteratees__), n2.__takeCount__ = this.__takeCount__, n2.__views__ = Tu(this.__views__), n2;
        }
        function Yt2() {
          if (this.__filtered__) {
            var n2 = new Ct2(this);
            n2.__dir__ = -1, n2.__filtered__ = true;
          } else n2 = this.clone(), n2.__dir__ *= -1;
          return n2;
        }
        function Qt2() {
          var n2 = this.__wrapped__.value(), t2 = this.__dir__, r3 = bh(n2), e2 = t2 < 0, u2 = r3 ? n2.length : 0, i2 = Oi(0, u2, this.__views__), o2 = i2.start, f2 = i2.end, c2 = f2 - o2, a2 = e2 ? f2 : o2 - 1, l2 = this.__iteratees__, s2 = l2.length, h2 = 0, p3 = Hl(c2, this.__takeCount__);
          if (!r3 || !e2 && u2 == c2 && p3 == c2) return wu(n2, this.__actions__);
          var _2 = [];
          n: for (; c2-- && h2 < p3; ) {
            a2 += t2;
            for (var v2 = -1, g2 = n2[a2]; ++v2 < s2; ) {
              var y3 = l2[v2], d3 = y3.iteratee, b2 = y3.type, w2 = d3(g2);
              if (b2 == zn) g2 = w2;
              else if (!w2) {
                if (b2 == Rn) continue n;
                break n;
              }
            }
            _2[h2++] = g2;
          }
          return _2;
        }
        function Xt2(n2) {
          var t2 = -1, r3 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r3; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function nr2() {
          this.__data__ = is2 ? is2(null) : {}, this.size = 0;
        }
        function tr2(n2) {
          var t2 = this.has(n2) && delete this.__data__[n2];
          return this.size -= t2 ? 1 : 0, t2;
        }
        function rr2(n2) {
          var t2 = this.__data__;
          if (is2) {
            var r3 = t2[n2];
            return r3 === on ? X : r3;
          }
          return bl.call(t2, n2) ? t2[n2] : X;
        }
        function er2(n2) {
          var t2 = this.__data__;
          return is2 ? t2[n2] !== X : bl.call(t2, n2);
        }
        function ur2(n2, t2) {
          var r3 = this.__data__;
          return this.size += this.has(n2) ? 0 : 1, r3[n2] = is2 && t2 === X ? on : t2, this;
        }
        function ir2(n2) {
          var t2 = -1, r3 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r3; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function or2() {
          this.__data__ = [], this.size = 0;
        }
        function fr2(n2) {
          var t2 = this.__data__, r3 = Wr2(t2, n2);
          return !(r3 < 0) && (r3 == t2.length - 1 ? t2.pop() : Ll.call(t2, r3, 1), --this.size, true);
        }
        function cr2(n2) {
          var t2 = this.__data__, r3 = Wr2(t2, n2);
          return r3 < 0 ? X : t2[r3][1];
        }
        function ar2(n2) {
          return Wr2(this.__data__, n2) > -1;
        }
        function lr2(n2, t2) {
          var r3 = this.__data__, e2 = Wr2(r3, n2);
          return e2 < 0 ? (++this.size, r3.push([n2, t2])) : r3[e2][1] = t2, this;
        }
        function sr2(n2) {
          var t2 = -1, r3 = null == n2 ? 0 : n2.length;
          for (this.clear(); ++t2 < r3; ) {
            var e2 = n2[t2];
            this.set(e2[0], e2[1]);
          }
        }
        function hr2() {
          this.size = 0, this.__data__ = { hash: new Xt2(), map: new (ts || ir2)(), string: new Xt2() };
        }
        function pr2(n2) {
          var t2 = xi(this, n2).delete(n2);
          return this.size -= t2 ? 1 : 0, t2;
        }
        function _r2(n2) {
          return xi(this, n2).get(n2);
        }
        function vr2(n2) {
          return xi(this, n2).has(n2);
        }
        function gr2(n2, t2) {
          var r3 = xi(this, n2), e2 = r3.size;
          return r3.set(n2, t2), this.size += r3.size == e2 ? 0 : 1, this;
        }
        function yr2(n2) {
          var t2 = -1, r3 = null == n2 ? 0 : n2.length;
          for (this.__data__ = new sr2(); ++t2 < r3; ) this.add(n2[t2]);
        }
        function dr2(n2) {
          return this.__data__.set(n2, on), this;
        }
        function br2(n2) {
          return this.__data__.has(n2);
        }
        function wr2(n2) {
          this.size = (this.__data__ = new ir2(n2)).size;
        }
        function mr2() {
          this.__data__ = new ir2(), this.size = 0;
        }
        function xr2(n2) {
          var t2 = this.__data__, r3 = t2.delete(n2);
          return this.size = t2.size, r3;
        }
        function jr2(n2) {
          return this.__data__.get(n2);
        }
        function Ar2(n2) {
          return this.__data__.has(n2);
        }
        function kr2(n2, t2) {
          var r3 = this.__data__;
          if (r3 instanceof ir2) {
            var e2 = r3.__data__;
            if (!ts || e2.length < tn - 1) return e2.push([n2, t2]), this.size = ++r3.size, this;
            r3 = this.__data__ = new sr2(e2);
          }
          return r3.set(n2, t2), this.size = r3.size, this;
        }
        function Or2(n2, t2) {
          var r3 = bh(n2), e2 = !r3 && dh(n2), u2 = !r3 && !e2 && mh(n2), i2 = !r3 && !e2 && !u2 && Oh(n2), o2 = r3 || e2 || u2 || i2, f2 = o2 ? O(n2.length, hl) : [], c2 = f2.length;
          for (var a2 in n2) !t2 && !bl.call(n2, a2) || o2 && ("length" == a2 || u2 && ("offset" == a2 || "parent" == a2) || i2 && ("buffer" == a2 || "byteLength" == a2 || "byteOffset" == a2) || Ci(a2, c2)) || f2.push(a2);
          return f2;
        }
        function Ir2(n2) {
          var t2 = n2.length;
          return t2 ? n2[tu(0, t2 - 1)] : X;
        }
        function Rr2(n2, t2) {
          return Xi(Tu(n2), Mr2(t2, 0, n2.length));
        }
        function zr2(n2) {
          return Xi(Tu(n2));
        }
        function Er2(n2, t2, r3) {
          (r3 === X || Gf(n2[t2], r3)) && (r3 !== X || t2 in n2) || Br2(n2, t2, r3);
        }
        function Sr2(n2, t2, r3) {
          var e2 = n2[t2];
          bl.call(n2, t2) && Gf(e2, r3) && (r3 !== X || t2 in n2) || Br2(n2, t2, r3);
        }
        function Wr2(n2, t2) {
          for (var r3 = n2.length; r3--; ) if (Gf(n2[r3][0], t2)) return r3;
          return -1;
        }
        function Lr2(n2, t2, r3, e2) {
          return ys(n2, function(n3, u2, i2) {
            t2(e2, n3, r3(n3), i2);
          }), e2;
        }
        function Cr2(n2, t2) {
          return n2 && $u(t2, Pc(t2), n2);
        }
        function Ur2(n2, t2) {
          return n2 && $u(t2, qc(t2), n2);
        }
        function Br2(n2, t2, r3) {
          "__proto__" == t2 && Tl ? Tl(n2, t2, { configurable: true, enumerable: true, value: r3, writable: true }) : n2[t2] = r3;
        }
        function Tr2(n2, t2) {
          for (var r3 = -1, e2 = t2.length, u2 = il(e2), i2 = null == n2; ++r3 < e2; ) u2[r3] = i2 ? X : Mc(n2, t2[r3]);
          return u2;
        }
        function Mr2(n2, t2, r3) {
          return n2 === n2 && (r3 !== X && (n2 = n2 <= r3 ? n2 : r3), t2 !== X && (n2 = n2 >= t2 ? n2 : t2)), n2;
        }
        function Fr2(n2, t2, e2, u2, i2, o2) {
          var f2, c2 = t2 & an, a2 = t2 & ln, l2 = t2 & sn;
          if (e2 && (f2 = i2 ? e2(n2, u2, i2, o2) : e2(n2)), f2 !== X) return f2;
          if (!fc(n2)) return n2;
          var s2 = bh(n2);
          if (s2) {
            if (f2 = zi(n2), !c2) return Tu(n2, f2);
          } else {
            var h2 = zs(n2), p3 = h2 == Kn || h2 == Vn;
            if (mh(n2)) return Iu(n2, c2);
            if (h2 == Yn || h2 == Dn || p3 && !i2) {
              if (f2 = a2 || p3 ? {} : Ei(n2), !c2) return a2 ? Mu(n2, Ur2(f2, n2)) : Du(n2, Cr2(f2, n2));
            } else {
              if (!Vr[h2]) return i2 ? n2 : {};
              f2 = Si(n2, h2, c2);
            }
          }
          o2 || (o2 = new wr2());
          var _2 = o2.get(n2);
          if (_2) return _2;
          o2.set(n2, f2), kh(n2) ? n2.forEach(function(r3) {
            f2.add(Fr2(r3, t2, e2, r3, n2, o2));
          }) : jh(n2) && n2.forEach(function(r3, u3) {
            f2.set(u3, Fr2(r3, t2, e2, u3, n2, o2));
          });
          var v2 = l2 ? a2 ? di : yi : a2 ? qc : Pc, g2 = s2 ? X : v2(n2);
          return r2(g2 || n2, function(r3, u3) {
            g2 && (u3 = r3, r3 = n2[u3]), Sr2(f2, u3, Fr2(r3, t2, e2, u3, n2, o2));
          }), f2;
        }
        function Nr2(n2) {
          var t2 = Pc(n2);
          return function(r3) {
            return Pr2(r3, n2, t2);
          };
        }
        function Pr2(n2, t2, r3) {
          var e2 = r3.length;
          if (null == n2) return !e2;
          for (n2 = ll(n2); e2--; ) {
            var u2 = r3[e2], i2 = t2[u2], o2 = n2[u2];
            if (o2 === X && !(u2 in n2) || !i2(o2)) return false;
          }
          return true;
        }
        function Gr2(n2, t2, r3) {
          if ("function" != typeof n2) throw new pl(en);
          return Ws(function() {
            n2.apply(X, r3);
          }, t2);
        }
        function Hr2(n2, t2, r3, e2) {
          var u2 = -1, i2 = o, a2 = true, l2 = n2.length, s2 = [], h2 = t2.length;
          if (!l2) return s2;
          r3 && (t2 = c(t2, z(r3))), e2 ? (i2 = f, a2 = false) : t2.length >= tn && (i2 = S, a2 = false, t2 = new yr2(t2));
          n: for (; ++u2 < l2; ) {
            var p3 = n2[u2], _2 = null == r3 ? p3 : r3(p3);
            if (p3 = e2 || 0 !== p3 ? p3 : 0, a2 && _2 === _2) {
              for (var v2 = h2; v2--; ) if (t2[v2] === _2) continue n;
              s2.push(p3);
            } else i2(t2, _2, e2) || s2.push(p3);
          }
          return s2;
        }
        function Jr2(n2, t2) {
          var r3 = true;
          return ys(n2, function(n3, e2, u2) {
            return r3 = !!t2(n3, e2, u2);
          }), r3;
        }
        function Yr2(n2, t2, r3) {
          for (var e2 = -1, u2 = n2.length; ++e2 < u2; ) {
            var i2 = n2[e2], o2 = t2(i2);
            if (null != o2 && (f2 === X ? o2 === o2 && !bc(o2) : r3(o2, f2))) var f2 = o2, c2 = i2;
          }
          return c2;
        }
        function ne2(n2, t2, r3, e2) {
          var u2 = n2.length;
          for (r3 = kc(r3), r3 < 0 && (r3 = -r3 > u2 ? 0 : u2 + r3), e2 = e2 === X || e2 > u2 ? u2 : kc(e2), e2 < 0 && (e2 += u2), e2 = r3 > e2 ? 0 : Oc(e2); r3 < e2; ) n2[r3++] = t2;
          return n2;
        }
        function te2(n2, t2) {
          var r3 = [];
          return ys(n2, function(n3, e2, u2) {
            t2(n3, e2, u2) && r3.push(n3);
          }), r3;
        }
        function ee2(n2, t2, r3, e2, u2) {
          var i2 = -1, o2 = n2.length;
          for (r3 || (r3 = Li), u2 || (u2 = []); ++i2 < o2; ) {
            var f2 = n2[i2];
            t2 > 0 && r3(f2) ? t2 > 1 ? ee2(f2, t2 - 1, r3, e2, u2) : a(u2, f2) : e2 || (u2[u2.length] = f2);
          }
          return u2;
        }
        function ue2(n2, t2) {
          return n2 && bs(n2, t2, Pc);
        }
        function oe2(n2, t2) {
          return n2 && ws(n2, t2, Pc);
        }
        function fe2(n2, t2) {
          return i(t2, function(t3) {
            return uc(n2[t3]);
          });
        }
        function _e2(n2, t2) {
          t2 = ku(t2, n2);
          for (var r3 = 0, e2 = t2.length; null != n2 && r3 < e2; ) n2 = n2[no(t2[r3++])];
          return r3 && r3 == e2 ? n2 : X;
        }
        function de2(n2, t2, r3) {
          var e2 = t2(n2);
          return bh(n2) ? e2 : a(e2, r3(n2));
        }
        function we(n2) {
          return null == n2 ? n2 === X ? ut : Jn : Bl && Bl in ll(n2) ? ki(n2) : Ki(n2);
        }
        function me(n2, t2) {
          return n2 > t2;
        }
        function xe(n2, t2) {
          return null != n2 && bl.call(n2, t2);
        }
        function je(n2, t2) {
          return null != n2 && t2 in ll(n2);
        }
        function Ae(n2, t2, r3) {
          return n2 >= Hl(t2, r3) && n2 < Gl(t2, r3);
        }
        function ke(n2, t2, r3) {
          for (var e2 = r3 ? f : o, u2 = n2[0].length, i2 = n2.length, a2 = i2, l2 = il(i2), s2 = 1 / 0, h2 = []; a2--; ) {
            var p3 = n2[a2];
            a2 && t2 && (p3 = c(p3, z(t2))), s2 = Hl(p3.length, s2), l2[a2] = !r3 && (t2 || u2 >= 120 && p3.length >= 120) ? new yr2(a2 && p3) : X;
          }
          p3 = n2[0];
          var _2 = -1, v2 = l2[0];
          n: for (; ++_2 < u2 && h2.length < s2; ) {
            var g2 = p3[_2], y3 = t2 ? t2(g2) : g2;
            if (g2 = r3 || 0 !== g2 ? g2 : 0, !(v2 ? S(v2, y3) : e2(h2, y3, r3))) {
              for (a2 = i2; --a2; ) {
                var d3 = l2[a2];
                if (!(d3 ? S(d3, y3) : e2(n2[a2], y3, r3))) continue n;
              }
              v2 && v2.push(y3), h2.push(g2);
            }
          }
          return h2;
        }
        function Oe(n2, t2, r3, e2) {
          return ue2(n2, function(n3, u2, i2) {
            t2(e2, r3(n3), u2, i2);
          }), e2;
        }
        function Ie(t2, r3, e2) {
          r3 = ku(r3, t2), t2 = Gi(t2, r3);
          var u2 = null == t2 ? t2 : t2[no(jo(r3))];
          return null == u2 ? X : n(u2, t2, e2);
        }
        function Re(n2) {
          return cc(n2) && we(n2) == Dn;
        }
        function ze(n2) {
          return cc(n2) && we(n2) == ft;
        }
        function Ee(n2) {
          return cc(n2) && we(n2) == Pn;
        }
        function Se(n2, t2, r3, e2, u2) {
          return n2 === t2 || (null == n2 || null == t2 || !cc(n2) && !cc(t2) ? n2 !== n2 && t2 !== t2 : We(n2, t2, r3, e2, Se, u2));
        }
        function We(n2, t2, r3, e2, u2, i2) {
          var o2 = bh(n2), f2 = bh(t2), c2 = o2 ? Mn : zs(n2), a2 = f2 ? Mn : zs(t2);
          c2 = c2 == Dn ? Yn : c2, a2 = a2 == Dn ? Yn : a2;
          var l2 = c2 == Yn, s2 = a2 == Yn, h2 = c2 == a2;
          if (h2 && mh(n2)) {
            if (!mh(t2)) return false;
            o2 = true, l2 = false;
          }
          if (h2 && !l2) return i2 || (i2 = new wr2()), o2 || Oh(n2) ? pi2(n2, t2, r3, e2, u2, i2) : _i(n2, t2, c2, r3, e2, u2, i2);
          if (!(r3 & hn)) {
            var p3 = l2 && bl.call(n2, "__wrapped__"), _2 = s2 && bl.call(t2, "__wrapped__");
            if (p3 || _2) {
              var v2 = p3 ? n2.value() : n2, g2 = _2 ? t2.value() : t2;
              return i2 || (i2 = new wr2()), u2(v2, g2, r3, e2, i2);
            }
          }
          return !!h2 && (i2 || (i2 = new wr2()), vi(n2, t2, r3, e2, u2, i2));
        }
        function Le(n2) {
          return cc(n2) && zs(n2) == Gn;
        }
        function Ce(n2, t2, r3, e2) {
          var u2 = r3.length, i2 = u2, o2 = !e2;
          if (null == n2) return !i2;
          for (n2 = ll(n2); u2--; ) {
            var f2 = r3[u2];
            if (o2 && f2[2] ? f2[1] !== n2[f2[0]] : !(f2[0] in n2)) return false;
          }
          for (; ++u2 < i2; ) {
            f2 = r3[u2];
            var c2 = f2[0], a2 = n2[c2], l2 = f2[1];
            if (o2 && f2[2]) {
              if (a2 === X && !(c2 in n2)) return false;
            } else {
              var s2 = new wr2();
              if (e2) var h2 = e2(a2, l2, c2, n2, t2, s2);
              if (!(h2 === X ? Se(l2, a2, hn | pn, e2, s2) : h2)) return false;
            }
          }
          return true;
        }
        function Ue(n2) {
          return !(!fc(n2) || Di(n2)) && (uc(n2) ? kl : Zt).test(to(n2));
        }
        function Be(n2) {
          return cc(n2) && we(n2) == nt;
        }
        function Te(n2) {
          return cc(n2) && zs(n2) == tt;
        }
        function $e(n2) {
          return cc(n2) && oc(n2.length) && !!Kr[we(n2)];
        }
        function De(n2) {
          return "function" == typeof n2 ? n2 : null == n2 ? La : "object" == typeof n2 ? bh(n2) ? Ze(n2[0], n2[1]) : qe(n2) : Fa(n2);
        }
        function Me(n2) {
          if (!Mi(n2)) return Vl(n2);
          var t2 = [];
          for (var r3 in ll(n2)) bl.call(n2, r3) && "constructor" != r3 && t2.push(r3);
          return t2;
        }
        function Fe(n2) {
          if (!fc(n2)) return Zi(n2);
          var t2 = Mi(n2), r3 = [];
          for (var e2 in n2) ("constructor" != e2 || !t2 && bl.call(n2, e2)) && r3.push(e2);
          return r3;
        }
        function Ne(n2, t2) {
          return n2 < t2;
        }
        function Pe(n2, t2) {
          var r3 = -1, e2 = Hf(n2) ? il(n2.length) : [];
          return ys(n2, function(n3, u2, i2) {
            e2[++r3] = t2(n3, u2, i2);
          }), e2;
        }
        function qe(n2) {
          var t2 = ji(n2);
          return 1 == t2.length && t2[0][2] ? Ni(t2[0][0], t2[0][1]) : function(r3) {
            return r3 === n2 || Ce(r3, n2, t2);
          };
        }
        function Ze(n2, t2) {
          return Bi(n2) && Fi(t2) ? Ni(no(n2), t2) : function(r3) {
            var e2 = Mc(r3, n2);
            return e2 === X && e2 === t2 ? Nc(r3, n2) : Se(t2, e2, hn | pn);
          };
        }
        function Ke(n2, t2, r3, e2, u2) {
          n2 !== t2 && bs(t2, function(i2, o2) {
            if (u2 || (u2 = new wr2()), fc(i2)) Ve(n2, t2, o2, r3, Ke, e2, u2);
            else {
              var f2 = e2 ? e2(Ji(n2, o2), i2, o2 + "", n2, t2, u2) : X;
              f2 === X && (f2 = i2), Er2(n2, o2, f2);
            }
          }, qc);
        }
        function Ve(n2, t2, r3, e2, u2, i2, o2) {
          var f2 = Ji(n2, r3), c2 = Ji(t2, r3), a2 = o2.get(c2);
          if (a2) return Er2(n2, r3, a2), X;
          var l2 = i2 ? i2(f2, c2, r3 + "", n2, t2, o2) : X, s2 = l2 === X;
          if (s2) {
            var h2 = bh(c2), p3 = !h2 && mh(c2), _2 = !h2 && !p3 && Oh(c2);
            l2 = c2, h2 || p3 || _2 ? bh(f2) ? l2 = f2 : Jf(f2) ? l2 = Tu(f2) : p3 ? (s2 = false, l2 = Iu(c2, true)) : _2 ? (s2 = false, l2 = Wu(c2, true)) : l2 = [] : gc(c2) || dh(c2) ? (l2 = f2, dh(f2) ? l2 = Rc(f2) : fc(f2) && !uc(f2) || (l2 = Ei(c2))) : s2 = false;
          }
          s2 && (o2.set(c2, l2), u2(l2, c2, e2, i2, o2), o2.delete(c2)), Er2(n2, r3, l2);
        }
        function Ge(n2, t2) {
          var r3 = n2.length;
          if (r3) return t2 += t2 < 0 ? r3 : 0, Ci(t2, r3) ? n2[t2] : X;
        }
        function He(n2, t2, r3) {
          t2 = t2.length ? c(t2, function(n3) {
            return bh(n3) ? function(t3) {
              return _e2(t3, 1 === n3.length ? n3[0] : n3);
            } : n3;
          }) : [La];
          var e2 = -1;
          return t2 = c(t2, z(mi())), A(Pe(n2, function(n3, r4, u2) {
            return { criteria: c(t2, function(t3) {
              return t3(n3);
            }), index: ++e2, value: n3 };
          }), function(n3, t3) {
            return Cu(n3, t3, r3);
          });
        }
        function Je(n2, t2) {
          return Ye(n2, t2, function(t3, r3) {
            return Nc(n2, r3);
          });
        }
        function Ye(n2, t2, r3) {
          for (var e2 = -1, u2 = t2.length, i2 = {}; ++e2 < u2; ) {
            var o2 = t2[e2], f2 = _e2(n2, o2);
            r3(f2, o2) && fu(i2, ku(o2, n2), f2);
          }
          return i2;
        }
        function Qe(n2) {
          return function(t2) {
            return _e2(t2, n2);
          };
        }
        function Xe(n2, t2, r3, e2) {
          var u2 = e2 ? d2 : y2, i2 = -1, o2 = t2.length, f2 = n2;
          for (n2 === t2 && (t2 = Tu(t2)), r3 && (f2 = c(n2, z(r3))); ++i2 < o2; ) for (var a2 = 0, l2 = t2[i2], s2 = r3 ? r3(l2) : l2; (a2 = u2(f2, s2, a2, e2)) > -1; ) f2 !== n2 && Ll.call(f2, a2, 1), Ll.call(n2, a2, 1);
          return n2;
        }
        function nu(n2, t2) {
          for (var r3 = n2 ? t2.length : 0, e2 = r3 - 1; r3--; ) {
            var u2 = t2[r3];
            if (r3 == e2 || u2 !== i2) {
              var i2 = u2;
              Ci(u2) ? Ll.call(n2, u2, 1) : yu(n2, u2);
            }
          }
          return n2;
        }
        function tu(n2, t2) {
          return n2 + Nl(Ql() * (t2 - n2 + 1));
        }
        function ru(n2, t2, r3, e2) {
          for (var u2 = -1, i2 = Gl(Fl((t2 - n2) / (r3 || 1)), 0), o2 = il(i2); i2--; ) o2[e2 ? i2 : ++u2] = n2, n2 += r3;
          return o2;
        }
        function eu(n2, t2) {
          var r3 = "";
          if (!n2 || t2 < 1 || t2 > Wn) return r3;
          do
            t2 % 2 && (r3 += n2), t2 = Nl(t2 / 2), t2 && (n2 += n2);
          while (t2);
          return r3;
        }
        function uu(n2, t2) {
          return Ls(Vi(n2, t2, La), n2 + "");
        }
        function iu(n2) {
          return Ir2(ra(n2));
        }
        function ou(n2, t2) {
          var r3 = ra(n2);
          return Xi(r3, Mr2(t2, 0, r3.length));
        }
        function fu(n2, t2, r3, e2) {
          if (!fc(n2)) return n2;
          t2 = ku(t2, n2);
          for (var u2 = -1, i2 = t2.length, o2 = i2 - 1, f2 = n2; null != f2 && ++u2 < i2; ) {
            var c2 = no(t2[u2]), a2 = r3;
            if ("__proto__" === c2 || "constructor" === c2 || "prototype" === c2) return n2;
            if (u2 != o2) {
              var l2 = f2[c2];
              a2 = e2 ? e2(l2, c2, f2) : X, a2 === X && (a2 = fc(l2) ? l2 : Ci(t2[u2 + 1]) ? [] : {});
            }
            Sr2(f2, c2, a2), f2 = f2[c2];
          }
          return n2;
        }
        function cu(n2) {
          return Xi(ra(n2));
        }
        function au(n2, t2, r3) {
          var e2 = -1, u2 = n2.length;
          t2 < 0 && (t2 = -t2 > u2 ? 0 : u2 + t2), r3 = r3 > u2 ? u2 : r3, r3 < 0 && (r3 += u2), u2 = t2 > r3 ? 0 : r3 - t2 >>> 0, t2 >>>= 0;
          for (var i2 = il(u2); ++e2 < u2; ) i2[e2] = n2[e2 + t2];
          return i2;
        }
        function lu(n2, t2) {
          var r3;
          return ys(n2, function(n3, e2, u2) {
            return r3 = t2(n3, e2, u2), !r3;
          }), !!r3;
        }
        function su(n2, t2, r3) {
          var e2 = 0, u2 = null == n2 ? e2 : n2.length;
          if ("number" == typeof t2 && t2 === t2 && u2 <= Tn) {
            for (; e2 < u2; ) {
              var i2 = e2 + u2 >>> 1, o2 = n2[i2];
              null !== o2 && !bc(o2) && (r3 ? o2 <= t2 : o2 < t2) ? e2 = i2 + 1 : u2 = i2;
            }
            return u2;
          }
          return hu(n2, t2, La, r3);
        }
        function hu(n2, t2, r3, e2) {
          var u2 = 0, i2 = null == n2 ? 0 : n2.length;
          if (0 === i2) return 0;
          t2 = r3(t2);
          for (var o2 = t2 !== t2, f2 = null === t2, c2 = bc(t2), a2 = t2 === X; u2 < i2; ) {
            var l2 = Nl((u2 + i2) / 2), s2 = r3(n2[l2]), h2 = s2 !== X, p3 = null === s2, _2 = s2 === s2, v2 = bc(s2);
            if (o2) var g2 = e2 || _2;
            else g2 = a2 ? _2 && (e2 || h2) : f2 ? _2 && h2 && (e2 || !p3) : c2 ? _2 && h2 && !p3 && (e2 || !v2) : !p3 && !v2 && (e2 ? s2 <= t2 : s2 < t2);
            g2 ? u2 = l2 + 1 : i2 = l2;
          }
          return Hl(i2, Bn);
        }
        function pu(n2, t2) {
          for (var r3 = -1, e2 = n2.length, u2 = 0, i2 = []; ++r3 < e2; ) {
            var o2 = n2[r3], f2 = t2 ? t2(o2) : o2;
            if (!r3 || !Gf(f2, c2)) {
              var c2 = f2;
              i2[u2++] = 0 === o2 ? 0 : o2;
            }
          }
          return i2;
        }
        function _u(n2) {
          return "number" == typeof n2 ? n2 : bc(n2) ? Cn : +n2;
        }
        function vu(n2) {
          if ("string" == typeof n2) return n2;
          if (bh(n2)) return c(n2, vu) + "";
          if (bc(n2)) return vs ? vs.call(n2) : "";
          var t2 = n2 + "";
          return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
        }
        function gu(n2, t2, r3) {
          var e2 = -1, u2 = o, i2 = n2.length, c2 = true, a2 = [], l2 = a2;
          if (r3) c2 = false, u2 = f;
          else if (i2 >= tn) {
            var s2 = t2 ? null : ks(n2);
            if (s2) return P(s2);
            c2 = false, u2 = S, l2 = new yr2();
          } else l2 = t2 ? [] : a2;
          n: for (; ++e2 < i2; ) {
            var h2 = n2[e2], p3 = t2 ? t2(h2) : h2;
            if (h2 = r3 || 0 !== h2 ? h2 : 0, c2 && p3 === p3) {
              for (var _2 = l2.length; _2--; ) if (l2[_2] === p3) continue n;
              t2 && l2.push(p3), a2.push(h2);
            } else u2(l2, p3, r3) || (l2 !== a2 && l2.push(p3), a2.push(h2));
          }
          return a2;
        }
        function yu(n2, t2) {
          return t2 = ku(t2, n2), n2 = Gi(n2, t2), null == n2 || delete n2[no(jo(t2))];
        }
        function du(n2, t2, r3, e2) {
          return fu(n2, t2, r3(_e2(n2, t2)), e2);
        }
        function bu(n2, t2, r3, e2) {
          for (var u2 = n2.length, i2 = e2 ? u2 : -1; (e2 ? i2-- : ++i2 < u2) && t2(n2[i2], i2, n2); ) ;
          return r3 ? au(n2, e2 ? 0 : i2, e2 ? i2 + 1 : u2) : au(n2, e2 ? i2 + 1 : 0, e2 ? u2 : i2);
        }
        function wu(n2, t2) {
          var r3 = n2;
          return r3 instanceof Ct2 && (r3 = r3.value()), l(t2, function(n3, t3) {
            return t3.func.apply(t3.thisArg, a([n3], t3.args));
          }, r3);
        }
        function mu(n2, t2, r3) {
          var e2 = n2.length;
          if (e2 < 2) return e2 ? gu(n2[0]) : [];
          for (var u2 = -1, i2 = il(e2); ++u2 < e2; ) for (var o2 = n2[u2], f2 = -1; ++f2 < e2; ) f2 != u2 && (i2[u2] = Hr2(i2[u2] || o2, n2[f2], t2, r3));
          return gu(ee2(i2, 1), t2, r3);
        }
        function xu(n2, t2, r3) {
          for (var e2 = -1, u2 = n2.length, i2 = t2.length, o2 = {}; ++e2 < u2; ) {
            r3(o2, n2[e2], e2 < i2 ? t2[e2] : X);
          }
          return o2;
        }
        function ju(n2) {
          return Jf(n2) ? n2 : [];
        }
        function Au(n2) {
          return "function" == typeof n2 ? n2 : La;
        }
        function ku(n2, t2) {
          return bh(n2) ? n2 : Bi(n2, t2) ? [n2] : Cs(Ec(n2));
        }
        function Ou(n2, t2, r3) {
          var e2 = n2.length;
          return r3 = r3 === X ? e2 : r3, !t2 && r3 >= e2 ? n2 : au(n2, t2, r3);
        }
        function Iu(n2, t2) {
          if (t2) return n2.slice();
          var r3 = n2.length, e2 = zl ? zl(r3) : new n2.constructor(r3);
          return n2.copy(e2), e2;
        }
        function Ru(n2) {
          var t2 = new n2.constructor(n2.byteLength);
          return new Rl(t2).set(new Rl(n2)), t2;
        }
        function zu(n2, t2) {
          return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.byteLength);
        }
        function Eu(n2) {
          var t2 = new n2.constructor(n2.source, Nt.exec(n2));
          return t2.lastIndex = n2.lastIndex, t2;
        }
        function Su(n2) {
          return _s ? ll(_s.call(n2)) : {};
        }
        function Wu(n2, t2) {
          return new n2.constructor(t2 ? Ru(n2.buffer) : n2.buffer, n2.byteOffset, n2.length);
        }
        function Lu(n2, t2) {
          if (n2 !== t2) {
            var r3 = n2 !== X, e2 = null === n2, u2 = n2 === n2, i2 = bc(n2), o2 = t2 !== X, f2 = null === t2, c2 = t2 === t2, a2 = bc(t2);
            if (!f2 && !a2 && !i2 && n2 > t2 || i2 && o2 && c2 && !f2 && !a2 || e2 && o2 && c2 || !r3 && c2 || !u2) return 1;
            if (!e2 && !i2 && !a2 && n2 < t2 || a2 && r3 && u2 && !e2 && !i2 || f2 && r3 && u2 || !o2 && u2 || !c2) return -1;
          }
          return 0;
        }
        function Cu(n2, t2, r3) {
          for (var e2 = -1, u2 = n2.criteria, i2 = t2.criteria, o2 = u2.length, f2 = r3.length; ++e2 < o2; ) {
            var c2 = Lu(u2[e2], i2[e2]);
            if (c2) {
              if (e2 >= f2) return c2;
              return c2 * ("desc" == r3[e2] ? -1 : 1);
            }
          }
          return n2.index - t2.index;
        }
        function Uu(n2, t2, r3, e2) {
          for (var u2 = -1, i2 = n2.length, o2 = r3.length, f2 = -1, c2 = t2.length, a2 = Gl(i2 - o2, 0), l2 = il(c2 + a2), s2 = !e2; ++f2 < c2; ) l2[f2] = t2[f2];
          for (; ++u2 < o2; ) (s2 || u2 < i2) && (l2[r3[u2]] = n2[u2]);
          for (; a2--; ) l2[f2++] = n2[u2++];
          return l2;
        }
        function Bu(n2, t2, r3, e2) {
          for (var u2 = -1, i2 = n2.length, o2 = -1, f2 = r3.length, c2 = -1, a2 = t2.length, l2 = Gl(i2 - f2, 0), s2 = il(l2 + a2), h2 = !e2; ++u2 < l2; ) s2[u2] = n2[u2];
          for (var p3 = u2; ++c2 < a2; ) s2[p3 + c2] = t2[c2];
          for (; ++o2 < f2; ) (h2 || u2 < i2) && (s2[p3 + r3[o2]] = n2[u2++]);
          return s2;
        }
        function Tu(n2, t2) {
          var r3 = -1, e2 = n2.length;
          for (t2 || (t2 = il(e2)); ++r3 < e2; ) t2[r3] = n2[r3];
          return t2;
        }
        function $u(n2, t2, r3, e2) {
          var u2 = !r3;
          r3 || (r3 = {});
          for (var i2 = -1, o2 = t2.length; ++i2 < o2; ) {
            var f2 = t2[i2], c2 = e2 ? e2(r3[f2], n2[f2], f2, r3, n2) : X;
            c2 === X && (c2 = n2[f2]), u2 ? Br2(r3, f2, c2) : Sr2(r3, f2, c2);
          }
          return r3;
        }
        function Du(n2, t2) {
          return $u(n2, Is(n2), t2);
        }
        function Mu(n2, t2) {
          return $u(n2, Rs(n2), t2);
        }
        function Fu(n2, r3) {
          return function(e2, u2) {
            var i2 = bh(e2) ? t : Lr2, o2 = r3 ? r3() : {};
            return i2(e2, n2, mi(u2, 2), o2);
          };
        }
        function Nu(n2) {
          return uu(function(t2, r3) {
            var e2 = -1, u2 = r3.length, i2 = u2 > 1 ? r3[u2 - 1] : X, o2 = u2 > 2 ? r3[2] : X;
            for (i2 = n2.length > 3 && "function" == typeof i2 ? (u2--, i2) : X, o2 && Ui(r3[0], r3[1], o2) && (i2 = u2 < 3 ? X : i2, u2 = 1), t2 = ll(t2); ++e2 < u2; ) {
              var f2 = r3[e2];
              f2 && n2(t2, f2, e2, i2);
            }
            return t2;
          });
        }
        function Pu(n2, t2) {
          return function(r3, e2) {
            if (null == r3) return r3;
            if (!Hf(r3)) return n2(r3, e2);
            for (var u2 = r3.length, i2 = t2 ? u2 : -1, o2 = ll(r3); (t2 ? i2-- : ++i2 < u2) && e2(o2[i2], i2, o2) !== false; ) ;
            return r3;
          };
        }
        function qu(n2) {
          return function(t2, r3, e2) {
            for (var u2 = -1, i2 = ll(t2), o2 = e2(t2), f2 = o2.length; f2--; ) {
              var c2 = o2[n2 ? f2 : ++u2];
              if (r3(i2[c2], c2, i2) === false) break;
            }
            return t2;
          };
        }
        function Zu(n2, t2, r3) {
          function e2() {
            return (this && this !== re && this instanceof e2 ? i2 : n2).apply(u2 ? r3 : this, arguments);
          }
          var u2 = t2 & _n, i2 = Gu(n2);
          return e2;
        }
        function Ku(n2) {
          return function(t2) {
            t2 = Ec(t2);
            var r3 = T(t2) ? G(t2) : X, e2 = r3 ? r3[0] : t2.charAt(0), u2 = r3 ? Ou(r3, 1).join("") : t2.slice(1);
            return e2[n2]() + u2;
          };
        }
        function Vu(n2) {
          return function(t2) {
            return l(Ra(ca(t2).replace($r, "")), n2, "");
          };
        }
        function Gu(n2) {
          return function() {
            var t2 = arguments;
            switch (t2.length) {
              case 0:
                return new n2();
              case 1:
                return new n2(t2[0]);
              case 2:
                return new n2(t2[0], t2[1]);
              case 3:
                return new n2(t2[0], t2[1], t2[2]);
              case 4:
                return new n2(t2[0], t2[1], t2[2], t2[3]);
              case 5:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4]);
              case 6:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]);
              case 7:
                return new n2(t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]);
            }
            var r3 = gs(n2.prototype), e2 = n2.apply(r3, t2);
            return fc(e2) ? e2 : r3;
          };
        }
        function Hu(t2, r3, e2) {
          function u2() {
            for (var o2 = arguments.length, f2 = il(o2), c2 = o2, a2 = wi(u2); c2--; ) f2[c2] = arguments[c2];
            var l2 = o2 < 3 && f2[0] !== a2 && f2[o2 - 1] !== a2 ? [] : N(f2, a2);
            return o2 -= l2.length, o2 < e2 ? oi(t2, r3, Qu, u2.placeholder, X, f2, l2, X, X, e2 - o2) : n(this && this !== re && this instanceof u2 ? i2 : t2, this, f2);
          }
          var i2 = Gu(t2);
          return u2;
        }
        function Ju(n2) {
          return function(t2, r3, e2) {
            var u2 = ll(t2);
            if (!Hf(t2)) {
              var i2 = mi(r3, 3);
              t2 = Pc(t2), r3 = function(n3) {
                return i2(u2[n3], n3, u2);
              };
            }
            var o2 = n2(t2, r3, e2);
            return o2 > -1 ? u2[i2 ? t2[o2] : o2] : X;
          };
        }
        function Yu(n2) {
          return gi(function(t2) {
            var r3 = t2.length, e2 = r3, u2 = Y2.prototype.thru;
            for (n2 && t2.reverse(); e2--; ) {
              var i2 = t2[e2];
              if ("function" != typeof i2) throw new pl(en);
              if (u2 && !o2 && "wrapper" == bi(i2)) var o2 = new Y2([], true);
            }
            for (e2 = o2 ? e2 : r3; ++e2 < r3; ) {
              i2 = t2[e2];
              var f2 = bi(i2), c2 = "wrapper" == f2 ? Os(i2) : X;
              o2 = c2 && $i(c2[0]) && c2[1] == (mn | yn | bn | xn) && !c2[4].length && 1 == c2[9] ? o2[bi(c2[0])].apply(o2, c2[3]) : 1 == i2.length && $i(i2) ? o2[f2]() : o2.thru(i2);
            }
            return function() {
              var n3 = arguments, e3 = n3[0];
              if (o2 && 1 == n3.length && bh(e3)) return o2.plant(e3).value();
              for (var u3 = 0, i3 = r3 ? t2[u3].apply(this, n3) : e3; ++u3 < r3; ) i3 = t2[u3].call(this, i3);
              return i3;
            };
          });
        }
        function Qu(n2, t2, r3, e2, u2, i2, o2, f2, c2, a2) {
          function l2() {
            for (var y3 = arguments.length, d3 = il(y3), b2 = y3; b2--; ) d3[b2] = arguments[b2];
            if (_2) var w2 = wi(l2), m2 = C(d3, w2);
            if (e2 && (d3 = Uu(d3, e2, u2, _2)), i2 && (d3 = Bu(d3, i2, o2, _2)), y3 -= m2, _2 && y3 < a2) {
              return oi(n2, t2, Qu, l2.placeholder, r3, d3, N(d3, w2), f2, c2, a2 - y3);
            }
            var x4 = h2 ? r3 : this, j2 = p3 ? x4[n2] : n2;
            return y3 = d3.length, f2 ? d3 = Hi(d3, f2) : v2 && y3 > 1 && d3.reverse(), s2 && c2 < y3 && (d3.length = c2), this && this !== re && this instanceof l2 && (j2 = g2 || Gu(j2)), j2.apply(x4, d3);
          }
          var s2 = t2 & mn, h2 = t2 & _n, p3 = t2 & vn, _2 = t2 & (yn | dn), v2 = t2 & jn, g2 = p3 ? X : Gu(n2);
          return l2;
        }
        function Xu(n2, t2) {
          return function(r3, e2) {
            return Oe(r3, n2, t2(e2), {});
          };
        }
        function ni(n2, t2) {
          return function(r3, e2) {
            var u2;
            if (r3 === X && e2 === X) return t2;
            if (r3 !== X && (u2 = r3), e2 !== X) {
              if (u2 === X) return e2;
              "string" == typeof r3 || "string" == typeof e2 ? (r3 = vu(r3), e2 = vu(e2)) : (r3 = _u(r3), e2 = _u(e2)), u2 = n2(r3, e2);
            }
            return u2;
          };
        }
        function ti(t2) {
          return gi(function(r3) {
            return r3 = c(r3, z(mi())), uu(function(e2) {
              var u2 = this;
              return t2(r3, function(t3) {
                return n(t3, u2, e2);
              });
            });
          });
        }
        function ri(n2, t2) {
          t2 = t2 === X ? " " : vu(t2);
          var r3 = t2.length;
          if (r3 < 2) return r3 ? eu(t2, n2) : t2;
          var e2 = eu(t2, Fl(n2 / V(t2)));
          return T(t2) ? Ou(G(e2), 0, n2).join("") : e2.slice(0, n2);
        }
        function ei(t2, r3, e2, u2) {
          function i2() {
            for (var r4 = -1, c2 = arguments.length, a2 = -1, l2 = u2.length, s2 = il(l2 + c2), h2 = this && this !== re && this instanceof i2 ? f2 : t2; ++a2 < l2; ) s2[a2] = u2[a2];
            for (; c2--; ) s2[a2++] = arguments[++r4];
            return n(h2, o2 ? e2 : this, s2);
          }
          var o2 = r3 & _n, f2 = Gu(t2);
          return i2;
        }
        function ui(n2) {
          return function(t2, r3, e2) {
            return e2 && "number" != typeof e2 && Ui(t2, r3, e2) && (r3 = e2 = X), t2 = Ac(t2), r3 === X ? (r3 = t2, t2 = 0) : r3 = Ac(r3), e2 = e2 === X ? t2 < r3 ? 1 : -1 : Ac(e2), ru(t2, r3, e2, n2);
          };
        }
        function ii(n2) {
          return function(t2, r3) {
            return "string" == typeof t2 && "string" == typeof r3 || (t2 = Ic(t2), r3 = Ic(r3)), n2(t2, r3);
          };
        }
        function oi(n2, t2, r3, e2, u2, i2, o2, f2, c2, a2) {
          var l2 = t2 & yn, s2 = l2 ? o2 : X, h2 = l2 ? X : o2, p3 = l2 ? i2 : X, _2 = l2 ? X : i2;
          t2 |= l2 ? bn : wn, t2 &= ~(l2 ? wn : bn), t2 & gn || (t2 &= -4);
          var v2 = [n2, t2, u2, p3, s2, _2, h2, f2, c2, a2], g2 = r3.apply(X, v2);
          return $i(n2) && Ss(g2, v2), g2.placeholder = e2, Yi(g2, n2, t2);
        }
        function fi(n2) {
          var t2 = al[n2];
          return function(n3, r3) {
            if (n3 = Ic(n3), r3 = null == r3 ? 0 : Hl(kc(r3), 292), r3 && Zl(n3)) {
              var e2 = (Ec(n3) + "e").split("e");
              return e2 = (Ec(t2(e2[0] + "e" + (+e2[1] + r3))) + "e").split("e"), +(e2[0] + "e" + (+e2[1] - r3));
            }
            return t2(n3);
          };
        }
        function ci(n2) {
          return function(t2) {
            var r3 = zs(t2);
            return r3 == Gn ? M(t2) : r3 == tt ? q(t2) : I(t2, n2(t2));
          };
        }
        function ai(n2, t2, r3, e2, u2, i2, o2, f2) {
          var c2 = t2 & vn;
          if (!c2 && "function" != typeof n2) throw new pl(en);
          var a2 = e2 ? e2.length : 0;
          if (a2 || (t2 &= -97, e2 = u2 = X), o2 = o2 === X ? o2 : Gl(kc(o2), 0), f2 = f2 === X ? f2 : kc(f2), a2 -= u2 ? u2.length : 0, t2 & wn) {
            var l2 = e2, s2 = u2;
            e2 = u2 = X;
          }
          var h2 = c2 ? X : Os(n2), p3 = [n2, t2, r3, e2, u2, l2, s2, i2, o2, f2];
          if (h2 && qi(p3, h2), n2 = p3[0], t2 = p3[1], r3 = p3[2], e2 = p3[3], u2 = p3[4], f2 = p3[9] = p3[9] === X ? c2 ? 0 : n2.length : Gl(p3[9] - a2, 0), !f2 && t2 & (yn | dn) && (t2 &= -25), t2 && t2 != _n) _2 = t2 == yn || t2 == dn ? Hu(n2, t2, f2) : t2 != bn && t2 != (_n | bn) || u2.length ? Qu.apply(X, p3) : ei(n2, t2, r3, e2);
          else var _2 = Zu(n2, t2, r3);
          return Yi((h2 ? ms : Ss)(_2, p3), n2, t2);
        }
        function li(n2, t2, r3, e2) {
          return n2 === X || Gf(n2, gl[r3]) && !bl.call(e2, r3) ? t2 : n2;
        }
        function si(n2, t2, r3, e2, u2, i2) {
          return fc(n2) && fc(t2) && (i2.set(t2, n2), Ke(n2, t2, X, si, i2), i2.delete(t2)), n2;
        }
        function hi(n2) {
          return gc(n2) ? X : n2;
        }
        function pi2(n2, t2, r3, e2, u2, i2) {
          var o2 = r3 & hn, f2 = n2.length, c2 = t2.length;
          if (f2 != c2 && !(o2 && c2 > f2)) return false;
          var a2 = i2.get(n2), l2 = i2.get(t2);
          if (a2 && l2) return a2 == t2 && l2 == n2;
          var s2 = -1, p3 = true, _2 = r3 & pn ? new yr2() : X;
          for (i2.set(n2, t2), i2.set(t2, n2); ++s2 < f2; ) {
            var v2 = n2[s2], g2 = t2[s2];
            if (e2) var y3 = o2 ? e2(g2, v2, s2, t2, n2, i2) : e2(v2, g2, s2, n2, t2, i2);
            if (y3 !== X) {
              if (y3) continue;
              p3 = false;
              break;
            }
            if (_2) {
              if (!h(t2, function(n3, t3) {
                if (!S(_2, t3) && (v2 === n3 || u2(v2, n3, r3, e2, i2))) return _2.push(t3);
              })) {
                p3 = false;
                break;
              }
            } else if (v2 !== g2 && !u2(v2, g2, r3, e2, i2)) {
              p3 = false;
              break;
            }
          }
          return i2.delete(n2), i2.delete(t2), p3;
        }
        function _i(n2, t2, r3, e2, u2, i2, o2) {
          switch (r3) {
            case ct:
              if (n2.byteLength != t2.byteLength || n2.byteOffset != t2.byteOffset) return false;
              n2 = n2.buffer, t2 = t2.buffer;
            case ft:
              return !(n2.byteLength != t2.byteLength || !i2(new Rl(n2), new Rl(t2)));
            case Nn:
            case Pn:
            case Hn:
              return Gf(+n2, +t2);
            case Zn:
              return n2.name == t2.name && n2.message == t2.message;
            case nt:
            case rt:
              return n2 == t2 + "";
            case Gn:
              var f2 = M;
            case tt:
              var c2 = e2 & hn;
              if (f2 || (f2 = P), n2.size != t2.size && !c2) return false;
              var a2 = o2.get(n2);
              if (a2) return a2 == t2;
              e2 |= pn, o2.set(n2, t2);
              var l2 = pi2(f2(n2), f2(t2), e2, u2, i2, o2);
              return o2.delete(n2), l2;
            case et:
              if (_s) return _s.call(n2) == _s.call(t2);
          }
          return false;
        }
        function vi(n2, t2, r3, e2, u2, i2) {
          var o2 = r3 & hn, f2 = yi(n2), c2 = f2.length;
          if (c2 != yi(t2).length && !o2) return false;
          for (var a2 = c2; a2--; ) {
            var l2 = f2[a2];
            if (!(o2 ? l2 in t2 : bl.call(t2, l2))) return false;
          }
          var s2 = i2.get(n2), h2 = i2.get(t2);
          if (s2 && h2) return s2 == t2 && h2 == n2;
          var p3 = true;
          i2.set(n2, t2), i2.set(t2, n2);
          for (var _2 = o2; ++a2 < c2; ) {
            l2 = f2[a2];
            var v2 = n2[l2], g2 = t2[l2];
            if (e2) var y3 = o2 ? e2(g2, v2, l2, t2, n2, i2) : e2(v2, g2, l2, n2, t2, i2);
            if (!(y3 === X ? v2 === g2 || u2(v2, g2, r3, e2, i2) : y3)) {
              p3 = false;
              break;
            }
            _2 || (_2 = "constructor" == l2);
          }
          if (p3 && !_2) {
            var d3 = n2.constructor, b2 = t2.constructor;
            d3 != b2 && "constructor" in n2 && "constructor" in t2 && !("function" == typeof d3 && d3 instanceof d3 && "function" == typeof b2 && b2 instanceof b2) && (p3 = false);
          }
          return i2.delete(n2), i2.delete(t2), p3;
        }
        function gi(n2) {
          return Ls(Vi(n2, X, _o), n2 + "");
        }
        function yi(n2) {
          return de2(n2, Pc, Is);
        }
        function di(n2) {
          return de2(n2, qc, Rs);
        }
        function bi(n2) {
          for (var t2 = n2.name + "", r3 = fs[t2], e2 = bl.call(fs, t2) ? r3.length : 0; e2--; ) {
            var u2 = r3[e2], i2 = u2.func;
            if (null == i2 || i2 == n2) return u2.name;
          }
          return t2;
        }
        function wi(n2) {
          return (bl.call(Z2, "placeholder") ? Z2 : n2).placeholder;
        }
        function mi() {
          var n2 = Z2.iteratee || Ca;
          return n2 = n2 === Ca ? De : n2, arguments.length ? n2(arguments[0], arguments[1]) : n2;
        }
        function xi(n2, t2) {
          var r3 = n2.__data__;
          return Ti(t2) ? r3["string" == typeof t2 ? "string" : "hash"] : r3.map;
        }
        function ji(n2) {
          for (var t2 = Pc(n2), r3 = t2.length; r3--; ) {
            var e2 = t2[r3], u2 = n2[e2];
            t2[r3] = [e2, u2, Fi(u2)];
          }
          return t2;
        }
        function Ai(n2, t2) {
          var r3 = B(n2, t2);
          return Ue(r3) ? r3 : X;
        }
        function ki(n2) {
          var t2 = bl.call(n2, Bl), r3 = n2[Bl];
          try {
            n2[Bl] = X;
            var e2 = true;
          } catch (n3) {
          }
          var u2 = xl.call(n2);
          return e2 && (t2 ? n2[Bl] = r3 : delete n2[Bl]), u2;
        }
        function Oi(n2, t2, r3) {
          for (var e2 = -1, u2 = r3.length; ++e2 < u2; ) {
            var i2 = r3[e2], o2 = i2.size;
            switch (i2.type) {
              case "drop":
                n2 += o2;
                break;
              case "dropRight":
                t2 -= o2;
                break;
              case "take":
                t2 = Hl(t2, n2 + o2);
                break;
              case "takeRight":
                n2 = Gl(n2, t2 - o2);
            }
          }
          return { start: n2, end: t2 };
        }
        function Ii(n2) {
          var t2 = n2.match(Bt);
          return t2 ? t2[1].split(Tt) : [];
        }
        function Ri(n2, t2, r3) {
          t2 = ku(t2, n2);
          for (var e2 = -1, u2 = t2.length, i2 = false; ++e2 < u2; ) {
            var o2 = no(t2[e2]);
            if (!(i2 = null != n2 && r3(n2, o2))) break;
            n2 = n2[o2];
          }
          return i2 || ++e2 != u2 ? i2 : (u2 = null == n2 ? 0 : n2.length, !!u2 && oc(u2) && Ci(o2, u2) && (bh(n2) || dh(n2)));
        }
        function zi(n2) {
          var t2 = n2.length, r3 = new n2.constructor(t2);
          return t2 && "string" == typeof n2[0] && bl.call(n2, "index") && (r3.index = n2.index, r3.input = n2.input), r3;
        }
        function Ei(n2) {
          return "function" != typeof n2.constructor || Mi(n2) ? {} : gs(El(n2));
        }
        function Si(n2, t2, r3) {
          var e2 = n2.constructor;
          switch (t2) {
            case ft:
              return Ru(n2);
            case Nn:
            case Pn:
              return new e2(+n2);
            case ct:
              return zu(n2, r3);
            case at:
            case lt:
            case st:
            case ht:
            case pt:
            case _t:
            case vt:
            case gt:
            case yt:
              return Wu(n2, r3);
            case Gn:
              return new e2();
            case Hn:
            case rt:
              return new e2(n2);
            case nt:
              return Eu(n2);
            case tt:
              return new e2();
            case et:
              return Su(n2);
          }
        }
        function Wi(n2, t2) {
          var r3 = t2.length;
          if (!r3) return n2;
          var e2 = r3 - 1;
          return t2[e2] = (r3 > 1 ? "& " : "") + t2[e2], t2 = t2.join(r3 > 2 ? ", " : " "), n2.replace(Ut, "{\n/* [wrapped with " + t2 + "] */\n");
        }
        function Li(n2) {
          return bh(n2) || dh(n2) || !!(Cl && n2 && n2[Cl]);
        }
        function Ci(n2, t2) {
          var r3 = typeof n2;
          return t2 = null == t2 ? Wn : t2, !!t2 && ("number" == r3 || "symbol" != r3 && Vt.test(n2)) && n2 > -1 && n2 % 1 == 0 && n2 < t2;
        }
        function Ui(n2, t2, r3) {
          if (!fc(r3)) return false;
          var e2 = typeof t2;
          return !!("number" == e2 ? Hf(r3) && Ci(t2, r3.length) : "string" == e2 && t2 in r3) && Gf(r3[t2], n2);
        }
        function Bi(n2, t2) {
          if (bh(n2)) return false;
          var r3 = typeof n2;
          return !("number" != r3 && "symbol" != r3 && "boolean" != r3 && null != n2 && !bc(n2)) || (zt.test(n2) || !Rt.test(n2) || null != t2 && n2 in ll(t2));
        }
        function Ti(n2) {
          var t2 = typeof n2;
          return "string" == t2 || "number" == t2 || "symbol" == t2 || "boolean" == t2 ? "__proto__" !== n2 : null === n2;
        }
        function $i(n2) {
          var t2 = bi(n2), r3 = Z2[t2];
          if ("function" != typeof r3 || !(t2 in Ct2.prototype)) return false;
          if (n2 === r3) return true;
          var e2 = Os(r3);
          return !!e2 && n2 === e2[0];
        }
        function Di(n2) {
          return !!ml && ml in n2;
        }
        function Mi(n2) {
          var t2 = n2 && n2.constructor;
          return n2 === ("function" == typeof t2 && t2.prototype || gl);
        }
        function Fi(n2) {
          return n2 === n2 && !fc(n2);
        }
        function Ni(n2, t2) {
          return function(r3) {
            return null != r3 && (r3[n2] === t2 && (t2 !== X || n2 in ll(r3)));
          };
        }
        function Pi(n2) {
          var t2 = Cf(n2, function(n3) {
            return r3.size === fn && r3.clear(), n3;
          }), r3 = t2.cache;
          return t2;
        }
        function qi(n2, t2) {
          var r3 = n2[1], e2 = t2[1], u2 = r3 | e2, i2 = u2 < (_n | vn | mn), o2 = e2 == mn && r3 == yn || e2 == mn && r3 == xn && n2[7].length <= t2[8] || e2 == (mn | xn) && t2[7].length <= t2[8] && r3 == yn;
          if (!i2 && !o2) return n2;
          e2 & _n && (n2[2] = t2[2], u2 |= r3 & _n ? 0 : gn);
          var f2 = t2[3];
          if (f2) {
            var c2 = n2[3];
            n2[3] = c2 ? Uu(c2, f2, t2[4]) : f2, n2[4] = c2 ? N(n2[3], cn) : t2[4];
          }
          return f2 = t2[5], f2 && (c2 = n2[5], n2[5] = c2 ? Bu(c2, f2, t2[6]) : f2, n2[6] = c2 ? N(n2[5], cn) : t2[6]), f2 = t2[7], f2 && (n2[7] = f2), e2 & mn && (n2[8] = null == n2[8] ? t2[8] : Hl(n2[8], t2[8])), null == n2[9] && (n2[9] = t2[9]), n2[0] = t2[0], n2[1] = u2, n2;
        }
        function Zi(n2) {
          var t2 = [];
          if (null != n2) for (var r3 in ll(n2)) t2.push(r3);
          return t2;
        }
        function Ki(n2) {
          return xl.call(n2);
        }
        function Vi(t2, r3, e2) {
          return r3 = Gl(r3 === X ? t2.length - 1 : r3, 0), function() {
            for (var u2 = arguments, i2 = -1, o2 = Gl(u2.length - r3, 0), f2 = il(o2); ++i2 < o2; ) f2[i2] = u2[r3 + i2];
            i2 = -1;
            for (var c2 = il(r3 + 1); ++i2 < r3; ) c2[i2] = u2[i2];
            return c2[r3] = e2(f2), n(t2, this, c2);
          };
        }
        function Gi(n2, t2) {
          return t2.length < 2 ? n2 : _e2(n2, au(t2, 0, -1));
        }
        function Hi(n2, t2) {
          for (var r3 = n2.length, e2 = Hl(t2.length, r3), u2 = Tu(n2); e2--; ) {
            var i2 = t2[e2];
            n2[e2] = Ci(i2, r3) ? u2[i2] : X;
          }
          return n2;
        }
        function Ji(n2, t2) {
          if (("constructor" !== t2 || "function" != typeof n2[t2]) && "__proto__" != t2) return n2[t2];
        }
        function Yi(n2, t2, r3) {
          var e2 = t2 + "";
          return Ls(n2, Wi(e2, ro(Ii(e2), r3)));
        }
        function Qi(n2) {
          var t2 = 0, r3 = 0;
          return function() {
            var e2 = Jl(), u2 = In - (e2 - r3);
            if (r3 = e2, u2 > 0) {
              if (++t2 >= On) return arguments[0];
            } else t2 = 0;
            return n2.apply(X, arguments);
          };
        }
        function Xi(n2, t2) {
          var r3 = -1, e2 = n2.length, u2 = e2 - 1;
          for (t2 = t2 === X ? e2 : t2; ++r3 < t2; ) {
            var i2 = tu(r3, u2), o2 = n2[i2];
            n2[i2] = n2[r3], n2[r3] = o2;
          }
          return n2.length = t2, n2;
        }
        function no(n2) {
          if ("string" == typeof n2 || bc(n2)) return n2;
          var t2 = n2 + "";
          return "0" == t2 && 1 / n2 == -Sn ? "-0" : t2;
        }
        function to(n2) {
          if (null != n2) {
            try {
              return dl.call(n2);
            } catch (n3) {
            }
            try {
              return n2 + "";
            } catch (n3) {
            }
          }
          return "";
        }
        function ro(n2, t2) {
          return r2($n, function(r3) {
            var e2 = "_." + r3[0];
            t2 & r3[1] && !o(n2, e2) && n2.push(e2);
          }), n2.sort();
        }
        function eo(n2) {
          if (n2 instanceof Ct2) return n2.clone();
          var t2 = new Y2(n2.__wrapped__, n2.__chain__);
          return t2.__actions__ = Tu(n2.__actions__), t2.__index__ = n2.__index__, t2.__values__ = n2.__values__, t2;
        }
        function uo(n2, t2, r3) {
          t2 = (r3 ? Ui(n2, t2, r3) : t2 === X) ? 1 : Gl(kc(t2), 0);
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2 || t2 < 1) return [];
          for (var u2 = 0, i2 = 0, o2 = il(Fl(e2 / t2)); u2 < e2; ) o2[i2++] = au(n2, u2, u2 += t2);
          return o2;
        }
        function io(n2) {
          for (var t2 = -1, r3 = null == n2 ? 0 : n2.length, e2 = 0, u2 = []; ++t2 < r3; ) {
            var i2 = n2[t2];
            i2 && (u2[e2++] = i2);
          }
          return u2;
        }
        function oo() {
          var n2 = arguments.length;
          if (!n2) return [];
          for (var t2 = il(n2 - 1), r3 = arguments[0], e2 = n2; e2--; ) t2[e2 - 1] = arguments[e2];
          return a(bh(r3) ? Tu(r3) : [r3], ee2(t2, 1));
        }
        function fo(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r3 || t2 === X ? 1 : kc(t2), au(n2, t2 < 0 ? 0 : t2, e2)) : [];
        }
        function co(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r3 || t2 === X ? 1 : kc(t2), t2 = e2 - t2, au(n2, 0, t2 < 0 ? 0 : t2)) : [];
        }
        function ao(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), true, true) : [];
        }
        function lo(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), true) : [];
        }
        function so(n2, t2, r3, e2) {
          var u2 = null == n2 ? 0 : n2.length;
          return u2 ? (r3 && "number" != typeof r3 && Ui(n2, t2, r3) && (r3 = 0, e2 = u2), ne2(n2, t2, r3, e2)) : [];
        }
        function ho(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = null == r3 ? 0 : kc(r3);
          return u2 < 0 && (u2 = Gl(e2 + u2, 0)), g(n2, mi(t2, 3), u2);
        }
        function po(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = e2 - 1;
          return r3 !== X && (u2 = kc(r3), u2 = r3 < 0 ? Gl(e2 + u2, 0) : Hl(u2, e2 - 1)), g(n2, mi(t2, 3), u2, true);
        }
        function _o(n2) {
          return (null == n2 ? 0 : n2.length) ? ee2(n2, 1) : [];
        }
        function vo(n2) {
          return (null == n2 ? 0 : n2.length) ? ee2(n2, Sn) : [];
        }
        function go(n2, t2) {
          return (null == n2 ? 0 : n2.length) ? (t2 = t2 === X ? 1 : kc(t2), ee2(n2, t2)) : [];
        }
        function yo(n2) {
          for (var t2 = -1, r3 = null == n2 ? 0 : n2.length, e2 = {}; ++t2 < r3; ) {
            var u2 = n2[t2];
            e2[u2[0]] = u2[1];
          }
          return e2;
        }
        function bo(n2) {
          return n2 && n2.length ? n2[0] : X;
        }
        function wo(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = null == r3 ? 0 : kc(r3);
          return u2 < 0 && (u2 = Gl(e2 + u2, 0)), y2(n2, t2, u2);
        }
        function mo(n2) {
          return (null == n2 ? 0 : n2.length) ? au(n2, 0, -1) : [];
        }
        function xo(n2, t2) {
          return null == n2 ? "" : Kl.call(n2, t2);
        }
        function jo(n2) {
          var t2 = null == n2 ? 0 : n2.length;
          return t2 ? n2[t2 - 1] : X;
        }
        function Ao(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          if (!e2) return -1;
          var u2 = e2;
          return r3 !== X && (u2 = kc(r3), u2 = u2 < 0 ? Gl(e2 + u2, 0) : Hl(u2, e2 - 1)), t2 === t2 ? K(n2, t2, u2) : g(n2, b, u2, true);
        }
        function ko(n2, t2) {
          return n2 && n2.length ? Ge(n2, kc(t2)) : X;
        }
        function Oo(n2, t2) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2) : n2;
        }
        function Io(n2, t2, r3) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, mi(r3, 2)) : n2;
        }
        function Ro(n2, t2, r3) {
          return n2 && n2.length && t2 && t2.length ? Xe(n2, t2, X, r3) : n2;
        }
        function zo(n2, t2) {
          var r3 = [];
          if (!n2 || !n2.length) return r3;
          var e2 = -1, u2 = [], i2 = n2.length;
          for (t2 = mi(t2, 3); ++e2 < i2; ) {
            var o2 = n2[e2];
            t2(o2, e2, n2) && (r3.push(o2), u2.push(e2));
          }
          return nu(n2, u2), r3;
        }
        function Eo(n2) {
          return null == n2 ? n2 : Xl.call(n2);
        }
        function So(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (r3 && "number" != typeof r3 && Ui(n2, t2, r3) ? (t2 = 0, r3 = e2) : (t2 = null == t2 ? 0 : kc(t2), r3 = r3 === X ? e2 : kc(r3)), au(n2, t2, r3)) : [];
        }
        function Wo(n2, t2) {
          return su(n2, t2);
        }
        function Lo(n2, t2, r3) {
          return hu(n2, t2, mi(r3, 2));
        }
        function Co(n2, t2) {
          var r3 = null == n2 ? 0 : n2.length;
          if (r3) {
            var e2 = su(n2, t2);
            if (e2 < r3 && Gf(n2[e2], t2)) return e2;
          }
          return -1;
        }
        function Uo(n2, t2) {
          return su(n2, t2, true);
        }
        function Bo(n2, t2, r3) {
          return hu(n2, t2, mi(r3, 2), true);
        }
        function To(n2, t2) {
          if (null == n2 ? 0 : n2.length) {
            var r3 = su(n2, t2, true) - 1;
            if (Gf(n2[r3], t2)) return r3;
          }
          return -1;
        }
        function $o(n2) {
          return n2 && n2.length ? pu(n2) : [];
        }
        function Do(n2, t2) {
          return n2 && n2.length ? pu(n2, mi(t2, 2)) : [];
        }
        function Mo(n2) {
          var t2 = null == n2 ? 0 : n2.length;
          return t2 ? au(n2, 1, t2) : [];
        }
        function Fo(n2, t2, r3) {
          return n2 && n2.length ? (t2 = r3 || t2 === X ? 1 : kc(t2), au(n2, 0, t2 < 0 ? 0 : t2)) : [];
        }
        function No(n2, t2, r3) {
          var e2 = null == n2 ? 0 : n2.length;
          return e2 ? (t2 = r3 || t2 === X ? 1 : kc(t2), t2 = e2 - t2, au(n2, t2 < 0 ? 0 : t2, e2)) : [];
        }
        function Po(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3), false, true) : [];
        }
        function qo(n2, t2) {
          return n2 && n2.length ? bu(n2, mi(t2, 3)) : [];
        }
        function Zo(n2) {
          return n2 && n2.length ? gu(n2) : [];
        }
        function Ko(n2, t2) {
          return n2 && n2.length ? gu(n2, mi(t2, 2)) : [];
        }
        function Vo(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, n2 && n2.length ? gu(n2, X, t2) : [];
        }
        function Go(n2) {
          if (!n2 || !n2.length) return [];
          var t2 = 0;
          return n2 = i(n2, function(n3) {
            if (Jf(n3)) return t2 = Gl(n3.length, t2), true;
          }), O(t2, function(t3) {
            return c(n2, m(t3));
          });
        }
        function Ho(t2, r3) {
          if (!t2 || !t2.length) return [];
          var e2 = Go(t2);
          return null == r3 ? e2 : c(e2, function(t3) {
            return n(r3, X, t3);
          });
        }
        function Jo(n2, t2) {
          return xu(n2 || [], t2 || [], Sr2);
        }
        function Yo(n2, t2) {
          return xu(n2 || [], t2 || [], fu);
        }
        function Qo(n2) {
          var t2 = Z2(n2);
          return t2.__chain__ = true, t2;
        }
        function Xo(n2, t2) {
          return t2(n2), n2;
        }
        function nf(n2, t2) {
          return t2(n2);
        }
        function tf() {
          return Qo(this);
        }
        function rf() {
          return new Y2(this.value(), this.__chain__);
        }
        function ef() {
          this.__values__ === X && (this.__values__ = jc(this.value()));
          var n2 = this.__index__ >= this.__values__.length;
          return { done: n2, value: n2 ? X : this.__values__[this.__index__++] };
        }
        function uf() {
          return this;
        }
        function of(n2) {
          for (var t2, r3 = this; r3 instanceof J2; ) {
            var e2 = eo(r3);
            e2.__index__ = 0, e2.__values__ = X, t2 ? u2.__wrapped__ = e2 : t2 = e2;
            var u2 = e2;
            r3 = r3.__wrapped__;
          }
          return u2.__wrapped__ = n2, t2;
        }
        function ff() {
          var n2 = this.__wrapped__;
          if (n2 instanceof Ct2) {
            var t2 = n2;
            return this.__actions__.length && (t2 = new Ct2(this)), t2 = t2.reverse(), t2.__actions__.push({ func: nf, args: [Eo], thisArg: X }), new Y2(t2, this.__chain__);
          }
          return this.thru(Eo);
        }
        function cf() {
          return wu(this.__wrapped__, this.__actions__);
        }
        function af(n2, t2, r3) {
          var e2 = bh(n2) ? u : Jr2;
          return r3 && Ui(n2, t2, r3) && (t2 = X), e2(n2, mi(t2, 3));
        }
        function lf(n2, t2) {
          return (bh(n2) ? i : te2)(n2, mi(t2, 3));
        }
        function sf(n2, t2) {
          return ee2(yf(n2, t2), 1);
        }
        function hf(n2, t2) {
          return ee2(yf(n2, t2), Sn);
        }
        function pf(n2, t2, r3) {
          return r3 = r3 === X ? 1 : kc(r3), ee2(yf(n2, t2), r3);
        }
        function _f(n2, t2) {
          return (bh(n2) ? r2 : ys)(n2, mi(t2, 3));
        }
        function vf(n2, t2) {
          return (bh(n2) ? e : ds)(n2, mi(t2, 3));
        }
        function gf(n2, t2, r3, e2) {
          n2 = Hf(n2) ? n2 : ra(n2), r3 = r3 && !e2 ? kc(r3) : 0;
          var u2 = n2.length;
          return r3 < 0 && (r3 = Gl(u2 + r3, 0)), dc(n2) ? r3 <= u2 && n2.indexOf(t2, r3) > -1 : !!u2 && y2(n2, t2, r3) > -1;
        }
        function yf(n2, t2) {
          return (bh(n2) ? c : Pe)(n2, mi(t2, 3));
        }
        function df(n2, t2, r3, e2) {
          return null == n2 ? [] : (bh(t2) || (t2 = null == t2 ? [] : [t2]), r3 = e2 ? X : r3, bh(r3) || (r3 = null == r3 ? [] : [r3]), He(n2, t2, r3));
        }
        function bf(n2, t2, r3) {
          var e2 = bh(n2) ? l : j, u2 = arguments.length < 3;
          return e2(n2, mi(t2, 4), r3, u2, ys);
        }
        function wf(n2, t2, r3) {
          var e2 = bh(n2) ? s : j, u2 = arguments.length < 3;
          return e2(n2, mi(t2, 4), r3, u2, ds);
        }
        function mf(n2, t2) {
          return (bh(n2) ? i : te2)(n2, Uf(mi(t2, 3)));
        }
        function xf(n2) {
          return (bh(n2) ? Ir2 : iu)(n2);
        }
        function jf(n2, t2, r3) {
          return t2 = (r3 ? Ui(n2, t2, r3) : t2 === X) ? 1 : kc(t2), (bh(n2) ? Rr2 : ou)(n2, t2);
        }
        function Af(n2) {
          return (bh(n2) ? zr2 : cu)(n2);
        }
        function kf(n2) {
          if (null == n2) return 0;
          if (Hf(n2)) return dc(n2) ? V(n2) : n2.length;
          var t2 = zs(n2);
          return t2 == Gn || t2 == tt ? n2.size : Me(n2).length;
        }
        function Of(n2, t2, r3) {
          var e2 = bh(n2) ? h : lu;
          return r3 && Ui(n2, t2, r3) && (t2 = X), e2(n2, mi(t2, 3));
        }
        function If(n2, t2) {
          if ("function" != typeof t2) throw new pl(en);
          return n2 = kc(n2), function() {
            if (--n2 < 1) return t2.apply(this, arguments);
          };
        }
        function Rf(n2, t2, r3) {
          return t2 = r3 ? X : t2, t2 = n2 && null == t2 ? n2.length : t2, ai(n2, mn, X, X, X, X, t2);
        }
        function zf(n2, t2) {
          var r3;
          if ("function" != typeof t2) throw new pl(en);
          return n2 = kc(n2), function() {
            return --n2 > 0 && (r3 = t2.apply(this, arguments)), n2 <= 1 && (t2 = X), r3;
          };
        }
        function Ef(n2, t2, r3) {
          t2 = r3 ? X : t2;
          var e2 = ai(n2, yn, X, X, X, X, X, t2);
          return e2.placeholder = Ef.placeholder, e2;
        }
        function Sf(n2, t2, r3) {
          t2 = r3 ? X : t2;
          var e2 = ai(n2, dn, X, X, X, X, X, t2);
          return e2.placeholder = Sf.placeholder, e2;
        }
        function Wf(n2, t2, r3) {
          function e2(t3) {
            var r4 = h2, e3 = p3;
            return h2 = p3 = X, d3 = t3, v2 = n2.apply(e3, r4);
          }
          function u2(n3) {
            return d3 = n3, g2 = Ws(f2, t2), b2 ? e2(n3) : v2;
          }
          function i2(n3) {
            var r4 = n3 - y3, e3 = n3 - d3, u3 = t2 - r4;
            return w2 ? Hl(u3, _2 - e3) : u3;
          }
          function o2(n3) {
            var r4 = n3 - y3, e3 = n3 - d3;
            return y3 === X || r4 >= t2 || r4 < 0 || w2 && e3 >= _2;
          }
          function f2() {
            var n3 = fh();
            return o2(n3) ? c2(n3) : (g2 = Ws(f2, i2(n3)), X);
          }
          function c2(n3) {
            return g2 = X, m2 && h2 ? e2(n3) : (h2 = p3 = X, v2);
          }
          function a2() {
            g2 !== X && As(g2), d3 = 0, h2 = y3 = p3 = g2 = X;
          }
          function l2() {
            return g2 === X ? v2 : c2(fh());
          }
          function s2() {
            var n3 = fh(), r4 = o2(n3);
            if (h2 = arguments, p3 = this, y3 = n3, r4) {
              if (g2 === X) return u2(y3);
              if (w2) return As(g2), g2 = Ws(f2, t2), e2(y3);
            }
            return g2 === X && (g2 = Ws(f2, t2)), v2;
          }
          var h2, p3, _2, v2, g2, y3, d3 = 0, b2 = false, w2 = false, m2 = true;
          if ("function" != typeof n2) throw new pl(en);
          return t2 = Ic(t2) || 0, fc(r3) && (b2 = !!r3.leading, w2 = "maxWait" in r3, _2 = w2 ? Gl(Ic(r3.maxWait) || 0, t2) : _2, m2 = "trailing" in r3 ? !!r3.trailing : m2), s2.cancel = a2, s2.flush = l2, s2;
        }
        function Lf(n2) {
          return ai(n2, jn);
        }
        function Cf(n2, t2) {
          if ("function" != typeof n2 || null != t2 && "function" != typeof t2) throw new pl(en);
          var r3 = function() {
            var e2 = arguments, u2 = t2 ? t2.apply(this, e2) : e2[0], i2 = r3.cache;
            if (i2.has(u2)) return i2.get(u2);
            var o2 = n2.apply(this, e2);
            return r3.cache = i2.set(u2, o2) || i2, o2;
          };
          return r3.cache = new (Cf.Cache || sr2)(), r3;
        }
        function Uf(n2) {
          if ("function" != typeof n2) throw new pl(en);
          return function() {
            var t2 = arguments;
            switch (t2.length) {
              case 0:
                return !n2.call(this);
              case 1:
                return !n2.call(this, t2[0]);
              case 2:
                return !n2.call(this, t2[0], t2[1]);
              case 3:
                return !n2.call(this, t2[0], t2[1], t2[2]);
            }
            return !n2.apply(this, t2);
          };
        }
        function Bf(n2) {
          return zf(2, n2);
        }
        function Tf(n2, t2) {
          if ("function" != typeof n2) throw new pl(en);
          return t2 = t2 === X ? t2 : kc(t2), uu(n2, t2);
        }
        function $f(t2, r3) {
          if ("function" != typeof t2) throw new pl(en);
          return r3 = null == r3 ? 0 : Gl(kc(r3), 0), uu(function(e2) {
            var u2 = e2[r3], i2 = Ou(e2, 0, r3);
            return u2 && a(i2, u2), n(t2, this, i2);
          });
        }
        function Df(n2, t2, r3) {
          var e2 = true, u2 = true;
          if ("function" != typeof n2) throw new pl(en);
          return fc(r3) && (e2 = "leading" in r3 ? !!r3.leading : e2, u2 = "trailing" in r3 ? !!r3.trailing : u2), Wf(n2, t2, { leading: e2, maxWait: t2, trailing: u2 });
        }
        function Mf(n2) {
          return Rf(n2, 1);
        }
        function Ff(n2, t2) {
          return ph(Au(t2), n2);
        }
        function Nf() {
          if (!arguments.length) return [];
          var n2 = arguments[0];
          return bh(n2) ? n2 : [n2];
        }
        function Pf(n2) {
          return Fr2(n2, sn);
        }
        function qf(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, sn, t2);
        }
        function Zf(n2) {
          return Fr2(n2, an | sn);
        }
        function Kf(n2, t2) {
          return t2 = "function" == typeof t2 ? t2 : X, Fr2(n2, an | sn, t2);
        }
        function Vf(n2, t2) {
          return null == t2 || Pr2(n2, t2, Pc(t2));
        }
        function Gf(n2, t2) {
          return n2 === t2 || n2 !== n2 && t2 !== t2;
        }
        function Hf(n2) {
          return null != n2 && oc(n2.length) && !uc(n2);
        }
        function Jf(n2) {
          return cc(n2) && Hf(n2);
        }
        function Yf(n2) {
          return n2 === true || n2 === false || cc(n2) && we(n2) == Nn;
        }
        function Qf(n2) {
          return cc(n2) && 1 === n2.nodeType && !gc(n2);
        }
        function Xf(n2) {
          if (null == n2) return true;
          if (Hf(n2) && (bh(n2) || "string" == typeof n2 || "function" == typeof n2.splice || mh(n2) || Oh(n2) || dh(n2))) return !n2.length;
          var t2 = zs(n2);
          if (t2 == Gn || t2 == tt) return !n2.size;
          if (Mi(n2)) return !Me(n2).length;
          for (var r3 in n2) if (bl.call(n2, r3)) return false;
          return true;
        }
        function nc(n2, t2) {
          return Se(n2, t2);
        }
        function tc(n2, t2, r3) {
          r3 = "function" == typeof r3 ? r3 : X;
          var e2 = r3 ? r3(n2, t2) : X;
          return e2 === X ? Se(n2, t2, X, r3) : !!e2;
        }
        function rc(n2) {
          if (!cc(n2)) return false;
          var t2 = we(n2);
          return t2 == Zn || t2 == qn || "string" == typeof n2.message && "string" == typeof n2.name && !gc(n2);
        }
        function ec(n2) {
          return "number" == typeof n2 && Zl(n2);
        }
        function uc(n2) {
          if (!fc(n2)) return false;
          var t2 = we(n2);
          return t2 == Kn || t2 == Vn || t2 == Fn || t2 == Xn;
        }
        function ic(n2) {
          return "number" == typeof n2 && n2 == kc(n2);
        }
        function oc(n2) {
          return "number" == typeof n2 && n2 > -1 && n2 % 1 == 0 && n2 <= Wn;
        }
        function fc(n2) {
          var t2 = typeof n2;
          return null != n2 && ("object" == t2 || "function" == t2);
        }
        function cc(n2) {
          return null != n2 && "object" == typeof n2;
        }
        function ac(n2, t2) {
          return n2 === t2 || Ce(n2, t2, ji(t2));
        }
        function lc(n2, t2, r3) {
          return r3 = "function" == typeof r3 ? r3 : X, Ce(n2, t2, ji(t2), r3);
        }
        function sc(n2) {
          return vc(n2) && n2 != +n2;
        }
        function hc(n2) {
          if (Es(n2)) throw new fl(rn);
          return Ue(n2);
        }
        function pc(n2) {
          return null === n2;
        }
        function _c(n2) {
          return null == n2;
        }
        function vc(n2) {
          return "number" == typeof n2 || cc(n2) && we(n2) == Hn;
        }
        function gc(n2) {
          if (!cc(n2) || we(n2) != Yn) return false;
          var t2 = El(n2);
          if (null === t2) return true;
          var r3 = bl.call(t2, "constructor") && t2.constructor;
          return "function" == typeof r3 && r3 instanceof r3 && dl.call(r3) == jl;
        }
        function yc(n2) {
          return ic(n2) && n2 >= -Wn && n2 <= Wn;
        }
        function dc(n2) {
          return "string" == typeof n2 || !bh(n2) && cc(n2) && we(n2) == rt;
        }
        function bc(n2) {
          return "symbol" == typeof n2 || cc(n2) && we(n2) == et;
        }
        function wc(n2) {
          return n2 === X;
        }
        function mc(n2) {
          return cc(n2) && zs(n2) == it;
        }
        function xc(n2) {
          return cc(n2) && we(n2) == ot;
        }
        function jc(n2) {
          if (!n2) return [];
          if (Hf(n2)) return dc(n2) ? G(n2) : Tu(n2);
          if (Ul && n2[Ul]) return D(n2[Ul]());
          var t2 = zs(n2);
          return (t2 == Gn ? M : t2 == tt ? P : ra)(n2);
        }
        function Ac(n2) {
          if (!n2) return 0 === n2 ? n2 : 0;
          if (n2 = Ic(n2), n2 === Sn || n2 === -Sn) {
            return (n2 < 0 ? -1 : 1) * Ln;
          }
          return n2 === n2 ? n2 : 0;
        }
        function kc(n2) {
          var t2 = Ac(n2), r3 = t2 % 1;
          return t2 === t2 ? r3 ? t2 - r3 : t2 : 0;
        }
        function Oc(n2) {
          return n2 ? Mr2(kc(n2), 0, Un) : 0;
        }
        function Ic(n2) {
          if ("number" == typeof n2) return n2;
          if (bc(n2)) return Cn;
          if (fc(n2)) {
            var t2 = "function" == typeof n2.valueOf ? n2.valueOf() : n2;
            n2 = fc(t2) ? t2 + "" : t2;
          }
          if ("string" != typeof n2) return 0 === n2 ? n2 : +n2;
          n2 = R(n2);
          var r3 = qt.test(n2);
          return r3 || Kt.test(n2) ? Xr(n2.slice(2), r3 ? 2 : 8) : Pt.test(n2) ? Cn : +n2;
        }
        function Rc(n2) {
          return $u(n2, qc(n2));
        }
        function zc(n2) {
          return n2 ? Mr2(kc(n2), -Wn, Wn) : 0 === n2 ? n2 : 0;
        }
        function Ec(n2) {
          return null == n2 ? "" : vu(n2);
        }
        function Sc(n2, t2) {
          var r3 = gs(n2);
          return null == t2 ? r3 : Cr2(r3, t2);
        }
        function Wc(n2, t2) {
          return v(n2, mi(t2, 3), ue2);
        }
        function Lc(n2, t2) {
          return v(n2, mi(t2, 3), oe2);
        }
        function Cc(n2, t2) {
          return null == n2 ? n2 : bs(n2, mi(t2, 3), qc);
        }
        function Uc(n2, t2) {
          return null == n2 ? n2 : ws(n2, mi(t2, 3), qc);
        }
        function Bc(n2, t2) {
          return n2 && ue2(n2, mi(t2, 3));
        }
        function Tc(n2, t2) {
          return n2 && oe2(n2, mi(t2, 3));
        }
        function $c(n2) {
          return null == n2 ? [] : fe2(n2, Pc(n2));
        }
        function Dc(n2) {
          return null == n2 ? [] : fe2(n2, qc(n2));
        }
        function Mc(n2, t2, r3) {
          var e2 = null == n2 ? X : _e2(n2, t2);
          return e2 === X ? r3 : e2;
        }
        function Fc(n2, t2) {
          return null != n2 && Ri(n2, t2, xe);
        }
        function Nc(n2, t2) {
          return null != n2 && Ri(n2, t2, je);
        }
        function Pc(n2) {
          return Hf(n2) ? Or2(n2) : Me(n2);
        }
        function qc(n2) {
          return Hf(n2) ? Or2(n2, true) : Fe(n2);
        }
        function Zc(n2, t2) {
          var r3 = {};
          return t2 = mi(t2, 3), ue2(n2, function(n3, e2, u2) {
            Br2(r3, t2(n3, e2, u2), n3);
          }), r3;
        }
        function Kc(n2, t2) {
          var r3 = {};
          return t2 = mi(t2, 3), ue2(n2, function(n3, e2, u2) {
            Br2(r3, e2, t2(n3, e2, u2));
          }), r3;
        }
        function Vc(n2, t2) {
          return Gc(n2, Uf(mi(t2)));
        }
        function Gc(n2, t2) {
          if (null == n2) return {};
          var r3 = c(di(n2), function(n3) {
            return [n3];
          });
          return t2 = mi(t2), Ye(n2, r3, function(n3, r4) {
            return t2(n3, r4[0]);
          });
        }
        function Hc(n2, t2, r3) {
          t2 = ku(t2, n2);
          var e2 = -1, u2 = t2.length;
          for (u2 || (u2 = 1, n2 = X); ++e2 < u2; ) {
            var i2 = null == n2 ? X : n2[no(t2[e2])];
            i2 === X && (e2 = u2, i2 = r3), n2 = uc(i2) ? i2.call(n2) : i2;
          }
          return n2;
        }
        function Jc(n2, t2, r3) {
          return null == n2 ? n2 : fu(n2, t2, r3);
        }
        function Yc(n2, t2, r3, e2) {
          return e2 = "function" == typeof e2 ? e2 : X, null == n2 ? n2 : fu(n2, t2, r3, e2);
        }
        function Qc(n2, t2, e2) {
          var u2 = bh(n2), i2 = u2 || mh(n2) || Oh(n2);
          if (t2 = mi(t2, 4), null == e2) {
            var o2 = n2 && n2.constructor;
            e2 = i2 ? u2 ? new o2() : [] : fc(n2) && uc(o2) ? gs(El(n2)) : {};
          }
          return (i2 ? r2 : ue2)(n2, function(n3, r3, u3) {
            return t2(e2, n3, r3, u3);
          }), e2;
        }
        function Xc(n2, t2) {
          return null == n2 || yu(n2, t2);
        }
        function na(n2, t2, r3) {
          return null == n2 ? n2 : du(n2, t2, Au(r3));
        }
        function ta(n2, t2, r3, e2) {
          return e2 = "function" == typeof e2 ? e2 : X, null == n2 ? n2 : du(n2, t2, Au(r3), e2);
        }
        function ra(n2) {
          return null == n2 ? [] : E(n2, Pc(n2));
        }
        function ea(n2) {
          return null == n2 ? [] : E(n2, qc(n2));
        }
        function ua(n2, t2, r3) {
          return r3 === X && (r3 = t2, t2 = X), r3 !== X && (r3 = Ic(r3), r3 = r3 === r3 ? r3 : 0), t2 !== X && (t2 = Ic(t2), t2 = t2 === t2 ? t2 : 0), Mr2(Ic(n2), t2, r3);
        }
        function ia(n2, t2, r3) {
          return t2 = Ac(t2), r3 === X ? (r3 = t2, t2 = 0) : r3 = Ac(r3), n2 = Ic(n2), Ae(n2, t2, r3);
        }
        function oa(n2, t2, r3) {
          if (r3 && "boolean" != typeof r3 && Ui(n2, t2, r3) && (t2 = r3 = X), r3 === X && ("boolean" == typeof t2 ? (r3 = t2, t2 = X) : "boolean" == typeof n2 && (r3 = n2, n2 = X)), n2 === X && t2 === X ? (n2 = 0, t2 = 1) : (n2 = Ac(n2), t2 === X ? (t2 = n2, n2 = 0) : t2 = Ac(t2)), n2 > t2) {
            var e2 = n2;
            n2 = t2, t2 = e2;
          }
          if (r3 || n2 % 1 || t2 % 1) {
            var u2 = Ql();
            return Hl(n2 + u2 * (t2 - n2 + Qr("1e-" + ((u2 + "").length - 1))), t2);
          }
          return tu(n2, t2);
        }
        function fa(n2) {
          return Qh(Ec(n2).toLowerCase());
        }
        function ca(n2) {
          return n2 = Ec(n2), n2 && n2.replace(Gt, ve).replace(Dr, "");
        }
        function aa(n2, t2, r3) {
          n2 = Ec(n2), t2 = vu(t2);
          var e2 = n2.length;
          r3 = r3 === X ? e2 : Mr2(kc(r3), 0, e2);
          var u2 = r3;
          return r3 -= t2.length, r3 >= 0 && n2.slice(r3, u2) == t2;
        }
        function la(n2) {
          return n2 = Ec(n2), n2 && At.test(n2) ? n2.replace(xt, ge) : n2;
        }
        function sa(n2) {
          return n2 = Ec(n2), n2 && Wt.test(n2) ? n2.replace(St, "\\$&") : n2;
        }
        function ha(n2, t2, r3) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          if (!t2 || e2 >= t2) return n2;
          var u2 = (t2 - e2) / 2;
          return ri(Nl(u2), r3) + n2 + ri(Fl(u2), r3);
        }
        function pa(n2, t2, r3) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          return t2 && e2 < t2 ? n2 + ri(t2 - e2, r3) : n2;
        }
        function _a(n2, t2, r3) {
          n2 = Ec(n2), t2 = kc(t2);
          var e2 = t2 ? V(n2) : 0;
          return t2 && e2 < t2 ? ri(t2 - e2, r3) + n2 : n2;
        }
        function va(n2, t2, r3) {
          return r3 || null == t2 ? t2 = 0 : t2 && (t2 = +t2), Yl(Ec(n2).replace(Lt, ""), t2 || 0);
        }
        function ga(n2, t2, r3) {
          return t2 = (r3 ? Ui(n2, t2, r3) : t2 === X) ? 1 : kc(t2), eu(Ec(n2), t2);
        }
        function ya() {
          var n2 = arguments, t2 = Ec(n2[0]);
          return n2.length < 3 ? t2 : t2.replace(n2[1], n2[2]);
        }
        function da(n2, t2, r3) {
          return r3 && "number" != typeof r3 && Ui(n2, t2, r3) && (t2 = r3 = X), (r3 = r3 === X ? Un : r3 >>> 0) ? (n2 = Ec(n2), n2 && ("string" == typeof t2 || null != t2 && !Ah(t2)) && (t2 = vu(t2), !t2 && T(n2)) ? Ou(G(n2), 0, r3) : n2.split(t2, r3)) : [];
        }
        function ba(n2, t2, r3) {
          return n2 = Ec(n2), r3 = null == r3 ? 0 : Mr2(kc(r3), 0, n2.length), t2 = vu(t2), n2.slice(r3, r3 + t2.length) == t2;
        }
        function wa(n2, t2, r3) {
          var e2 = Z2.templateSettings;
          r3 && Ui(n2, t2, r3) && (t2 = X), n2 = Ec(n2), t2 = Sh({}, t2, e2, li);
          var u2, i2, o2 = Sh({}, t2.imports, e2.imports, li), f2 = Pc(o2), c2 = E(o2, f2), a2 = 0, l2 = t2.interpolate || Ht, s2 = "__p += '", h2 = sl((t2.escape || Ht).source + "|" + l2.source + "|" + (l2 === It ? Ft : Ht).source + "|" + (t2.evaluate || Ht).source + "|$", "g"), p3 = "//# sourceURL=" + (bl.call(t2, "sourceURL") ? (t2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Zr + "]") + "\n";
          n2.replace(h2, function(t3, r4, e3, o3, f3, c3) {
            return e3 || (e3 = o3), s2 += n2.slice(a2, c3).replace(Jt, U), r4 && (u2 = true, s2 += "' +\n__e(" + r4 + ") +\n'"), f3 && (i2 = true, s2 += "';\n" + f3 + ";\n__p += '"), e3 && (s2 += "' +\n((__t = (" + e3 + ")) == null ? '' : __t) +\n'"), a2 = c3 + t3.length, t3;
          }), s2 += "';\n";
          var _2 = bl.call(t2, "variable") && t2.variable;
          if (_2) {
            if (Dt.test(_2)) throw new fl(un);
          } else s2 = "with (obj) {\n" + s2 + "\n}\n";
          s2 = (i2 ? s2.replace(dt, "") : s2).replace(bt, "$1").replace(wt, "$1;"), s2 = "function(" + (_2 || "obj") + ") {\n" + (_2 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (u2 ? ", __e = _.escape" : "") + (i2 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + s2 + "return __p\n}";
          var v2 = Xh(function() {
            return cl(f2, p3 + "return " + s2).apply(X, c2);
          });
          if (v2.source = s2, rc(v2)) throw v2;
          return v2;
        }
        function ma(n2) {
          return Ec(n2).toLowerCase();
        }
        function xa(n2) {
          return Ec(n2).toUpperCase();
        }
        function ja(n2, t2, r3) {
          if (n2 = Ec(n2), n2 && (r3 || t2 === X)) return R(n2);
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2), u2 = G(t2);
          return Ou(e2, W(e2, u2), L(e2, u2) + 1).join("");
        }
        function Aa(n2, t2, r3) {
          if (n2 = Ec(n2), n2 && (r3 || t2 === X)) return n2.slice(0, H(n2) + 1);
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2);
          return Ou(e2, 0, L(e2, G(t2)) + 1).join("");
        }
        function ka(n2, t2, r3) {
          if (n2 = Ec(n2), n2 && (r3 || t2 === X)) return n2.replace(Lt, "");
          if (!n2 || !(t2 = vu(t2))) return n2;
          var e2 = G(n2);
          return Ou(e2, W(e2, G(t2))).join("");
        }
        function Oa(n2, t2) {
          var r3 = An, e2 = kn;
          if (fc(t2)) {
            var u2 = "separator" in t2 ? t2.separator : u2;
            r3 = "length" in t2 ? kc(t2.length) : r3, e2 = "omission" in t2 ? vu(t2.omission) : e2;
          }
          n2 = Ec(n2);
          var i2 = n2.length;
          if (T(n2)) {
            var o2 = G(n2);
            i2 = o2.length;
          }
          if (r3 >= i2) return n2;
          var f2 = r3 - V(e2);
          if (f2 < 1) return e2;
          var c2 = o2 ? Ou(o2, 0, f2).join("") : n2.slice(0, f2);
          if (u2 === X) return c2 + e2;
          if (o2 && (f2 += c2.length - f2), Ah(u2)) {
            if (n2.slice(f2).search(u2)) {
              var a2, l2 = c2;
              for (u2.global || (u2 = sl(u2.source, Ec(Nt.exec(u2)) + "g")), u2.lastIndex = 0; a2 = u2.exec(l2); ) var s2 = a2.index;
              c2 = c2.slice(0, s2 === X ? f2 : s2);
            }
          } else if (n2.indexOf(vu(u2), f2) != f2) {
            var h2 = c2.lastIndexOf(u2);
            h2 > -1 && (c2 = c2.slice(0, h2));
          }
          return c2 + e2;
        }
        function Ia(n2) {
          return n2 = Ec(n2), n2 && jt.test(n2) ? n2.replace(mt, ye) : n2;
        }
        function Ra(n2, t2, r3) {
          return n2 = Ec(n2), t2 = r3 ? X : t2, t2 === X ? $(n2) ? Q(n2) : _(n2) : n2.match(t2) || [];
        }
        function za(t2) {
          var r3 = null == t2 ? 0 : t2.length, e2 = mi();
          return t2 = r3 ? c(t2, function(n2) {
            if ("function" != typeof n2[1]) throw new pl(en);
            return [e2(n2[0]), n2[1]];
          }) : [], uu(function(e3) {
            for (var u2 = -1; ++u2 < r3; ) {
              var i2 = t2[u2];
              if (n(i2[0], this, e3)) return n(i2[1], this, e3);
            }
          });
        }
        function Ea(n2) {
          return Nr2(Fr2(n2, an));
        }
        function Sa(n2) {
          return function() {
            return n2;
          };
        }
        function Wa(n2, t2) {
          return null == n2 || n2 !== n2 ? t2 : n2;
        }
        function La(n2) {
          return n2;
        }
        function Ca(n2) {
          return De("function" == typeof n2 ? n2 : Fr2(n2, an));
        }
        function Ua(n2) {
          return qe(Fr2(n2, an));
        }
        function Ba(n2, t2) {
          return Ze(n2, Fr2(t2, an));
        }
        function Ta(n2, t2, e2) {
          var u2 = Pc(t2), i2 = fe2(t2, u2);
          null != e2 || fc(t2) && (i2.length || !u2.length) || (e2 = t2, t2 = n2, n2 = this, i2 = fe2(t2, Pc(t2)));
          var o2 = !(fc(e2) && "chain" in e2 && !e2.chain), f2 = uc(n2);
          return r2(i2, function(r3) {
            var e3 = t2[r3];
            n2[r3] = e3, f2 && (n2.prototype[r3] = function() {
              var t3 = this.__chain__;
              if (o2 || t3) {
                var r4 = n2(this.__wrapped__);
                return (r4.__actions__ = Tu(this.__actions__)).push({ func: e3, args: arguments, thisArg: n2 }), r4.__chain__ = t3, r4;
              }
              return e3.apply(n2, a([this.value()], arguments));
            });
          }), n2;
        }
        function $a() {
          return re._ === this && (re._ = Al), this;
        }
        function Da() {
        }
        function Ma(n2) {
          return n2 = kc(n2), uu(function(t2) {
            return Ge(t2, n2);
          });
        }
        function Fa(n2) {
          return Bi(n2) ? m(no(n2)) : Qe(n2);
        }
        function Na(n2) {
          return function(t2) {
            return null == n2 ? X : _e2(n2, t2);
          };
        }
        function Pa() {
          return [];
        }
        function qa() {
          return false;
        }
        function Za() {
          return {};
        }
        function Ka() {
          return "";
        }
        function Va() {
          return true;
        }
        function Ga(n2, t2) {
          if (n2 = kc(n2), n2 < 1 || n2 > Wn) return [];
          var r3 = Un, e2 = Hl(n2, Un);
          t2 = mi(t2), n2 -= Un;
          for (var u2 = O(e2, t2); ++r3 < n2; ) t2(r3);
          return u2;
        }
        function Ha(n2) {
          return bh(n2) ? c(n2, no) : bc(n2) ? [n2] : Tu(Cs(Ec(n2)));
        }
        function Ja(n2) {
          var t2 = ++wl;
          return Ec(n2) + t2;
        }
        function Ya(n2) {
          return n2 && n2.length ? Yr2(n2, La, me) : X;
        }
        function Qa(n2, t2) {
          return n2 && n2.length ? Yr2(n2, mi(t2, 2), me) : X;
        }
        function Xa(n2) {
          return w(n2, La);
        }
        function nl(n2, t2) {
          return w(n2, mi(t2, 2));
        }
        function tl(n2) {
          return n2 && n2.length ? Yr2(n2, La, Ne) : X;
        }
        function rl(n2, t2) {
          return n2 && n2.length ? Yr2(n2, mi(t2, 2), Ne) : X;
        }
        function el(n2) {
          return n2 && n2.length ? k(n2, La) : 0;
        }
        function ul(n2, t2) {
          return n2 && n2.length ? k(n2, mi(t2, 2)) : 0;
        }
        x3 = null == x3 ? re : be.defaults(re.Object(), x3, be.pick(re, qr));
        var il = x3.Array, ol = x3.Date, fl = x3.Error, cl = x3.Function, al = x3.Math, ll = x3.Object, sl = x3.RegExp, hl = x3.String, pl = x3.TypeError, _l = il.prototype, vl = cl.prototype, gl = ll.prototype, yl = x3["__core-js_shared__"], dl = vl.toString, bl = gl.hasOwnProperty, wl = 0, ml = function() {
          var n2 = /[^.]+$/.exec(yl && yl.keys && yl.keys.IE_PROTO || "");
          return n2 ? "Symbol(src)_1." + n2 : "";
        }(), xl = gl.toString, jl = dl.call(ll), Al = re._, kl = sl("^" + dl.call(bl).replace(St, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Ol = ie ? x3.Buffer : X, Il = x3.Symbol, Rl = x3.Uint8Array, zl = Ol ? Ol.allocUnsafe : X, El = F(ll.getPrototypeOf, ll), Sl = ll.create, Wl = gl.propertyIsEnumerable, Ll = _l.splice, Cl = Il ? Il.isConcatSpreadable : X, Ul = Il ? Il.iterator : X, Bl = Il ? Il.toStringTag : X, Tl = function() {
          try {
            var n2 = Ai(ll, "defineProperty");
            return n2({}, "", {}), n2;
          } catch (n3) {
          }
        }(), $l = x3.clearTimeout !== re.clearTimeout && x3.clearTimeout, Dl = ol && ol.now !== re.Date.now && ol.now, Ml = x3.setTimeout !== re.setTimeout && x3.setTimeout, Fl = al.ceil, Nl = al.floor, Pl = ll.getOwnPropertySymbols, ql = Ol ? Ol.isBuffer : X, Zl = x3.isFinite, Kl = _l.join, Vl = F(ll.keys, ll), Gl = al.max, Hl = al.min, Jl = ol.now, Yl = x3.parseInt, Ql = al.random, Xl = _l.reverse, ns = Ai(x3, "DataView"), ts = Ai(x3, "Map"), rs = Ai(x3, "Promise"), es = Ai(x3, "Set"), us = Ai(x3, "WeakMap"), is2 = Ai(ll, "create"), os = us && new us(), fs = {}, cs = to(ns), as = to(ts), ls = to(rs), ss = to(es), hs = to(us), ps = Il ? Il.prototype : X, _s = ps ? ps.valueOf : X, vs = ps ? ps.toString : X, gs = /* @__PURE__ */ function() {
          function n2() {
          }
          return function(t2) {
            if (!fc(t2)) return {};
            if (Sl) return Sl(t2);
            n2.prototype = t2;
            var r3 = new n2();
            return n2.prototype = X, r3;
          };
        }();
        Z2.templateSettings = { escape: kt, evaluate: Ot, interpolate: It, variable: "", imports: { _: Z2 } }, Z2.prototype = J2.prototype, Z2.prototype.constructor = Z2, Y2.prototype = gs(J2.prototype), Y2.prototype.constructor = Y2, Ct2.prototype = gs(J2.prototype), Ct2.prototype.constructor = Ct2, Xt2.prototype.clear = nr2, Xt2.prototype.delete = tr2, Xt2.prototype.get = rr2, Xt2.prototype.has = er2, Xt2.prototype.set = ur2, ir2.prototype.clear = or2, ir2.prototype.delete = fr2, ir2.prototype.get = cr2, ir2.prototype.has = ar2, ir2.prototype.set = lr2, sr2.prototype.clear = hr2, sr2.prototype.delete = pr2, sr2.prototype.get = _r2, sr2.prototype.has = vr2, sr2.prototype.set = gr2, yr2.prototype.add = yr2.prototype.push = dr2, yr2.prototype.has = br2, wr2.prototype.clear = mr2, wr2.prototype.delete = xr2, wr2.prototype.get = jr2, wr2.prototype.has = Ar2, wr2.prototype.set = kr2;
        var ys = Pu(ue2), ds = Pu(oe2, true), bs = qu(), ws = qu(true), ms = os ? function(n2, t2) {
          return os.set(n2, t2), n2;
        } : La, xs = Tl ? function(n2, t2) {
          return Tl(n2, "toString", {
            configurable: true,
            enumerable: false,
            value: Sa(t2),
            writable: true
          });
        } : La, js = uu, As = $l || function(n2) {
          return re.clearTimeout(n2);
        }, ks = es && 1 / P(new es([, -0]))[1] == Sn ? function(n2) {
          return new es(n2);
        } : Da, Os = os ? function(n2) {
          return os.get(n2);
        } : Da, Is = Pl ? function(n2) {
          return null == n2 ? [] : (n2 = ll(n2), i(Pl(n2), function(t2) {
            return Wl.call(n2, t2);
          }));
        } : Pa, Rs = Pl ? function(n2) {
          for (var t2 = []; n2; ) a(t2, Is(n2)), n2 = El(n2);
          return t2;
        } : Pa, zs = we;
        (ns && zs(new ns(new ArrayBuffer(1))) != ct || ts && zs(new ts()) != Gn || rs && zs(rs.resolve()) != Qn || es && zs(new es()) != tt || us && zs(new us()) != it) && (zs = function(n2) {
          var t2 = we(n2), r3 = t2 == Yn ? n2.constructor : X, e2 = r3 ? to(r3) : "";
          if (e2) switch (e2) {
            case cs:
              return ct;
            case as:
              return Gn;
            case ls:
              return Qn;
            case ss:
              return tt;
            case hs:
              return it;
          }
          return t2;
        });
        var Es = yl ? uc : qa, Ss = Qi(ms), Ws = Ml || function(n2, t2) {
          return re.setTimeout(n2, t2);
        }, Ls = Qi(xs), Cs = Pi(function(n2) {
          var t2 = [];
          return 46 === n2.charCodeAt(0) && t2.push(""), n2.replace(Et, function(n3, r3, e2, u2) {
            t2.push(e2 ? u2.replace(Mt, "$1") : r3 || n3);
          }), t2;
        }), Us = uu(function(n2, t2) {
          return Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true)) : [];
        }), Bs = uu(function(n2, t2) {
          var r3 = jo(t2);
          return Jf(r3) && (r3 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), mi(r3, 2)) : [];
        }), Ts = uu(function(n2, t2) {
          var r3 = jo(t2);
          return Jf(r3) && (r3 = X), Jf(n2) ? Hr2(n2, ee2(t2, 1, Jf, true), X, r3) : [];
        }), $s = uu(function(n2) {
          var t2 = c(n2, ju);
          return t2.length && t2[0] === n2[0] ? ke(t2) : [];
        }), Ds = uu(function(n2) {
          var t2 = jo(n2), r3 = c(n2, ju);
          return t2 === jo(r3) ? t2 = X : r3.pop(), r3.length && r3[0] === n2[0] ? ke(r3, mi(t2, 2)) : [];
        }), Ms = uu(function(n2) {
          var t2 = jo(n2), r3 = c(n2, ju);
          return t2 = "function" == typeof t2 ? t2 : X, t2 && r3.pop(), r3.length && r3[0] === n2[0] ? ke(r3, X, t2) : [];
        }), Fs = uu(Oo), Ns = gi(function(n2, t2) {
          var r3 = null == n2 ? 0 : n2.length, e2 = Tr2(n2, t2);
          return nu(n2, c(t2, function(n3) {
            return Ci(n3, r3) ? +n3 : n3;
          }).sort(Lu)), e2;
        }), Ps = uu(function(n2) {
          return gu(ee2(n2, 1, Jf, true));
        }), qs = uu(function(n2) {
          var t2 = jo(n2);
          return Jf(t2) && (t2 = X), gu(ee2(n2, 1, Jf, true), mi(t2, 2));
        }), Zs = uu(function(n2) {
          var t2 = jo(n2);
          return t2 = "function" == typeof t2 ? t2 : X, gu(ee2(n2, 1, Jf, true), X, t2);
        }), Ks = uu(function(n2, t2) {
          return Jf(n2) ? Hr2(n2, t2) : [];
        }), Vs = uu(function(n2) {
          return mu(i(n2, Jf));
        }), Gs = uu(function(n2) {
          var t2 = jo(n2);
          return Jf(t2) && (t2 = X), mu(i(n2, Jf), mi(t2, 2));
        }), Hs = uu(function(n2) {
          var t2 = jo(n2);
          return t2 = "function" == typeof t2 ? t2 : X, mu(i(n2, Jf), X, t2);
        }), Js = uu(Go), Ys = uu(function(n2) {
          var t2 = n2.length, r3 = t2 > 1 ? n2[t2 - 1] : X;
          return r3 = "function" == typeof r3 ? (n2.pop(), r3) : X, Ho(n2, r3);
        }), Qs = gi(function(n2) {
          var t2 = n2.length, r3 = t2 ? n2[0] : 0, e2 = this.__wrapped__, u2 = function(t3) {
            return Tr2(t3, n2);
          };
          return !(t2 > 1 || this.__actions__.length) && e2 instanceof Ct2 && Ci(r3) ? (e2 = e2.slice(r3, +r3 + (t2 ? 1 : 0)), e2.__actions__.push({ func: nf, args: [u2], thisArg: X }), new Y2(e2, this.__chain__).thru(function(n3) {
            return t2 && !n3.length && n3.push(X), n3;
          })) : this.thru(u2);
        }), Xs = Fu(function(n2, t2, r3) {
          bl.call(n2, r3) ? ++n2[r3] : Br2(n2, r3, 1);
        }), nh = Ju(ho), th = Ju(po), rh = Fu(function(n2, t2, r3) {
          bl.call(n2, r3) ? n2[r3].push(t2) : Br2(n2, r3, [t2]);
        }), eh = uu(function(t2, r3, e2) {
          var u2 = -1, i2 = "function" == typeof r3, o2 = Hf(t2) ? il(t2.length) : [];
          return ys(t2, function(t3) {
            o2[++u2] = i2 ? n(r3, t3, e2) : Ie(t3, r3, e2);
          }), o2;
        }), uh = Fu(function(n2, t2, r3) {
          Br2(n2, r3, t2);
        }), ih = Fu(function(n2, t2, r3) {
          n2[r3 ? 0 : 1].push(t2);
        }, function() {
          return [[], []];
        }), oh = uu(function(n2, t2) {
          if (null == n2) return [];
          var r3 = t2.length;
          return r3 > 1 && Ui(n2, t2[0], t2[1]) ? t2 = [] : r3 > 2 && Ui(t2[0], t2[1], t2[2]) && (t2 = [t2[0]]), He(n2, ee2(t2, 1), []);
        }), fh = Dl || function() {
          return re.Date.now();
        }, ch = uu(function(n2, t2, r3) {
          var e2 = _n;
          if (r3.length) {
            var u2 = N(r3, wi(ch));
            e2 |= bn;
          }
          return ai(n2, e2, t2, r3, u2);
        }), ah = uu(function(n2, t2, r3) {
          var e2 = _n | vn;
          if (r3.length) {
            var u2 = N(r3, wi(ah));
            e2 |= bn;
          }
          return ai(t2, e2, n2, r3, u2);
        }), lh = uu(function(n2, t2) {
          return Gr2(n2, 1, t2);
        }), sh = uu(function(n2, t2, r3) {
          return Gr2(n2, Ic(t2) || 0, r3);
        });
        Cf.Cache = sr2;
        var hh = js(function(t2, r3) {
          r3 = 1 == r3.length && bh(r3[0]) ? c(r3[0], z(mi())) : c(ee2(r3, 1), z(mi()));
          var e2 = r3.length;
          return uu(function(u2) {
            for (var i2 = -1, o2 = Hl(u2.length, e2); ++i2 < o2; ) u2[i2] = r3[i2].call(this, u2[i2]);
            return n(t2, this, u2);
          });
        }), ph = uu(function(n2, t2) {
          return ai(n2, bn, X, t2, N(t2, wi(ph)));
        }), _h = uu(function(n2, t2) {
          return ai(n2, wn, X, t2, N(t2, wi(_h)));
        }), vh = gi(function(n2, t2) {
          return ai(n2, xn, X, X, X, t2);
        }), gh = ii(me), yh = ii(function(n2, t2) {
          return n2 >= t2;
        }), dh = Re(/* @__PURE__ */ function() {
          return arguments;
        }()) ? Re : function(n2) {
          return cc(n2) && bl.call(n2, "callee") && !Wl.call(n2, "callee");
        }, bh = il.isArray, wh = ce ? z(ce) : ze, mh = ql || qa, xh = ae ? z(ae) : Ee, jh = le ? z(le) : Le, Ah = se ? z(se) : Be, kh = he ? z(he) : Te, Oh = pe ? z(pe) : $e, Ih = ii(Ne), Rh = ii(function(n2, t2) {
          return n2 <= t2;
        }), zh = Nu(function(n2, t2) {
          if (Mi(t2) || Hf(t2)) return $u(t2, Pc(t2), n2), X;
          for (var r3 in t2) bl.call(t2, r3) && Sr2(n2, r3, t2[r3]);
        }), Eh = Nu(function(n2, t2) {
          $u(t2, qc(t2), n2);
        }), Sh = Nu(function(n2, t2, r3, e2) {
          $u(t2, qc(t2), n2, e2);
        }), Wh = Nu(function(n2, t2, r3, e2) {
          $u(t2, Pc(t2), n2, e2);
        }), Lh = gi(Tr2), Ch = uu(function(n2, t2) {
          n2 = ll(n2);
          var r3 = -1, e2 = t2.length, u2 = e2 > 2 ? t2[2] : X;
          for (u2 && Ui(t2[0], t2[1], u2) && (e2 = 1); ++r3 < e2; ) for (var i2 = t2[r3], o2 = qc(i2), f2 = -1, c2 = o2.length; ++f2 < c2; ) {
            var a2 = o2[f2], l2 = n2[a2];
            (l2 === X || Gf(l2, gl[a2]) && !bl.call(n2, a2)) && (n2[a2] = i2[a2]);
          }
          return n2;
        }), Uh = uu(function(t2) {
          return t2.push(X, si), n(Mh, X, t2);
        }), Bh = Xu(function(n2, t2, r3) {
          null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), n2[t2] = r3;
        }, Sa(La)), Th = Xu(function(n2, t2, r3) {
          null != t2 && "function" != typeof t2.toString && (t2 = xl.call(t2)), bl.call(n2, t2) ? n2[t2].push(r3) : n2[t2] = [r3];
        }, mi), $h = uu(Ie), Dh = Nu(function(n2, t2, r3) {
          Ke(n2, t2, r3);
        }), Mh = Nu(function(n2, t2, r3, e2) {
          Ke(n2, t2, r3, e2);
        }), Fh = gi(function(n2, t2) {
          var r3 = {};
          if (null == n2) return r3;
          var e2 = false;
          t2 = c(t2, function(t3) {
            return t3 = ku(t3, n2), e2 || (e2 = t3.length > 1), t3;
          }), $u(n2, di(n2), r3), e2 && (r3 = Fr2(r3, an | ln | sn, hi));
          for (var u2 = t2.length; u2--; ) yu(r3, t2[u2]);
          return r3;
        }), Nh = gi(function(n2, t2) {
          return null == n2 ? {} : Je(n2, t2);
        }), Ph = ci(Pc), qh = ci(qc), Zh = Vu(function(n2, t2, r3) {
          return t2 = t2.toLowerCase(), n2 + (r3 ? fa(t2) : t2);
        }), Kh = Vu(function(n2, t2, r3) {
          return n2 + (r3 ? "-" : "") + t2.toLowerCase();
        }), Vh = Vu(function(n2, t2, r3) {
          return n2 + (r3 ? " " : "") + t2.toLowerCase();
        }), Gh = Ku("toLowerCase"), Hh = Vu(function(n2, t2, r3) {
          return n2 + (r3 ? "_" : "") + t2.toLowerCase();
        }), Jh = Vu(function(n2, t2, r3) {
          return n2 + (r3 ? " " : "") + Qh(t2);
        }), Yh = Vu(function(n2, t2, r3) {
          return n2 + (r3 ? " " : "") + t2.toUpperCase();
        }), Qh = Ku("toUpperCase"), Xh = uu(function(t2, r3) {
          try {
            return n(t2, X, r3);
          } catch (n2) {
            return rc(n2) ? n2 : new fl(n2);
          }
        }), np = gi(function(n2, t2) {
          return r2(t2, function(t3) {
            t3 = no(t3), Br2(n2, t3, ch(n2[t3], n2));
          }), n2;
        }), tp = Yu(), rp = Yu(true), ep = uu(function(n2, t2) {
          return function(r3) {
            return Ie(r3, n2, t2);
          };
        }), up = uu(function(n2, t2) {
          return function(r3) {
            return Ie(n2, r3, t2);
          };
        }), ip = ti(c), op = ti(u), fp2 = ti(h), cp = ui(), ap = ui(true), lp = ni(function(n2, t2) {
          return n2 + t2;
        }, 0), sp = fi("ceil"), hp = ni(function(n2, t2) {
          return n2 / t2;
        }, 1), pp = fi("floor"), _p = ni(function(n2, t2) {
          return n2 * t2;
        }, 1), vp = fi("round"), gp = ni(function(n2, t2) {
          return n2 - t2;
        }, 0);
        return Z2.after = If, Z2.ary = Rf, Z2.assign = zh, Z2.assignIn = Eh, Z2.assignInWith = Sh, Z2.assignWith = Wh, Z2.at = Lh, Z2.before = zf, Z2.bind = ch, Z2.bindAll = np, Z2.bindKey = ah, Z2.castArray = Nf, Z2.chain = Qo, Z2.chunk = uo, Z2.compact = io, Z2.concat = oo, Z2.cond = za, Z2.conforms = Ea, Z2.constant = Sa, Z2.countBy = Xs, Z2.create = Sc, Z2.curry = Ef, Z2.curryRight = Sf, Z2.debounce = Wf, Z2.defaults = Ch, Z2.defaultsDeep = Uh, Z2.defer = lh, Z2.delay = sh, Z2.difference = Us, Z2.differenceBy = Bs, Z2.differenceWith = Ts, Z2.drop = fo, Z2.dropRight = co, Z2.dropRightWhile = ao, Z2.dropWhile = lo, Z2.fill = so, Z2.filter = lf, Z2.flatMap = sf, Z2.flatMapDeep = hf, Z2.flatMapDepth = pf, Z2.flatten = _o, Z2.flattenDeep = vo, Z2.flattenDepth = go, Z2.flip = Lf, Z2.flow = tp, Z2.flowRight = rp, Z2.fromPairs = yo, Z2.functions = $c, Z2.functionsIn = Dc, Z2.groupBy = rh, Z2.initial = mo, Z2.intersection = $s, Z2.intersectionBy = Ds, Z2.intersectionWith = Ms, Z2.invert = Bh, Z2.invertBy = Th, Z2.invokeMap = eh, Z2.iteratee = Ca, Z2.keyBy = uh, Z2.keys = Pc, Z2.keysIn = qc, Z2.map = yf, Z2.mapKeys = Zc, Z2.mapValues = Kc, Z2.matches = Ua, Z2.matchesProperty = Ba, Z2.memoize = Cf, Z2.merge = Dh, Z2.mergeWith = Mh, Z2.method = ep, Z2.methodOf = up, Z2.mixin = Ta, Z2.negate = Uf, Z2.nthArg = Ma, Z2.omit = Fh, Z2.omitBy = Vc, Z2.once = Bf, Z2.orderBy = df, Z2.over = ip, Z2.overArgs = hh, Z2.overEvery = op, Z2.overSome = fp2, Z2.partial = ph, Z2.partialRight = _h, Z2.partition = ih, Z2.pick = Nh, Z2.pickBy = Gc, Z2.property = Fa, Z2.propertyOf = Na, Z2.pull = Fs, Z2.pullAll = Oo, Z2.pullAllBy = Io, Z2.pullAllWith = Ro, Z2.pullAt = Ns, Z2.range = cp, Z2.rangeRight = ap, Z2.rearg = vh, Z2.reject = mf, Z2.remove = zo, Z2.rest = Tf, Z2.reverse = Eo, Z2.sampleSize = jf, Z2.set = Jc, Z2.setWith = Yc, Z2.shuffle = Af, Z2.slice = So, Z2.sortBy = oh, Z2.sortedUniq = $o, Z2.sortedUniqBy = Do, Z2.split = da, Z2.spread = $f, Z2.tail = Mo, Z2.take = Fo, Z2.takeRight = No, Z2.takeRightWhile = Po, Z2.takeWhile = qo, Z2.tap = Xo, Z2.throttle = Df, Z2.thru = nf, Z2.toArray = jc, Z2.toPairs = Ph, Z2.toPairsIn = qh, Z2.toPath = Ha, Z2.toPlainObject = Rc, Z2.transform = Qc, Z2.unary = Mf, Z2.union = Ps, Z2.unionBy = qs, Z2.unionWith = Zs, Z2.uniq = Zo, Z2.uniqBy = Ko, Z2.uniqWith = Vo, Z2.unset = Xc, Z2.unzip = Go, Z2.unzipWith = Ho, Z2.update = na, Z2.updateWith = ta, Z2.values = ra, Z2.valuesIn = ea, Z2.without = Ks, Z2.words = Ra, Z2.wrap = Ff, Z2.xor = Vs, Z2.xorBy = Gs, Z2.xorWith = Hs, Z2.zip = Js, Z2.zipObject = Jo, Z2.zipObjectDeep = Yo, Z2.zipWith = Ys, Z2.entries = Ph, Z2.entriesIn = qh, Z2.extend = Eh, Z2.extendWith = Sh, Ta(Z2, Z2), Z2.add = lp, Z2.attempt = Xh, Z2.camelCase = Zh, Z2.capitalize = fa, Z2.ceil = sp, Z2.clamp = ua, Z2.clone = Pf, Z2.cloneDeep = Zf, Z2.cloneDeepWith = Kf, Z2.cloneWith = qf, Z2.conformsTo = Vf, Z2.deburr = ca, Z2.defaultTo = Wa, Z2.divide = hp, Z2.endsWith = aa, Z2.eq = Gf, Z2.escape = la, Z2.escapeRegExp = sa, Z2.every = af, Z2.find = nh, Z2.findIndex = ho, Z2.findKey = Wc, Z2.findLast = th, Z2.findLastIndex = po, Z2.findLastKey = Lc, Z2.floor = pp, Z2.forEach = _f, Z2.forEachRight = vf, Z2.forIn = Cc, Z2.forInRight = Uc, Z2.forOwn = Bc, Z2.forOwnRight = Tc, Z2.get = Mc, Z2.gt = gh, Z2.gte = yh, Z2.has = Fc, Z2.hasIn = Nc, Z2.head = bo, Z2.identity = La, Z2.includes = gf, Z2.indexOf = wo, Z2.inRange = ia, Z2.invoke = $h, Z2.isArguments = dh, Z2.isArray = bh, Z2.isArrayBuffer = wh, Z2.isArrayLike = Hf, Z2.isArrayLikeObject = Jf, Z2.isBoolean = Yf, Z2.isBuffer = mh, Z2.isDate = xh, Z2.isElement = Qf, Z2.isEmpty = Xf, Z2.isEqual = nc, Z2.isEqualWith = tc, Z2.isError = rc, Z2.isFinite = ec, Z2.isFunction = uc, Z2.isInteger = ic, Z2.isLength = oc, Z2.isMap = jh, Z2.isMatch = ac, Z2.isMatchWith = lc, Z2.isNaN = sc, Z2.isNative = hc, Z2.isNil = _c, Z2.isNull = pc, Z2.isNumber = vc, Z2.isObject = fc, Z2.isObjectLike = cc, Z2.isPlainObject = gc, Z2.isRegExp = Ah, Z2.isSafeInteger = yc, Z2.isSet = kh, Z2.isString = dc, Z2.isSymbol = bc, Z2.isTypedArray = Oh, Z2.isUndefined = wc, Z2.isWeakMap = mc, Z2.isWeakSet = xc, Z2.join = xo, Z2.kebabCase = Kh, Z2.last = jo, Z2.lastIndexOf = Ao, Z2.lowerCase = Vh, Z2.lowerFirst = Gh, Z2.lt = Ih, Z2.lte = Rh, Z2.max = Ya, Z2.maxBy = Qa, Z2.mean = Xa, Z2.meanBy = nl, Z2.min = tl, Z2.minBy = rl, Z2.stubArray = Pa, Z2.stubFalse = qa, Z2.stubObject = Za, Z2.stubString = Ka, Z2.stubTrue = Va, Z2.multiply = _p, Z2.nth = ko, Z2.noConflict = $a, Z2.noop = Da, Z2.now = fh, Z2.pad = ha, Z2.padEnd = pa, Z2.padStart = _a, Z2.parseInt = va, Z2.random = oa, Z2.reduce = bf, Z2.reduceRight = wf, Z2.repeat = ga, Z2.replace = ya, Z2.result = Hc, Z2.round = vp, Z2.runInContext = p2, Z2.sample = xf, Z2.size = kf, Z2.snakeCase = Hh, Z2.some = Of, Z2.sortedIndex = Wo, Z2.sortedIndexBy = Lo, Z2.sortedIndexOf = Co, Z2.sortedLastIndex = Uo, Z2.sortedLastIndexBy = Bo, Z2.sortedLastIndexOf = To, Z2.startCase = Jh, Z2.startsWith = ba, Z2.subtract = gp, Z2.sum = el, Z2.sumBy = ul, Z2.template = wa, Z2.times = Ga, Z2.toFinite = Ac, Z2.toInteger = kc, Z2.toLength = Oc, Z2.toLower = ma, Z2.toNumber = Ic, Z2.toSafeInteger = zc, Z2.toString = Ec, Z2.toUpper = xa, Z2.trim = ja, Z2.trimEnd = Aa, Z2.trimStart = ka, Z2.truncate = Oa, Z2.unescape = Ia, Z2.uniqueId = Ja, Z2.upperCase = Yh, Z2.upperFirst = Qh, Z2.each = _f, Z2.eachRight = vf, Z2.first = bo, Ta(Z2, function() {
          var n2 = {};
          return ue2(Z2, function(t2, r3) {
            bl.call(Z2.prototype, r3) || (n2[r3] = t2);
          }), n2;
        }(), { chain: false }), Z2.VERSION = nn, r2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n2) {
          Z2[n2].placeholder = Z2;
        }), r2(["drop", "take"], function(n2, t2) {
          Ct2.prototype[n2] = function(r3) {
            r3 = r3 === X ? 1 : Gl(kc(r3), 0);
            var e2 = this.__filtered__ && !t2 ? new Ct2(this) : this.clone();
            return e2.__filtered__ ? e2.__takeCount__ = Hl(r3, e2.__takeCount__) : e2.__views__.push({ size: Hl(r3, Un), type: n2 + (e2.__dir__ < 0 ? "Right" : "") }), e2;
          }, Ct2.prototype[n2 + "Right"] = function(t3) {
            return this.reverse()[n2](t3).reverse();
          };
        }), r2(["filter", "map", "takeWhile"], function(n2, t2) {
          var r3 = t2 + 1, e2 = r3 == Rn || r3 == En;
          Ct2.prototype[n2] = function(n3) {
            var t3 = this.clone();
            return t3.__iteratees__.push({ iteratee: mi(n3, 3), type: r3 }), t3.__filtered__ = t3.__filtered__ || e2, t3;
          };
        }), r2(["head", "last"], function(n2, t2) {
          var r3 = "take" + (t2 ? "Right" : "");
          Ct2.prototype[n2] = function() {
            return this[r3](1).value()[0];
          };
        }), r2(["initial", "tail"], function(n2, t2) {
          var r3 = "drop" + (t2 ? "" : "Right");
          Ct2.prototype[n2] = function() {
            return this.__filtered__ ? new Ct2(this) : this[r3](1);
          };
        }), Ct2.prototype.compact = function() {
          return this.filter(La);
        }, Ct2.prototype.find = function(n2) {
          return this.filter(n2).head();
        }, Ct2.prototype.findLast = function(n2) {
          return this.reverse().find(n2);
        }, Ct2.prototype.invokeMap = uu(function(n2, t2) {
          return "function" == typeof n2 ? new Ct2(this) : this.map(function(r3) {
            return Ie(r3, n2, t2);
          });
        }), Ct2.prototype.reject = function(n2) {
          return this.filter(Uf(mi(n2)));
        }, Ct2.prototype.slice = function(n2, t2) {
          n2 = kc(n2);
          var r3 = this;
          return r3.__filtered__ && (n2 > 0 || t2 < 0) ? new Ct2(r3) : (n2 < 0 ? r3 = r3.takeRight(-n2) : n2 && (r3 = r3.drop(n2)), t2 !== X && (t2 = kc(t2), r3 = t2 < 0 ? r3.dropRight(-t2) : r3.take(t2 - n2)), r3);
        }, Ct2.prototype.takeRightWhile = function(n2) {
          return this.reverse().takeWhile(n2).reverse();
        }, Ct2.prototype.toArray = function() {
          return this.take(Un);
        }, ue2(Ct2.prototype, function(n2, t2) {
          var r3 = /^(?:filter|find|map|reject)|While$/.test(t2), e2 = /^(?:head|last)$/.test(t2), u2 = Z2[e2 ? "take" + ("last" == t2 ? "Right" : "") : t2], i2 = e2 || /^find/.test(t2);
          u2 && (Z2.prototype[t2] = function() {
            var t3 = this.__wrapped__, o2 = e2 ? [1] : arguments, f2 = t3 instanceof Ct2, c2 = o2[0], l2 = f2 || bh(t3), s2 = function(n3) {
              var t4 = u2.apply(Z2, a([n3], o2));
              return e2 && h2 ? t4[0] : t4;
            };
            l2 && r3 && "function" == typeof c2 && 1 != c2.length && (f2 = l2 = false);
            var h2 = this.__chain__, p3 = !!this.__actions__.length, _2 = i2 && !h2, v2 = f2 && !p3;
            if (!i2 && l2) {
              t3 = v2 ? t3 : new Ct2(this);
              var g2 = n2.apply(t3, o2);
              return g2.__actions__.push({ func: nf, args: [s2], thisArg: X }), new Y2(g2, h2);
            }
            return _2 && v2 ? n2.apply(this, o2) : (g2 = this.thru(s2), _2 ? e2 ? g2.value()[0] : g2.value() : g2);
          });
        }), r2(["pop", "push", "shift", "sort", "splice", "unshift"], function(n2) {
          var t2 = _l[n2], r3 = /^(?:push|sort|unshift)$/.test(n2) ? "tap" : "thru", e2 = /^(?:pop|shift)$/.test(n2);
          Z2.prototype[n2] = function() {
            var n3 = arguments;
            if (e2 && !this.__chain__) {
              var u2 = this.value();
              return t2.apply(bh(u2) ? u2 : [], n3);
            }
            return this[r3](function(r4) {
              return t2.apply(bh(r4) ? r4 : [], n3);
            });
          };
        }), ue2(Ct2.prototype, function(n2, t2) {
          var r3 = Z2[t2];
          if (r3) {
            var e2 = r3.name + "";
            bl.call(fs, e2) || (fs[e2] = []), fs[e2].push({ name: t2, func: r3 });
          }
        }), fs[Qu(X, vn).name] = [{ name: "wrapper", func: X }], Ct2.prototype.clone = $t2, Ct2.prototype.reverse = Yt2, Ct2.prototype.value = Qt2, Z2.prototype.at = Qs, Z2.prototype.chain = tf, Z2.prototype.commit = rf, Z2.prototype.next = ef, Z2.prototype.plant = of, Z2.prototype.reverse = ff, Z2.prototype.toJSON = Z2.prototype.valueOf = Z2.prototype.value = cf, Z2.prototype.first = Z2.prototype.head, Ul && (Z2.prototype[Ul] = uf), Z2;
      }, be = de();
      ue ? ((ue.exports = be)._ = be, ee._ = be) : re._ = be;
    }).call(lodash_min);
  })(lodash_min$1, lodash_min$1.exports);
  return lodash_min$1.exports;
}
var _mapping = {};
var hasRequired_mapping;
function require_mapping() {
  if (hasRequired_mapping) return _mapping;
  hasRequired_mapping = 1;
  (function(exports) {
    exports.aliasToReal = {
      // Lodash aliases.
      "each": "forEach",
      "eachRight": "forEachRight",
      "entries": "toPairs",
      "entriesIn": "toPairsIn",
      "extend": "assignIn",
      "extendAll": "assignInAll",
      "extendAllWith": "assignInAllWith",
      "extendWith": "assignInWith",
      "first": "head",
      // Methods that are curried variants of others.
      "conforms": "conformsTo",
      "matches": "isMatch",
      "property": "get",
      // Ramda aliases.
      "__": "placeholder",
      "F": "stubFalse",
      "T": "stubTrue",
      "all": "every",
      "allPass": "overEvery",
      "always": "constant",
      "any": "some",
      "anyPass": "overSome",
      "apply": "spread",
      "assoc": "set",
      "assocPath": "set",
      "complement": "negate",
      "compose": "flowRight",
      "contains": "includes",
      "dissoc": "unset",
      "dissocPath": "unset",
      "dropLast": "dropRight",
      "dropLastWhile": "dropRightWhile",
      "equals": "isEqual",
      "identical": "eq",
      "indexBy": "keyBy",
      "init": "initial",
      "invertObj": "invert",
      "juxt": "over",
      "omitAll": "omit",
      "nAry": "ary",
      "path": "get",
      "pathEq": "matchesProperty",
      "pathOr": "getOr",
      "paths": "at",
      "pickAll": "pick",
      "pipe": "flow",
      "pluck": "map",
      "prop": "get",
      "propEq": "matchesProperty",
      "propOr": "getOr",
      "props": "at",
      "symmetricDifference": "xor",
      "symmetricDifferenceBy": "xorBy",
      "symmetricDifferenceWith": "xorWith",
      "takeLast": "takeRight",
      "takeLastWhile": "takeRightWhile",
      "unapply": "rest",
      "unnest": "flatten",
      "useWith": "overArgs",
      "where": "conformsTo",
      "whereEq": "isMatch",
      "zipObj": "zipObject"
    };
    exports.aryMethod = {
      "1": [
        "assignAll",
        "assignInAll",
        "attempt",
        "castArray",
        "ceil",
        "create",
        "curry",
        "curryRight",
        "defaultsAll",
        "defaultsDeepAll",
        "floor",
        "flow",
        "flowRight",
        "fromPairs",
        "invert",
        "iteratee",
        "memoize",
        "method",
        "mergeAll",
        "methodOf",
        "mixin",
        "nthArg",
        "over",
        "overEvery",
        "overSome",
        "rest",
        "reverse",
        "round",
        "runInContext",
        "spread",
        "template",
        "trim",
        "trimEnd",
        "trimStart",
        "uniqueId",
        "words",
        "zipAll"
      ],
      "2": [
        "add",
        "after",
        "ary",
        "assign",
        "assignAllWith",
        "assignIn",
        "assignInAllWith",
        "at",
        "before",
        "bind",
        "bindAll",
        "bindKey",
        "chunk",
        "cloneDeepWith",
        "cloneWith",
        "concat",
        "conformsTo",
        "countBy",
        "curryN",
        "curryRightN",
        "debounce",
        "defaults",
        "defaultsDeep",
        "defaultTo",
        "delay",
        "difference",
        "divide",
        "drop",
        "dropRight",
        "dropRightWhile",
        "dropWhile",
        "endsWith",
        "eq",
        "every",
        "filter",
        "find",
        "findIndex",
        "findKey",
        "findLast",
        "findLastIndex",
        "findLastKey",
        "flatMap",
        "flatMapDeep",
        "flattenDepth",
        "forEach",
        "forEachRight",
        "forIn",
        "forInRight",
        "forOwn",
        "forOwnRight",
        "get",
        "groupBy",
        "gt",
        "gte",
        "has",
        "hasIn",
        "includes",
        "indexOf",
        "intersection",
        "invertBy",
        "invoke",
        "invokeMap",
        "isEqual",
        "isMatch",
        "join",
        "keyBy",
        "lastIndexOf",
        "lt",
        "lte",
        "map",
        "mapKeys",
        "mapValues",
        "matchesProperty",
        "maxBy",
        "meanBy",
        "merge",
        "mergeAllWith",
        "minBy",
        "multiply",
        "nth",
        "omit",
        "omitBy",
        "overArgs",
        "pad",
        "padEnd",
        "padStart",
        "parseInt",
        "partial",
        "partialRight",
        "partition",
        "pick",
        "pickBy",
        "propertyOf",
        "pull",
        "pullAll",
        "pullAt",
        "random",
        "range",
        "rangeRight",
        "rearg",
        "reject",
        "remove",
        "repeat",
        "restFrom",
        "result",
        "sampleSize",
        "some",
        "sortBy",
        "sortedIndex",
        "sortedIndexOf",
        "sortedLastIndex",
        "sortedLastIndexOf",
        "sortedUniqBy",
        "split",
        "spreadFrom",
        "startsWith",
        "subtract",
        "sumBy",
        "take",
        "takeRight",
        "takeRightWhile",
        "takeWhile",
        "tap",
        "throttle",
        "thru",
        "times",
        "trimChars",
        "trimCharsEnd",
        "trimCharsStart",
        "truncate",
        "union",
        "uniqBy",
        "uniqWith",
        "unset",
        "unzipWith",
        "without",
        "wrap",
        "xor",
        "zip",
        "zipObject",
        "zipObjectDeep"
      ],
      "3": [
        "assignInWith",
        "assignWith",
        "clamp",
        "differenceBy",
        "differenceWith",
        "findFrom",
        "findIndexFrom",
        "findLastFrom",
        "findLastIndexFrom",
        "getOr",
        "includesFrom",
        "indexOfFrom",
        "inRange",
        "intersectionBy",
        "intersectionWith",
        "invokeArgs",
        "invokeArgsMap",
        "isEqualWith",
        "isMatchWith",
        "flatMapDepth",
        "lastIndexOfFrom",
        "mergeWith",
        "orderBy",
        "padChars",
        "padCharsEnd",
        "padCharsStart",
        "pullAllBy",
        "pullAllWith",
        "rangeStep",
        "rangeStepRight",
        "reduce",
        "reduceRight",
        "replace",
        "set",
        "slice",
        "sortedIndexBy",
        "sortedLastIndexBy",
        "transform",
        "unionBy",
        "unionWith",
        "update",
        "xorBy",
        "xorWith",
        "zipWith"
      ],
      "4": [
        "fill",
        "setWith",
        "updateWith"
      ]
    };
    exports.aryRearg = {
      "2": [1, 0],
      "3": [2, 0, 1],
      "4": [3, 2, 0, 1]
    };
    exports.iterateeAry = {
      "dropRightWhile": 1,
      "dropWhile": 1,
      "every": 1,
      "filter": 1,
      "find": 1,
      "findFrom": 1,
      "findIndex": 1,
      "findIndexFrom": 1,
      "findKey": 1,
      "findLast": 1,
      "findLastFrom": 1,
      "findLastIndex": 1,
      "findLastIndexFrom": 1,
      "findLastKey": 1,
      "flatMap": 1,
      "flatMapDeep": 1,
      "flatMapDepth": 1,
      "forEach": 1,
      "forEachRight": 1,
      "forIn": 1,
      "forInRight": 1,
      "forOwn": 1,
      "forOwnRight": 1,
      "map": 1,
      "mapKeys": 1,
      "mapValues": 1,
      "partition": 1,
      "reduce": 2,
      "reduceRight": 2,
      "reject": 1,
      "remove": 1,
      "some": 1,
      "takeRightWhile": 1,
      "takeWhile": 1,
      "times": 1,
      "transform": 2
    };
    exports.iterateeRearg = {
      "mapKeys": [1],
      "reduceRight": [1, 0]
    };
    exports.methodRearg = {
      "assignInAllWith": [1, 0],
      "assignInWith": [1, 2, 0],
      "assignAllWith": [1, 0],
      "assignWith": [1, 2, 0],
      "differenceBy": [1, 2, 0],
      "differenceWith": [1, 2, 0],
      "getOr": [2, 1, 0],
      "intersectionBy": [1, 2, 0],
      "intersectionWith": [1, 2, 0],
      "isEqualWith": [1, 2, 0],
      "isMatchWith": [2, 1, 0],
      "mergeAllWith": [1, 0],
      "mergeWith": [1, 2, 0],
      "padChars": [2, 1, 0],
      "padCharsEnd": [2, 1, 0],
      "padCharsStart": [2, 1, 0],
      "pullAllBy": [2, 1, 0],
      "pullAllWith": [2, 1, 0],
      "rangeStep": [1, 2, 0],
      "rangeStepRight": [1, 2, 0],
      "setWith": [3, 1, 2, 0],
      "sortedIndexBy": [2, 1, 0],
      "sortedLastIndexBy": [2, 1, 0],
      "unionBy": [1, 2, 0],
      "unionWith": [1, 2, 0],
      "updateWith": [3, 1, 2, 0],
      "xorBy": [1, 2, 0],
      "xorWith": [1, 2, 0],
      "zipWith": [1, 2, 0]
    };
    exports.methodSpread = {
      "assignAll": { "start": 0 },
      "assignAllWith": { "start": 0 },
      "assignInAll": { "start": 0 },
      "assignInAllWith": { "start": 0 },
      "defaultsAll": { "start": 0 },
      "defaultsDeepAll": { "start": 0 },
      "invokeArgs": { "start": 2 },
      "invokeArgsMap": { "start": 2 },
      "mergeAll": { "start": 0 },
      "mergeAllWith": { "start": 0 },
      "partial": { "start": 1 },
      "partialRight": { "start": 1 },
      "without": { "start": 1 },
      "zipAll": { "start": 0 }
    };
    exports.mutate = {
      "array": {
        "fill": true,
        "pull": true,
        "pullAll": true,
        "pullAllBy": true,
        "pullAllWith": true,
        "pullAt": true,
        "remove": true,
        "reverse": true
      },
      "object": {
        "assign": true,
        "assignAll": true,
        "assignAllWith": true,
        "assignIn": true,
        "assignInAll": true,
        "assignInAllWith": true,
        "assignInWith": true,
        "assignWith": true,
        "defaults": true,
        "defaultsAll": true,
        "defaultsDeep": true,
        "defaultsDeepAll": true,
        "merge": true,
        "mergeAll": true,
        "mergeAllWith": true,
        "mergeWith": true
      },
      "set": {
        "set": true,
        "setWith": true,
        "unset": true,
        "update": true,
        "updateWith": true
      }
    };
    exports.realToAlias = function() {
      var hasOwnProperty = Object.prototype.hasOwnProperty, object2 = exports.aliasToReal, result = {};
      for (var key in object2) {
        var value = object2[key];
        if (hasOwnProperty.call(result, value)) {
          result[value].push(key);
        } else {
          result[value] = [key];
        }
      }
      return result;
    }();
    exports.remap = {
      "assignAll": "assign",
      "assignAllWith": "assignWith",
      "assignInAll": "assignIn",
      "assignInAllWith": "assignInWith",
      "curryN": "curry",
      "curryRightN": "curryRight",
      "defaultsAll": "defaults",
      "defaultsDeepAll": "defaultsDeep",
      "findFrom": "find",
      "findIndexFrom": "findIndex",
      "findLastFrom": "findLast",
      "findLastIndexFrom": "findLastIndex",
      "getOr": "get",
      "includesFrom": "includes",
      "indexOfFrom": "indexOf",
      "invokeArgs": "invoke",
      "invokeArgsMap": "invokeMap",
      "lastIndexOfFrom": "lastIndexOf",
      "mergeAll": "merge",
      "mergeAllWith": "mergeWith",
      "padChars": "pad",
      "padCharsEnd": "padEnd",
      "padCharsStart": "padStart",
      "propertyOf": "get",
      "rangeStep": "range",
      "rangeStepRight": "rangeRight",
      "restFrom": "rest",
      "spreadFrom": "spread",
      "trimChars": "trim",
      "trimCharsEnd": "trimEnd",
      "trimCharsStart": "trimStart",
      "zipAll": "zip"
    };
    exports.skipFixed = {
      "castArray": true,
      "flow": true,
      "flowRight": true,
      "iteratee": true,
      "mixin": true,
      "rearg": true,
      "runInContext": true
    };
    exports.skipRearg = {
      "add": true,
      "assign": true,
      "assignIn": true,
      "bind": true,
      "bindKey": true,
      "concat": true,
      "difference": true,
      "divide": true,
      "eq": true,
      "gt": true,
      "gte": true,
      "isEqual": true,
      "lt": true,
      "lte": true,
      "matchesProperty": true,
      "merge": true,
      "multiply": true,
      "overArgs": true,
      "partial": true,
      "partialRight": true,
      "propertyOf": true,
      "random": true,
      "range": true,
      "rangeRight": true,
      "subtract": true,
      "zip": true,
      "zipObject": true,
      "zipObjectDeep": true
    };
  })(_mapping);
  return _mapping;
}
var placeholder;
var hasRequiredPlaceholder;
function requirePlaceholder() {
  if (hasRequiredPlaceholder) return placeholder;
  hasRequiredPlaceholder = 1;
  placeholder = {};
  return placeholder;
}
var _baseConvert;
var hasRequired_baseConvert;
function require_baseConvert() {
  if (hasRequired_baseConvert) return _baseConvert;
  hasRequired_baseConvert = 1;
  var mapping = require_mapping(), fallbackHolder = requirePlaceholder();
  var push = Array.prototype.push;
  function baseArity(func, n) {
    return n == 2 ? function(a, b) {
      return func.apply(void 0, arguments);
    } : function(a) {
      return func.apply(void 0, arguments);
    };
  }
  function baseAry(func, n) {
    return n == 2 ? function(a, b) {
      return func(a, b);
    } : function(a) {
      return func(a);
    };
  }
  function cloneArray(array2) {
    var length2 = array2 ? array2.length : 0, result = Array(length2);
    while (length2--) {
      result[length2] = array2[length2];
    }
    return result;
  }
  function createCloner(func) {
    return function(object2) {
      return func({}, object2);
    };
  }
  function flatSpread(func, start2) {
    return function() {
      var length2 = arguments.length, lastIndex = length2 - 1, args = Array(length2);
      while (length2--) {
        args[length2] = arguments[length2];
      }
      var array2 = args[start2], otherArgs = args.slice(0, start2);
      if (array2) {
        push.apply(otherArgs, array2);
      }
      if (start2 != lastIndex) {
        push.apply(otherArgs, args.slice(start2 + 1));
      }
      return func.apply(this, otherArgs);
    };
  }
  function wrapImmutable(func, cloner) {
    return function() {
      var length2 = arguments.length;
      if (!length2) {
        return;
      }
      var args = Array(length2);
      while (length2--) {
        args[length2] = arguments[length2];
      }
      var result = args[0] = cloner.apply(void 0, args);
      func.apply(void 0, args);
      return result;
    };
  }
  function baseConvert(util, name, func, options) {
    var isLib = typeof name == "function", isObj = name === Object(name);
    if (isObj) {
      options = func;
      func = name;
      name = void 0;
    }
    if (func == null) {
      throw new TypeError();
    }
    options || (options = {});
    var config2 = {
      "cap": "cap" in options ? options.cap : true,
      "curry": "curry" in options ? options.curry : true,
      "fixed": "fixed" in options ? options.fixed : true,
      "immutable": "immutable" in options ? options.immutable : true,
      "rearg": "rearg" in options ? options.rearg : true
    };
    var defaultHolder = isLib ? func : fallbackHolder, forceCurry = "curry" in options && options.curry, forceFixed = "fixed" in options && options.fixed, forceRearg = "rearg" in options && options.rearg, pristine = isLib ? func.runInContext() : void 0;
    var helpers = isLib ? func : {
      "ary": util.ary,
      "assign": util.assign,
      "clone": util.clone,
      "curry": util.curry,
      "forEach": util.forEach,
      "isArray": util.isArray,
      "isError": util.isError,
      "isFunction": util.isFunction,
      "isWeakMap": util.isWeakMap,
      "iteratee": util.iteratee,
      "keys": util.keys,
      "rearg": util.rearg,
      "toInteger": util.toInteger,
      "toPath": util.toPath
    };
    var ary = helpers.ary, assign2 = helpers.assign, clone = helpers.clone, curry = helpers.curry, each = helpers.forEach, isArray = helpers.isArray, isError = helpers.isError, isFunction = helpers.isFunction, isWeakMap = helpers.isWeakMap, keys = helpers.keys, rearg = helpers.rearg, toInteger = helpers.toInteger, toPath = helpers.toPath;
    var aryMethodKeys = keys(mapping.aryMethod);
    var wrappers = {
      "castArray": function(castArray) {
        return function() {
          var value = arguments[0];
          return isArray(value) ? castArray(cloneArray(value)) : castArray.apply(void 0, arguments);
        };
      },
      "iteratee": function(iteratee) {
        return function() {
          var func2 = arguments[0], arity = arguments[1], result = iteratee(func2, arity), length2 = result.length;
          if (config2.cap && typeof arity == "number") {
            arity = arity > 2 ? arity - 2 : 1;
            return length2 && length2 <= arity ? result : baseAry(result, arity);
          }
          return result;
        };
      },
      "mixin": function(mixin) {
        return function(source) {
          var func2 = this;
          if (!isFunction(func2)) {
            return mixin(func2, Object(source));
          }
          var pairs2 = [];
          each(keys(source), function(key) {
            if (isFunction(source[key])) {
              pairs2.push([key, func2.prototype[key]]);
            }
          });
          mixin(func2, Object(source));
          each(pairs2, function(pair) {
            var value = pair[1];
            if (isFunction(value)) {
              func2.prototype[pair[0]] = value;
            } else {
              delete func2.prototype[pair[0]];
            }
          });
          return func2;
        };
      },
      "nthArg": function(nthArg) {
        return function(n) {
          var arity = n < 0 ? 1 : toInteger(n) + 1;
          return curry(nthArg(n), arity);
        };
      },
      "rearg": function(rearg2) {
        return function(func2, indexes) {
          var arity = indexes ? indexes.length : 0;
          return curry(rearg2(func2, indexes), arity);
        };
      },
      "runInContext": function(runInContext) {
        return function(context2) {
          return baseConvert(util, runInContext(context2), options);
        };
      }
    };
    function castCap(name2, func2) {
      if (config2.cap) {
        var indexes = mapping.iterateeRearg[name2];
        if (indexes) {
          return iterateeRearg(func2, indexes);
        }
        var n = !isLib && mapping.iterateeAry[name2];
        if (n) {
          return iterateeAry(func2, n);
        }
      }
      return func2;
    }
    function castCurry(name2, func2, n) {
      return forceCurry || config2.curry && n > 1 ? curry(func2, n) : func2;
    }
    function castFixed(name2, func2, n) {
      if (config2.fixed && (forceFixed || !mapping.skipFixed[name2])) {
        var data = mapping.methodSpread[name2], start2 = data && data.start;
        return start2 === void 0 ? ary(func2, n) : flatSpread(func2, start2);
      }
      return func2;
    }
    function castRearg(name2, func2, n) {
      return config2.rearg && n > 1 && (forceRearg || !mapping.skipRearg[name2]) ? rearg(func2, mapping.methodRearg[name2] || mapping.aryRearg[n]) : func2;
    }
    function cloneByPath(object2, path2) {
      path2 = toPath(path2);
      var index = -1, length2 = path2.length, lastIndex = length2 - 1, result = clone(Object(object2)), nested = result;
      while (nested != null && ++index < length2) {
        var key = path2[index], value = nested[key];
        if (value != null && !(isFunction(value) || isError(value) || isWeakMap(value))) {
          nested[key] = clone(index == lastIndex ? value : Object(value));
        }
        nested = nested[key];
      }
      return result;
    }
    function convertLib(options2) {
      return _.runInContext.convert(options2)(void 0);
    }
    function createConverter(name2, func2) {
      var realName = mapping.aliasToReal[name2] || name2, methodName = mapping.remap[realName] || realName, oldOptions = options;
      return function(options2) {
        var newUtil = isLib ? pristine : helpers, newFunc = isLib ? pristine[methodName] : func2, newOptions = assign2(assign2({}, oldOptions), options2);
        return baseConvert(newUtil, realName, newFunc, newOptions);
      };
    }
    function iterateeAry(func2, n) {
      return overArg(func2, function(func3) {
        return typeof func3 == "function" ? baseAry(func3, n) : func3;
      });
    }
    function iterateeRearg(func2, indexes) {
      return overArg(func2, function(func3) {
        var n = indexes.length;
        return baseArity(rearg(baseAry(func3, n), indexes), n);
      });
    }
    function overArg(func2, transform2) {
      return function() {
        var length2 = arguments.length;
        if (!length2) {
          return func2();
        }
        var args = Array(length2);
        while (length2--) {
          args[length2] = arguments[length2];
        }
        var index = config2.rearg ? 0 : length2 - 1;
        args[index] = transform2(args[index]);
        return func2.apply(void 0, args);
      };
    }
    function wrap(name2, func2, placeholder2) {
      var result, realName = mapping.aliasToReal[name2] || name2, wrapped = func2, wrapper2 = wrappers[realName];
      if (wrapper2) {
        wrapped = wrapper2(func2);
      } else if (config2.immutable) {
        if (mapping.mutate.array[realName]) {
          wrapped = wrapImmutable(func2, cloneArray);
        } else if (mapping.mutate.object[realName]) {
          wrapped = wrapImmutable(func2, createCloner(func2));
        } else if (mapping.mutate.set[realName]) {
          wrapped = wrapImmutable(func2, cloneByPath);
        }
      }
      each(aryMethodKeys, function(aryKey) {
        each(mapping.aryMethod[aryKey], function(otherName) {
          if (realName == otherName) {
            var data = mapping.methodSpread[realName], afterRearg = data && data.afterRearg;
            result = afterRearg ? castFixed(realName, castRearg(realName, wrapped, aryKey), aryKey) : castRearg(realName, castFixed(realName, wrapped, aryKey), aryKey);
            result = castCap(realName, result);
            result = castCurry(realName, result, aryKey);
            return false;
          }
        });
        return !result;
      });
      result || (result = wrapped);
      if (result == func2) {
        result = forceCurry ? curry(result, 1) : function() {
          return func2.apply(this, arguments);
        };
      }
      result.convert = createConverter(realName, func2);
      result.placeholder = func2.placeholder = placeholder2;
      return result;
    }
    if (!isObj) {
      return wrap(name, func, defaultHolder);
    }
    var _ = func;
    var pairs = [];
    each(aryMethodKeys, function(aryKey) {
      each(mapping.aryMethod[aryKey], function(key) {
        var func2 = _[mapping.remap[key] || key];
        if (func2) {
          pairs.push([key, wrap(key, func2, _)]);
        }
      });
    });
    each(keys(_), function(key) {
      var func2 = _[key];
      if (typeof func2 == "function") {
        var length2 = pairs.length;
        while (length2--) {
          if (pairs[length2][0] == key) {
            return;
          }
        }
        func2.convert = createConverter(key, func2);
        pairs.push([key, func2]);
      }
    });
    each(pairs, function(pair) {
      _[pair[0]] = pair[1];
    });
    _.convert = convertLib;
    _.placeholder = _;
    each(keys(_), function(key) {
      each(mapping.realToAlias[key] || [], function(alias) {
        _[alias] = _[key];
      });
    });
    return _;
  }
  _baseConvert = baseConvert;
  return _baseConvert;
}
var fp;
var hasRequiredFp;
function requireFp() {
  if (hasRequiredFp) return fp;
  hasRequiredFp = 1;
  var _ = requireLodash_min().runInContext();
  fp = require_baseConvert()(_, _);
  return fp;
}
var fpExports = requireFp();
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}
function isAbsolute(pathname2) {
  return pathname2.charAt(0) === "/";
}
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }
  list.pop();
}
function resolvePathname(to, from2) {
  if (from2 === void 0) from2 = "";
  var toParts = to && to.split("/") || [];
  var fromParts = from2 && from2.split("/") || [];
  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from2 && isAbsolute(from2);
  var mustEndAbs = isToAbs || isFromAbs;
  if (to && isAbsolute(to)) {
    fromParts = toParts;
  } else if (toParts.length) {
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }
  if (!fromParts.length) return "/";
  var hasTrailingSlash;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === "." || last === ".." || last === "";
  } else {
    hasTrailingSlash = false;
  }
  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];
    if (part === ".") {
      spliceOne(fromParts, i);
    } else if (part === "..") {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }
  if (!mustEndAbs) for (; up--; up) fromParts.unshift("..");
  if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0])))
    fromParts.unshift("");
  var result = fromParts.join("/");
  if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
  return result;
}
var prefix$2 = "Invariant failed";
function invariant(condition, message) {
  {
    throw new Error(prefix$2);
  }
}
function addLeadingSlash$1(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function stripLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2.substr(1) : path2;
}
function hasBasename(path2, prefix2) {
  return path2.toLowerCase().indexOf(prefix2.toLowerCase()) === 0 && "/?#".indexOf(path2.charAt(prefix2.length)) !== -1;
}
function stripBasename$1(path2, prefix2) {
  return hasBasename(path2, prefix2) ? path2.substr(prefix2.length) : path2;
}
function stripTrailingSlash(path2) {
  return path2.charAt(path2.length - 1) === "/" ? path2.slice(0, -1) : path2;
}
function parsePath(path2) {
  var pathname2 = path2 || "/";
  var search = "";
  var hash2 = "";
  var hashIndex = pathname2.indexOf("#");
  if (hashIndex !== -1) {
    hash2 = pathname2.substr(hashIndex);
    pathname2 = pathname2.substr(0, hashIndex);
  }
  var searchIndex = pathname2.indexOf("?");
  if (searchIndex !== -1) {
    search = pathname2.substr(searchIndex);
    pathname2 = pathname2.substr(0, searchIndex);
  }
  return {
    pathname: pathname2,
    search: search === "?" ? "" : search,
    hash: hash2 === "#" ? "" : hash2
  };
}
function createPath(location) {
  var pathname2 = location.pathname, search = location.search, hash2 = location.hash;
  var path2 = pathname2 || "/";
  if (search && search !== "?") path2 += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#") path2 += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return path2;
}
function createLocation(path2, state, key, currentLocation) {
  var location;
  if (typeof path2 === "string") {
    location = parsePath(path2);
    location.state = state;
  } else {
    location = _extends$2({}, path2);
    if (location.pathname === void 0) location.pathname = "";
    if (location.search) {
      if (location.search.charAt(0) !== "?") location.search = "?" + location.search;
    } else {
      location.search = "";
    }
    if (location.hash) {
      if (location.hash.charAt(0) !== "#") location.hash = "#" + location.hash;
    } else {
      location.hash = "";
    }
    if (state !== void 0 && location.state === void 0) location.state = state;
  }
  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }
  if (key) location.key = key;
  if (currentLocation) {
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== "/") {
      location.pathname = resolvePathname(location.pathname, currentLocation.pathname);
    }
  } else {
    if (!location.pathname) {
      location.pathname = "/";
    }
  }
  return location;
}
function createTransitionManager() {
  var prompt = null;
  function setPrompt(nextPrompt) {
    prompt = nextPrompt;
    return function() {
      if (prompt === nextPrompt) prompt = null;
    };
  }
  function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    if (prompt != null) {
      var result = typeof prompt === "function" ? prompt(location, action) : prompt;
      if (typeof result === "string") {
        if (typeof getUserConfirmation === "function") {
          getUserConfirmation(result, callback);
        } else {
          callback(true);
        }
      } else {
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  }
  var listeners = [];
  function appendListener(fn) {
    var isActive = true;
    function listener() {
      if (isActive) fn.apply(void 0, arguments);
    }
    listeners.push(listener);
    return function() {
      isActive = false;
      listeners = listeners.filter(function(item) {
        return item !== listener;
      });
    };
  }
  function notifyListeners() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    listeners.forEach(function(listener) {
      return listener.apply(void 0, args);
    });
  }
  return {
    setPrompt,
    confirmTransitionTo,
    appendListener,
    notifyListeners
  };
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function getConfirmation(message, callback) {
  callback(window.confirm(message));
}
function supportsHistory() {
  var ua = window.navigator.userAgent;
  if ((ua.indexOf("Android 2.") !== -1 || ua.indexOf("Android 4.0") !== -1) && ua.indexOf("Mobile Safari") !== -1 && ua.indexOf("Chrome") === -1 && ua.indexOf("Windows Phone") === -1) return false;
  return window.history && "pushState" in window.history;
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf("Trident") === -1;
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf("Firefox") === -1;
}
function isExtraneousPopstateEvent(event) {
  return event.state === void 0 && navigator.userAgent.indexOf("CriOS") === -1;
}
var PopStateEvent = "popstate";
var HashChangeEvent = "hashchange";
function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    return {};
  }
}
function createBrowserHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  var canUseHistory = supportsHistory();
  var needsHashChangeListener = !supportsPopStateOnHashChange();
  var _props = props, _props$forceRefresh = _props.forceRefresh, forceRefresh = _props$forceRefresh === void 0 ? false : _props$forceRefresh, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  function getDOMLocation(historyState) {
    var _ref = historyState || {}, key = _ref.key, state = _ref.state;
    var _window$location = window.location, pathname2 = _window$location.pathname, search = _window$location.search, hash2 = _window$location.hash;
    var path2 = pathname2 + search + hash2;
    if (basename) path2 = stripBasename$1(path2, basename);
    return createLocation(path2, state, key);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function handlePopState(event) {
    if (isExtraneousPopstateEvent(event)) return;
    handlePop(getDOMLocation(event.state));
  }
  function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  }
  var forceNextPop = false;
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allKeys.indexOf(toLocation.key);
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allKeys.indexOf(fromLocation.key);
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];
  function createHref(location) {
    return basename + createPath(location);
  }
  function push(path2, state) {
    var action = "PUSH";
    var location = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.pushState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex + 1);
          nextKeys.push(location.key);
          allKeys = nextKeys;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.href = href;
      }
    });
  }
  function replace2(path2, state) {
    var action = "REPLACE";
    var location = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      var href = createHref(location);
      var key = location.key, state2 = location.state;
      if (canUseHistory) {
        globalHistory.replaceState({
          key,
          state: state2
        }, null, href);
        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          if (prevIndex !== -1) allKeys[prevIndex] = location.key;
          setState({
            action,
            location
          });
        }
      } else {
        window.location.replace(href);
      }
    });
  }
  function go(n) {
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.addEventListener(HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(PopStateEvent, handlePopState);
      if (needsHashChangeListener) window.removeEventListener(HashChangeEvent, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace: replace2,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
var HashChangeEvent$1 = "hashchange";
var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path2) {
      return path2.charAt(0) === "!" ? path2 : "!/" + stripLeadingSlash(path2);
    },
    decodePath: function decodePath(path2) {
      return path2.charAt(0) === "!" ? path2.substr(1) : path2;
    }
  },
  noslash: {
    encodePath: stripLeadingSlash,
    decodePath: addLeadingSlash$1
  },
  slash: {
    encodePath: addLeadingSlash$1,
    decodePath: addLeadingSlash$1
  }
};
function stripHash(url) {
  var hashIndex = url.indexOf("#");
  return hashIndex === -1 ? url : url.slice(0, hashIndex);
}
function getHashPath() {
  var href = window.location.href;
  var hashIndex = href.indexOf("#");
  return hashIndex === -1 ? "" : href.substring(hashIndex + 1);
}
function pushHashPath(path2) {
  window.location.hash = path2;
}
function replaceHashPath(path2) {
  window.location.replace(stripHash(window.location.href) + "#" + path2);
}
function createHashHistory(props) {
  if (props === void 0) {
    props = {};
  }
  !canUseDOM ? invariant() : void 0;
  var globalHistory = window.history;
  supportsGoWithoutReloadUsingHash();
  var _props = props, _props$getUserConfirm = _props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === void 0 ? getConfirmation : _props$getUserConfirm, _props$hashType = _props.hashType, hashType = _props$hashType === void 0 ? "slash" : _props$hashType;
  var basename = props.basename ? stripTrailingSlash(addLeadingSlash$1(props.basename)) : "";
  var _HashPathCoders$hashT = HashPathCoders[hashType], encodePath2 = _HashPathCoders$hashT.encodePath, decodePath2 = _HashPathCoders$hashT.decodePath;
  function getDOMLocation() {
    var path22 = decodePath2(getHashPath());
    if (basename) path22 = stripBasename$1(path22, basename);
    return createLocation(path22);
  }
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = globalHistory.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  var forceNextPop = false;
  var ignorePath = null;
  function locationsAreEqual$$1(a, b) {
    return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash;
  }
  function handleHashChange() {
    var path22 = getHashPath();
    var encodedPath2 = encodePath2(path22);
    if (path22 !== encodedPath2) {
      replaceHashPath(encodedPath2);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;
      if (!forceNextPop && locationsAreEqual$$1(prevLocation, location)) return;
      if (ignorePath === createPath(location)) return;
      ignorePath = null;
      handlePop(location);
    }
  }
  function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = "POP";
      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
        if (ok) {
          setState({
            action,
            location
          });
        } else {
          revertPop(location);
        }
      });
    }
  }
  function revertPop(fromLocation) {
    var toLocation = history.location;
    var toIndex = allPaths.lastIndexOf(createPath(toLocation));
    if (toIndex === -1) toIndex = 0;
    var fromIndex = allPaths.lastIndexOf(createPath(fromLocation));
    if (fromIndex === -1) fromIndex = 0;
    var delta = toIndex - fromIndex;
    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  }
  var path2 = getHashPath();
  var encodedPath = encodePath2(path2);
  if (path2 !== encodedPath) replaceHashPath(encodedPath);
  var initialLocation = getDOMLocation();
  var allPaths = [createPath(initialLocation)];
  function createHref(location) {
    var baseTag = document.querySelector("base");
    var href = "";
    if (baseTag && baseTag.getAttribute("href")) {
      href = stripHash(window.location.href);
    }
    return href + "#" + encodePath2(basename + createPath(location));
  }
  function push(path22, state) {
    var action = "PUSH";
    var location = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      var path3 = createPath(location);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        pushHashPath(encodedPath2);
        var prevIndex = allPaths.lastIndexOf(createPath(history.location));
        var nextPaths = allPaths.slice(0, prevIndex + 1);
        nextPaths.push(path3);
        allPaths = nextPaths;
        setState({
          action,
          location
        });
      } else {
        setState();
      }
    });
  }
  function replace2(path22, state) {
    var action = "REPLACE";
    var location = createLocation(path22, void 0, void 0, history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      var path3 = createPath(location);
      var encodedPath2 = encodePath2(basename + path3);
      var hashChanged = getHashPath() !== encodedPath2;
      if (hashChanged) {
        ignorePath = path3;
        replaceHashPath(encodedPath2);
      }
      var prevIndex = allPaths.indexOf(createPath(history.location));
      if (prevIndex !== -1) allPaths[prevIndex] = path3;
      setState({
        action,
        location
      });
    });
  }
  function go(n) {
    globalHistory.go(n);
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  var listenerCount = 0;
  function checkDOMListeners(delta) {
    listenerCount += delta;
    if (listenerCount === 1 && delta === 1) {
      window.addEventListener(HashChangeEvent$1, handleHashChange);
    } else if (listenerCount === 0) {
      window.removeEventListener(HashChangeEvent$1, handleHashChange);
    }
  }
  var isBlocked = false;
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    var unblock = transitionManager.setPrompt(prompt);
    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }
    return function() {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }
      return unblock();
    };
  }
  function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);
    return function() {
      checkDOMListeners(-1);
      unlisten();
    };
  }
  var history = {
    length: globalHistory.length,
    action: "POP",
    location: initialLocation,
    createHref,
    push,
    replace: replace2,
    go,
    goBack,
    goForward,
    block,
    listen
  };
  return history;
}
function clamp$2(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
}
function createMemoryHistory(props) {
  if (props === void 0) {
    props = {};
  }
  var _props = props, getUserConfirmation = _props.getUserConfirmation, _props$initialEntries = _props.initialEntries, initialEntries = _props$initialEntries === void 0 ? ["/"] : _props$initialEntries, _props$initialIndex = _props.initialIndex, initialIndex = _props$initialIndex === void 0 ? 0 : _props$initialIndex, _props$keyLength = _props.keyLength, keyLength = _props$keyLength === void 0 ? 6 : _props$keyLength;
  var transitionManager = createTransitionManager();
  function setState(nextState) {
    _extends$2(history, nextState);
    history.length = history.entries.length;
    transitionManager.notifyListeners(history.location, history.action);
  }
  function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  }
  var index = clamp$2(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function(entry) {
    return typeof entry === "string" ? createLocation(entry, void 0, createKey()) : createLocation(entry, void 0, entry.key || createKey());
  });
  var createHref = createPath;
  function push(path2, state) {
    var action = "PUSH";
    var location = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;
      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }
      setState({
        action,
        location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  }
  function replace2(path2, state) {
    var action = "REPLACE";
    var location = createLocation(path2, state, createKey(), history.location);
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (!ok) return;
      history.entries[history.index] = location;
      setState({
        action,
        location
      });
    });
  }
  function go(n) {
    var nextIndex = clamp$2(history.index + n, 0, history.entries.length - 1);
    var action = "POP";
    var location = history.entries[nextIndex];
    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function(ok) {
      if (ok) {
        setState({
          action,
          location,
          index: nextIndex
        });
      } else {
        setState();
      }
    });
  }
  function goBack() {
    go(-1);
  }
  function goForward() {
    go(1);
  }
  function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  }
  function block(prompt) {
    if (prompt === void 0) {
      prompt = false;
    }
    return transitionManager.setPrompt(prompt);
  }
  function listen(listener) {
    return transitionManager.appendListener(listener);
  }
  var history = {
    length: entries.length,
    action: "POP",
    location: entries[index],
    index,
    entries,
    createHref,
    push,
    replace: replace2,
    go,
    goBack,
    goForward,
    canGo,
    block,
    listen
  };
  return history;
}
var pathToRegexp$1 = { exports: {} };
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  isarray = Array.isArray || function(arr) {
    return Object.prototype.toString.call(arr) == "[object Array]";
  };
  return isarray;
}
var hasRequiredPathToRegexp;
function requirePathToRegexp() {
  if (hasRequiredPathToRegexp) return pathToRegexp$1.exports;
  hasRequiredPathToRegexp = 1;
  var isarray2 = requireIsarray();
  pathToRegexp$1.exports = pathToRegexp2;
  pathToRegexp$1.exports.parse = parse2;
  pathToRegexp$1.exports.compile = compile2;
  pathToRegexp$1.exports.tokensToFunction = tokensToFunction;
  pathToRegexp$1.exports.tokensToRegExp = tokensToRegExp;
  var PATH_REGEXP = new RegExp([
    // Match escaped characters that would otherwise appear in future matches.
    // This allows the user to escape special characters that won't transform.
    "(\\\\.)",
    // Match Express-style parameters and un-named parameters with a prefix
    // and optional suffixes. Matches appear as:
    //
    // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
    // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
    // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
    "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"
  ].join("|"), "g");
  function parse2(str, options) {
    var tokens = [];
    var key = 0;
    var index = 0;
    var path2 = "";
    var defaultDelimiter = options && options.delimiter || "/";
    var res;
    while ((res = PATH_REGEXP.exec(str)) != null) {
      var m = res[0];
      var escaped = res[1];
      var offset = res.index;
      path2 += str.slice(index, offset);
      index = offset + m.length;
      if (escaped) {
        path2 += escaped[1];
        continue;
      }
      var next2 = str[index];
      var prefix2 = res[2];
      var name = res[3];
      var capture = res[4];
      var group = res[5];
      var modifier = res[6];
      var asterisk = res[7];
      if (path2) {
        tokens.push(path2);
        path2 = "";
      }
      var partial = prefix2 != null && next2 != null && next2 !== prefix2;
      var repeat = modifier === "+" || modifier === "*";
      var optional = modifier === "?" || modifier === "*";
      var delimiter2 = prefix2 || defaultDelimiter;
      var pattern = capture || group;
      var prevText = prefix2 || (typeof tokens[tokens.length - 1] === "string" ? tokens[tokens.length - 1] : "");
      tokens.push({
        name: name || key++,
        prefix: prefix2 || "",
        delimiter: delimiter2,
        optional,
        repeat,
        partial,
        asterisk: !!asterisk,
        pattern: pattern ? escapeGroup(pattern) : asterisk ? ".*" : restrictBacktrack(delimiter2, prevText)
      });
    }
    if (index < str.length) {
      path2 += str.substr(index);
    }
    if (path2) {
      tokens.push(path2);
    }
    return tokens;
  }
  function restrictBacktrack(delimiter2, prevText) {
    if (!prevText || prevText.indexOf(delimiter2) > -1) {
      return "[^" + escapeString(delimiter2) + "]+?";
    }
    return escapeString(prevText) + "|(?:(?!" + escapeString(prevText) + ")[^" + escapeString(delimiter2) + "])+?";
  }
  function compile2(str, options) {
    return tokensToFunction(parse2(str, options), options);
  }
  function encodeURIComponentPretty(str) {
    return encodeURI(str).replace(/[\/?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeAsterisk(str) {
    return encodeURI(str).replace(/[?#]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function tokensToFunction(tokens, options) {
    var matches = new Array(tokens.length);
    for (var i = 0; i < tokens.length; i++) {
      if (typeof tokens[i] === "object") {
        matches[i] = new RegExp("^(?:" + tokens[i].pattern + ")$", flags2(options));
      }
    }
    return function(obj, opts) {
      var path2 = "";
      var data = obj || {};
      var options2 = opts || {};
      var encode = options2.pretty ? encodeURIComponentPretty : encodeURIComponent;
      for (var i2 = 0; i2 < tokens.length; i2++) {
        var token2 = tokens[i2];
        if (typeof token2 === "string") {
          path2 += token2;
          continue;
        }
        var value = data[token2.name];
        var segment;
        if (value == null) {
          if (token2.optional) {
            if (token2.partial) {
              path2 += token2.prefix;
            }
            continue;
          } else {
            throw new TypeError('Expected "' + token2.name + '" to be defined');
          }
        }
        if (isarray2(value)) {
          if (!token2.repeat) {
            throw new TypeError('Expected "' + token2.name + '" to not repeat, but received `' + JSON.stringify(value) + "`");
          }
          if (value.length === 0) {
            if (token2.optional) {
              continue;
            } else {
              throw new TypeError('Expected "' + token2.name + '" to not be empty');
            }
          }
          for (var j = 0; j < value.length; j++) {
            segment = encode(value[j]);
            if (!matches[i2].test(segment)) {
              throw new TypeError('Expected all "' + token2.name + '" to match "' + token2.pattern + '", but received `' + JSON.stringify(segment) + "`");
            }
            path2 += (j === 0 ? token2.prefix : token2.delimiter) + segment;
          }
          continue;
        }
        segment = token2.asterisk ? encodeAsterisk(value) : encode(value);
        if (!matches[i2].test(segment)) {
          throw new TypeError('Expected "' + token2.name + '" to match "' + token2.pattern + '", but received "' + segment + '"');
        }
        path2 += token2.prefix + segment;
      }
      return path2;
    };
  }
  function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
  }
  function escapeGroup(group) {
    return group.replace(/([=!:$\/()])/g, "\\$1");
  }
  function attachKeys(re, keys) {
    re.keys = keys;
    return re;
  }
  function flags2(options) {
    return options && options.sensitive ? "" : "i";
  }
  function regexpToRegexp(path2, keys) {
    var groups = path2.source.match(/\((?!\?)/g);
    if (groups) {
      for (var i = 0; i < groups.length; i++) {
        keys.push({
          name: i,
          prefix: null,
          delimiter: null,
          optional: false,
          repeat: false,
          partial: false,
          asterisk: false,
          pattern: null
        });
      }
    }
    return attachKeys(path2, keys);
  }
  function arrayToRegexp(path2, keys, options) {
    var parts = [];
    for (var i = 0; i < path2.length; i++) {
      parts.push(pathToRegexp2(path2[i], keys, options).source);
    }
    var regexp = new RegExp("(?:" + parts.join("|") + ")", flags2(options));
    return attachKeys(regexp, keys);
  }
  function stringToRegexp(path2, keys, options) {
    return tokensToRegExp(parse2(path2, options), keys, options);
  }
  function tokensToRegExp(tokens, keys, options) {
    if (!isarray2(keys)) {
      options = /** @type {!Object} */
      keys || options;
      keys = [];
    }
    options = options || {};
    var strict = options.strict;
    var end = options.end !== false;
    var route = "";
    for (var i = 0; i < tokens.length; i++) {
      var token2 = tokens[i];
      if (typeof token2 === "string") {
        route += escapeString(token2);
      } else {
        var prefix2 = escapeString(token2.prefix);
        var capture = "(?:" + token2.pattern + ")";
        keys.push(token2);
        if (token2.repeat) {
          capture += "(?:" + prefix2 + capture + ")*";
        }
        if (token2.optional) {
          if (!token2.partial) {
            capture = "(?:" + prefix2 + "(" + capture + "))?";
          } else {
            capture = prefix2 + "(" + capture + ")?";
          }
        } else {
          capture = prefix2 + "(" + capture + ")";
        }
        route += capture;
      }
    }
    var delimiter2 = escapeString(options.delimiter || "/");
    var endsWithDelimiter = route.slice(-delimiter2.length) === delimiter2;
    if (!strict) {
      route = (endsWithDelimiter ? route.slice(0, -delimiter2.length) : route) + "(?:" + delimiter2 + "(?=$))?";
    }
    if (end) {
      route += "$";
    } else {
      route += strict && endsWithDelimiter ? "" : "(?=" + delimiter2 + "|$)";
    }
    return attachKeys(new RegExp("^" + route, flags2(options)), keys);
  }
  function pathToRegexp2(path2, keys, options) {
    if (!isarray2(keys)) {
      options = /** @type {!Object} */
      keys || options;
      keys = [];
    }
    options = options || {};
    if (path2 instanceof RegExp) {
      return regexpToRegexp(
        path2,
        /** @type {!Array} */
        keys
      );
    }
    if (isarray2(path2)) {
      return arrayToRegexp(
        /** @type {!Array} */
        path2,
        /** @type {!Array} */
        keys,
        options
      );
    }
    return stringToRegexp(
      /** @type {string} */
      path2,
      /** @type {!Array} */
      keys,
      options
    );
  }
  return pathToRegexp$1.exports;
}
var pathToRegexpExports = requirePathToRegexp();
const pathToRegexp = /* @__PURE__ */ getDefaultExportFromCjs(pathToRegexpExports);
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d2 = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r2 = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x2 = b ? Symbol.for("react.responder") : 60118, y2 = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r2:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d2:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r2;
  reactIs_production_min.Portal = d2;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r2;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d2;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x2 || a.$$typeof === y2 || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  return reactIs_production_min;
}
var hasRequiredReactIs$1;
function requireReactIs$1() {
  if (hasRequiredReactIs$1) return reactIs$1.exports;
  hasRequiredReactIs$1 = 1;
  {
    reactIs$1.exports = requireReactIs_production_min();
  }
  return reactIs$1.exports;
}
requireReactIs$1();
var MAX_SIGNED_31_BIT_INT = 1073741823;
var commonjsGlobal = typeof globalThis !== "undefined" ? (
  // eslint-disable-next-line no-undef
  globalThis
) : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
function getUniqueId() {
  var key = "__global_unique_id__";
  return commonjsGlobal[key] = (commonjsGlobal[key] || 0) + 1;
}
function objectIs(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function(h) {
        return h !== handler;
      });
    },
    get: function get2() {
      return value;
    },
    set: function set2(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function(handler) {
        return handler(value, changedBits);
      });
    }
  };
}
function onlyChild(children2) {
  return Array.isArray(children2) ? children2[0] : children2;
}
function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;
  var contextProp = "__create-react-context-" + getUniqueId() + "__";
  var Provider2 = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Provider22, _React$Component);
    function Provider22() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }
    var _proto = Provider22.prototype;
    _proto.getChildContext = function getChildContext() {
      var _ref;
      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };
    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;
        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === "function" ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
          changedBits |= 0;
          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };
    _proto.render = function render() {
      return this.props.children;
    };
    return Provider22;
  }(React.Component);
  Provider2.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);
  var Consumer = /* @__PURE__ */ function(_React$Component2) {
    _inheritsLoose(Consumer2, _React$Component2);
    function Consumer2() {
      var _this2;
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      _this2 = _React$Component2.call.apply(_React$Component2, [this].concat(args)) || this;
      _this2.observedBits = void 0;
      _this2.state = {
        value: _this2.getValue()
      };
      _this2.onUpdate = function(newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;
        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };
      return _this2;
    }
    var _proto2 = Consumer2.prototype;
    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }
      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === void 0 || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };
    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };
    _proto2.getValue = function getValue2() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };
    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };
    return Consumer2;
  }(React.Component);
  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider2,
    Consumer
  };
}
var createContext = React.createContext || createReactContext;
var createNamedContext = function createNamedContext2(name) {
  var context2 = createContext();
  context2.displayName = name;
  return context2;
};
var historyContext = /* @__PURE__ */ createNamedContext("Router-History");
var context = /* @__PURE__ */ createNamedContext("Router");
var Router = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Router2, _React$Component);
  Router2.computeRootMatch = function computeRootMatch(pathname2) {
    return {
      path: "/",
      url: "/",
      params: {},
      isExact: pathname2 === "/"
    };
  };
  function Router2(props) {
    var _this;
    _this = _React$Component.call(this, props) || this;
    _this.state = {
      location: props.history.location
    };
    _this._isMounted = false;
    _this._pendingLocation = null;
    if (!props.staticContext) {
      _this.unlisten = props.history.listen(function(location) {
        _this._pendingLocation = location;
      });
    }
    return _this;
  }
  var _proto = Router2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;
    this._isMounted = true;
    if (this.unlisten) {
      this.unlisten();
    }
    if (!this.props.staticContext) {
      this.unlisten = this.props.history.listen(function(location) {
        if (_this2._isMounted) {
          _this2.setState({
            location
          });
        }
      });
    }
    if (this._pendingLocation) {
      this.setState({
        location: this._pendingLocation
      });
    }
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.unlisten) {
      this.unlisten();
      this._isMounted = false;
      this._pendingLocation = null;
    }
  };
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(context.Provider, {
      value: {
        history: this.props.history,
        location: this.state.location,
        match: Router2.computeRootMatch(this.state.location.pathname),
        staticContext: this.props.staticContext
      }
    }, /* @__PURE__ */ React.createElement(historyContext.Provider, {
      children: this.props.children || null,
      value: this.props.history
    }));
  };
  return Router2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(MemoryRouter2, _React$Component);
  function MemoryRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createMemoryHistory(_this.props);
    return _this;
  }
  var _proto = MemoryRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return MemoryRouter2;
})(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(Lifecycle2, _React$Component);
  function Lifecycle2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Lifecycle2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    if (this.props.onUpdate) this.props.onUpdate.call(this, this, prevProps);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.props.onUnmount) this.props.onUnmount.call(this, this);
  };
  _proto.render = function render() {
    return null;
  };
  return Lifecycle2;
})(React.Component);
var cache$1 = {};
var cacheLimit$1 = 1e4;
var cacheCount$1 = 0;
function compilePath$1(path2, options) {
  var cacheKey = "" + options.end + options.strict + options.sensitive;
  var pathCache = cache$1[cacheKey] || (cache$1[cacheKey] = {});
  if (pathCache[path2]) return pathCache[path2];
  var keys = [];
  var regexp = pathToRegexp(path2, keys, options);
  var result = {
    regexp,
    keys
  };
  if (cacheCount$1 < cacheLimit$1) {
    pathCache[path2] = result;
    cacheCount$1++;
  }
  return result;
}
function matchPath(pathname2, options) {
  if (options === void 0) {
    options = {};
  }
  if (typeof options === "string" || Array.isArray(options)) {
    options = {
      path: options
    };
  }
  var _options = options, path2 = _options.path, _options$exact = _options.exact, exact = _options$exact === void 0 ? false : _options$exact, _options$strict = _options.strict, strict = _options$strict === void 0 ? false : _options$strict, _options$sensitive = _options.sensitive, sensitive = _options$sensitive === void 0 ? false : _options$sensitive;
  var paths2 = [].concat(path2);
  return paths2.reduce(function(matched, path22) {
    if (!path22 && path22 !== "") return null;
    if (matched) return matched;
    var _compilePath = compilePath$1(path22, {
      end: exact,
      strict,
      sensitive
    }), regexp = _compilePath.regexp, keys = _compilePath.keys;
    var match2 = regexp.exec(pathname2);
    if (!match2) return null;
    var url = match2[0], values2 = match2.slice(1);
    var isExact = pathname2 === url;
    if (exact && !isExact) return null;
    return {
      path: path22,
      // the path used to match
      url: path22 === "/" && url === "" ? "/" : url,
      // the matched portion of the URL
      isExact,
      // whether or not we matched exactly
      params: keys.reduce(function(memo, key, index) {
        memo[key.name] = values2[index];
        return memo;
      }, {})
    };
  }, null);
}
function isEmptyChildren(children2) {
  return React.Children.count(children2) === 0;
}
var Route = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Route2, _React$Component);
  function Route2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Route2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context$1) {
      !context$1 ? invariant() : void 0;
      var location = _this.props.location || context$1.location;
      var match2 = _this.props.computedMatch ? _this.props.computedMatch : _this.props.path ? matchPath(location.pathname, _this.props) : context$1.match;
      var props = _extends$2({}, context$1, {
        location,
        match: match2
      });
      var _this$props = _this.props, children2 = _this$props.children, component = _this$props.component, render2 = _this$props.render;
      if (Array.isArray(children2) && isEmptyChildren(children2)) {
        children2 = null;
      }
      return /* @__PURE__ */ React.createElement(context.Provider, {
        value: props
      }, props.match ? children2 ? typeof children2 === "function" ? children2(props) : children2 : component ? /* @__PURE__ */ React.createElement(component, props) : render2 ? render2(props) : null : typeof children2 === "function" ? children2(props) : null);
    });
  };
  return Route2;
}(React.Component);
function addLeadingSlash(path2) {
  return path2.charAt(0) === "/" ? path2 : "/" + path2;
}
function addBasename(basename, location) {
  if (!basename) return location;
  return _extends$2({}, location, {
    pathname: addLeadingSlash(basename) + location.pathname
  });
}
function stripBasename(basename, location) {
  if (!basename) return location;
  var base = addLeadingSlash(basename);
  if (location.pathname.indexOf(base) !== 0) return location;
  return _extends$2({}, location, {
    pathname: location.pathname.substr(base.length)
  });
}
function createURL(location) {
  return typeof location === "string" ? location : createPath(location);
}
function staticHandler(methodName) {
  return function() {
    invariant();
  };
}
function noop$4() {
}
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(StaticRouter2, _React$Component);
  function StaticRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.handlePush = function(location) {
      return _this.navigateTo(location, "PUSH");
    };
    _this.handleReplace = function(location) {
      return _this.navigateTo(location, "REPLACE");
    };
    _this.handleListen = function() {
      return noop$4;
    };
    _this.handleBlock = function() {
      return noop$4;
    };
    return _this;
  }
  var _proto = StaticRouter2.prototype;
  _proto.navigateTo = function navigateTo(location, action) {
    var _this$props = this.props, _this$props$basename = _this$props.basename, basename = _this$props$basename === void 0 ? "" : _this$props$basename, _this$props$context = _this$props.context, context2 = _this$props$context === void 0 ? {} : _this$props$context;
    context2.action = action;
    context2.location = addBasename(basename, createLocation(location));
    context2.url = createURL(context2.location);
  };
  _proto.render = function render() {
    var _this$props2 = this.props, _this$props2$basename = _this$props2.basename, basename = _this$props2$basename === void 0 ? "" : _this$props2$basename, _this$props2$context = _this$props2.context, context2 = _this$props2$context === void 0 ? {} : _this$props2$context, _this$props2$location = _this$props2.location, location = _this$props2$location === void 0 ? "/" : _this$props2$location, rest = _objectWithoutPropertiesLoose(_this$props2, ["basename", "context", "location"]);
    var history = {
      createHref: function createHref(path2) {
        return addLeadingSlash(basename + createURL(path2));
      },
      action: "POP",
      location: stripBasename(basename, createLocation(location)),
      push: this.handlePush,
      replace: this.handleReplace,
      go: staticHandler(),
      goBack: staticHandler(),
      goForward: staticHandler(),
      listen: this.handleListen,
      block: this.handleBlock
    };
    return /* @__PURE__ */ React.createElement(Router, _extends$2({}, rest, {
      history,
      staticContext: context2
    }));
  };
  return StaticRouter2;
})(React.Component);
var Switch = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Switch2, _React$Component);
  function Switch2() {
    return _React$Component.apply(this, arguments) || this;
  }
  var _proto = Switch2.prototype;
  _proto.render = function render() {
    var _this = this;
    return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
      !context2 ? invariant() : void 0;
      var location = _this.props.location || context2.location;
      var element, match2;
      React.Children.forEach(_this.props.children, function(child) {
        if (match2 == null && /* @__PURE__ */ React.isValidElement(child)) {
          element = child;
          var path2 = child.props.path || child.props.from;
          match2 = path2 ? matchPath(location.pathname, _extends$2({}, child.props, {
            path: path2
          })) : context2.match;
        }
      });
      return match2 ? /* @__PURE__ */ React.cloneElement(element, {
        location,
        computedMatch: match2
      }) : null;
    });
  };
  return Switch2;
}(React.Component);
var useContext = React.useContext;
function useHistory() {
  return useContext(historyContext);
}
function useLocation() {
  return useContext(context).location;
}
var BrowserRouter = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(BrowserRouter2, _React$Component);
  function BrowserRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createBrowserHistory(_this.props);
    return _this;
  }
  var _proto = BrowserRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return BrowserRouter2;
}(React.Component);
/* @__PURE__ */ (function(_React$Component) {
  _inheritsLoose(HashRouter2, _React$Component);
  function HashRouter2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.history = createHashHistory(_this.props);
    return _this;
  }
  var _proto = HashRouter2.prototype;
  _proto.render = function render() {
    return /* @__PURE__ */ React.createElement(Router, {
      history: this.history,
      children: this.props.children
    });
  };
  return HashRouter2;
})(React.Component);
var resolveToLocation = function resolveToLocation2(to, currentLocation) {
  return typeof to === "function" ? to(currentLocation) : to;
};
var normalizeToLocation = function normalizeToLocation2(to, currentLocation) {
  return typeof to === "string" ? createLocation(to, null, null, currentLocation) : to;
};
var forwardRefShim = function forwardRefShim2(C) {
  return C;
};
var forwardRef = React.forwardRef;
if (typeof forwardRef === "undefined") {
  forwardRef = forwardRefShim;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var LinkAnchor = forwardRef(function(_ref, forwardedRef) {
  var innerRef = _ref.innerRef, navigate = _ref.navigate, _onClick = _ref.onClick, rest = _objectWithoutPropertiesLoose(_ref, ["innerRef", "navigate", "onClick"]);
  var target = rest.target;
  var props = _extends$2({}, rest, {
    onClick: function onClick(event) {
      try {
        if (_onClick) _onClick(event);
      } catch (ex) {
        event.preventDefault();
        throw ex;
      }
      if (!event.defaultPrevented && // onClick prevented default
      event.button === 0 && // ignore everything but left clicks
      (!target || target === "_self") && // let browser handle "target=_blank" etc.
      !isModifiedEvent(event)) {
        event.preventDefault();
        navigate();
      }
    }
  });
  if (forwardRefShim !== forwardRef) {
    props.ref = forwardedRef || innerRef;
  } else {
    props.ref = innerRef;
  }
  return /* @__PURE__ */ React.createElement("a", props);
});
var Link = forwardRef(function(_ref2, forwardedRef) {
  var _ref2$component = _ref2.component, component = _ref2$component === void 0 ? LinkAnchor : _ref2$component, replace2 = _ref2.replace, to = _ref2.to, innerRef = _ref2.innerRef, rest = _objectWithoutPropertiesLoose(_ref2, ["component", "replace", "to", "innerRef"]);
  return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant() : void 0;
    var history = context2.history;
    var location = normalizeToLocation(resolveToLocation(to, context2.location), context2.location);
    var href = location ? history.createHref(location) : "";
    var props = _extends$2({}, rest, {
      href,
      navigate: function navigate() {
        var location2 = resolveToLocation(to, context2.location);
        var isDuplicateNavigation = createPath(context2.location) === createPath(normalizeToLocation(location2));
        var method = replace2 || isDuplicateNavigation ? history.replace : history.push;
        method(location2);
      }
    });
    if (forwardRefShim !== forwardRef) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ React.createElement(component, props);
  });
});
var forwardRefShim$1 = function forwardRefShim3(C) {
  return C;
};
var forwardRef$1 = React.forwardRef;
if (typeof forwardRef$1 === "undefined") {
  forwardRef$1 = forwardRefShim$1;
}
function joinClassnames() {
  for (var _len = arguments.length, classnames2 = new Array(_len), _key = 0; _key < _len; _key++) {
    classnames2[_key] = arguments[_key];
  }
  return classnames2.filter(function(i) {
    return i;
  }).join(" ");
}
var NavLink = forwardRef$1(function(_ref, forwardedRef) {
  var _ref$ariaCurrent = _ref["aria-current"], ariaCurrent = _ref$ariaCurrent === void 0 ? "page" : _ref$ariaCurrent, _ref$activeClassName = _ref.activeClassName, activeClassName = _ref$activeClassName === void 0 ? "active" : _ref$activeClassName, activeStyle = _ref.activeStyle, classNameProp = _ref.className, exact = _ref.exact, isActiveProp = _ref.isActive, locationProp = _ref.location, sensitive = _ref.sensitive, strict = _ref.strict, styleProp = _ref.style, to = _ref.to, innerRef = _ref.innerRef, rest = _objectWithoutPropertiesLoose(_ref, ["aria-current", "activeClassName", "activeStyle", "className", "exact", "isActive", "location", "sensitive", "strict", "style", "to", "innerRef"]);
  return /* @__PURE__ */ React.createElement(context.Consumer, null, function(context2) {
    !context2 ? invariant() : void 0;
    var currentLocation = locationProp || context2.location;
    var toLocation = normalizeToLocation(resolveToLocation(to, currentLocation), currentLocation);
    var path2 = toLocation.pathname;
    var escapedPath = path2 && path2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    var match2 = escapedPath ? matchPath(currentLocation.pathname, {
      path: escapedPath,
      exact,
      sensitive,
      strict
    }) : null;
    var isActive = !!(isActiveProp ? isActiveProp(match2, currentLocation) : match2);
    var className = typeof classNameProp === "function" ? classNameProp(isActive) : classNameProp;
    var style2 = typeof styleProp === "function" ? styleProp(isActive) : styleProp;
    if (isActive) {
      className = joinClassnames(className, activeClassName);
      style2 = _extends$2({}, style2, activeStyle);
    }
    var props = _extends$2({
      "aria-current": isActive && ariaCurrent || null,
      className,
      style: style2,
      to: toLocation
    }, rest);
    if (forwardRefShim$1 !== forwardRef$1) {
      props.ref = forwardedRef || innerRef;
    } else {
      props.innerRef = innerRef;
    }
    return /* @__PURE__ */ React.createElement(Link, props);
  });
});
var classnames$1 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var hasRequiredClassnames;
function requireClassnames() {
  if (hasRequiredClassnames) return classnames$1.exports;
  hasRequiredClassnames = 1;
  (function(module) {
    (function() {
      var hasOwn2 = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn2.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else {
        window.classNames = classNames;
      }
    })();
  })(classnames$1);
  return classnames$1.exports;
}
var classnamesExports = requireClassnames();
const classnames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
const Button = ({
  children: children2,
  dataTest = "test-default-btn",
  disabled = false,
  onClick,
  size = "regular",
  mode = "primary"
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "kedro button", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    className: classnames(
      "button__btn",
      `button__btn--${size}`,
      `button__btn--${mode}`
    ),
    "data-test": dataTest,
    disabled,
    onClick,
    children: children2
  }
) });
Button.propTypes = {
  dataTest: PropTypes.string,
  disabled: PropTypes.bool,
  mode: PropTypes.oneOf(["primary", "secondary", "success"]),
  onClick: PropTypes.func,
  size: PropTypes.oneOf(["regular", "small"])
};
const CloseIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }) });
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition$1 = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context2) {
    var _this;
    _this = _React$Component.call(this, props, context2) || this;
    var parentGroup = context2;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2) forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : React.cloneElement(React.Children.only(children2), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition$1.contextType = TransitionGroupContext;
Transition$1.propTypes = {};
function noop$3() {
}
Transition$1.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$3,
  onEntering: noop$3,
  onEntered: noop$3,
  onExit: noop$3,
  onExiting: noop$3,
  onExited: noop$3
};
Transition$1.UNMOUNTED = UNMOUNTED;
Transition$1.EXITED = EXITED;
Transition$1.ENTERING = ENTERING;
Transition$1.ENTERED = ENTERED;
Transition$1.EXITING = EXITING;
var _addClass = function addClass$1(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c) {
    return addClass(node2, c);
  });
};
var removeClass = function removeClass2(node2, classes) {
  return node2 && classes && classes.split(" ").forEach(function(c) {
    return removeClass$1(node2, c);
  });
};
var CSSTransition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node2, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node2 = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node2, type);
      _this.addClass(node2, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument4[0];
      _this.removeClasses(node2, "appear");
      _this.removeClasses(node2, "enter");
      _this.addClass(node2, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument5[0];
      _this.addClass(node2, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node2 = _this$resolveArgument6[0];
      _this.removeClasses(node2, "exit");
      _this.addClass(node2, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass2(node2, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node2) forceReflow(node2);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node2, className);
    }
  };
  _proto.removeClasses = function removeClasses(node2, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass(node2, baseClassName);
    }
    if (activeClassName) {
      removeClass(node2, activeClassName);
    }
    if (doneClassName) {
      removeClass(node2, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props;
    _this$props.classNames;
    var props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends$2({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = {};
const DelayedRenderer = ({ children: children2, waitBeforeShow = 1200 }) => {
  const [isShown, setIsShown] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const timer2 = setTimeout(() => {
      setIsShown(true);
    }, waitBeforeShow);
    return () => clearTimeout(timer2);
  }, [waitBeforeShow]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CSSTransition,
    {
      classNames: "fade",
      in: isShown,
      onExited: () => setIsShown(true),
      timeout: 300,
      unmountOnExit: true,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: children2 })
    }
  );
};
const FeatureHintDot = ({
  appState,
  featureHintsContent: featureHintsContent2,
  featureHintStep,
  hideDot,
  requestedHintClose
}) => {
  const [elementCenter, setElementCenter] = reactExports.useState({ x: null, y: null });
  const [hideHighlightDot, setHideHighlightDot] = reactExports.useState(hideDot);
  reactExports.useEffect(() => {
    setHideHighlightDot(hideDot);
  }, [hideDot]);
  reactExports.useEffect(() => {
    const findAndSetCoords = (elementId) => {
      if (!elementId || requestedHintClose) {
        return;
      }
      const $element = document.querySelector(elementId);
      if ($element) {
        const { left, top, width: width2, height: height2 } = $element.getBoundingClientRect();
        setHideHighlightDot(false);
        setElementCenter({
          x: left + width2 / 2,
          y: top + height2 / 2
        });
      } else {
        setHideHighlightDot(true);
      }
    };
    if (!featureHintsContent2[featureHintStep].elementId) {
      setHideHighlightDot(true);
    }
    findAndSetCoords(featureHintsContent2[featureHintStep].elementId);
  }, [appState, featureHintStep, featureHintsContent2, requestedHintClose]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "feature-hints__highlightDot",
      style: {
        left: `${elementCenter.x}px`,
        opacity: hideHighlightDot ? 0 : 1,
        top: `${elementCenter.y}px`
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { fill: "none", height: "100", viewBox: "0 0 100 100", width: "100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            cx: "50",
            cy: "50",
            fillOpacity: "0.1",
            fill: "url(#paint0_radial_103_11727)",
            r: "49.5",
            stroke: "#FFBC00",
            strokeWidth: 1.5
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "radialGradient",
          {
            cx: "0",
            cy: "0",
            gradientTransform: "translate(50 50) rotate(90) scale(50)",
            gradientUnits: "userSpaceOnUse",
            id: "paint0_radial_103_11727",
            r: "1",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "0.140625", stopColor: "#FFE300", stopOpacity: "0" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("stop", { offset: "1", stopColor: "#FFE300" })
            ]
          }
        ) })
      ] })
    }
  );
};
const mapStateToProps$o = (state) => ({
  appState: state
});
const FeatureHintDot$1 = connect(mapStateToProps$o)(FeatureHintDot);
const featureHintsContent = [
  {
    title: "Workflow run status",
    description: "Get a clear view of what happened during your pipeline run. The Run Status feature helps you quickly understand whether a run succeeded or failed, which nodes executed, and where any issues occurred, so you can debug faster and improve your workflows with confidence.",
    learnMoreLink: "https://docs.kedro.org/projects/kedro-viz/en/stable/workflow-view/",
    elementId: ".pipeline-menu-button--workflow"
  },
  {
    title: "Publish and share Kedro-Viz",
    description: "You can publish Kedro-Viz and share it with others by hosting your project on AWS S3, Azure Blob Storage and GCP Cloud Storage, making sharing with collaborators and stakeholders easier and faster.",
    learnMoreLink: "https://docs.kedro.org/projects/kedro-viz/en/stable/share_kedro_viz/",
    elementId: ".pipeline-menu-button--deploy"
  },
  {
    title: "Preview your datasets in the metadata panel",
    description: "View a small preview of datasets by clicking on a node and opening the metadata panel. The ability to expand to view a larger preview is also possible when the panel is open. Along with a preview, there will also be information about your dataset, such as the file path and the dataset type.",
    learnMoreLink: "https://docs.kedro.org/projects/kedro-viz/en/stable/preview_datasets/",
    elementId: "#nodes .pipeline-node--data:first-of-type .pipeline-node__bg"
  },
  {
    title: "Plotly and Matplotlib",
    description: "Kedro-Viz supports integration with Plotly and Matplotlib in order to make interactive visualisations of a Kedro project.",
    learnMoreLink: "https://docs.kedro.org/projects/kedro-viz/en/stable/preview_plotly_datasets/",
    elementId: ".pipeline-node__bg--plotly",
    image: "data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAk4AAAFICAYAAACm6HF1AAA2fklEQVR4AezWAQEAIAwDoGuD9Q87I/gAkIKTpAMAwE/vACsAIE4AAOIEACBOAADiBAAgTgAA4gQAIE4AAIgTAIA4AQCIEwCAOAEAiBMAgDgBAIgTAADiBAAgTgAA4gQAIE4AAOIEACBOAACIEwCAOAEAiBMAgDgBAIgTAIA4AQCIEwAA4gQAIE4AAOIEACBOAADiBAAgTgAA4gQAgDgBAIgTAIA4AQCIEwCAOAEAiBMAAOIEACBOAADiBAAgTgAA4gQAIE4Aj727BJAqCqM4fp6MG56QspKm4q4JGu7WcEib6AGHiEuvVNyh4O7OjrsiPa28y/9Xx+faefoBAMEJGLRc11V3d7disZhMEQ6HZdtmDEGfz6dAIEDbDEKO43inbQAPcAV4ZGGeMWOGvn77qQ8fP8gEo0aO1PcfP1Sv1+V1kUhEtmUrk80Y0za9vb0qVyryulAopGArOP3q7dVAunXjmgATWEOHDm0I8MDkv3r1aj34FBMAb1m5aIK2bV4iwAANV4CH3HrwVAC8w5K0cHZSgClsAQAAgOAEAABAcAIAACA4AQAAEJyMBwAACE4AAAAgOAEAABCcAAAAKLkC9KyfoJ8/f8oEiURcmUxG9XpDXhcMBmRZtgqFgjFtk8vlVa1W5XV+v79dski5XE4D5cn9ywIITsAAuHD2hF68eCETjBkzRp8+fTJicY7H4+1CzMaE2nbbfP36VaVSyYiCxdFoVO3fA4DghP/M1j17jdmr4Q8EVC6VDKnA76qtVqsa0zaVSkWNet2ItrEcS9VyRf3h3etHOnZovwYBgOAE9By+qMELwIYF4zSYWJalUaNGqb0X0bZtpVIptff0ptPpf08BODkcAIBIJKI1a9Zo48aNSiaT6uzs1IIFC7Rjxw5NnTr139MAghMAAE327gI6qnt9+/41EQgSIliQ4u4UPS0tsGiR9lA97va+j7u7u7sd14dVOYcqxf7FXYoHJ4EUQtCgsXnWd63/zgrTDGTI7GRm9/p0zUpmZs8kaUJyzf279/2bNWuWCE+//OUv9bvf/U5vvvmmfvzjH2vFihW6du1aKyc5FNAPptzc3FZ7xYqLi7nvMxUt+vsCVLVa4viioiIVFhZynzKSOTiZmZmVlZXR4K+LFy/q3r17vK87d+6ovLxcR44cUaBbt25aunSpvvWtb+mb3/ymvva1r2nYsGGEIoKXvvCFL3C7vvKVr3Afy34KEIi+//3vq2/fvlq4cKG++93vasqUKQJLhK+++iqP01e/+lV98YtfJJwp45iDk5mZ2fnz5zVgwADNnz9fvXv3VkvxeLy5kvTyyy9r0KBB2rRpk1avXq2qqioNHz6c4KQ5c+bo6aef1oYNG/Thhx8yQkRf//rXqUw1V6mGDBlCoCJE6cSJE5xdSnVKr732mi5fvqx33nmH5yVIEdBkbg43MzPLODt37qSapKlTp2rBggWckUv1SUePHtXu3bs5c5LQo8GDB+snP/lJ8/LdmTNnCE0qKSnRuHHjtHbtWh0/flzgGKpL06dPJ2gpwFJgTU2NAosXL+bjafPmzWpsbBTWrVunV155hbBFBUzm4GRmZpYx6urqCCvatm0bIUj9+/dnCY4QRd+RVq1aRSWK5Ttdv379MxUpKkhNTU0PzCdjkChn5pWWljb3NnEslaiW+vTpQxVL3/ve99QSgalr164OTg5OZmZmmYfgc+vWLS6qrKzUgQMHtGzZMo0aNUpgAG2ypm0CEfdxCQTXqSLx3MlwH2MP3n//fbXE4whZ5h4nMzOzjDJx4sSgKhRgeY4Ly2jB0hvLefQfJZ4NR2WJkESlqmUzOFUqqlAPDU4s2zFRnwoVU9uDCx+PQGYOTmZmZhnl2Wef1Z//839ey5cvp8lbM2fOpGFb48ePp9lbOHfunE6fPs1Zb5o7dy69S5wJx3IelSHt3buXs+U4s06TJk3SCy+8QI8St+thWB5kCZCz8WbPns3z0hiuH/3oR0GYC595qc7sL3xlimpv3ozMcL679+6qqbFJ2S6/axflxHJ0P+P6Nvy94Y90bl5eh31vzp89pkzx9ttva+zYsVSTWJpjWY5eJr3xxhuccScwouCDDz4g2NCTRIWJqeI6dOgQFSVt376dAMXz8P+SqhHN4s09SoSj/fv3f6b6RKWJeVHTpk2jAZ3H8hiej+U6WfaKlZSUxJXhzCilf/vb36bR05v8epPfEHiT3yhj2Y2fT8IN/96SLZXl5+dzNh1LeYnH8Hieh4bzlJfaEh9rWS3u4JRVHJz6Dh6nm7URqjjdvaempkZluy75XRTLydH9+9GpON2/d18NEdi0mGoT35+7d+8oXa5Xn9evfvFjfQ6ZxfNkWYtXkZzyWlFREZSJMw5l7+DU23S80vrfH1UpOm7JsvF7Y99YMEFmbg63rDJhwgSaF1mTpwSc0k7hbHLZpUuX0EMd03qZyPvMM89wJorMzMwcnKzDsQ5PcKJnoby8nPV4zvIgRD0QpOhtYCIu/RqM/wcBhiZJTq+lL4XHBfeBoW7BY1keY0gcp94SuDieJkcey8d4VLBjuWPNmjWcvcIMFZmZmTk4Waf0XxBwBg4cqKFDh3Kd02XZWJJTbjmLg6CjkSNHclvzKbSEIY7nLcGGPZxGjx7NMc3Pu2jRoub5Jy+++CJVLU7dJYBRQeJ9juFjKwmqWYQ1zlrhcQSuzllKNDMz8zgC43TaS5cu6ZNPPtHZs2eZPUIw4ZRYKkGEJPZi4nRajmNfJapE9ENxm5566imqQPQd6cknn6QHKehHosrUfBYIA9w4jt4kltwIQkEYmjVrFlN4k57FQ1gimFFpYqlu48aNKi8vFwhvPH+qVTYzy5iGc/6Nhz7t28zByULBUhtLalSDcPDgQX7xMGyNUKSTJ08SkghGSfueWnPlyhVCk8A+T5xKy1JfMDQuGT42c0/Y3DLY14nlwSA4Ec4cnMyyVyymUIc4ukJtDk4WKqpKBKNdu3bR78QrQZbLVFZWxmA3BrQFoao5CNHbxBA2qlfDhw9nmY6qVNKAQj8VFSj2eaKqRSBLho/H/Bv6oZi5RIWKABU4duzYY40joMplZp2vob4h82d2FfQJKdXVSXU3ZQ5OlmValrGPHDnC1gJavHhxc7WHcf/l5eWaN28eIYYgpQAVKHqXjh8/zoWlOx5LRYnHNocfnitA9Yg+KsIYwYmwxsdoDQPm9u3bR9Ch0kSlK9iewMwsfHndlTdgnsIQv3tZjRe3yBycLMswQTtAMOLsNUrnhBQCELZu3UpliSoU1aUHHktlKdjd+7e//S3BiqqVAvRPtcQWBCtXruS4YPouPUyt9jmw7xO9UEzF5ng20zQz6ygxxZSTm68wNOXmKSLMwckIM4kIQ60hTAUIQhzXBkEoQ9K+KZ4PBLN0h6al8ybIzDpXj+53Mz05KSeP4BRngwyu8z53tPL2UffpwWMeN5CZg5PZtWvXxKUjndr0E52tqFAUDCwboOrL1WqIwIafhT17Ki83T9duXI/M96am5orqGuqU7boXFKigezddvXpNnxtJKk5BJGqXnFyZg5NZFjXCX1TV+UpFQW5M3uQ3g7833uQ3i1EYouIUBi/VZRMHJ7Ovf+v7kfnjXFTUSzTjNzXFle0KCroqFsthaTYy35vbt+80h9ryo4e1bu1HsizqccrLa9tqHG8Ra9tqXhO7JpiDk1m2mLH0NXU0s0EbP3JwyrJBUzk5+VIIi3U5rjhFjYOTmZlZTn6X5jJRUsH9KYhFqcfJHJzMzMzYDYEeJ8XjXElnblKjK04R4OBkZmaW8pKal+rMwcnMzIyKU0jzlnJy8mQOTmZmZpER47+8fFeczMHJzMysbeOWuqTeyNSGZqhY5MYRmIOTmZl5HEFbAo6X6szByczMLCb2qktBNMcRmIOTWbf8XJmZPXIcQW5u8j1727Hnb25uTOmSn5+vwsJC8bneunVLbJwej8fbMKm/gG2O2GSdbYGS7xlqDk5m//Of/W1dqKpSFPTr209sH9PQ2BCB3fJ7KDcvTzdv3ojM9+b69euqq68Tsm1/RCPg5ITUHB5L07Y+RVqyZIn69u0rEJo+/PBDVVVVPTQQDhw4UEuXLhXhiet1dXU6dOiQtm3b9tnQZQ5OZgcP7NepU6cUBU888YQ3+c3c702Wb/JrBJywqlnp8Pzzz6tr16568803xc/ZggULtHz5cv385z/netKwRWi6cOGCNmzYoMbGRo0ZM0avvfaajh8/rpqaGpmDk9kDVv3h97LM1ZTbRX/97/49rXz7DVnn8VIdwSmn5bJb2vC87dWjRw9NmjRJv/rVr3Tp0iVhy5Yt+t73vqd+/fqpsrJSrSFo8SJlx44dzRtqV1RUiKBVUlLi4OTgZPZZ3W9XyjJXQ34PmXU+NvkNqeKUhudleY5qUcugw9JwU1OT+vTpkzQ4cQxLefPnz9eNGzd0+fJlUR2tr6/XmTNn9JjMwcnMzDzHKSeMgpNGDy1T6axZStWuXbsUoCGc3iSCUoAle6737NlTyVBZWr9+vV5//XV96UtfEg3l3bp101tvvfWYS/7m4GRmZhYs1YXg6s1bourTHpwN9zhoCJ8xY4auXLkiepxGjhypJ598UgsXLtSKFSvE8p05OJmZmaUkFowNCMHNO/dozm7fc9y8yckUDzSac52xBNyXzIgRIzRlyhTRQM7JC1yOHDmiH/zgB3rmmWe0evVqmYOTmZmlzMkpRsUpcbsUrmVAjxMVI0ISDd1BUArmMtHH1LLCxHG3b98OrrOc90Blifc5m7VLly56DObgZGZmFmtRcYpl3JgDwtKxY8dEk/d7770n+p3mzp3b3PAdWLx4sWgW/9nPfiZmNJ0/f14EpTlz5mjz5s3CoEGDVFZWJs7KMwcnMzOzlMXCHICZpjlOq1at0le+8hX9qT/1p8QZdlSVVq5cqTt37ijQu3dvFRcXK0CoWrt2rZjlNH78eNEQ3r17d3388cc6efKkwmcOTmZm5ubwThisSdXpxz/+sQg+LMfV1tYqEZWmlqg6lZeX68SJEyzt0SPF49p3Rp05OJmZmTHHKR7kqMfcmq61x/O86USFKVX0OdELZQ5OZo/UlJMvy1zxWK7MMkFOXk5IAzBzZA5OZlnjn/x0paqrLysKSktLdO36dcWb4sp2DOHjlfjt23e0e8d2mXUilrDC63Gi4mQOTmbZYt2aVd7k15v8mj1SXm4sC543ZObgZPaL//afVB+NRkgaQjmbJos39C3Qn/nLf0XHjh6WZRpv8psXUsWJSpY5OFkWYpfs/v37i8vevXtT+gPMY9nzKEz5+fnibBGWcK5du5a2jzck70a0fmrzlbXqexSqsFcvmWWi/LyQgpOX6rKSg5OxPxHLI+yInfLa/6uvvqq3335bDF0Ly+TJkzVhwgSxp9PgwYPFx2NDyo5gZu5xys9NfZNfL9WZg1NE9ejRQ6NGjdLFixfFXA+qTX379hX7GPH+gQMHRChimuzw4cPFL5GKigoxdXbo0KEaOHCgpk2bJvZbunfvnqhAEXCoEg0ZMkT0EPXr10+c8srH4vHnzp0T9xGC6GM5fvx40ioXvS7Dhg0Tu3jzvMuXLxebUX7yyScKm5lZLKg4pT5z4JEzC3Kz76w6c3AywhJY/qKxmOW6Z599Vozw79mzpxYtWiSmyxKImEZLwGG0/wcffKD6+nqBtzwPYYjptAQc9kFi7D/BiRBG2OF2AtrEiRNF4KqsrBRhjJBFQGsNS3Q8d7AHE48vLS1VRzEzJycqQ4rzfky80/x+PB68bRGK2NwuOEYPPi7AMUHvlDk4WXZhYBqhhCrS2bNnRWgiCNFsTJii0sSGjwxIoxJFnxGBiqU9HkOYOnr0KNUmjn1gh26eA9zGdNpdu3aJEPTlL3+ZShNhjLBGxYvglLTixGaVBDZwPLcFJk2axOeUcs+UZZ6S4mJRneTni+8xlwjgxQQ/91RuIzEqghcz2YRqd01NTbuaw/PzchWGXJ7cHJwsu1Epon+IQAX2LeIXz5IlS0SF6PTp0wSoICAlSnY7m0kG1S0CExtQ8jEIaw/9g0KI4zkJOzwHnx8hLVBdXZ1SEArCGIHLMgrfX372CMp8j3g/Ki9OuPBzG5kKdTZ9b/ic2ycmKkNhNDmxebA5OFmWo0GcniUqQPyiHzBgAMGEKgBLbfwSotok8D5VpaKiIv7Y0edEIOEVNstzVKqSfgyOobeJIMTzJROEuDFjxqi8vFzjxo0jzLUMTo/1qjnz2L379/leB9Um3o9KIKQySwU3Ks3SEfnepFBxCmVJzUt1lrXByYLGbtCTRJiZOXOmQFjil/6GDRs4u40gQ9Wp+XiatqdOnUrliOU4lu80Z84cXbp0iaAj8D5Vq8COHTt4fj399NOELx6rZLh/y5Ytmj17NsuI2r17N5+TOoKZWSzVs99ccbLoBycjjAQIOAcPHtSRI0cEeouCQEUooseIMBOgiZzAxOO4fePGjVShmhvHQdBqiefYvn07x/EYHktjufr06aNEhw4dYlmPgMYrXe/cbWaRmeOUF8tRRJiDkxGYEhCGHnksIYhLqh+DZvHa2lolCoISx6ZbRUNRdCaH5+WqsSGLJ4fzs5WBzILm8ODMuSSzBoIz5VKaVeCKk+XJLHWd1mz63T/zF7xXnZm1oTk8xtvEcQLclnAdsbYc4y1XLKLByczMvFdd4qDK5rpR++Rl05Yr5uBk9i//4T/gjCdFQbBnYFbJydcv/u8KrVv7kTKZWZe8nKQLb4HUB4m7OdwcnB7rjx17sDEXibPWGAR55coVpmMrfDarpE4qyVU0sESXXV9LY/divZUVG/uaz6r74+CUfI7TY414Sn3LFXNw8ua6zEnizDJmHnGWGUEqg4KTmZnX6sJqRXLByVIMTkaliZlGY8eOFdj6hD3cMoOZmcVEZSicyeEMDjYHJ0sBc5GYtM2SHXt0UYFi37cMYmbmpbqcmPeqs0wITlZeXq7CwkJCE5O0GRTJQEmZmVlmbbnS3OOExLzTPMYpecNT4m1cz00tkJmDkw0dOlTnzp3Tpk2blJnMzKy5MhRLlq4Sr7ftmHT2TvXo0UODBg1in0e20aL1o80bHNNjywv4kpISBhGzDZYsI4OTUW3iB5Ulu8xjZmaxEMcG5MRiaRuA+5WvfIWwxC4LhCC9++67Onz4sB6GE5LYQP3VV1/V9evX2YNU165dy9zg5OBk7MHGRrctdxrnjDo2xTUzswyZHB5Sc3i6lupeeOEFlZeXa926deweQL+sFixYwItyKkhKhtC0fPlyvf3224QlQpcb1jM/OFllZSVn1ynAD3mmMDNzj1NmN4cXFxerrKxM77//fjDQl15ZghN/W5L+TenevbumTp3Khu4czybqLO3JMjo42fHjx7nIOkdd71GyzhPP7yazLBBacEpHdad3795swM4y3QN7f1J5ohUkmV69eql///7s16l58+bRI8VzsLzHW1lGBiebM2dO8wwn0j5jCXbu3Kn9+/crfLbsWz/0Jr9m9ugep5CC09ABfbVkyRKl6qOPPmrZK8u/+weqRSy5NTU1qWfPnkqmW7duhCfNmDGDJT0eo8mTJxOi9H/+z/+h50mWccHJ9u7dS5lUgblz56qurk4dwyZPma7SPv0UBf369tXAwUP4ZalMV3X+vC5cqJRZtmAcgeLNTU5t24iOt4gnP+ZizRVt3LhR7UG1icoVL74DvM/lYX9P8vPz2d+S/iZVV1cLRUVF+uY3v6nZs2dr9erVsowLTsYPPJcAp5AOGTKEMKXw2b/5899Wx7J4br7+4xtr9d//y7+XWVb44x6nuBDjato2/OXS3o3G6WFinEDL4MTqBWHqYUtunJREpYrxBYHbt29zchJ9U5xxRxVKllHByYYNG0ZTX/Na98iRI3XixAl1DMu9VqGOZfEu3WXmpbr09U5RLaLSzHZdnKmN0tJSlu4YLaAA/U78nWEj+SA4EdoGDx6sqqoqgRDF0h/hKWNDk4OTK06UUoM1ac6KuHr1qszMLLPGEYQwjUC5sRy1F7OXtm/frqVLlxJ8WH7T/PnzGW2jy5cvK/DKK68QnvQf/sN/IFTxt4Z2ES1cuJAQRbVJo0aNYgaU3nrrLVlGBiejcY/ZGUFY6tOnj0aPHu2qk5lZBo0jCPJNLM3JiedOB3afYGmNE45YsuNEkQ0bNjzQCkKIoiJFaAoQnKhW8ThQofrVr37lsTiZF5wsOIOOLVf4ISbtg2U7LlkSnMzMvOVKO6RrBZAqE2fa0euE1prC33vvvVZXPXbt2sWZ3FSrqF55llNmBicjNDGtlbXlESNGEJwIU/zgMvlVmcPMzIKAk9gIHhMSb0veLJ54Pc2tUwSmNJyoZBkYnIxUzxoyM5xo1KupqREy61RyMzOLJewpl5M8KKV8DC+YzcHJ2oiQxJh7GvEYQRBg6BiXTGFm5qW6jHhec3CyadOmadKkSczM0JkzZwhQ2rJlSwYFJzMzy22e44Q0zb90xclSD05GUOLMB3aypreJuU5syphRzMzc4xQK5ybLk6W8XMcppGzIyCgCdqsuKChQx7CGkiGyjp8cLh2WWRaNI6DHKRMCmTk42dGjRxl5T68TQ8g4I6J536Lw2ff+zr/W2YoKRcHAsgGqvlythiyY9nvr5g2ZZZOcUBJOyoHMHJzs5MmTbLTI7A298cYbjCno0MFjFpOFE4zYI8vMS3VpfV5zcDLG3zPPieD0u9/9ThMmTOAPjg4fPqzw2U//1p+QpVleV/3nD7Z7E1+L3l51KXaHP/oYV5ws5eBkTz31lPbs2aP+/fuz+SJ7C2ncuHEdHpx69+6tmTNnsgWM3n333ZSGqDH9vLKyMtQZVAwJZQ8lqnNU6U6dOsUSp9ordrFclmYFhYoWs5hyEgvUiddjiW/bdoxzk+XJUm4OZ3fqAMGF0fkdberUqeywra1btzI9NqWtY5577jn95je/YainwsKZhufPn+djaPHixWxGyXWFz8wsxOZwpfS85uBkR44c0bPPPis0NjYynqDDt1xhhhTVHDYaZsuX3bt3s9GwxowZQzDS5s2bmSvFMZo4caJw4cIFjmNpkeVGLViwgM2KOTuQ59OhQ4eoDmnGjBns2k3FiOvq1asXYZGvW+PHj+fr5TF8jIcGL/ZS4nF8fhxPL5iZWcfNcUoYypS2pnOZg5OloqKiQqtWrWJ+E8GA99nBWh2JffLoq2IJ7Ny5c3wuhBrCCuMRtHTpUraHYddsQhAbQFL1oeKjqqoqAg9Li+y6Tbhi2Y/gxFgFwhePYSmSMMZO3DwPFS76ughMmjx5smbPns3ZhA+tzD3xxBMENJbpCG4yM+uwcQTNVzrt9BRzcPLgS8IJu1lToTl9+jR71qkz0M/EciFVJUINvU5FRUWaPn1684bEhJzCwkICD8GJyhHBSJcuXWJpj7D3yKW6ffv2EaiERYsWEdhYmmzz3Co+xh/90R8Rnvi4BCiBil23bt2UOayoqBdBV4+Lnwvmm/Xo0UNRMGDAAP4NBb2DWY1/a1yyqepLP+Snn36qxxaPS/GmFOaBpzBPnOc1BydLzaBBg/iHTXBSJiAIUXki6ICgRMWHRvZNmzaxITHBJ1kIY0muTWFt//79BKCgV6pNGyNT5SJAMSw0CE5Uxh7nlz9N7eGw2tpb7fpDRTBnWZbl4yggBPJzS/9itqMKTaDl6/lcaWpUKOKNMgcnS6GxmjPpeAveD4IKl85y/PhxPf300yzZURViE2J6kujB4n16mqiYUT3i8yT0sUTHGYEsoWnu3LlU0zR48OCk1aSDBw/S/6SdO3dyDEGGZTy1hiDGcxLY+HgEHj7HANWyzGIE7fac9chjg7dRwL8dvhYu2Y6vIfh6PnfBKYSKU6wpLnNwsjai/4clMc4YGz58OGeKCfQLEUo6EiMRaLoGfUsff/wx4YjlOfqwuE9r1qzR2LFjqRbRi9W8EfEf/vAHmr8JP4wloCpFRYjlRy5CeXl5EAxBEKOvinBFhYtK0kP/6NB4zrG8cn/nnXc4A1Adw8wsLjWFExTjrji1jYOTsURFw3UrS1SdMnE5MbhQhufSEssm27ZtUyKWGLkgCElcEh/bEpUjQhaXAKGMilYiqlLBsWZmnSKkgBNzj1ObODgZvQ6tnBnm7WeoUCUKc0lgdW1v3YzIFjc9enRn2VJNnV76v6/yo4cVGWZxKk4tmsOTar4//N4pc3AyY0mOS0f6j//tv9JkrgjgLDYassMImmYW2lJdk8zByczMzGfVtUGMSpY5OJlli3f/+7+Wpc+OT+/q+9/7lqLFLO5xBDAHJ7PY6Z2yNMofq8gxiytxAGb6uOLk4CQzMzP3OLVReoIT415GjhzJaBuGx3LykcrLyxkcnNK+pczgO3PmDHP59BjMwcnMzCyuWMJSXaZVnNhwfcmSJcy846xtLVu2jDmBzNVr00BlBg3z+HHjxjEr7/GDkzk4mZmZxUPrcWpKyy4Uzz33HDPvCEoCZwuzQTsDlZmz96jHv/jii2ylw36lMgcnMzOzdognNHHHuC3J9RSPSUNzeFlZGctsLbeiYmAwS3bs4vDQ4MQxs2fPZistrV27lqqTzMHJzMysfc3hjQ2h5CY1Nqm92BqL5Tn2Fg3wPnPxCFQP64uip2ny5MlasWKFzMHJzMwsDeKKE5xCUFhcrEmTJilVLfczZYmNjbVb4jq9TV27dlUybM7Ohu6rV69m71FClszByczMLA0rdQ0tpxEE77f+VsnvS3x8/d07bJWk9uDx9ClxCfA+FSUqUcnMmzePDdxZptOMGTPYqJ3qlYYNG0bFii2w2IRd5uBkZmbWZvGg4hSPk0jSulXdndob7d726caNG1SWODNOAUJQbm4u9ymZiooKqkwaOnSoUFBQwPPQF8WG6zp37tyDwckcnMwO5I/g1ZqioKBrV9XV13XqJr/l5ysURWbxhvpQ9vhNxxJgTU0NZ8Np9OjRvGWZjjBEjxP3KcD9jCjYs2cPy3hav379A1UqQtTrr7+uffv2ae/evQ8u/8EcnMz+9r/4197k18weLh4nOLWSkYL1t+B60hyV9JimNGxsTlVo8+bNWrRokUpLSxl6yTwmHT16lN6lB5bmWJYjOCEhGBG0CFS8bT00mYOT2de/9X1dvXpVUVBU1Eu1tbUPrTj9+hc/1s2bN2VmqYkTcBKaleLN18G1WJJjEGv9mDQ1nVMlono+YsQI9ezZU9u2bdPBgwd5IdXyGJbwkg7EJHBRaUo6/NIcnMxm71+tz4uSxa/rD4VF7QhOZq44pXu/uniatnIhDFFh4pLM/v379TAEJ6pR5uBkZmbWznEE9QoDc5wixhyczMzMFacGpdAdnu6tXMzByczMzAMw6Z2KDHNwMjMziwcDMMU7YpZTklPmEm5s7Rgl3Bat4GQOTmZmZkFzeBhLdQ0yByczM7PIDcDEw3by9VKdOTiZmZnFQ+hxcsXJIhuczMzMm/w2hBScGpoUGebgZGZmxnDJpobGhO7ueCtvA8mPSbyvKd4gc3Ayyx4LX1Z9fYOiIDc3T40PWU64Xtxfj8fMGkOrOMVlDk5mWeMv/Zf/7k1+zezhqDjVNyoMbPKbNczByWzR88s0eWq1ssGxo4e5qOOZWVODB2Cag9PnVn5+Pjtk6/bt22r8nP+jnbt3n7JBQVmZNj+3xMGpc5gLTlScwulxcnN4ZnNwsu7du+vll1/WnTt3tHXrVl2+fFltQdAaP3689u7dqzDl5OSotLRUkydP1qZNm5qXnQh7PXr00OzZs7V69Wqly71LF5U1hg6VmXUGluoako+5TLwthWO8VGcOThlu7NixOn36tHbs2KFUFBQUaNKkSaEHp5EjR2rZsmUEO23evFmBYcOGacmSJe7f6XhmFmdnFPc4mYPT505RUZGmTZumvLw8Kkg6cOAAYUhDhw5VU1OTdu/erfLycqo6mjBhAqfg6tq1a3r//fc1ZswYlZWV6ctf/rIOHTqk+vp6nk979uxRz549tXDhQq1atUojRoygMtX8S4bbnnvuOfXt21e5ubn6+OOPdebMGSVz4sQJXb16VUuXLv3M7dXV1XrttdfU8czMzeENaaoxxRLOqnNwcnCyjHXjxg2qTVRztH//fk2ZMkUlJSX64IMPCEWaN28eZ5gRqAgqBCKqP4QeHkcg0rvvvkvVhyDFsl/z8hohKhaLqUuXLiy1aeXKlbp//z4hjPv13nvvqV+/fpo/fz7BSelUWFhIGFQqCI7Zhq+xa9euSob/99xPQM12fB3B1xsFwfcmCqg+Z+HXw++j9hScmOMUyl51vGg1ByfLYIQeqkVcCDgEnrlz5/JHikoPbzV9+nQNGjSIahNVJ35B6ubNm/wD17179xQgKLXm4sWLunLlCvfzPAQnfeELX+C5CW9Kt3HjxhGEFHV8jXzPHlZR5I9DFBr+CcMEwChVe/m3V1dXF4k+SX4Ws+jnjM+VinW7Kk6N9Q0JwSje5gbw4G1rjyeQZQlzcDIqT2fPntXGjRubgxBBicbsFStWEHLUq1cvgdsJQMEx/AHgVWfwOC6JOO7WrVs0oGvXrl3Nx6Ybz/04IYTAlU1qa2uZ0/TQihShNQp9YJzxGYT5COBr4Q83wTYSwYlqNF/P54nHEZiDk+ngwYN66aWXtHjxYgINZ62xxMYfaD3zzDOEI5q1aQjnDxlBi2N18uRJfmnS18R19enTJ2nZngbvV199lVfcBC/CFst2SoYKFX1YLB1SCWPZkAA3ZMgQlgpZWtSCBQvoreLzVMcwM2+5ElZzeJPMwckyVUJ1huU3KkuEEYLT3bt3WY7T22+/zZIQwUlbtmzhVTJVDP3+979X7969CTIcy2N55anr168TnDhGx44doz/qgY/xxhtvsPQSVKCo9hDSWq0y1NTUMCaBS/NtOH/+PEFJO3fu5HlYalRHMTNrqk+hx8mb/EaHg5Ml9lgQQBJL7gSl1paEOJaloJahiEuw7AeCV2Ko4T4ugYEDB9IonviKjmVDQlmryxk8Lz1X6da1f5myQdeyTvs8zYwBmGH1OHmp7lEcnMyqqqq4KBPseHKaqqsvKxscW/uRzKwzxMPa5NfN4dnFwcls3ZpVj97k18y85UpDU0jN4fG0jbygN3XUqFGcjKCKigqtX7+edoeHbr9FT+nEiRNVXFxMuwVtEezawJnR+gxzcDKbPGW6Svv0U0fZtWObso+Z0cQdrLSlU2Oa5jg9/fTTDDTmLGkCEDP09Pzzz3MyDteTzktjaDHtGvS/9u/fn90ltHz5cv385z/XZ5iDk9msK7c1q2uxOsK4l1/S6w5OWcYsmOOUhoATUnM4FaY5c+ZozZo12rdvX/P4EnZa4ISeS5cuJR1Jw5nUwXy+w4cP08eqr371qww6bb69mTk4mV3YvUcdZeDMmco+ZhanMpTB4wgY38JSHTs8BDjBhyGy7PyQLDgFQ40Th4UGb83ByczMLHVBj1PCeXNIdpvadAzBKZ6WyfScMd1ySY7rhB+GGKewnQ47RzCrzyNfHJzMzMwef6kuWFKLt5qrEqRwzKCx4/Rsr75KFb1MLZu8GenSEte5tHUfT56DocY0ibN8Zw5OZmZmjyfEpbrq02d16NS5dm+fxbJcyy2tuM5uDZxV9ygcy36ibN7+4Ycfsswnc3AyM7N2cI9Tk8Jw59at9u7JGOzewFJbMJSYXR0IRFx/ZGM5lSZGErz11luqrKyUOTiZmZk9vniIzeFpCGSME2D+Evt7vv/++/Q2acKECWyN9UBjOAGJQMWIApbx2PrqxRdfZHlOP/vZz9i5QebgZGZmaeAepzjvSLHYo7vDY2rjMekbgMkoAjZt//////+fxnDCkD7++GP2B1Vg2LBh7E2qAO+PHj2aJT798Ic/VEuHDh3S6tWrZQ5OZmZmGTOOoDEN4wjAXp9svM74ARq9L1y4kLgPKUGIEQTNjeSXL1/Wr3/9a3qhlODx9wY1ByczM7NMnuMUYFmOSzKEqcQN3c+dOydzcDJrs9K/9ueDxszQ7aq/rexjZlRo6EUKKzhlDXNwMvvdr3/mTX47jZk3+RU9TtnCHJzM/uSXv82ZJwpLQa9C/cef/i9VXahU9jKzhpAqQ41NcWUNc3AyO/zv/6vCNOmVl5T9zNwc3tC2gOPgZA5OZmZm9SEFHAJZpJiDk5mZuTk8tIpTPK4IMwcnMzNzxYn3Y0LibSkeE63gZA5OZmZmcRGcmhJvTXJkCsd4qc4cnMzMLAXucXLFKVocnMzMzD1OKQQcj3EyByczM3PFKS0tTeC2iC/VmYOTmZm5x6ll8Ikneavk97XyeDeHR4uDk5mZWVwJ4wjij3ibwn2uOGUVByezJ//jv9TN2lqF5Z6kW6veVBYzszgVJ89xMgcnM/2nf/cvvMlvyMy85Ury1qdGZRFzcDL7zte+o9qbtWqvvF499S//2T+UmaXE4wgUV5YyByfr2bOn+vTpo4qKCjXRCPk5sPsf/3ulwxf/zT9RNJlZXCEu1cXilJ+yjTk42fTp0zV27Fh9+umnunDhQpuDUywW0/Lly7Vq1SrV1dUpLIsWLdLEiRN1584dYd++fdqzZ4/MzMJ2R01amXNdZmHIUdax/Px8jRo1il4fHT58WPX19SooKNCgQYO4KDc3V+jevbsGDx6sJ554QsXFxUJhYSHX1b9/f/Xq1YvHNd+H0tLS5sd269ZNRUVF6t27N4GL4zVkyBAey8fQo2zevFm//OUvuejAgQPqcGZmZg5O1qNHD5WUlBCSNHToUK5r4cKFmjJliubMmaNp06YRdDRy5Ehu06RJk/TCCy8Qhjiet5owYYIGDBig0aNHc0zz81IpAtWiF198UQsWLND48eMJYJo/fz7vc4wGDhyoRyF0BSGLcNfhzMzMvFRn169f16VLl/TJJ5/o7Nmzmjt3Lkt12r9/PyGFkKSjR4/q0KFDHKe+ffsSYOiH4jY99dRT2rBhg+7du6cnn3xSXbt2FXJycqgyCXl5eaqpqeE4xeNxvfzyyzp//jwXQpRmzZqlyspKJVNVVaVhw4ZpxowZVKz03nvv8bkIhDeeP9UqWzrFcnKooHV6jxqfQ0NDg7IdXwc/e3wtUekf5N/H/fv3le14ocSLIr6ebMHvs1u3bsnMwclCwVIb1R2qQTh48CC/eLR06VJCkU6ePMkvTYJR0r6n1ly5coXQJFDhoieKpT6cO3dOD0Nw4wIqVVS2guBEOOvs4BSEw85E0OASBfy/5GvhbRQEX0tjY6O/N50UnMwcnCw0Fy9eZClMu3bt4i2v/glMVJr00Ucf0aAdhKrmIERvE38UCEcjRozgFSlVqaQBpbq6mgoUvUr8EubxehiqTIQ1fgGWlZWpvLxcgWPHjilVhC2qXOkSb2rS1atXO33J9dq1a5Go0vA18IeZ/6dRWQ7na4lCxYl/h7zo4esxM/c4fW5Rxm5Z3aGatHjxYi1btoyeJX5RUmnSvHnzqPioS5cuCnA7vUtUgTgjjxDEYzlLr7a2ViBsEXpaNnrT18RxwbFIVsGaOnUqx1H14jl15swZmZmZueJknWLdunUK8Kp4zZo1vOInQBGahK1btxKKqEJRXXrgsVSWuI1w9Nvf/pZg9UAPBP1TLd28eVMrV67kOB5DhYHm8lb7hE6fPq3169dT9SJEZV5vhZmZmYOTtbbkkyy0EKYCBKE2hpsglCFp3xTPhzCWOWa8/orSoaAjG8PNzMzByYz+HC4daXX1SZ2tqFC77V6vyDIzMwcnMxrU8/JyNWhAmdKB5+lELGXSOB+Zs+oQkXEEfG/o6YvE2V3BEj5jQLKpes5uA2YOTmaPh6VFxhnwCzUqZwcx/Z0zFaMwHJSJ8/TNRep7w4kTd+/ejcKMLcaIZMv3Jl0B3MzBydy/xdl5/CFjq5mo/HFmHhZfUwQwMiJK3xuGuEYiCFI5o+r0/9i7WxsIgSAAo7PLb3BURO90gcUiKIFLtgAwJ2Dznh6xlzGfuDAf3w34HAEAgHACABBOAADCCQAA4QQAIJwAAIQTAIBwAgAQTgAAwgkAAOEEACCcAAAc+YVt26Im67pWc+B33/fadlPNhf7jOOI8z/gPIM3zfD1OAQBw5agLAID/OEHf95Fz/uzbU0pxZxzHMvdyZQf376xuN0XTNGVHL1Z+xzAMjzPTNEXXdVEhEE7Qtm0sy/Jj3ww8FIiCMP4BVFWhklQVJaWgChAiVUJJRf9pUhQCQQRBEkUgBdQunPkczt7eAXjl/WAtg5k3b83M9/ah0+lgOBwin8/jXXA4HGi1Wmi32xiPx0gmk7DicrnQ7XZpMxgM5MkirSLZbBb9fp8xST7+K9KhUAiTyQTRaFTZ3HzvK657KpWCDYyx2WxKjsSe7yqSSCQwGo3QaDToq8fjgRWv18t9WKvV0Ov1UCwWodFodOOk+TDC4TDi8ThmsxnW6zWLNyd/9RG/ZbKn77vdDrlc7pdqZhgGttstptOp/JTMRiMQCCipNKXTaez3e8bj9/sRi8X+VHEqlQptFFU2ZI3Ff4mF61+tVm19LRQK3G+r1QrL5ZL5UjE3pVIJp9MJ8/lc4uB3YiWTyeDxeGCxWGCz2aBcLuPD0Gh046TRBINB3G433kC7XC6iFHByfgcikQiu1yuezycOhwN8Ph/cbjd+YpqmxEWb+/3O21w8OlIMp9NJteV8PuP1ekmRlqbW9kirXq/jeDzS9oudM9BcLArC+AAQECSAgogEKnqDJNK7BaAHCBCAAEoSopCAkFJQFVCt33BwDxuAufc/P1a7d8PMztmdb+ebc61SKBTkdDpxrrgVSF0QerF9qsJpNpvxeyoIv9+vSbuRCdN+v9fa7HY7KRaLEkOuTAIRVpyx2+0mGcNxXDg5Ds2LZhCgcaVlPwORF2Lnk7h/xc7UAPF0Pp/FGogmJhsIPXi9XuQXTz6YYuhUg9dHUCurIJQQq0BOxB7bcNQKsVur1dQKGwwGOnWzBnEiWMNZQyDFtQGE1efzkX6/L51ORxaLhTiO48LJyRg0tXgZmX/80wC2DjtawOf7/f5v7M1mk6kGlpDJ/KgD0KCBmvAsFopYjfl8nl0bfo4FZnJCiMigJiEnahPnE0TIdDrFRlVLr1KpWNtBY0qJSE2cNc5eLGobjYZsNhsZj8fkpDXKGI7jwslxeHlfsLiw7WgA9/td0sDlcsEaYWrGxEKb8OPxwCYJuzMqQFqtFtYKlhANT59ZgwkTsSGGiK9UKmF1JfbQyA+BsVqtZL1eY7Fi2elzYxA754oaED/ig2kftWFpGmsSMcVZw3Lle+xFUT+ErTkReL1e9YwxfeLzeDwGS1LPFnkhbPmByCJXcsoYjuNvDncc9k9Y4uXmEw17Pp/L8/mUNMCuCQu53AakSfG/fKYaNLFutyvD4ZBGprec2DfhphMsl0uEh7mpxna7lXa7jR2nNQg7TNVqlSkHtUIsJsQWvyZnaxwOBymXy9xEI3ZEKwJEa9Pr9WQ0GrF7xnNqRb4qOCaTiTkLEiGHWOW2I7dO+fMONly9XicvhBRnCpuOv0+cO10QdxzH3xzuZBT2T2jeTAHSGDvNjAaXdrCpmGqwH/RXzlXYfyJnRJNVEH0I9F9x8p1cLvevvTvwqCyN4zj8q2nuzJiZyVVJqBQESokEkQgqUSFEob8uQRKRClWBCEQICilSqVSVuut9uYssu4uGdp+Hy8y55wDw8X3PVYqpfx+0QEk4AQD4kysAAF4OBwAQTgAAwgkAQDgBAAgnAACEEwCAcAIAEE4AAMIJAOA/HU4AAMIJAADhBAAgnAAAhBMAgHACqKysjEKhEBUVFfEXAIQTwOfPn6O7uzump6djcnIypqamor29Pd4AEE4A9fX10dfXFysrK7GwsBCbm5vx/PwcSVqfvn//Hr9+/Ypv375FWflaWqnKvn79Gl++fIkfP37k61VVVfme9Elx9l4AquI3Afj06VPc39/HxcVFPDw8xM3NTZQ1NzdHb29vvLy85BhaWlqKpqam6OzsjNfX17i+vo719fX8fVqqzs/Pc0AtLy/n1aqxsTE/d3p6mu8DsDgBH9rJyUkcHBzE7OxszMzMRH9/f16UkvTvnZ2dmJ+fT2tUXpF6enpicXEx5ubmImlpaYmkuro6NjY28vWfP39GW1tbrK6uxtraWrS2tuagArA4AR9aOpZLwbO7u5uDqaOjIwYGBtLRXf6uvEA9Pj7mIEru7u4iSUtSsViM5Pb29s/rdXV1OZS6uroiOTs7y8sWgMUJ+NBqa2ujoaEhnp6e4vLyMg4PD9N6lP+fYid9n47bUlSlI7303lNNTU1an3I0XV1dxVvp2C8F19bWVjqiy5/0LIBwAj60tCKNjo7G+Ph4jI2N5eO57e3tKJVKsbe3l99xGhoayvck+/v7MTg4GMPDwzmcjo6O4q3j4+P0vlN+ZmRkJCYmJt5tcQKoKBaLpfiNANLRWvlILkVTWVqY0i/q0jFcWVqb0i/l/m5FSrFUKBTec20CKP2zcAIAoFQZ/2sAAN5xAgAQTgAAwgkAQDgBAAgnAADhBACAcAIAEE4AAMIJAEA4AQAIJwAA4QQAIJwAABBOAADCCQBAOAEACCcAAOEEACCcAAAQTgAAwgkAQDgBAAgnAADhBAAgnAAAhBMAAMIJAEA4AQAIJwAA4QQAIJwAAIQTAAB/AHcGHj/wVFfnAAAAAElFTkSuQmCC"
  },
  {
    title: "Filters and tags",
    description: "Use filters and tags to adjust the view of your visualisation and see only what you want, whether that's Nodes, Datasets, or tags you've created yourself.",
    elementId: ".pipeline-nodelist-section__title span",
    learnMoreLink: "https://docs.kedro.org/en/stable/build/nodes/#how-to-tag-a-node"
  },
  {
    title: "Settings panel",
    description: "Find additional settings and experiments by opening the settings panel. You can even show or hide this very onboarding journey.",
    elementId: ".pipeline-menu-button--settings"
  }
];
const localStorageKeyShowHints = "showFeatureHints";
const localStorageKeyFeatureHintsStep = "featureHintStep";
const updatedFeatureHintsContent = isRunningLocally() ? featureHintsContent : featureHintsContent.slice(1);
const numFeatureHints = updatedFeatureHintsContent.length;
const FeatureHints = ({ metadataVisible, onToggleShowFeatureHints }) => {
  const [areFeatureHintsShown, setAreFeatureHintsShown] = reactExports.useState(false);
  const [featureHintStep, setFeatureHintStep] = reactExports.useState(0);
  const [hideHighlightDot, setHideHighlightDot] = reactExports.useState(false);
  const [requestedHintClose, setRequestedHintClose] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const localStorageState = loadLocalStorage(localStorageName);
    if (localStorageState[localStorageKeyShowHints]) {
      setAreFeatureHintsShown(true);
    } else {
      setAreFeatureHintsShown(false);
    }
    if (localStorageState.featureHintStep) {
      setFeatureHintStep(localStorageState.featureHintStep);
    }
  }, []);
  reactExports.useEffect(() => {
    if (!updatedFeatureHintsContent[featureHintStep].elementId) {
      setHideHighlightDot(true);
    }
    saveLocalStorage(localStorageName, {
      [localStorageKeyFeatureHintsStep]: featureHintStep
    });
  }, [featureHintStep]);
  const triggerCloseHints = () => {
    setRequestedHintClose(true);
    setHideHighlightDot(true);
    onToggleShowFeatureHints(false);
    setTimeout(() => {
      triggerLocalStorageSave();
    }, 4e3);
  };
  const triggerLocalStorageSave = () => {
    setAreFeatureHintsShown(false);
    saveLocalStorage(localStorageName, {
      [localStorageKeyFeatureHintsStep]: 0,
      [localStorageKeyShowHints]: false
    });
  };
  if (areFeatureHintsShown === false) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DelayedRenderer, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FeatureHintDot$1,
      {
        featureHintsContent: updatedFeatureHintsContent,
        featureHintStep,
        hideDot: hideHighlightDot,
        requestedHintClose
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "feature-hints",
        style: {
          right: metadataVisible ? `${metaSidebarWidth.open + 36}px` : "36px"
        },
        children: requestedHintClose ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "feature-hints__reopen-message", children: "You can revisit these hints at any time in the Settings panel." }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-hints__nav", children: [
            featureHintStep + 1,
            " of ",
            numFeatureHints,
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: "feature-hints__close",
                onClick: () => triggerCloseHints(),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feature-hints__header", children: updatedFeatureHintsContent[featureHintStep].title }),
          updatedFeatureHintsContent[featureHintStep].image && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              alt: updatedFeatureHintsContent[featureHintStep].title,
              src: updatedFeatureHintsContent[featureHintStep].image
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feature-hints__description", children: updatedFeatureHintsContent[featureHintStep].description }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-hints__buttonsWrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: updatedFeatureHintsContent[featureHintStep].learnMoreLink ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: updatedFeatureHintsContent[featureHintStep].learnMoreLink,
                rel: "noreferrer",
                target: "_blank",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { mode: "secondary", size: "small", children: "Learn more" })
              }
            ) : null }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feature-hints__backNextButtons", children: [
              featureHintStep > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  mode: "secondary",
                  onClick: () => setFeatureHintStep(featureHintStep - 1),
                  size: "small",
                  children: "Back"
                }
              ) : null,
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  mode: "primary",
                  onClick: () => featureHintStep + 1 === numFeatureHints ? triggerCloseHints() : setFeatureHintStep(featureHintStep + 1),
                  size: "small",
                  children: featureHintStep + 1 === numFeatureHints ? "Close" : "Next"
                }
              )
            ] })
          ] })
        ] })
      }
    )
  ] });
};
const mapDispatchToProps$g = (dispatch2, ownProps) => ({
  onToggleShowFeatureHints: () => {
    dispatch2(toggleShowFeatureHints(false));
  },
  ...ownProps
});
const mapStateToProps$n = (state) => {
  return {
    metadataVisible: getVisibleMetaSidebar(state)
  };
};
const FeatureHints$1 = connect(mapStateToProps$n, mapDispatchToProps$g)(FeatureHints);
const DownloadIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("g", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 4.5L12.7071 3.79289L12 3.08579L11.2929 3.79289L12 4.5ZM8.29289 6.79289L7.58579 7.5L9 8.91421L9.70711 8.20711L8.29289 6.79289ZM14.2929 8.20711L15 8.91421L16.4142 7.5L15.7071 6.79289L14.2929 8.20711ZM15.75 9.5H14.75V11.5H15.75V9.5ZM18.75 10.5H19.75V9.5H18.75V10.5ZM18.75 20.25V21.25H19.75V20.25H18.75ZM5.25 20.25H4.25V21.25H5.25V20.25ZM5.25 10.5V9.5H4.25V10.5H5.25ZM8.25 11.5H9.25V9.5H8.25V11.5ZM11 4.5V15H13V4.5H11ZM9.70711 8.20711L12.7071 5.20711L11.2929 3.79289L8.29289 6.79289L9.70711 8.20711ZM11.2929 5.20711L14.2929 8.20711L15.7071 6.79289L12.7071 3.79289L11.2929 5.20711ZM15.75 11.5H18.75V9.5H15.75V11.5ZM17.75 10.5V20.25H19.75V10.5H17.75ZM18.75 19.25H5.25V21.25H18.75V19.25ZM6.25 20.25V10.5H4.25V20.25H6.25ZM5.25 11.5H8.25V9.5H5.25V11.5Z" }) }) });
const labelPositionTypes = ["right", "left", "bottom", "top"];
const IconButton = ({
  active = false,
  ariaLabel,
  ariaLive,
  children: children2,
  className,
  container = "li",
  dataTest = "test-default-btn",
  disabled = false,
  icon,
  labelText,
  labelTextPosition = "right",
  onClick,
  visible = true,
  ...rest
}) => {
  const Icon = icon;
  let inTimeout;
  const [isTooltipVisible, setIsTooltipVisible] = reactExports.useState(false);
  const labelPosition = labelPositionTypes.includes(
    labelTextPosition.toLowerCase()
  ) ? labelTextPosition.toLocaleLowerCase() : "right";
  const showTooltip = () => {
    inTimeout = setTimeout(() => {
      window.localStorage.setItem("kedro-viz-tooltip-show", true);
      setIsTooltipVisible(true);
    }, 333);
  };
  const hideTooltip = () => {
    clearTimeout(inTimeout);
    setIsTooltipVisible(false);
  };
  return visible ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper$2, { container, ...rest, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        "aria-label": ariaLabel,
        "aria-live": ariaLive,
        className: classnames(className, {
          "pipeline-icon-toolbar__button": true,
          "pipeline-icon-toolbar__button--active": active
        }),
        "data-test": dataTest,
        disabled,
        onClick,
        onMouseEnter: showTooltip,
        onMouseLeave: hideTooltip,
        children: [
          Icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { className: "pipeline-icon" }),
          labelText && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "span",
            {
              className: classnames(
                "pipeline-toolbar__label",
                {
                  "pipeline-toolbar__label__visible": isTooltipVisible
                },
                `pipeline-toolbar__label-${labelPosition}`
              ),
              children: labelText
            }
          )
        ]
      }
    ),
    children2
  ] }) : null;
};
const Wrapper$2 = ({ children: children2, container: Container = "li", ...rest }) => {
  if (typeof Container === "symbol") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(React.Fragment, { children: children2 });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Container, { className: "pipeline-icon--container", ...rest, children: children2 });
  }
};
IconButton.propTypes = {
  active: PropTypes.bool,
  ariaLabel: PropTypes.string,
  ariaLive: PropTypes.string,
  children: PropTypes.node,
  dataTest: PropTypes.string,
  disabled: PropTypes.bool,
  icon: PropTypes.func,
  labelText: PropTypes.oneOfType([PropTypes.string, PropTypes.node]),
  // it takes a string or a JSX element
  onClick: PropTypes.func,
  visible: PropTypes.bool
};
const LogoIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 32 32", fill: "none", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M16 0L6.55651e-07 16L16 32L32 16L16 0Z", fill: "#FFC900" }) });
const SettingsIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "-4 -4 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.75 7L16.25 7 16.5 10 14.5 10z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0.75 7L2.25 7 2.5 10 0.5 10z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.75 0L9.25 0 9.5 3 7.5 3z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.75 14L9.25 14 9.5 17 7.5 17z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.7 2.05L14.2 2.05 14.45 5.05 12.45 5.05z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.8 11.95L4.3 11.95 4.55 14.95 2.55 14.95z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M2.8 2.05L4.3 2.05 4.55 5.05 2.55 5.05z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12.7 11.95L14.2 11.95 14.45 14.95 12.45 14.95z" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 8.389c0 3.866-3.134 7-7 7s-7-3.134-7-7 3.134-7 7-7 7 3.134 7 7zm-2 0c0-2.762-2.239-5-5-5s-5 2.238-5 5c0 2.761 2.239 5 5 5s5-2.239 5-5z" })
] }) });
const ThemeIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 3a9 9 0 110 18 9 9 0 010-18zm0 2v14a7 7 0 100-14z" }) });
const TreeIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a3 3 0 0 1 2.16 5.082l4.47 8.94a3 3 0 1 1-1.79.895l-4.469-8.94a3.03 3.03 0 0 1-.742 0l-4.47 8.94a3 3 0 1 1-1.789-.895l4.47-8.94A3 3 0 0 1 12 2z" }) });
const WorkflowIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22.4807 12.7497V11.2498H17.0115L14.7884 17.0228L9.21149 2.80371L5.91536 11.2498H1.49996V12.7497H6.96921L9.21151 6.96709L14.798 21.1862L18.0653 12.7497H22.4807Z" }) });
function groupByErrorStatus(items) {
  const status = { success: {}, failed: {} };
  Object.entries(items || {}).forEach(([id2, item]) => {
    if (item.error) {
      status.failed[id2] = item;
    } else {
      status.success[id2] = item;
    }
  });
  return status;
}
const getDatasetsStatus = createSelector(
  [(state) => state.runStatus.datasets],
  groupByErrorStatus
);
const getNodesStatus = createSelector(
  [(state) => state.runStatus.nodes],
  groupByErrorStatus
);
const isRunStatusAvailable = createSelector(
  [
    (state) => {
      var _a;
      return (_a = state.runStatus) == null ? void 0 : _a.nodes;
    },
    (state) => {
      var _a;
      return (_a = state.runStatus) == null ? void 0 : _a.datasets;
    },
    (state) => {
      var _a, _b;
      return (_b = (_a = state.runStatus) == null ? void 0 : _a.pipeline) == null ? void 0 : _b.runId;
    }
  ],
  (nodes, datasets, runId) => {
    const hasNodes = nodes && Object.keys(nodes).length > 0;
    const hasDatasets = datasets && Object.keys(datasets).length > 0;
    const hasValidRunId = runId && runId !== "default-run-id";
    return (hasNodes || hasDatasets) && hasValidRunId;
  }
);
const getPipelineRunData = (state) => {
  var _a;
  return ((_a = state.runStatus) == null ? void 0 : _a.pipeline) || {};
};
const getNodeError = (state, nodeId) => {
  var _a, _b;
  const node2 = (_b = (_a = state.runStatus) == null ? void 0 : _a.nodes) == null ? void 0 : _b[nodeId];
  return node2 == null ? void 0 : node2.error;
};
const getDatasetError = (state, nodeId) => {
  var _a, _b;
  const dataset = (_b = (_a = state.runStatus) == null ? void 0 : _a.datasets) == null ? void 0 : _b[nodeId];
  return dataset == null ? void 0 : dataset.error;
};
const isNewRun = (endTime) => {
  const lastEndTime = localStorage.getItem(localStorageLastRunEndTime);
  if (!endTime) {
    return false;
  }
  if (!lastEndTime) {
    return true;
  }
  try {
    const currentRunTime = new Date(endTime).getTime();
    const lastRunTime = new Date(lastEndTime).getTime();
    return currentRunTime > lastRunTime;
  } catch (error) {
    console.warn("Error comparing run timestamps:", error);
    return false;
  }
};
function setLocalStorageLastRunEndTime(endTime) {
  localStorage.setItem(localStorageLastRunEndTime, endTime);
}
const GlobalToolbar = ({
  isOutdated,
  onToggleSettingsModal,
  onToggleShareableUrlModal,
  onToggleTheme,
  theme,
  runStatusPipelineInfo,
  view
}) => {
  const [isLatestRun, setIsLatestRun] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setIsLatestRun(isNewRun(runStatusPipelineInfo.endTime));
  }, [isLatestRun, runStatusPipelineInfo.endTime]);
  reactExports.useEffect(() => {
    if (view === VIEW.WORKFLOW) {
      setLocalStorageLastRunEndTime(runStatusPipelineInfo.endTime);
      setIsLatestRun(false);
    }
  }, [view, runStatusPipelineInfo.endTime]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-global-toolbar", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pipeline-global-routes-toolbar kedro", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: "Kedro Viz logo and link",
          className: "pipeline-menu-button--logo pipeline-menu-button--large",
          dataTest: "global-toolbar-kedro-icon",
          disabled: false,
          icon: LogoIcon
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NavLink, { exact: true, to: { pathname: sanitizedPathname() }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: "View your pipeline",
          dataTest: "global-toolbar-flowchart-btn",
          className: "pipeline-menu-button--large pipeline-menu-button--link",
          disabled: false,
          icon: TreeIcon,
          labelText: "Flowchart"
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: "run-status-nav-wrapper",
          exact: true,
          to: { pathname: `${sanitizedPathname()}workflow` },
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                ariaLabel: "View your workflow",
                dataTest: "global-toolbar-workflow-btn",
                className: "pipeline-menu-button--workflow pipeline-menu-button--large pipeline-menu-button--link",
                disabled: false,
                icon: WorkflowIcon,
                labelText: "Workflow"
              }
            ),
            view === VIEW.FLOWCHART && isLatestRun && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "run-status-dot" })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pipeline-global-control-toolbar kedro", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: `Change to ${theme === "light" ? "dark" : "light"} theme`,
          ariaLive: "polite",
          dataTest: `global-toolbar-theme-btn-${theme}`,
          className: "pipeline-menu-button--theme pipeline-menu-button--large",
          icon: ThemeIcon,
          labelText: "Toggle theme",
          onClick: () => onToggleTheme(theme === "light" ? "dark" : "light")
        }
      ),
      isRunningLocally() && /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: "Publish and share",
          className: "pipeline-menu-button--deploy pipeline-menu-button--large",
          dataTest: "global-toolbar-deploy-btn",
          disabled: false,
          icon: DownloadIcon,
          labelText: "Publish and share",
          onClick: () => onToggleShareableUrlModal(true)
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: "Change the settings flags",
          className: "pipeline-menu-button--settings pipeline-menu-button--large",
          dataTest: "global-toolbar-settings-btn",
          disabled: false,
          icon: SettingsIcon,
          labelText: "Settings",
          onClick: () => onToggleSettingsModal(true),
          children: isOutdated && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "update-reminder-dot" })
        }
      )
    ] })
  ] });
};
const mapStateToProps$m = (state) => ({
  theme: state.theme,
  visible: state.visible,
  runStatusPipelineInfo: getPipelineRunData(state),
  view: state.view
});
const mapDispatchToProps$f = (dispatch2) => ({
  onToggleSettingsModal: (value) => {
    dispatch2(toggleSettingsModal(value));
  },
  onToggleShareableUrlModal: (value) => {
    dispatch2(toggleShareableUrlModal(value));
  },
  onToggleTheme: (value) => {
    dispatch2(toggleTheme(value));
  }
});
const GlobalToolbar$1 = connect(mapStateToProps$m, mapDispatchToProps$f)(GlobalToolbar);
const getGraphLoading = (state) => state.loading.graph;
const getPipelineLoading = (state) => state.loading.pipeline;
const getNodeLoading = (state) => state.loading.node;
const isLoading = createSelector(
  [getGraphLoading, getPipelineLoading, getNodeLoading],
  (graphLoading, pipelineLoading, nodeLoading) => {
    return graphLoading || pipelineLoading || nodeLoading;
  }
);
const Modal = ({
  children: children2,
  className,
  closeModal,
  message,
  title,
  visible
}) => {
  const handleKeyDown2 = (event) => {
    if (event.keyCode === 27) {
      closeModal(true);
    }
  };
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleKeyDown2);
    return () => window.removeEventListener("keydown", handleKeyDown2);
  }, [visible]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("modal", {
        "modal--visible": visible,
        [className]: !!className
      }),
      role: "dialog",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            onClick: closeModal,
            className: classnames("modal__bg", {
              "modal__bg--visible": visible
            })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classnames("modal__content", {
              "modal__content--visible": visible
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "modal__wrapper", children: [
              title && /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "modal__title", children: title }),
              message && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "modal__description", children: message }),
              children2
            ] })
          }
        )
      ]
    }
  );
};
var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">';
var prefix$1 = {
  xmlns: "http://www.w3.org/2000/xmlns/",
  xlink: "http://www.w3.org/1999/xlink",
  svg: "http://www.w3.org/2000/svg"
};
var REMOVE_TIMEOUT = 10;
var DEFAULT_FILENAME = "untitled";
function getEmptySvgDeclarationComputed() {
  var emptySvg = document.createElementNS(prefix$1.svg, "svg");
  document.body.appendChild(emptySvg);
  emptySvg.style.all = "initial";
  var emptySvgDeclarationComputed = getComputedStyle(emptySvg);
  document.body.removeChild(emptySvg);
  emptySvg = null;
  return emptySvgDeclarationComputed;
}
function getSource(svg) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$css = _ref.css, css2 = _ref$css === void 0 ? "inline" : _ref$css;
  if (!(svg instanceof SVGElement)) {
    throw new Error("SVG element is required");
  }
  svg.setAttribute("version", "1.1");
  svg.removeAttribute("xmlns");
  svg.removeAttribute("xlink");
  if (!svg.hasAttributeNS(prefix$1.xmlns, "xmlns")) {
    svg.setAttributeNS(prefix$1.xmlns, "xmlns", prefix$1.svg);
  }
  if (!svg.hasAttributeNS(prefix$1.xmlns, "xmlns:xlink")) {
    svg.setAttributeNS(prefix$1.xmlns, "xmlns:xlink", prefix$1.xlink);
  }
  if (css2 === "inline") {
    setInlineStyles(svg, getEmptySvgDeclarationComputed());
  } else if (css2 === "internal") {
    setInternalStyles(svg);
  }
  var source = new XMLSerializer().serializeToString(svg);
  var rect = svg.getBoundingClientRect();
  var result = {
    top: rect.top,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    "class": svg.getAttribute("class"),
    id: svg.getAttribute("id"),
    name: svg.getAttribute("name"),
    childElementCount: svg.childElementCount,
    source: doctype + source
  };
  return result;
}
function setInlineStyles(svg, emptySvgDeclarationComputed) {
  function explicitlySetStyle(element) {
    var cSSStyleDeclarationComputed = getComputedStyle(element);
    var key;
    var value;
    var computedStyleStr = "";
    for (var _i = 0, len = cSSStyleDeclarationComputed.length; _i < len; _i++) {
      key = cSSStyleDeclarationComputed[_i];
      value = cSSStyleDeclarationComputed.getPropertyValue(key);
      if (value !== emptySvgDeclarationComputed.getPropertyValue(key)) {
        computedStyleStr += "".concat(key, ":").concat(value, ";");
      }
    }
    element.setAttribute("style", computedStyleStr);
  }
  function traverse(obj) {
    var tree = [];
    tree.push(obj);
    visit(obj);
    function visit(node2) {
      if (node2 && node2.hasChildNodes()) {
        var child = node2.firstChild;
        while (child) {
          if (child.nodeType === 1 && child.nodeName !== "SCRIPT") {
            tree.push(child);
            visit(child);
          }
          child = child.nextSibling;
        }
      }
    }
    return tree;
  }
  var allElements = traverse(svg);
  var i = allElements.length;
  while (i--) {
    explicitlySetStyle(allElements[i]);
  }
}
function setInternalStyles(svg) {
  var style2 = document.createElement("style");
  style2.innerHTML = Array.from(document.styleSheets).filter(function(styleSheet) {
    return (
      // Prevent CORS errors
      !styleSheet.href || styleSheet.href.startsWith(document.location.origin)
    );
  }).map(function(styleSheet) {
    return Array.from(styleSheet.cssRules).map(function(rule) {
      return rule.cssText;
    }).join(" ");
  }).join(" ");
  svg.prepend(style2);
}
function getFilename(source) {
  if (!(source instanceof SVGElement)) {
    throw new Error("SVG Element is required");
  }
  return source.getAttribute("id") || source.getAttribute("class") || document.title.replace(/[^a-z0-9]/gi, "-").toLowerCase() || DEFAULT_FILENAME;
}
function commenceDownload(filename, imgdata, callback) {
  var a = document.createElement("a");
  document.body.appendChild(a);
  a.setAttribute("class", "svg-crowbar");
  a.setAttribute("download", filename);
  a.setAttribute("href", imgdata);
  a.style.display = "none";
  a.click();
  setTimeout(function() {
    if (callback) {
      callback();
    }
    document.body.removeChild(a);
  }, REMOVE_TIMEOUT);
}
function download(source) {
  var filename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_FILENAME;
  var url = URL.createObjectURL(new Blob([source.source], {
    type: "text/xml"
  }));
  commenceDownload("".concat(filename, ".svg"), url, function() {
    return URL.revokeObjectURL(url);
  });
}
function _fixSource(source) {
  return btoa(unescape(encodeURIComponent(source.replace(/[\u00A0-\u2666]/g, function(c) {
    return "&#".concat(c.charCodeAt(0), ";");
  }))));
}
var DEFAULT_OPTIONS = {
  debug: false,
  fixSource: _fixSource
};
function downloadPng$1(source) {
  var filename = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_FILENAME;
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_OPTIONS, _ref$debug = _ref.debug, debug = _ref$debug === void 0 ? DEFAULT_OPTIONS.debug : _ref$debug, _ref$fixSource = _ref.fixSource, fixSource = _ref$fixSource === void 0 ? DEFAULT_OPTIONS.fixSource : _ref$fixSource;
  var canvas = document.createElement("canvas");
  var dpr = window.devicePixelRatio || 1;
  document.body.appendChild(canvas);
  canvas.setAttribute("id", "svg-image");
  canvas.setAttribute("width", source.width * dpr);
  canvas.setAttribute("height", source.height * dpr);
  if (debug === false) {
    canvas.style.display = "none";
  }
  var context2 = canvas.getContext("2d");
  var imgsrc = "data:image/svg+xml;base64,".concat(fixSource(source.source));
  var image = new Image();
  function onLoad() {
    context2.scale(dpr, dpr);
    context2.drawImage(image, 0, 0);
    var canvasdata = canvas.toDataURL("image/png");
    if (debug === false) {
      commenceDownload("".concat(filename, ".png"), canvasdata, function() {
        return document.body.removeChild(canvas);
      });
    }
  }
  image.onload = onLoad;
  image.src = imgsrc;
  if (debug === true) {
    document.body.appendChild(image);
  }
}
var downloadSvg = function downloadSvg2(svgElement, filename, options) {
  return download(getSource(svgElement, options), filename || getFilename(svgElement));
};
var downloadPng = function downloadPng2(svgElement, filename, options) {
  return downloadPng$1(getSource(svgElement, options), filename || getFilename(svgElement), options === null || options === void 0 ? void 0 : options.downloadPNGOptions);
};
const exportGraph = ({ format, theme, graphSize, mockFn }) => {
  const downloadFormats = {
    png: downloadPng,
    svg: downloadSvg
  };
  const download2 = mockFn || downloadFormats[format];
  const svg = document.querySelector("#pipeline-graph");
  const clone = svg.parentNode.appendChild(svg.cloneNode(true));
  clone.classList.add("kedro", `kui-theme--${theme}`, "pipeline-graph--export");
  let width2, height2;
  const hasGraph = isFinite(graphSize.width) && isFinite(graphSize.height);
  if (hasGraph) {
    width2 = graphSize.width + graphSize.marginx * 2;
    height2 = graphSize.height + graphSize.marginy * 2;
    clone && clone.setAttribute("viewBox", `0 0 ${width2} ${height2}`);
  }
  if (clone) {
    let zoomWrapperElement = clone.querySelector("#zoom-wrapper");
    zoomWrapperElement && zoomWrapperElement.removeAttribute("transform");
    zoomWrapperElement && zoomWrapperElement.setAttribute(
      "transform",
      `translate(${globalToolbarWidth}, 0)`
    );
  }
  if (format === "png") {
    const maxWidth2 = 5e3;
    width2 = Math.min(width2, maxWidth2);
    height2 = Math.min(height2, maxWidth2 * (height2 / width2));
  }
  if (hasGraph) {
    clone && clone.setAttribute("width", width2);
    clone && clone.setAttribute("height", height2);
  }
  const style2 = document.createElement("style");
  if (format === "svg") {
    style2.innerHTML = "@import url(https://fonts.googleapis.com/css?family=Inter:400);";
  } else {
    style2.innerHTML = `.kedro {
      font-family: "Trebuchet MS", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", Tahoma, sans-serif;
      letter-spacing: -0.4px;
    }`;
  }
  clone.prepend(style2);
  const options = format === "svg" ? { css: "internal" } : void 0;
  download2(clone, "kedro-pipeline", options);
  svg.parentNode.removeChild(clone);
};
const ExportModal = ({ graphSize, theme, onToggle, visible }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      closeModal: () => onToggle(false),
      title: "Export pipeline visualisation",
      visible: visible.exportModal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-export-modal", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            dataTest: "export-modal-download-png-btn",
            onClick: () => {
              exportGraph({ format: "png", theme, graphSize });
              onToggle(false);
            },
            children: "Download PNG"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            dataTest: "export-modal-download-svg-btn",
            onClick: () => {
              exportGraph({ format: "svg", theme, graphSize });
              onToggle(false);
            },
            children: "Download SVG"
          }
        )
      ] })
    }
  );
};
const mapStateToProps$l = (state) => ({
  graphSize: state.graph.size || {},
  visible: state.visible,
  theme: state.theme
});
const mapDispatchToProps$e = (dispatch2) => ({
  onToggle: (value) => {
    dispatch2(toggleExportModal(value));
  }
});
const ExportModal$1 = connect(mapStateToProps$l, mapDispatchToProps$e)(ExportModal);
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports;
var hasRequiredLodash;
function requireLodash() {
  if (hasRequiredLodash) return lodash$1.exports;
  hasRequiredLodash = 1;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array2, setter, iteratee, accumulator) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        while (++index < length2) {
          var value = array2[index];
          setter(accumulator, value, iteratee(value), array2);
        }
        return accumulator;
      }
      function arrayEach(array2, iteratee) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        while (++index < length2) {
          if (iteratee(array2[index], index, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEachRight(array2, iteratee) {
        var length2 = array2 == null ? 0 : array2.length;
        while (length2--) {
          if (iteratee(array2[length2], length2, array2) === false) {
            break;
          }
        }
        return array2;
      }
      function arrayEvery(array2, predicate) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        while (++index < length2) {
          if (!predicate(array2[index], index, array2)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array2, predicate) {
        var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array2, value) {
        var length2 = array2 == null ? 0 : array2.length;
        return !!length2 && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        while (++index < length2) {
          if (comparator(value, array2[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array2, iteratee) {
        var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
        while (++index < length2) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      function arrayPush(array2, values2) {
        var index = -1, length2 = values2.length, offset = array2.length;
        while (++index < length2) {
          array2[offset + index] = values2[index];
        }
        return array2;
      }
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        if (initAccum && length2) {
          accumulator = array2[++index];
        }
        while (++index < length2) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function arrayReduceRight(array2, iteratee, accumulator, initAccum) {
        var length2 = array2 == null ? 0 : array2.length;
        if (initAccum && length2) {
          accumulator = array2[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array2[length2], length2, array2);
        }
        return accumulator;
      }
      function arraySome(array2, predicate) {
        var index = -1, length2 = array2 == null ? 0 : array2.length;
        while (++index < length2) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length2 = array2.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length2) {
          if (predicate(array2[index], index, array2)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array2, value, fromIndex, comparator) {
        var index = fromIndex - 1, length2 = array2.length;
        while (++index < length2) {
          if (comparator(array2[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array2, iteratee) {
        var length2 = array2 == null ? 0 : array2.length;
        return length2 ? baseSum(array2, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? undefined$1 : object2[key];
        };
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? undefined$1 : object2[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array2, comparer) {
        var length2 = array2.length;
        array2.sort(comparer);
        while (length2--) {
          array2[length2] = array2[length2].value;
        }
        return array2;
      }
      function baseSum(array2, iteratee) {
        var result, index = -1, length2 = array2.length;
        while (++index < length2) {
          var current = iteratee(array2[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object2, props) {
        return arrayMap(props, function(key) {
          return [key, object2[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object2, props) {
        return arrayMap(props, function(key) {
          return object2[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length2 = strSymbols.length;
        while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array2, placeholder2) {
        var length2 = array2.length, result = 0;
        while (length2--) {
          if (array2[length2] === placeholder2) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object2, key) {
        return object2 == null ? undefined$1 : object2[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform2) {
        return function(arg) {
          return func(transform2(arg));
        };
      }
      function replaceHolders(array2, placeholder2) {
        var index = -1, length2 = array2.length, resIndex = 0, result = [];
        while (++index < length2) {
          var value = array2[index];
          if (value === placeholder2 || value === PLACEHOLDER) {
            array2[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array2, value, fromIndex) {
        var index = fromIndex - 1, length2 = array2.length;
        while (++index < length2) {
          if (array2[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array2, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array2[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context2) {
        context2 = context2 == null ? root2 : _.defaults(root2.Object(), context2, _.pick(root2, contextProps));
        var Array2 = context2.Array, Date2 = context2.Date, Error2 = context2.Error, Function2 = context2.Function, Math2 = context2.Math, Object2 = context2.Object, RegExp2 = context2.RegExp, String2 = context2.String, TypeError2 = context2.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context2["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root2._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context2.Buffer : undefined$1, Symbol2 = context2.Symbol, Uint8Array2 = context2.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context2.clearTimeout !== root2.clearTimeout && context2.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context2.setTimeout !== root2.setTimeout && context2.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context2.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context2.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context2, "DataView"), Map2 = getNative(context2, "Map"), Promise2 = getNative(context2, "Promise"), Set2 = getNative(context2, "Set"), WeakMap2 = getNative(context2, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object2() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object2.prototype = proto;
            var result2 = new object2();
            object2.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array2 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array2), isRight = dir < 0, arrLength = isArr ? array2.length : 0, view = getView2(0, arrLength, this.__views__), start2 = view.start, end = view.end, length2 = end - start2, index = isRight ? end : start2 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array2, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array2[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined$1 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length2) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values3) {
          var index = -1, length2 = values3 == null ? 0 : values3.length;
          this.__data__ = new MapCache();
          while (++index < length2) {
            this.add(values3[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array2) {
          var length2 = array2.length;
          return length2 ? array2[baseRandom(0, length2 - 1)] : undefined$1;
        }
        function arraySampleSize(array2, n) {
          return shuffleSelf(copyArray(array2), baseClamp(n, 0, array2.length));
        }
        function arrayShuffle(array2) {
          return shuffleSelf(copyArray(array2));
        }
        function assignMergeValue(object2, key, value) {
          if (value !== undefined$1 && !eq(object2[key], value) || value === undefined$1 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assignValue(object2, key, value) {
          var objValue = object2[key];
          if (!(hasOwnProperty.call(object2, key) && eq(objValue, value)) || value === undefined$1 && !(key in object2)) {
            baseAssignValue(object2, key, value);
          }
        }
        function assocIndexOf(array2, key) {
          var length2 = array2.length;
          while (length2--) {
            if (eq(array2[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object2, source) {
          return object2 && copyObject(source, keys(source), object2);
        }
        function baseAssignIn(object2, source) {
          return object2 && copyObject(source, keysIn(source), object2);
        }
        function baseAssignValue(object2, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object2, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object2[key] = value;
          }
        }
        function baseAt(object2, paths2) {
          var index = -1, length2 = paths2.length, result2 = Array2(length2), skip = object2 == null;
          while (++index < length2) {
            result2[index] = skip ? undefined$1 : get2(object2, paths2[index]);
          }
          return result2;
        }
        function baseClamp(number, lower2, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower2 !== undefined$1) {
              number = number >= lower2 ? number : lower2;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object2, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object2 ? customizer(value, key, object2, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object2) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object2 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object2) {
            return baseConformsTo(object2, source, props);
          };
        }
        function baseConformsTo(object2, source, props) {
          var length2 = props.length;
          if (object2 == null) {
            return !length2;
          }
          object2 = Object2(object2);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object2[key];
            if (value === undefined$1 && !(key in object2) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array2, values3, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array2.length, result2 = [], valuesLength = values3.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values3 = arrayMap(values3, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values3.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values3 = new SetCache(values3);
          }
          outer:
            while (++index < length2) {
              var value = array2[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values3[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values3, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array2, iteratee2, comparator) {
          var index = -1, length2 = array2.length;
          while (++index < length2) {
            var value = array2[index], current = iteratee2(value);
            if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array2, value, start2, end) {
          var length2 = array2.length;
          start2 = toInteger(start2);
          if (start2 < 0) {
            start2 = -start2 > length2 ? 0 : length2 + start2;
          }
          end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
          if (end < 0) {
            end += length2;
          }
          end = start2 > end ? 0 : toLength(end);
          while (start2 < end) {
            array2[start2++] = value;
          }
          return array2;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array2, depth, predicate, isStrict, result2) {
          var index = -1, length2 = array2.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length2) {
            var value = array2[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object2, iteratee2) {
          return object2 && baseFor(object2, iteratee2, keys);
        }
        function baseForOwnRight(object2, iteratee2) {
          return object2 && baseForRight(object2, iteratee2, keys);
        }
        function baseFunctions(object2, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object2[key]);
          });
        }
        function baseGet(object2, path2) {
          path2 = castPath(path2, object2);
          var index = 0, length2 = path2.length;
          while (object2 != null && index < length2) {
            object2 = object2[toKey(path2[index++])];
          }
          return index && index == length2 ? object2 : undefined$1;
        }
        function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object2);
          return isArray(object2) ? result2 : arrayPush(result2, symbolsFunc(object2));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object2, key) {
          return object2 != null && hasOwnProperty.call(object2, key);
        }
        function baseHasIn(object2, key) {
          return object2 != null && key in Object2(object2);
        }
        function baseInRange(number, start2, end) {
          return number >= nativeMin(start2, end) && number < nativeMax(start2, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array2 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array2 = arrayMap(array2, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array2.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array2.length >= 120) ? new SetCache(othIndex && array2) : undefined$1;
          }
          array2 = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length2 && result2.length < maxLength) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object2, setter, iteratee2, accumulator) {
          baseForOwn(object2, function(value, key, object3) {
            setter(accumulator, iteratee2(value), key, object3);
          });
          return accumulator;
        }
        function baseInvoke(object2, path2, args) {
          path2 = castPath(path2, object2);
          object2 = parent(object2, path2);
          var func = object2 == null ? object2 : object2[toKey(last(path2))];
          return func == null ? undefined$1 : apply(func, object2, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object2)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object2, source, matchData, customizer) {
          var index = matchData.length, length2 = index, noCustomizer = !customizer;
          if (object2 == null) {
            return !length2;
          }
          object2 = Object2(object2);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
              return false;
            }
          }
          while (++index < length2) {
            data = matchData[index];
            var key = data[0], objValue = object2[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object2)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object2, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity2;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result2 = [];
          for (var key in Object2(object2)) {
            if (hasOwnProperty.call(object2, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object2) {
          if (!isObject(object2)) {
            return nativeKeysIn(object2);
          }
          var isProto = isPrototype(object2), result2 = [];
          for (var key in object2) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object2, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object2) {
            return object2 === source || baseIsMatch(object2, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object2) {
            var objValue = get2(object2, path2);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object2, source, srcIndex, customizer, stack) {
          if (object2 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object2, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object2, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object2, key, newValue);
        }
        function baseNth(array2, n) {
          var length2 = array2.length;
          if (!length2) {
            return;
          }
          n += n < 0 ? length2 : 0;
          return isIndex(n, length2) ? array2[n] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity2];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object2, other) {
            return compareMultiple(object2, other, orders);
          });
        }
        function basePick(object2, paths2) {
          return basePickBy(object2, paths2, function(value, path2) {
            return hasIn(object2, path2);
          });
        }
        function basePickBy(object2, paths2, predicate) {
          var index = -1, length2 = paths2.length, result2 = {};
          while (++index < length2) {
            var path2 = paths2[index], value = baseGet(object2, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object2), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object2) {
            return baseGet(object2, path2);
          };
        }
        function basePullAll(array2, values3, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values3.length, seen = array2;
          if (array2 === values3) {
            values3 = copyArray(values3);
          }
          if (iteratee2) {
            seen = arrayMap(array2, baseUnary(iteratee2));
          }
          while (++index < length2) {
            var fromIndex = 0, value = values3[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array2) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array2, fromIndex, 1);
            }
          }
          return array2;
        }
        function basePullAt(array2, indexes) {
          var length2 = array2 ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index = indexes[length2];
            if (length2 == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array2, index, 1);
              } else {
                baseUnset(array2, index);
              }
            }
          }
          return array2;
        }
        function baseRandom(lower2, upper) {
          return lower2 + nativeFloor(nativeRandom() * (upper - lower2 + 1));
        }
        function baseRange(start2, end, step, fromRight) {
          var index = -1, length2 = nativeMax(nativeCeil((end - start2) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index] = start2;
            start2 += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start2) {
          return setToString(overRest(func, start2, identity2), func + "");
        }
        function baseSample(collection) {
          return arraySample(values2(collection));
        }
        function baseSampleSize(collection, n) {
          var array2 = values2(collection);
          return shuffleSelf(array2, baseClamp(n, 0, array2.length));
        }
        function baseSet(object2, path2, value, customizer) {
          if (!isObject(object2)) {
            return object2;
          }
          path2 = castPath(path2, object2);
          var index = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
          while (nested != null && ++index < length2) {
            var key = toKey(path2[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object2;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue) ? objValue : isIndex(path2[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object2;
        }
        var baseSetData = !metaMap ? identity2 : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity2 : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant2(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values2(collection));
        }
        function baseSlice(array2, start2, end) {
          var index = -1, length2 = array2.length;
          if (start2 < 0) {
            start2 = -start2 > length2 ? 0 : length2 + start2;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start2 > end ? 0 : end - start2 >>> 0;
          start2 >>>= 0;
          var result2 = Array2(length2);
          while (++index < length2) {
            result2[index] = array2[index + start2];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array2, value, retHighest) {
          var low = 0, high = array2 == null ? low : array2.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array2[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array2, value, identity2, retHighest);
        }
        function baseSortedIndexBy(array2, value, iteratee2, retHighest) {
          var low = 0, high = array2 == null ? 0 : array2.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array2[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array2, iteratee2) {
          var index = -1, length2 = array2.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length2 = array2.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set3 = iteratee2 ? null : createSet(array2);
            if (set3) {
              return setToArray(set3);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length2) {
              var value = array2[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object2, path2) {
          path2 = castPath(path2, object2);
          object2 = parent(object2, path2);
          return object2 == null || delete object2[toKey(last(path2))];
        }
        function baseUpdate(object2, path2, updater, customizer) {
          return baseSet(object2, path2, updater(baseGet(object2, path2)), customizer);
        }
        function baseWhile(array2, predicate, isDrop, fromRight) {
          var length2 = array2.length, index = fromRight ? length2 : -1;
          while ((fromRight ? index-- : ++index < length2) && predicate(array2[index], index, array2)) {
          }
          return isDrop ? baseSlice(array2, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array2, fromRight ? index + 1 : 0, fromRight ? length2 : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length2);
          while (++index < length2) {
            var array2 = arrays[index], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array2, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values3, assignFunc) {
          var index = -1, length2 = props.length, valsLength = values3.length, result2 = {};
          while (++index < length2) {
            var value = index < valsLength ? values3[index] : undefined$1;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity2;
        }
        function castPath(value, object2) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object2) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array2, start2, end) {
          var length2 = array2.length;
          end = end === undefined$1 ? length2 : end;
          return !start2 && end >= length2 ? array2 : baseSlice(array2, start2, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root2.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object2, other, orders) {
          var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index < length2) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object2.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array2) {
          var index = -1, length2 = source.length;
          array2 || (array2 = Array2(length2));
          while (++index < length2) {
            array2[index] = source[index];
          }
          return array2;
        }
        function copyObject(source, props, object2, customizer) {
          var isNew = !object2;
          object2 || (object2 = {});
          var index = -1, length2 = props.length;
          while (++index < length2) {
            var key = props[index];
            var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object2, key, newValue);
            } else {
              assignValue(object2, key, newValue);
            }
          }
          return object2;
        }
        function copySymbols(source, object2) {
          return copyObject(source, getSymbols(source), object2);
        }
        function copySymbolsIn(source, object2) {
          return copyObject(source, getSymbolsIn(source), object2);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object2, sources) {
            var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined$1 : customizer;
              length2 = 1;
            }
            object2 = Object2(object2);
            while (++index < length2) {
              var source = sources[index];
              if (source) {
                assigner(object2, source, index, customizer);
              }
            }
            return object2;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length2) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object2), props = keysFunc(object2), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper2;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index = length2, placeholder2 = getHolder(wrapper2);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length2 < 3 && args[0] !== placeholder2 && args[length2 - 1] !== placeholder2 ? [] : replaceHolders(args, placeholder2);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length2
              );
            }
            var fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper2;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                var wrapper2 = new LodashWrapper([], true);
              }
            }
            index = wrapper2 ? index : length2;
            while (++index < length2) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
              } else {
                wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper2 && args.length == 1 && isArray(value)) {
                return wrapper2.plant(value).value();
              }
              var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
              while (++index2 < length2) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index = length2;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder2 = getHolder(wrapper2), holdersCount = countHolders(args, placeholder2);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder2);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root2 && this instanceof wrapper2) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper2;
        }
        function createInverter(setter, toIteratee) {
          return function(object2, iteratee2) {
            return baseInverter(object2, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper2;
        }
        function createRange(fromRight) {
          return function(start2, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start2, end, step)) {
              end = step = undefined$1;
            }
            start2 = toFinite(start2);
            if (end === undefined$1) {
              end = start2;
              start2 = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start2 < end ? 1 : -1 : toFinite(step);
            return baseRange(start2, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder2, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= -4;
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder2;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values3) {
          return new Set2(values3);
        };
        function createToPairs(keysFunc) {
          return function(object2) {
            var tag = getTag(object2);
            if (tag == mapTag) {
              return mapToArray(object2);
            }
            if (tag == setTag) {
              return setToPairs(object2);
            }
            return baseToPairs(object2, keysFunc(object2));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= -97;
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= -25;
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object2) {
          if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array2);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array2;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array2, other);
          stack.set(other, array2);
          while (++index < arrLength) {
            var arrValue = array2[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array2);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
              }
              object2 = object2.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object2, +other);
            case errorTag:
              return object2.name == other.name && object2.message == other.message;
            case regexpTag:
            case stringTag:
              return object2 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object2.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object2);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object2, other);
              var result2 = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object2);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object2);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object2;
          }
          var result2 = true;
          stack.set(object2, other);
          stack.set(other, object2);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object2[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object2.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object2);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object2) {
          return baseGetAllKeys(object2, keys, getSymbols);
        }
        function getAllKeysIn(object2) {
          return baseGetAllKeys(object2, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop2 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array2 = realNames[result2], length2 = hasOwnProperty.call(realNames, result2) ? array2.length : 0;
          while (length2--) {
            var data = array2[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object2 = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
          return object2.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object2) {
          var result2 = keys(object2), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object2[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object2, key) {
          var value = getValue2(object2, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
          if (object2 == null) {
            return [];
          }
          object2 = Object2(object2);
          return arrayFilter(nativeGetSymbols(object2), function(symbol) {
            return propertyIsEnumerable.call(object2, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
          var result2 = [];
          while (object2) {
            arrayPush(result2, getSymbols(object2));
            object2 = getPrototype(object2);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView2(start2, end, transforms) {
          var index = -1, length2 = transforms.length;
          while (++index < length2) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start2 += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start2 + size2);
                break;
              case "takeRight":
                start2 = nativeMax(start2, end - size2);
                break;
            }
          }
          return { "start": start2, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object2, path2, hasFunc) {
          path2 = castPath(path2, object2);
          var index = -1, length2 = path2.length, result2 = false;
          while (++index < length2) {
            var key = toKey(path2[index]);
            if (!(result2 = object2 != null && hasFunc(object2, key))) {
              break;
            }
            object2 = object2[key];
          }
          if (result2 || ++index != length2) {
            return result2;
          }
          length2 = object2 == null ? 0 : object2.length;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
        }
        function initCloneArray(array2) {
          var length2 = array2.length, result2 = new array2.constructor(length2);
          if (length2 && typeof array2[0] == "string" && hasOwnProperty.call(array2, "index")) {
            result2.index = array2.index;
            result2.input = array2.input;
          }
          return result2;
        }
        function initCloneObject(object2) {
          return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
        }
        function initCloneByTag(object2, tag, isDeep) {
          var Ctor = object2.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object2);
            case boolTag:
            case dateTag:
              return new Ctor(+object2);
            case dataViewTag:
              return cloneDataView(object2, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object2, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object2);
            case regexpTag:
              return cloneRegExp(object2);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object2);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length2) {
          var type = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index, object2) {
          if (!isObject(object2)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
            return eq(object2[index], value);
          }
          return false;
        }
        function isKey(value, object2) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object2(object2);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object2) {
            if (object2 == null) {
              return false;
            }
            return object2[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object2));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize2(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object2) {
          var result2 = [];
          if (object2 != null) {
            for (var key in Object2(object2)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start2, transform3) {
          start2 = nativeMax(start2 === undefined$1 ? func.length - 1 : start2, 0);
          return function() {
            var args = arguments, index = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array2(length2);
            while (++index < length2) {
              array2[index] = args[start2 + index];
            }
            index = -1;
            var otherArgs = Array2(start2 + 1);
            while (++index < start2) {
              otherArgs[index] = args[index];
            }
            otherArgs[start2] = transform3(array2);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object2, path2) {
          return path2.length < 2 ? object2 : baseGet(object2, baseSlice(path2, 0, -1));
        }
        function reorder(array2, indexes) {
          var arrLength = array2.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array2);
          while (length2--) {
            var index = indexes[length2];
            array2[length2] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array2;
        }
        function safeGet(object2, key) {
          if (key === "constructor" && typeof object2[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object2[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root2.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper2, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array2, size2) {
          var index = -1, length2 = array2.length, lastIndex = length2 - 1;
          size2 = size2 === undefined$1 ? length2 : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array2[rand];
            array2[rand] = array2[index];
            array2[index] = value;
          }
          array2.length = size2;
          return array2;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match2, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper2) {
          if (wrapper2 instanceof LazyWrapper) {
            return wrapper2.clone();
          }
          var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
          result2.__actions__ = copyArray(wrapper2.__actions__);
          result2.__index__ = wrapper2.__index__;
          result2.__values__ = wrapper2.__values__;
          return result2;
        }
        function chunk(array2, size2, guard) {
          if (guard ? isIterateeCall(array2, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index < length2) {
            result2[resIndex++] = baseSlice(array2, index, index += size2);
          }
          return result2;
        }
        function compact(array2) {
          var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result2 = [];
          while (++index < length2) {
            var value = array2[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array2 = arguments[0], index = length2;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array2) ? copyArray(array2) : [array2], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array2, values3) {
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array2, values3) {
          var iteratee2 = last(values3);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array2, values3) {
          var comparator = last(values3);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values3, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array2, n, guard) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array2, n < 0 ? 0 : n, length2);
        }
        function dropRight(array2, n, guard) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), true) : [];
        }
        function fill(array2, value, start2, end) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          if (start2 && typeof start2 != "number" && isIterateeCall(array2, value, start2)) {
            start2 = 0;
            end = length2;
          }
          return baseFill(array2, value, start2, end);
        }
        function findIndex2(array2, predicate, fromIndex) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array2, predicate, fromIndex) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return -1;
          }
          var index = length2 - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return baseFindIndex(array2, getIteratee(predicate, 3), index, true);
        }
        function flatten(array2) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? baseFlatten(array2, 1) : [];
        }
        function flattenDeep(array2) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? baseFlatten(array2, INFINITY) : [];
        }
        function flattenDepth(array2, depth) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array2, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length2) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array2) {
          return array2 && array2.length ? array2[0] : undefined$1;
        }
        function indexOf(array2, value, fromIndex) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length2 + index, 0);
          }
          return baseIndexOf(array2, value, index);
        }
        function initial(array2) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? baseSlice(array2, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array2, separator) {
          return array2 == null ? "" : nativeJoin.call(array2, separator);
        }
        function last(array2) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? array2[length2 - 1] : undefined$1;
        }
        function lastIndexOf(array2, value, fromIndex) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return -1;
          }
          var index = length2;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array2, value, index) : baseFindIndex(array2, baseIsNaN, index, true);
        }
        function nth(array2, n) {
          return array2 && array2.length ? baseNth(array2, toInteger(n)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array2, values3) {
          return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3) : array2;
        }
        function pullAllBy(array2, values3, iteratee2) {
          return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, getIteratee(iteratee2, 2)) : array2;
        }
        function pullAllWith(array2, values3, comparator) {
          return array2 && array2.length && values3 && values3.length ? basePullAll(array2, values3, undefined$1, comparator) : array2;
        }
        var pullAt = flatRest(function(array2, indexes) {
          var length2 = array2 == null ? 0 : array2.length, result2 = baseAt(array2, indexes);
          basePullAt(array2, arrayMap(indexes, function(index) {
            return isIndex(index, length2) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array2, predicate) {
          var result2 = [];
          if (!(array2 && array2.length)) {
            return result2;
          }
          var index = -1, indexes = [], length2 = array2.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length2) {
            var value = array2[index];
            if (predicate(value, index, array2)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array2, indexes);
          return result2;
        }
        function reverse(array2) {
          return array2 == null ? array2 : nativeReverse.call(array2);
        }
        function slice2(array2, start2, end) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array2, start2, end)) {
            start2 = 0;
            end = length2;
          } else {
            start2 = start2 == null ? 0 : toInteger(start2);
            end = end === undefined$1 ? length2 : toInteger(end);
          }
          return baseSlice(array2, start2, end);
        }
        function sortedIndex(array2, value) {
          return baseSortedIndex(array2, value);
        }
        function sortedIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array2, value) {
          var length2 = array2 == null ? 0 : array2.length;
          if (length2) {
            var index = baseSortedIndex(array2, value);
            if (index < length2 && eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array2, value) {
          return baseSortedIndex(array2, value, true);
        }
        function sortedLastIndexBy(array2, value, iteratee2) {
          return baseSortedIndexBy(array2, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array2, value) {
          var length2 = array2 == null ? 0 : array2.length;
          if (length2) {
            var index = baseSortedIndex(array2, value, true) - 1;
            if (eq(array2[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array2) {
          return array2 && array2.length ? baseSortedUniq(array2) : [];
        }
        function sortedUniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseSortedUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array2) {
          var length2 = array2 == null ? 0 : array2.length;
          return length2 ? baseSlice(array2, 1, length2) : [];
        }
        function take(array2, n, guard) {
          if (!(array2 && array2.length)) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          return baseSlice(array2, 0, n < 0 ? 0 : n);
        }
        function takeRight(array2, n, guard) {
          var length2 = array2 == null ? 0 : array2.length;
          if (!length2) {
            return [];
          }
          n = guard || n === undefined$1 ? 1 : toInteger(n);
          n = length2 - n;
          return baseSlice(array2, n < 0 ? 0 : n, length2);
        }
        function takeRightWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array2, predicate) {
          return array2 && array2.length ? baseWhile(array2, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array2) {
          return array2 && array2.length ? baseUniq(array2) : [];
        }
        function uniqBy(array2, iteratee2) {
          return array2 && array2.length ? baseUniq(array2, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array2, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array2 && array2.length ? baseUniq(array2, undefined$1, comparator) : [];
        }
        function unzip(array2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var length2 = 0;
          array2 = arrayFilter(array2, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index) {
            return arrayMap(array2, baseProperty(index));
          });
        }
        function unzipWith(array2, iteratee2) {
          if (!(array2 && array2.length)) {
            return [];
          }
          var result2 = unzip(array2);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array2, values3) {
          return isArrayLikeObject(array2) ? baseDifference(array2, values3) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values3) {
          return baseZipObject(props || [], values3 || [], assignValue);
        }
        function zipObjectDeep(props, values3) {
          return baseZipObject(props || [], values3 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths2) {
          var length2 = paths2.length, start2 = length2 ? paths2[0] : 0, value = this.__wrapped__, interceptor = function(object2) {
            return baseAt(object2, paths2);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start2)) {
            return this.thru(interceptor);
          }
          value = value.slice(start2, +start2 + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array2) {
            if (length2 && !array2.length) {
              array2.push(undefined$1);
            }
            return array2;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find2 = createFind(findIndex2);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values2(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy2 = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now2 = ctxNow || function() {
          return root2.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey2 = baseRest(function(object2, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey2));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object2, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now2();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now2());
          }
          function debounced() {
            var time = now2(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize2(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize2.Cache || MapCache)();
          return memoized;
        }
        memoize2.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index < length2) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 === undefined$1 ? start2 : toInteger(start2);
          return baseRest(func, start2);
        }
        function spread(func, start2) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start2 = start2 == null ? 0 : nativeMax(toInteger(start2), 0);
          return baseRest(function(args) {
            var array2 = args[start2], otherArgs = castSlice(args, 0, start2);
            if (array2) {
              arrayPush(otherArgs, array2);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper2) {
          return partial(castFunction(wrapper2), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object2, source) {
          return source == null || baseConformsTo(object2, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty2(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object2, source) {
          return object2 === source || baseIsMatch(object2, source, getMatchData(source));
        }
        function isMatchWith(object2, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object2, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object2, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object2);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object2, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object2, source) {
          copyObject(source, keysIn(source), object2);
        });
        var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object2, customizer);
        });
        var assignWith = createAssigner(function(object2, source, srcIndex, customizer) {
          copyObject(source, keys(source), object2, customizer);
        });
        var at = flatRest(baseAt);
        function create2(prototype, properties2) {
          var result2 = baseCreate(prototype);
          return properties2 == null ? result2 : baseAssign(result2, properties2);
        }
        var defaults = baseRest(function(object2, sources) {
          object2 = Object2(object2);
          var index = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index < length2) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object2[key];
              if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object2, key)) {
                object2[key] = source[key];
              }
            }
          }
          return object2;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object2, predicate) {
          return baseFindKey(object2, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object2, iteratee2) {
          return object2 == null ? object2 : baseFor(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object2, iteratee2) {
          return object2 == null ? object2 : baseForRight(object2, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object2, iteratee2) {
          return object2 && baseForOwn(object2, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object2, iteratee2) {
          return object2 && baseForOwnRight(object2, getIteratee(iteratee2, 3));
        }
        function functions(object2) {
          return object2 == null ? [] : baseFunctions(object2, keys(object2));
        }
        function functionsIn(object2) {
          return object2 == null ? [] : baseFunctions(object2, keysIn(object2));
        }
        function get2(object2, path2, defaultValue) {
          var result2 = object2 == null ? undefined$1 : baseGet(object2, path2);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has(object2, path2) {
          return object2 != null && hasPath(object2, path2, baseHas);
        }
        function hasIn(object2, path2) {
          return object2 != null && hasPath(object2, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant2(identity2));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function keysIn(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
        }
        function mapKeys(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, iteratee2(value, key, object3), value);
          });
          return result2;
        }
        function mapValues(object2, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object2, function(value, key, object3) {
            baseAssignValue(result2, key, iteratee2(value, key, object3));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object2, source, srcIndex) {
          baseMerge(object2, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object2, source, srcIndex, customizer) {
          baseMerge(object2, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object2, paths2) {
          var result2 = {};
          if (object2 == null) {
            return result2;
          }
          var isDeep = false;
          paths2 = arrayMap(paths2, function(path2) {
            path2 = castPath(path2, object2);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object2, getAllKeysIn(object2), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths2.length;
          while (length2--) {
            baseUnset(result2, paths2[length2]);
          }
          return result2;
        });
        function omitBy(object2, predicate) {
          return pickBy(object2, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object2, paths2) {
          return object2 == null ? {} : basePick(object2, paths2);
        });
        function pickBy(object2, predicate) {
          if (object2 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object2), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object2, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object2, path2, defaultValue) {
          path2 = castPath(path2, object2);
          var index = -1, length2 = path2.length;
          if (!length2) {
            length2 = 1;
            object2 = undefined$1;
          }
          while (++index < length2) {
            var value = object2 == null ? undefined$1 : object2[toKey(path2[index])];
            if (value === undefined$1) {
              index = length2;
              value = defaultValue;
            }
            object2 = isFunction(value) ? value.call(object2) : value;
          }
          return object2;
        }
        function set2(object2, path2, value) {
          return object2 == null ? object2 : baseSet(object2, path2, value);
        }
        function setWith(object2, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object2 == null ? object2 : baseSet(object2, path2, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform2(object2, iteratee2, accumulator) {
          var isArr = isArray(object2), isArrLike = isArr || isBuffer2(object2) || isTypedArray(object2);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object2 && object2.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object2)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index, object3) {
            return iteratee2(accumulator, value, index, object3);
          });
          return accumulator;
        }
        function unset(object2, path2) {
          return object2 == null ? true : baseUnset(object2, path2);
        }
        function update(object2, path2, updater) {
          return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater));
        }
        function updateWith(object2, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object2 == null ? object2 : baseUpdate(object2, path2, castFunction(updater), customizer);
        }
        function values2(object2) {
          return object2 == null ? [] : baseValues(object2, keys(object2));
        }
        function valuesIn(object2) {
          return object2 == null ? [] : baseValues(object2, keysIn(object2));
        }
        function clamp2(number, lower2, upper) {
          if (upper === undefined$1) {
            upper = lower2;
            lower2 = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower2 !== undefined$1) {
            lower2 = toNumber(lower2);
            lower2 = lower2 === lower2 ? lower2 : 0;
          }
          return baseClamp(toNumber(number), lower2, upper);
        }
        function inRange(number, start2, end) {
          start2 = toFinite(start2);
          if (end === undefined$1) {
            end = start2;
            start2 = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start2, end);
        }
        function random(lower2, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower2, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower2 == "boolean") {
              floating = lower2;
              lower2 = undefined$1;
            }
          }
          if (lower2 === undefined$1 && upper === undefined$1) {
            lower2 = 0;
            upper = 1;
          } else {
            lower2 = toFinite(lower2);
            if (upper === undefined$1) {
              upper = lower2;
              lower2 = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower2 > upper) {
            var temp = lower2;
            lower2 = upper;
            upper = temp;
          }
          if (floating || lower2 % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower2 + rand * (upper - lower2 + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower2, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize2(word) : word);
        });
        function capitalize2(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position2) {
          string = toString(string);
          target = baseToString(target);
          var length2 = string.length;
          position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
          var end = position2;
          position2 -= target.length;
          return position2 >= 0 && string.slice(position2, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp2(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          if (!length2 || strLength >= length2) {
            return string;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
        }
        function padStart(string, length2, chars) {
          string = toString(string);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined$1) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace2() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position2) {
          string = toString(string);
          position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
          target = baseToString(target);
          return string.slice(position2, position2 + target.length) == target;
        }
        function template(string, options, guard) {
          var settings2 = lodash2.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings2, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim2(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start2 = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start2, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start2 = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start2).join("");
        }
        function truncate(string, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;
          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object2, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object2, key, bind(object2[key], object2));
          });
          return object2;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length2) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant2(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity2(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path2, args) {
          return function(object2) {
            return baseInvoke(object2, path2, args);
          };
        });
        var methodOf = baseRest(function(object2, args) {
          return function(path2) {
            return baseInvoke(object2, path2, args);
          };
        });
        function mixin(object2, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object2;
            object2 = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object2);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object2[methodName] = func;
            if (isFunc) {
              object2.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object2(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object2 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object2, arrayPush([this.value()], arguments));
              };
            }
          });
          return object2;
        }
        function noConflict() {
          if (root2._ === this) {
            root2._ = oldDash;
          }
          return this;
        }
        function noop2() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object2) {
          return function(path2) {
            return object2 == null ? undefined$1 : baseGet(object2, path2);
          };
        }
        var range2 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length2 = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId2(prefix2) {
          var id2 = ++idCounter;
          return toString(prefix2) + id2;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : undefined$1;
        }
        function maxBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array2) {
          return baseMean(array2, identity2);
        }
        function meanBy(array2, iteratee2) {
          return baseMean(array2, getIteratee(iteratee2, 2));
        }
        function min(array2) {
          return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : undefined$1;
        }
        function minBy(array2, iteratee2) {
          return array2 && array2.length ? baseExtremum(array2, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round2 = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array2) {
          return array2 && array2.length ? baseSum(array2, identity2) : 0;
        }
        function sumBy(array2, iteratee2) {
          return array2 && array2.length ? baseSum(array2, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign2;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey2;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant2;
        lodash2.countBy = countBy;
        lodash2.create = create2;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter2;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys;
        lodash2.keysIn = keysIn;
        lodash2.map = map;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize2;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit;
        lodash2.omitBy = omitBy;
        lodash2.once = once;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range2;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove2;
        lodash2.rest = rest;
        lodash2.reverse = reverse;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set2;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy2;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle;
        lodash2.thru = thru;
        lodash2.toArray = toArray;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform2;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values2;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize2;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp2;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith;
        lodash2.eq = eq;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp2;
        lodash2.every = every;
        lodash2.find = find2;
        lodash2.findIndex = findIndex2;
        lodash2.findKey = findKey;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get2;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity2;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray;
        lodash2.isArrayBuffer = isArrayBuffer;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean;
        lodash2.isBuffer = isBuffer2;
        lodash2.isDate = isDate;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty2;
        lodash2.isEqual = isEqual;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite2;
        lodash2.isFunction = isFunction;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber;
        lodash2.isObject = isObject;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray;
        lodash2.isUndefined = isUndefined;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop2;
        lodash2.now = now2;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace2;
        lodash2.result = result;
        lodash2.round = round2;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId2;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity2);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start2, end) {
          start2 = toInteger(start2);
          var result2 = this;
          if (result2.__filtered__ && (start2 > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start2 < 0) {
            result2 = result2.takeRight(-start2);
          } else if (start2) {
            result2 = result2.drop(start2);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start2);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _ = runInContext();
      if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root2._ = _;
      }
    }).call(lodash);
  })(lodash$1, lodash$1.exports);
  return lodash$1.exports;
}
var lodashExports = requireLodash();
const getHeap = () => {
  if (!window.heap) {
    window.heap = {
      track: lodashExports.noop
    };
  }
  return window.heap;
};
const getDataTestAttribute = (component, uiElement, state = "") => {
  const stateSuffix = state ? `-${state}` : "";
  return `${component}--${uiElement}${stateSuffix}`;
};
const getGraph = (state) => state.graph;
const getLayerName = (state) => state.layer.name;
const getFlowChartOrientation = (state) => state.orientation;
const getLayers = createSelector(
  [getGraph, getVisibleLayerIDs, getLayerName, getFlowChartOrientation],
  ({ nodes, size }, layerIDs, layerName, orientation) => {
    if (!nodes || !size || !nodes.length || !layerIDs.length) {
      return [];
    }
    const { width: width2, height: height2 } = size;
    const bounds = {};
    for (const node2 of nodes) {
      const layer = node2.nearestLayer || node2.layer;
      if (layer) {
        const bound = bounds[layer] || (bounds[layer] = [Infinity, -Infinity]);
        if (orientation === "vertical") {
          if (node2.y - node2.height < bound[0]) {
            bound[0] = node2.y - node2.height;
          }
          if (node2.y + node2.height > bound[1]) {
            bound[1] = node2.y + node2.height;
          }
        } else {
          if (node2.x - node2.width < bound[0]) {
            bound[0] = node2.x - node2.width;
          }
          if (node2.x + node2.width > bound[1]) {
            bound[1] = node2.x + node2.width;
          }
        }
      }
    }
    return layerIDs.map((id2, i) => {
      const currentBound = bounds[id2] || [0, 0];
      const prevBound = bounds[layerIDs[i - 1]] || [
        currentBound[0],
        currentBound[0]
      ];
      const nextBound = bounds[layerIDs[i + 1]] || [
        currentBound[1],
        currentBound[1]
      ];
      const start2 = (prevBound[1] + currentBound[0]) / 2;
      const end = (currentBound[1] + nextBound[0]) / 2;
      const rectSize = Math.max(width2, height2) * 5;
      if (orientation === "vertical") {
        return {
          id: id2,
          name: layerName[id2],
          y: start2,
          // Vertical layout moves along the y-axis
          x: (rectSize - width2) / -2,
          // Centered along x-axis
          height: Math.max(end - start2, 0),
          width: rectSize
        };
      }
      return {
        id: id2,
        name: layerName[id2],
        x: start2,
        // Horizontal layout moves along the x-axis
        y: (rectSize - height2) / -2,
        // Centered along y-axis
        width: Math.max(end - start2, 0),
        height: rectSize
      };
    });
  }
);
const getClickedNode = (state) => state.node.clicked;
const getVisibleEdgesByNode = createSelector(
  [getVisibleEdges],
  (edges) => {
    const sourceEdges = {};
    const targetEdges = {};
    for (const edge of edges) {
      if (!sourceEdges[edge.target]) {
        sourceEdges[edge.target] = [];
      }
      sourceEdges[edge.target].push(edge.source);
      if (!targetEdges[edge.source]) {
        targetEdges[edge.source] = [];
      }
      targetEdges[edge.source].push(edge.target);
    }
    return { sourceEdges, targetEdges };
  }
);
const findLinkedNodes = (nodeID, edgesByNode, visited) => {
  if (!visited[nodeID]) {
    visited[nodeID] = true;
    if (edgesByNode[nodeID]) {
      edgesByNode[nodeID].forEach(
        (nodeID2) => findLinkedNodes(nodeID2, edgesByNode, visited)
      );
    }
  }
  return visited;
};
const getLinkedNodes = createSelector(
  [getVisibleEdgesByNode, getClickedNode],
  ({ sourceEdges, targetEdges }, nodeID) => {
    if (!nodeID) {
      return {};
    }
    const linkedNodes = {};
    findLinkedNodes(nodeID, sourceEdges, linkedNodes);
    linkedNodes[nodeID] = false;
    findLinkedNodes(nodeID, targetEdges, linkedNodes);
    return linkedNodes;
  }
);
const getSlicedPipelineState = (state) => state.slice;
const getNodesRunCommand = (state) => state.node.runCommand;
const getRunCommand = createSelector(
  [getSlicedPipelineState, getNodesRunCommand],
  (slicedPipelineState, nodeRunCommand) => {
    const { from: from2, to } = slicedPipelineState;
    if (!from2 || !to) {
      return null;
    }
    const slicingPipelineCommand = nodeRunCommand[to] || "please define a run command for this node";
    return slicingPipelineCommand;
  }
);
var noop$2 = { value: () => {
} };
function dispatch$1() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch$1.prototype = dispatch$1.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$2(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$2(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$2(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _) copy2[t] = _[t].slice();
    return new Dispatch$1(copy2);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get$2(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set$2(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$2, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn = dispatch$1("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node2, name, id2, index, group, timing) {
  var schedules = node2.__transition;
  if (!schedules) node2.__transition = {};
  else if (id2 in schedules) return;
  create(node2, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get$1(node2, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node2, id2) {
  var schedule2 = get$1(node2, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get$1(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed) start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name) continue;
      if (o.state === STARTED) return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
    if (self2.state !== STARTING) return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node2.__transition;
  }
}
function interrupt(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2) delete node2.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function define$1(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$2(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color$1() {
}
var darker$1 = 0.7;
var brighter$1 = 1 / darker$1;
var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"), reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"), reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"), reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"), reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"), reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
var named$1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define$1(Color$1, color$2, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex$1,
  formatHsl: color_formatHsl$1,
  formatRgb: color_formatRgb$1,
  toString: color_formatRgb$1
});
function color_formatHex$1() {
  return this.rgb().formatHex();
}
function color_formatHsl$1() {
  return hslConvert$1(this).formatHsl();
}
function color_formatRgb$1() {
  return this.rgb().formatRgb();
}
function color$2(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) : l === 3 ? new Rgb$1(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba$1(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba$1(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
}
function rgbn$1(n) {
  return new Rgb$1(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba$1(r2, g, b, a) {
  if (a <= 0) r2 = g = b = NaN;
  return new Rgb$1(r2, g, b, a);
}
function rgbConvert$1(o) {
  if (!(o instanceof Color$1)) o = color$2(o);
  if (!o) return new Rgb$1();
  o = o.rgb();
  return new Rgb$1(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert$1(r2) : new Rgb$1(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb$1(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define$1(Rgb$1, rgb$1, extend$2(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex$1,
  formatRgb: rgb_formatRgb$1,
  toString: rgb_formatRgb$1
}));
function rgb_formatHex$1() {
  return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
}
function rgb_formatRgb$1() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex$1(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl$1(h, s, l, a);
}
function hslConvert$1(o) {
  if (o instanceof Hsl$1) return new Hsl$1(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$1)) o = color$2(o);
  if (!o) return new Hsl$1();
  if (o instanceof Hsl$1) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r2, g, b), max = Math.max(r2, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r2 === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r2) / s + 2;
    else h = (r2 - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl$1(h, s, l, o.opacity);
}
function hsl$1(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl$1(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define$1(Hsl$1, hsl$1, extend$2(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb$1(
      hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb$1(h, m1, m2),
      hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb$1(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a, d2) {
  return function(t) {
    return a + t * d2;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t) {
    return Math.pow(a + t * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d2 = b - a;
  return d2 ? linear(a, d2) : constant$2(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start2, end) {
    var r2 = color2((start2 = rgb$1(start2)).r, (end = rgb$1(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r2(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x2 = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i) x2[i] = interpolate$1(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x2[i](t);
    return c;
  };
}
function date(a, b) {
  var d2 = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d2.setTime(a * (1 - t) + b * t), d2;
  };
}
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate$1(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate$1(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$2(b) : (t === "number" ? interpolateNumber : t === "string" ? (c = color$2(b)) ? (b = c, interpolateRgb) : interpolateString : b instanceof color$2 ? interpolateRgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object : interpolateNumber)(a, b);
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d2, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d2) c -= a * skewX, d2 -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d2 * d2)) c /= scaleY, d2 /= scaleY, skewX /= scaleY;
  if (a * d2 < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity$1;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get$1(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node2) {
    return get$1(node2, id2).value[name];
  };
}
function define(constructor, factory2, prototype) {
  constructor.prototype = factory2.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r2, g, b, a) {
  if (a <= 0) r2 = g = b = NaN;
  return new Rgb(r2, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color)) o = color$1(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r2, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r2, g, b, opacity) {
  this.r = +r2;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color$1(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r2, g, b), max = Math.max(r2, g, b), h = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r2 === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r2) / s + 2;
    else h = (r2 - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend$1(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color$1 ? interpolateRgb : (c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$1(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$1(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$1(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error();
    set$1(this, id2).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match2) {
  if (typeof match2 !== "function") match2 = matcher(match2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match2.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set$1;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$1(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2) subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id2, i, subgroup, get$1(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children2 = select2.call(node2, node2.__data__, i, group), child, inherit2 = get$1(node2, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get$1(node2, id0);
        schedule(node2, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0) resolve();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule(node2, name, id2, i, group, timing || inherit(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var noop$1 = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _ = this._;
    for (var t in _) copy2[t] = _[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, true);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, true);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, true);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
const constant$1 = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform: transform2,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform2, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform(k, x2, y2) {
  this.k = k;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  while (!node2.__zoom) if (!(node2 = node2.parentNode)) return identity;
  return node2.__zoom;
}
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent, translateExtent) {
  var dx0 = transform2.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function d3Zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration2 = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom.transform = function(collection, transform2, point2, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform2, point2, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom.scaleBy = function(selection2, k, p, event) {
    zoom.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom.scaleTo = function(selection2, k, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom.translateBy = function(selection2, x2, y2, event) {
    zoom.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom.translateTo = function(selection2, x2, y2, p, event) {
    zoom.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform2, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform2.k ? transform2 : new Transform(k, transform2.x, transform2.y);
  }
  function translate(transform2, p0, p1) {
    var x2 = p0[0] - p1[0] * transform2.k, y2 = p0[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform2, point2, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point2 == null ? centroid(e) : typeof point2 === "function" ? point2.apply(that, args) : point2, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate2(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1) t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d2 = select(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d2
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k) return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }
    noevent(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var g = gesture(this, args, true).event(event), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer(event, currentTarget), currentTarget = event.currentTarget, x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();
    function mousemoved(event2) {
      noevent(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent(event);
    if (duration2 > 0) select(this).transition().duration(duration2).call(schedule2, t1, p0, event);
    else select(this).call(zoom.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$1(+_), zoom) : wheelDelta;
  };
  zoom.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$1(!!_), zoom) : filter2;
  };
  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$1(!!_), zoom) : touchable;
  };
  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$1([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };
  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };
  zoom.duration = function(_) {
    return arguments.length ? (duration2 = +_, zoom) : duration2;
  };
  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom) : interpolate2;
  };
  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };
  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };
  zoom.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
  };
  return zoom;
}
const viewing = ({
  container,
  wrapper: wrapper2,
  onViewChanged,
  onViewEnd,
  allowUserInput = true
}) => {
  const zoom = d3Zoom().on("zoom", (event) => {
    const transform2 = event.transform;
    if (isInvalidTransform(transform2)) {
      return;
    }
    select(wrapper2.current).attr("transform", transform2);
    onViewChanged && onViewChanged(transform2);
  }).on("end", onViewEnd).interpolate(interpolate$1);
  if (!allowUserInput) {
    zoom.filter(() => false);
  }
  select(container.current).call(zoom).on("dblclick.zoom", null);
  return {
    zoom,
    container,
    wrapper: wrapper2
  };
};
const origin = identity;
const isOrigin = ({ x: x2, y: y2, k }) => x2 === origin.x && y2 === origin.y && k === origin.k;
const isInvalidTransform = ({ x: x2, y: y2, k }) => !isFinite(x2 + y2 + k) || isNaN(x2 + y2 + k) || x2 === 0 && y2 === 0 && k === 0;
const getViewTransform = (view) => {
  const transform$1 = transform(view.wrapper.current);
  return isInvalidTransform(transform$1) ? origin : negateTransform(transform$1);
};
const negateTransform = (transform2) => (
  // This ensures +0 instead of -0
  origin.translate(-transform2.x || 0, -transform2.y || 0).scale(transform2.k)
);
const setViewExtents = (view, { translate, scale }) => {
  if (translate) {
    const { minX, minY, maxX, maxY } = translate;
    view.zoom.translateExtent([
      [minX, minY],
      [maxX, maxY]
    ]);
  }
  if (scale) {
    const { minK, maxK } = scale;
    view.zoom.scaleExtent([minK, maxK]);
  }
};
const getViewExtents = (view) => {
  const scale = view.zoom.scaleExtent();
  const translate = view.zoom.translateExtent();
  return {
    translate: {
      minX: translate[0][0],
      minY: translate[0][1],
      maxX: translate[1][0],
      maxY: translate[1][1]
    },
    scale: { minK: scale[0], maxK: scale[1] }
  };
};
const setViewTransform = (view, transform2, duration2 = 0, relative = false) => {
  const container = select(view.container.current);
  const current = getViewTransform(view);
  const hasTranslation = typeof transform2.x !== "undefined" && typeof transform2.y !== "undefined";
  let k, x2, y2;
  if (typeof jest !== "undefined") {
    duration2 = 0;
  }
  if (relative) {
    k = current.k + (transform2.k || 0);
    x2 = current.x + (transform2.x || 0);
    y2 = current.y + (transform2.y || 0);
  } else {
    k = transform2.k || current.k;
    x2 = transform2.x || current.x;
    y2 = transform2.y || current.y;
  }
  if (hasTranslation) {
    container.call(view.zoom.transform, origin);
    container.call(view.zoom.translateTo, x2 / k, y2 / k);
  }
  container.call(view.zoom.scaleTo, k);
  if (duration2) {
    const final = getViewTransform(view);
    container.call(view.zoom.transform, negateTransform(current));
    setViewTransformExact(view, final, duration2);
  }
};
const setViewTransformExact = (view, transform2, duration2 = 0) => {
  const container = select(view.container.current);
  const final = origin.translate(-transform2.x, -transform2.y).scale(transform2.k);
  if (typeof jest !== "undefined") {
    view.container.current.__zoom = final;
    return;
  }
  (!duration2 ? container : container.transition("zoom").duration(duration2)).call(view.zoom.transform, final);
};
const viewTransformToFit = ({
  offset,
  focus,
  viewWidth,
  viewHeight,
  objectWidth,
  objectHeight,
  minScaleX = 0,
  minScaleFocus = 0,
  focusOffset = 0.8,
  preventZoom
}) => {
  let scale = origin.k;
  let x2 = origin.x;
  let y2 = origin.y;
  const scaleY = viewHeight / objectHeight;
  const scaleX = viewWidth / objectWidth;
  const scaleXClamp = Math.max(minScaleX, scaleX);
  scale = Math.min(scaleXClamp, scaleY);
  if (focus || !preventZoom) {
    scale = Math.max(minScaleFocus, scale);
  }
  x2 += offset.x;
  y2 += offset.y;
  x2 += (viewWidth - objectWidth * scale) * 0.5;
  y2 += (viewHeight - objectHeight * scale) * 0.5;
  if (focus) {
    const isCroppedX = viewWidth < objectWidth * scale;
    const isCroppedY = viewHeight < objectHeight * scale;
    const objectCenterX = objectWidth * 0.5;
    const objectCenterY = objectHeight * 0.5;
    const focusCenterOffsetX = isCroppedX ? objectCenterX - focus.x : 0;
    const focusCenterOffsetY = isCroppedY ? objectCenterY - focus.y : 0;
    const focusRelativeOffsetX = focusCenterOffsetX / objectWidth;
    const focusRelativeOffsetY = focusCenterOffsetY / objectHeight;
    x2 += focusCenterOffsetX * scale;
    y2 += focusCenterOffsetY * scale;
    x2 -= focusRelativeOffsetX * viewWidth * focusOffset;
    y2 -= focusRelativeOffsetY * viewHeight * focusOffset;
  }
  return { x: -x2 || 0, y: -y2 || 0, k: scale };
};
const zeroWidthSpace = String.fromCharCode(8203);
const insertZeroWidthSpace = (text) => text.replace(/([^\w\s]|[_])/g, `${zeroWidthSpace}$1${zeroWidthSpace}`);
const Tooltip = ({
  arrowSize = "regular",
  centerArrow = false,
  chartSize = {},
  noDelay = false,
  style: style2 = {},
  targetRect = {},
  text = "",
  visible = false
}) => {
  let isTop = false, isRight = false;
  const isFlowchartTooltip = chartSize && Object.keys(chartSize).length;
  const styles2 = { ...style2 };
  if (isFlowchartTooltip) {
    let x2 = 0, y2 = 0;
    const { left, top, width: width2, height: height2, outerWidth, sidebarWidth: sidebarWidth2 } = chartSize;
    isRight = targetRect.left - sidebarWidth2 > width2 / 2;
    isTop = targetRect.top < height2 / 2;
    const xOffset = isRight ? targetRect.left - outerWidth : targetRect.left;
    const yOffset = isTop ? targetRect.top + targetRect.height : targetRect.top;
    x2 = xOffset - left + targetRect.width / 2;
    y2 = yOffset - top;
    styles2.transform = `translate(${x2}px, ${y2}px)`;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classnames("pipeline-tooltip", {
        "pipeline-tooltip--visible": visible,
        "pipeline-tooltip--right": isRight,
        "pipeline-tooltip--top": isTop,
        "pipeline-tooltip--chart": isFlowchartTooltip,
        "pipeline-tooltip--no-delay": noDelay,
        "pipeline-tooltip--center-arrow": centerArrow,
        "pipeline-tooltip--small-arrow": arrowSize === "small"
      }),
      style: styles2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-tooltip__text", children: insertZeroWidthSpace(text) })
    }
  );
};
const CopyIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17 1v1h4v16h-4v4H3V6h4V2h4V1h6zM7 8H5v12h10v-2H7V8zm4-4H9v12h10V4h-2v1h-6V4z" }) });
const CommandCopier = ({ command, classNames, isCommand, dataTest }) => {
  const [showCopied, setShowCopied] = reactExports.useState(false);
  const onCopyClick = () => {
    window.navigator.clipboard.writeText(command);
    setShowCopied(true);
    setTimeout(() => setShowCopied(false), 1500);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: classnames("command-value", classNames), children: command }),
    window.navigator.clipboard && isCommand && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "toolbox", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        IconButton,
        {
          ariaLabel: "Copy run command to clipboard.",
          className: "copy-button",
          dataTest,
          icon: CopyIcon,
          onClick: onCopyClick
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Tooltip,
        {
          text: "Copied!",
          visible: showCopied,
          noDelay: true,
          centerArrow: true,
          arrowSize: "small"
        }
      )
    ] })
  ] });
};
const CutIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    d: "M19.1924 20.7688L12.0386 13.6149L9.30394 16.3495C9.44367 16.5995 9.54335 16.8646 9.60297 17.1447C9.66258 17.4248 9.69239 17.7098 9.69239 17.9995C9.69239 19.0043 9.33472 19.8645 8.61939 20.58C7.90406 21.2956 7.04412 21.6534 6.03959 21.6534C5.03507 21.6534 4.17481 21.2957 3.45879 20.5803C2.74277 19.865 2.38477 19.0051 2.38477 18.0006C2.38477 16.996 2.74253 16.1358 3.45807 15.4197C4.17362 14.7037 5.03379 14.3457 6.03859 14.3457C6.32832 14.3457 6.61326 14.3755 6.89339 14.4351C7.17352 14.4947 7.43859 14.5944 7.68859 14.7342L10.4232 11.9995L7.68859 9.26488C7.43859 9.40463 7.17352 9.50431 6.89339 9.56393C6.61326 9.62354 6.32832 9.65335 6.03859 9.65335C5.03379 9.65335 4.17362 9.29568 3.45807 8.58033C2.74253 7.865 2.38477 7.00507 2.38477 6.00055C2.38477 4.99604 2.74243 4.13576 3.45777 3.41973C4.17312 2.70371 5.03305 2.3457 6.03757 2.3457C7.04208 2.3457 7.90235 2.70348 8.61837 3.41903C9.33438 4.13456 9.69239 4.99473 9.69239 5.99953C9.69239 6.28928 9.66258 6.57421 9.60297 6.85433C9.54335 7.13446 9.44367 7.39953 9.30394 7.64953L21.6155 19.9611V20.7688H19.1924ZM14.8078 10.8457L13.1924 9.2303L19.1924 3.2303H21.6155V4.038L14.8078 10.8457ZM6.03859 8.15338C6.63089 8.15338 7.13794 7.94248 7.55974 7.52068C7.98154 7.0989 8.19244 6.59185 8.19244 5.99953C8.19244 5.40721 7.98154 4.90016 7.55974 4.47838C7.13794 4.05658 6.63089 3.84568 6.03859 3.84568C5.44627 3.84568 4.93922 4.05658 4.51742 4.47838C4.09562 4.90016 3.88472 5.40721 3.88472 5.99953C3.88472 6.59185 4.09562 7.0989 4.51742 7.52068C4.93922 7.94248 5.44627 8.15338 6.03859 8.15338ZM12.0386 12.2495C12.1052 12.2495 12.1636 12.2245 12.2136 12.1745C12.2636 12.1245 12.2886 12.0662 12.2886 11.9995C12.2886 11.9329 12.2636 11.8745 12.2136 11.8246C12.1636 11.7746 12.1052 11.7496 12.0386 11.7496C11.9719 11.7496 11.9136 11.7746 11.8636 11.8246C11.8136 11.8745 11.7886 11.9329 11.7886 11.9995C11.7886 12.0662 11.8136 12.1245 11.8636 12.1745C11.9136 12.2245 11.9719 12.2495 12.0386 12.2495ZM6.03859 20.1534C6.63089 20.1534 7.13794 19.9425 7.55974 19.5207C7.98154 19.0989 8.19244 18.5918 8.19244 17.9995C8.19244 17.4072 7.98154 16.9002 7.55974 16.4784C7.13794 16.0566 6.63089 15.8457 6.03859 15.8457C5.44627 15.8457 4.93922 16.0566 4.51742 16.4784C4.09562 16.9002 3.88472 17.4072 3.88472 17.9995C3.88472 18.5918 4.09562 19.0989 4.51742 19.5207C4.93922 19.9425 5.44627 20.1534 6.03859 20.1534Z",
    fill: "black"
  }
) });
const calculateTransformX = ({
  screenWidth,
  slicePipelineActionBarWidth,
  metaDataPanelWidth,
  nodeListWidth,
  minimumTransformX
}) => {
  const actionBarWidthAdjustment = screenWidth > 2200 ? slicePipelineActionBarWidth : slicePipelineActionBarWidth / 2;
  return Math.max(
    screenWidth - nodeListWidth - metaDataPanelWidth - actionBarWidthAdjustment,
    minimumTransformX
  );
};
const SlicedPipelineActionBar = React.forwardRef((props, ref) => {
  const {
    chartSize,
    displayMetadataPanel,
    isSlicingPipelineApplied,
    onApplySlicingPipeline,
    onResetSlicingPipeline,
    runCommand,
    slicedPipelineLength,
    visibleSidebar
  } = props;
  const [isFirstRender, setIsFirstRender] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const timer2 = setTimeout(() => {
      setIsFirstRender(false);
    }, 500);
    return () => clearTimeout(timer2);
  }, []);
  const { outerWidth: screenWidth } = chartSize;
  const transitionMargin = 200;
  const slicePipelineActionBarWidth = ref.current && ref.current.firstChild.getBoundingClientRect().width;
  const metaDataPanelWidth = displayMetadataPanel ? metaSidebarWidth.open + transitionMargin / 1.5 : metaSidebarWidth.open;
  const nodeListWidth = visibleSidebar ? sidebarWidth.open - transitionMargin : sidebarWidth.open - transitionMargin / 1.5;
  const minimumTransformX = visibleSidebar ? sidebarWidth.open : sidebarWidth.closed;
  const transformX = calculateTransformX({
    screenWidth,
    slicePipelineActionBarWidth,
    metaDataPanelWidth,
    nodeListWidth,
    minimumTransformX
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("sliced-pipeline-action-bar", {
        "sliced-pipeline-action-bar--first-render": isFirstRender
      }),
      style: {
        transform: !isFirstRender ? `translateX(${transformX}px)` : "none",
        left: isFirstRender ? transformX : "auto",
        // Positioning adjustment on first render
        opacity: 1
      },
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "sliced-pipeline-action-bar--info", children: `${slicedPipelineLength} selected` }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classnames("sliced-pipeline-action-bar--run-command", {
              "sliced-pipeline-action-bar--run-command-long": runCommand.length > 90
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CommandCopier,
              {
                command: runCommand,
                isCommand: true,
                dataTest: getDataTestAttribute(
                  "sliced-pipeline-action-bar",
                  "run-command",
                  "copied"
                )
              }
            )
          }
        ),
        isSlicingPipelineApplied ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "sliced-pipeline-action-bar--cta sliced-pipeline-action-bar--reset",
            "datat-test": getDataTestAttribute(
              "sliced-pipeline-action-bar",
              "reset-btn",
              "clicked"
            ),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onResetSlicingPipeline, children: "Reset slice" })
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "sliced-pipeline-action-bar--cta sliced-pipeline-action-bar--slice",
            onClick: onApplySlicingPipeline,
            "datat-test": getDataTestAttribute(
              "sliced-pipeline-action-bar",
              "slice-btn",
              "clicked"
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                IconButton,
                {
                  ariaLabel: "Cut icon in slice button to slice a pipeline.",
                  className: "cut-icon",
                  icon: CutIcon
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sliced-pipeline-action-bar--slice-text", children: "Slice" })
            ]
          }
        )
      ]
    }
  );
});
const SlicedPipelineNotification = ({
  notification,
  visibleSidebar
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classnames("sliced-pipeline-notification", {
        "sliced-pipeline-notification--no-sidebar": !visibleSidebar
      }),
      children: notification
    }
  );
};
const FeedbackButton = ({ onClick, visible, title }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: classnames("feedback-button", {
        "feedback-button--visible": visible
      }),
      onClick,
      children: title
    }
  );
};
const MoodDissatisfiedIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, width: "32", height: "32", viewBox: "0 0 32 32", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    id: "icon",
    d: "M20.6406 14.1984C21.0945 14.1984 21.4815 14.0373 21.8017 13.7151C22.1219 13.3928 22.282 13.0048 22.282 12.551C22.282 12.0971 22.1209 11.7101 21.7987 11.3899C21.4764 11.0697 21.0884 10.9096 20.6346 10.9096C20.1808 10.9096 19.7937 11.0707 19.4735 11.3929C19.1533 11.7151 18.9932 12.1032 18.9932 12.557C18.9932 13.0108 19.1543 13.3978 19.4765 13.7181C19.7988 14.0383 20.1868 14.1984 20.6406 14.1984ZM11.3654 14.1984C11.8193 14.1984 12.2063 14.0373 12.5265 13.7151C12.8467 13.3928 13.0068 13.0048 13.0068 12.551C13.0068 12.0971 12.8457 11.7101 12.5235 11.3899C12.2013 11.0697 11.8132 10.9096 11.3594 10.9096C10.9056 10.9096 10.5185 11.0707 10.1983 11.3929C9.87809 11.7151 9.71797 12.1032 9.71797 12.557C9.71797 13.0108 9.8791 13.3978 10.2013 13.7181C10.5236 14.0383 10.9116 14.1984 11.3654 14.1984ZM16.0054 18.0497C14.6215 18.0497 13.3589 18.433 12.2177 19.1997C11.0766 19.9664 10.228 20.9853 9.67184 22.2565H11.2239C11.7128 21.383 12.3829 20.6991 13.2342 20.2048C14.0855 19.7105 15.011 19.4634 16.0107 19.4634C17.0104 19.4634 17.9324 19.7128 18.7765 20.2116C19.6207 20.7105 20.2946 21.3921 20.7983 22.2565H22.3282C21.7812 20.9762 20.9366 19.955 19.7944 19.1929C18.6523 18.4308 17.3893 18.0497 16.0054 18.0497ZM16.0022 28.6668C14.2503 28.6668 12.6036 28.3343 11.0621 27.6694C9.52057 27.0045 8.17966 26.1022 7.03937 24.9624C5.89906 23.8226 4.99632 22.4823 4.33114 20.9415C3.66596 19.4006 3.33337 17.7543 3.33337 16.0024C3.33337 14.2505 3.66582 12.6037 4.33071 11.0622C4.9956 9.5207 5.89793 8.17979 7.03771 7.0395C8.17751 5.89919 9.51783 4.99644 11.0587 4.33126C12.5995 3.66609 14.2459 3.3335 15.9978 3.3335C17.7497 3.3335 19.3964 3.66594 20.9379 4.33083C22.4794 4.99572 23.8204 5.89805 24.9606 7.03783C26.101 8.17763 27.0037 9.51795 27.6689 11.0588C28.3341 12.5996 28.6666 14.246 28.6666 15.9979C28.6666 17.7498 28.3342 19.3965 27.6693 20.938C27.0044 22.4796 26.1021 23.8205 24.9623 24.9608C23.8225 26.1011 22.4822 27.0038 20.9413 27.669C19.4005 28.3342 17.7542 28.6668 16.0022 28.6668ZM15.9992 26.9916C19.0674 26.9916 21.6665 25.9269 23.7965 23.7974C25.9265 21.668 26.9915 19.0692 26.9915 16.001C26.9915 12.9327 25.9268 10.3336 23.7973 8.20366C21.6679 6.07366 19.0691 5.00866 16.0008 5.00866C12.9326 5.00866 10.3335 6.07339 8.20354 8.20283C6.07354 10.3323 5.00854 12.9311 5.00854 15.9993C5.00854 19.0675 6.07326 21.6666 8.20271 23.7966C10.3321 25.9266 12.931 26.9916 15.9992 26.9916Z",
    fill: "#989898"
  }
) });
const MoodVeryDissatisfiedIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, width: "32", height: "32", viewBox: "0 0 32 32", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    id: "icon",
    d: "M16.0022 28.6668C14.2503 28.6668 12.6036 28.3343 11.0621 27.6694C9.52057 27.0045 8.17966 26.0985 7.03937 24.9513C5.89906 23.8041 4.99632 22.4615 4.33114 20.9235C3.66596 19.3855 3.33337 17.7466 3.33337 16.0066C3.33337 14.2519 3.66582 12.6037 4.33071 11.0622C4.9956 9.5207 5.89793 8.17979 7.03771 7.0395C8.17751 5.89919 9.51783 4.99644 11.0587 4.33126C12.5995 3.66609 14.2459 3.3335 15.9978 3.3335C17.7497 3.3335 19.3927 3.66594 20.9268 4.33083C22.4609 4.99572 23.8018 5.89805 24.9495 7.03783C26.0973 8.17763 27.0037 9.51795 27.6689 11.0588C28.3341 12.5996 28.6666 14.246 28.6666 15.9979C28.6666 17.7407 28.3342 19.3814 27.6693 20.9201C27.0044 22.4588 26.0984 23.802 24.9512 24.9497C23.804 26.0974 22.4637 27.0038 20.9302 27.669C19.3968 28.3342 17.7542 28.6668 16.0022 28.6668ZM15.9989 26.9916C19.0395 26.9916 21.6318 25.92 23.7756 23.7769C25.9195 21.6337 26.9915 19.0419 26.9915 16.0012C26.9915 12.9458 25.9199 10.3498 23.7767 8.21336C21.6336 6.0769 19.0417 5.00866 16.0011 5.00866C12.9457 5.00866 10.3497 6.07654 8.21324 8.2123C6.07677 10.348 5.00854 12.9436 5.00854 15.999C5.00854 19.0397 6.07642 21.6319 8.21217 23.7758C10.3479 25.9197 12.9435 26.9916 15.9989 26.9916ZM18.3402 14.254L18.9205 13.9172C18.9209 14.3656 19.0778 14.7468 19.3913 15.0608C19.7048 15.3748 20.0864 15.5317 20.536 15.5317C21.0009 15.5317 21.3916 15.3728 21.7081 15.0548C22.0246 14.7369 22.1829 14.347 22.1829 13.8852C22.1829 13.5943 22.1112 13.3245 21.9679 13.0758C21.8246 12.8271 21.6273 12.6309 21.376 12.4873L22.3718 11.9232L21.782 10.8848L17.7504 13.195L18.3402 14.254ZM13.6598 14.254L14.2496 13.195L10.218 10.8848L9.62824 11.9232L10.624 12.4873C10.3727 12.6309 10.1754 12.8271 10.0321 13.0758C9.88879 13.3245 9.81714 13.5943 9.81714 13.8852C9.81714 14.347 9.9754 14.7369 10.2919 15.0548C10.6084 15.3728 10.9991 15.5317 11.464 15.5317C11.9137 15.5317 12.2952 15.3748 12.6087 15.0608C12.9222 14.7468 13.0791 14.3656 13.0795 13.9172L13.6598 14.254ZM15.9992 17.383C14.5522 17.383 13.2811 17.8501 12.1857 18.7843C11.0904 19.7185 10.2858 20.8759 9.77184 22.2565H22.2282C21.7051 20.885 20.8979 19.7299 19.8066 18.7912C18.7154 17.8524 17.4462 17.383 15.9992 17.383Z",
    fill: "#989898"
  }
) });
const MoodNeutralIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, width: "32", height: "32", viewBox: "0 0 32 32", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    id: "icon",
    d: "M20.6406 14.1984C21.0945 14.1984 21.4815 14.0373 21.8017 13.7151C22.1219 13.3928 22.282 13.0048 22.282 12.551C22.282 12.0971 22.1209 11.7101 21.7987 11.3899C21.4764 11.0697 21.0884 10.9096 20.6346 10.9096C20.1808 10.9096 19.7937 11.0707 19.4735 11.3929C19.1533 11.7151 18.9932 12.1032 18.9932 12.557C18.9932 13.0108 19.1543 13.3978 19.4765 13.7181C19.7988 14.0383 20.1868 14.1984 20.6406 14.1984ZM11.3654 14.1984C11.8193 14.1984 12.2063 14.0373 12.5265 13.7151C12.8467 13.3928 13.0068 13.0048 13.0068 12.551C13.0068 12.0971 12.8457 11.7101 12.5235 11.3899C12.2013 11.0697 11.8132 10.9096 11.3594 10.9096C10.9056 10.9096 10.5185 11.0707 10.1983 11.3929C9.87809 11.7151 9.71797 12.1032 9.71797 12.557C9.71797 13.0108 9.8791 13.3978 10.2013 13.7181C10.5236 14.0383 10.9116 14.1984 11.3654 14.1984ZM12.0034 20.4753H20.0102V19.0702H12.0034V20.4753ZM16.0022 28.6668C14.2503 28.6668 12.6036 28.3343 11.0621 27.6694C9.52057 27.0045 8.17966 26.1022 7.03937 24.9624C5.89906 23.8226 4.99632 22.4823 4.33114 20.9415C3.66596 19.4006 3.33337 17.7543 3.33337 16.0024C3.33337 14.2505 3.66582 12.6037 4.33071 11.0622C4.9956 9.5207 5.89793 8.17979 7.03771 7.0395C8.17751 5.89919 9.51783 4.99644 11.0587 4.33126C12.5995 3.66609 14.2459 3.3335 15.9978 3.3335C17.7497 3.3335 19.3964 3.66594 20.9379 4.33083C22.4794 4.99572 23.8204 5.89805 24.9606 7.03783C26.101 8.17763 27.0037 9.51795 27.6689 11.0588C28.3341 12.5996 28.6666 14.246 28.6666 15.9979C28.6666 17.7498 28.3342 19.3965 27.6693 20.938C27.0044 22.4796 26.1021 23.8205 24.9623 24.9608C23.8225 26.1011 22.4822 27.0038 20.9413 27.669C19.4005 28.3342 17.7542 28.6668 16.0022 28.6668ZM15.9992 26.9916C19.0674 26.9916 21.6665 25.9269 23.7965 23.7974C25.9265 21.668 26.9915 19.0692 26.9915 16.001C26.9915 12.9327 25.9268 10.3336 23.7973 8.20366C21.6679 6.07366 19.0691 5.00866 16.0008 5.00866C12.9326 5.00866 10.3335 6.07339 8.20354 8.20283C6.07354 10.3323 5.00854 12.9311 5.00854 15.9993C5.00854 19.0675 6.07326 21.6666 8.20271 23.7966C10.3321 25.9266 12.931 26.9916 15.9992 26.9916Z",
    fill: "#989898"
  }
) });
const MoodSatisfiedIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, width: "32", height: "32", viewBox: "0 0 32 32", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    id: "icon",
    d: "M20.6405 14.6598C21.0943 14.6598 21.4814 14.4987 21.8016 14.1765C22.1218 13.8542 22.2819 13.4662 22.2819 13.0124C22.2819 12.5586 22.1208 12.1715 21.7986 11.8513C21.4763 11.5311 21.0883 11.371 20.6345 11.371C20.1806 11.371 19.7936 11.5321 19.4734 11.8543C19.1532 12.1766 18.9931 12.5646 18.9931 13.0184C18.9931 13.4722 19.1542 13.8593 19.4764 14.1795C19.7986 14.4997 20.1867 14.6598 20.6405 14.6598ZM11.3653 14.6598C11.8191 14.6598 12.2062 14.4987 12.5264 14.1765C12.8466 13.8542 13.0067 13.4662 13.0067 13.0124C13.0067 12.5586 12.8456 12.1715 12.5234 11.8513C12.2011 11.5311 11.8131 11.371 11.3593 11.371C10.9054 11.371 10.5184 11.5321 10.1982 11.8543C9.87796 12.1766 9.71785 12.5646 9.71785 13.0184C9.71785 13.4722 9.87897 13.8593 10.2012 14.1795C10.5234 14.4997 10.9115 14.6598 11.3653 14.6598ZM15.9999 23.3709C17.3731 23.3709 18.6343 22.9967 19.7836 22.2483C20.9329 21.4999 21.7811 20.4975 22.3281 19.2411H20.7982C20.2945 20.0963 19.6177 20.7628 18.7678 21.2406C17.9179 21.7184 16.997 21.9573 16.005 21.9573C15.013 21.9573 14.0903 21.7207 13.2371 21.2475C12.3838 20.7742 11.7127 20.1054 11.2238 19.2411H9.67172C10.2278 20.4975 11.0783 21.4999 12.223 22.2483C13.3677 22.9967 14.6267 23.3709 15.9999 23.3709ZM16.0021 29.1282C14.2502 29.1282 12.6035 28.7957 11.062 28.1309C9.52045 27.466 8.17954 26.5636 7.03925 25.4239C5.89894 24.2841 4.9962 22.9437 4.33102 21.4029C3.66584 19.8621 3.33325 18.2157 3.33325 16.4638C3.33325 14.7119 3.6657 13.0652 4.33059 11.5237C4.99547 9.98212 5.89781 8.64121 7.03759 7.50092C8.17739 6.36061 9.51771 5.45787 11.0586 4.79269C12.5994 4.12751 14.2457 3.79492 15.9977 3.79492C17.7496 3.79492 19.3963 4.12737 20.9378 4.79226C22.4793 5.45715 23.8202 6.35948 24.9605 7.49926C26.1008 8.63906 27.0036 9.97938 27.6688 11.5202C28.3339 13.061 28.6665 14.7074 28.6665 16.4593C28.6665 18.2112 28.3341 19.8579 27.6692 21.3995C27.0043 22.941 26.102 24.2819 24.9622 25.4222C23.8224 26.5625 22.4821 27.4652 20.9412 28.1304C19.4004 28.7956 17.754 29.1282 16.0021 29.1282ZM15.9991 27.453C19.0673 27.453 21.6664 26.3883 23.7964 24.2589C25.9264 22.1294 26.9914 19.5306 26.9914 16.4624C26.9914 13.3942 25.9266 10.7951 23.7972 8.66509C21.6678 6.53509 19.0689 5.47009 16.0007 5.47009C12.9325 5.47009 10.3334 6.53481 8.20342 8.66426C6.07342 10.7937 5.00842 13.3925 5.00842 16.4607C5.00842 19.5289 6.07314 22.128 8.20258 24.258C10.332 26.388 12.9308 27.453 15.9991 27.453Z",
    fill: "#989898"
  }
) });
const MoodVerySatisfiedIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, width: "32", height: "32", viewBox: "0 0 32 32", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    id: "icon",
    d: "M20.6406 14.1984C21.0945 14.1984 21.4815 14.0373 21.8017 13.7151C22.1219 13.3928 22.282 13.0048 22.282 12.551C22.282 12.0971 22.1209 11.7101 21.7987 11.3899C21.4764 11.0697 21.0884 10.9096 20.6346 10.9096C20.1808 10.9096 19.7937 11.0707 19.4735 11.3929C19.1533 11.7151 18.9932 12.1032 18.9932 12.557C18.9932 13.0108 19.1543 13.3978 19.4765 13.7181C19.7988 14.0383 20.1868 14.1984 20.6406 14.1984ZM11.3654 14.1984C11.8193 14.1984 12.2063 14.0373 12.5265 13.7151C12.8467 13.3928 13.0068 13.0048 13.0068 12.551C13.0068 12.0971 12.8457 11.7101 12.5235 11.3899C12.2013 11.0697 11.8132 10.9096 11.3594 10.9096C10.9056 10.9096 10.5185 11.0707 10.1983 11.3929C9.87809 11.7151 9.71797 12.1032 9.71797 12.557C9.71797 13.0108 9.8791 13.3978 10.2013 13.7181C10.5236 14.0383 10.9116 14.1984 11.3654 14.1984ZM16 22.9095C17.3732 22.9095 18.6345 22.5353 19.7837 21.7869C20.933 21.0384 21.7812 20.036 22.3282 18.7796H9.67184C10.228 20.036 11.0784 21.0384 12.2231 21.7869C13.3678 22.5353 14.6268 22.9095 16 22.9095ZM16.0022 28.6668C14.2503 28.6668 12.6036 28.3343 11.0621 27.6694C9.52057 27.0045 8.17966 26.1022 7.03937 24.9624C5.89906 23.8226 4.99632 22.4823 4.33114 20.9415C3.66596 19.4006 3.33337 17.7543 3.33337 16.0024C3.33337 14.2505 3.66582 12.6037 4.33071 11.0622C4.9956 9.5207 5.89793 8.17979 7.03771 7.0395C8.17751 5.89919 9.51783 4.99644 11.0587 4.33126C12.5995 3.66609 14.2459 3.3335 15.9978 3.3335C17.7497 3.3335 19.3964 3.66594 20.9379 4.33083C22.4794 4.99572 23.8204 5.89805 24.9606 7.03783C26.101 8.17763 27.0037 9.51795 27.6689 11.0588C28.3341 12.5996 28.6666 14.246 28.6666 15.9979C28.6666 17.7498 28.3342 19.3965 27.6693 20.938C27.0044 22.4796 26.1021 23.8205 24.9623 24.9608C23.8225 26.1011 22.4822 27.0038 20.9413 27.669C19.4005 28.3342 17.7542 28.6668 16.0022 28.6668ZM15.9992 26.9916C19.0674 26.9916 21.6665 25.9269 23.7965 23.7974C25.9265 21.668 26.9915 19.0692 26.9915 16.001C26.9915 12.9327 25.9268 10.3336 23.7973 8.20366C21.6679 6.07366 19.0691 5.00866 16.0008 5.00866C12.9326 5.00866 10.3335 6.07339 8.20354 8.20283C6.07354 10.3323 5.00854 12.9311 5.00854 15.9993C5.00854 19.0675 6.07326 21.6666 8.20271 23.7966C10.3321 25.9266 12.931 26.9916 15.9992 26.9916Z",
    fill: "#989898"
  }
) });
const moodConfig = {
  "Very dissatisfied": MoodVeryDissatisfiedIcon,
  Dissatisfied: MoodDissatisfiedIcon,
  Neutral: MoodNeutralIcon,
  Satisfied: MoodSatisfiedIcon,
  "Very satisfied": MoodVerySatisfiedIcon
};
const Mood = ({ selectedMood, onClick }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "mood-wrapper", children: Object.entries(moodConfig).map(([moodName, moodIcon]) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("mood-icon-wrapper", {
        "mood-icon-wrapper--selected": moodName === selectedMood
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            icon: moodIcon,
            className: classnames("mood-icon", {
              "mood-icon--selected": moodName === selectedMood
            }),
            onClick: () => onClick(moodName)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: classnames("mood-name", {
              "mood-name--selected": moodName === selectedMood
            }),
            children: moodName
          }
        )
      ]
    },
    moodName
  )) });
};
const FeedbackForm = ({ hideForm, title, usageContext }) => {
  const [formStatus, setFormStatus] = reactExports.useState("active");
  const [activeMood, setActiveMood] = reactExports.useState(null);
  const [feedbackText, setFeedbackText] = reactExports.useState("");
  const handleFormAction = (action) => {
    setFormStatus(action);
    const timer2 = setTimeout(() => {
      updateLocalStorageUsageContext(false);
      hideForm();
    }, 4e3);
    return () => clearTimeout(timer2);
  };
  const updateLocalStorageUsageContext = (value) => {
    const existingData = loadLocalStorage(localStorageFeedbackSeen) || {};
    existingData[usageContext] = value;
    saveLocalStorage(localStorageFeedbackSeen, existingData);
  };
  reactExports.useEffect(() => {
    if (formStatus === "submitted" || formStatus === "cancelled") {
      const timer2 = setTimeout(() => {
        setFormStatus("active");
        setActiveMood(null);
        setFeedbackText("");
      }, 4e3);
      return () => clearTimeout(timer2);
    }
  }, [formStatus]);
  const handleFormSubmit = (e) => {
    e.preventDefault();
    handleFormAction("submitted");
    getHeap().track(getDataTestAttribute(usageContext, "feedback-form"), {
      rating: activeMood,
      feedback: feedbackText
    });
  };
  const getMessages = () => {
    if (formStatus === "submitted") {
      return "Thank you for sharing feedback!";
    }
    if (formStatus === "cancelled") {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        "You can provide feedback any time by using",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        "the feedback button in the sliced view."
      ] });
    }
  };
  if (formStatus === "submitted" || formStatus === "cancelled") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "feedback-form--wrapper feedback-form--message", children: getMessages() });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: classnames("feedback-form--wrapper", {
          "feedback-form--wrapper-no-text-area": activeMood === null
        }),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "feedback-form--close-icon",
              onClick: () => handleFormAction("cancelled"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "feedback-form--title", children: title }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "feedback-form", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Mood, { selectedMood: activeMood, onClick: setActiveMood }),
            activeMood !== null && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  className: "feedback-form--text-area",
                  value: feedbackText,
                  onChange: (event) => setFeedbackText(event.target.value),
                  placeholder: "How can we improve this feature?"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", onClick: handleFormSubmit, children: "Submit feedback" })
            ] })
          ] })
        ]
      }
    );
  }
};
const markerIds = [
  "arrowhead",
  "arrowhead--input",
  "arrowhead--accent--input",
  "arrowhead--accent"
];
function GraphSVG({
  width: width2,
  height: height2,
  svgRef,
  wrapperRef,
  visibleGraph,
  children: children2,
  ...rest
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "svg",
    {
      id: "pipeline-graph",
      className: "pipeline-flowchart__graph",
      width: width2,
      height: height2,
      ref: svgRef,
      ...rest,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "g",
        {
          id: "zoom-wrapper",
          className: classnames("pipeline-zoom-wrapper", {
            "pipeline-zoom-wrapper--hidden": !visibleGraph
          }),
          ref: wrapperRef,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("defs", { children: markerIds.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              "marker",
              {
                id: `pipeline-${id2}`,
                className: `pipeline-flowchart__${id2}`,
                viewBox: "0 0 10 10",
                refX: "7",
                refY: "5",
                markerUnits: "strokeWidth",
                markerWidth: "8",
                markerHeight: "6",
                orient: "auto",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M 0 0 L 10 5 L 0 10 L 4 5 z" })
              },
              id2
            )) }),
            children2
          ]
        }
      )
    }
  );
}
const modifiers = (name, modifiers2, others = "") => Object.keys(modifiers2 || {}).reduce((classes, modifier) => {
  const value = modifiers2[modifier];
  if (typeof value !== "string" && typeof value !== "number") {
    return `${classes} ${name}--${value ? "" : "no-"}${modifier}`;
  }
  return `${classes} ${name}--${modifier}-${(value + "").replace(
    /\s/g,
    "-"
  )}`;
}, name) + (others ? " " + others : "");
const paths = {
  // database icon
  data: "M12 4c3.31 0 6 1.67 6 3.73l-.01.27H18v9h-.02a1.1 1.1 0 01-.16.42c-1.14 1.7-3.11 2.53-5.82 2.53s-4.68-.82-5.82-2.53a1.09 1.09 0 01-.16-.42H6V8h.01A2.33 2.33 0 016 7.73C6 5.67 8.69 4 12 4zm0 11.73c-1.6 0-2.94-.31-4-.94v1.64c.74.9 2.05 1.38 4 1.38 1.95 0 3.26-.48 4-1.38v-1.65c-1.06.64-2.4.95-4 .95zm0-4.26a8.33 8.33 0 01-4-.95v1.64c.75 1.1 2.04 1.65 4 1.65s3.25-.55 4-1.65V10.5c-1.06.6-2.46.96-4 .96zm0-5.34a6.3 6.3 0 00-3.23.8c-.56.35-.77.66-.77.8 0 .15.2.45.77.8.8.5 1.96.8 3.23.8s2.44-.3 3.23-.8c.56-.35.77-.65.77-.8 0-.14-.2-.45-.77-.8a6.3 6.3 0 00-3.23-.8z",
  // function icon
  task: "M20 4.2l.2.2L19 5.9c-2.3-1.8-3.8-.9-4.8 3.4h3.1v2h-3.5v.2l-.1.6c-1.2 7.9-4 11-8.3 8l-.2-.1 1.2-1.6c2.5 1.8 4.2.3 5.2-5.9l.2-1v-.2H9.2v-2h3c1.4-6 4.1-8 7.9-5z",
  // sliders icon
  parameters: "M10.2 14v1.5H20v2h-9.8V19H8.3v-1.5H5v-2h3.3V14h2zm7.4-9v1.5H20v2h-2.4V10h-1.8V8.5H5v-2h10.8V5h1.8z",
  modularPipeline: "M8.18 4c1.11 0 2.03.8 2.17 1.86l4.4 1.61c.31-.17.68-.27 1.07-.27 1.2 0 2.18.95 2.18 2.13s-.98 2.14-2.18 2.14c-.38 0-.73-.1-1.04-.26l-4.22 2.74L13.69 16c.3-.16.66-.26 1.04-.26 1.2 0 2.18.96 2.18 2.14 0 1.18-.98 2.13-2.18 2.13a2.16 2.16 0 01-2.17-2.35l-3.34-2.18c-.3.17-.66.26-1.04.26-1.2 0-2.18-.95-2.18-2.13s.98-2.13 2.18-2.13c.61 0 1.16.24 1.56.63l3.9-2.55v-.22-.13L9.63 7.73c-.39.33-.9.54-1.45.54C6.98 8.27 6 7.3 6 6.13 6 4.95 6.98 4 8.18 4z",
  // for plotly and matplotlib
  plotly: "M6.261 11.546l5.465 5.766-1.452 1.376-4.013-4.235-2.535 2.676-1.452-1.376 3.987-4.207zm6.911-2.898l8.495 7.607-1.334 1.49-7.14-6.394-2.514 2.325-1.358-1.469 3.851-3.559zM5.5 6C6.328 6 7 6.672 7 7.5S6.328 9 5.5 9 4 8.328 4 7.5 4.672 6 5.5 6z",
  image: "M6.261 11.546l5.465 5.766-1.452 1.376-4.013-4.235-2.535 2.676-1.452-1.376 3.987-4.207zm6.911-2.898l8.495 7.607-1.334 1.49-7.14-6.394-2.514 2.325-1.358-1.469 3.851-3.559zM5.5 6C6.328 6 7 6.672 7 7.5S6.328 9 5.5 9 4 8.328 4 7.5 4.672 6 5.5 6z"
};
const NodeIcon = ({ className, icon }) => paths[icon] ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    className: modifiers("pipeline-node-icon", { icon }, className),
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: paths[icon] })
  }
) : null;
function formatNumber(num) {
  return num % 1 === 0 ? String(num) : Number(num).toFixed(2).replace(/\.?0+$/, "");
}
function formatDuration(seconds) {
  if (isNaN(seconds)) {
    return "N/A";
  }
  const numSeconds = Number(seconds);
  if (numSeconds < 1) {
    const milliseconds = Math.round(numSeconds * 1e3);
    return `${milliseconds}ms`;
  }
  const totalSeconds = Math.floor(numSeconds);
  const minutes = Math.floor(totalSeconds / 60);
  const secs = numSeconds - minutes * 60;
  const secsStr = formatNumber(secs);
  if (minutes > 0) {
    return secs > 0 ? `${minutes}m ${secsStr}s` : `${minutes}m`;
  }
  return `${secsStr}s`;
}
function formatSize(bytes) {
  if (isNaN(bytes) || bytes === null) {
    return "N/A";
  }
  const numBytes = Number(bytes);
  if (numBytes < 1024) {
    return `${numBytes}B`;
  }
  const kilobytes = numBytes / 1024;
  if (kilobytes < 1024) {
    return `${kilobytes % 1 === 0 ? kilobytes : kilobytes.toFixed(2)}KB`;
  }
  const megabytes = kilobytes / 1024;
  return `${megabytes % 1 === 0 ? megabytes : megabytes.toFixed(2)}MB`;
}
function formatTimestamp(timestamp) {
  if (!timestamp) {
    return "N/A";
  }
  const pad2 = (num) => num.toString().padStart(2, "0");
  const date2 = new Date(timestamp);
  const day = pad2(date2.getDate());
  const month = pad2(date2.getMonth() + 1);
  const year = date2.getFullYear();
  const hour = pad2(date2.getHours());
  const minute = pad2(date2.getMinutes());
  const second = pad2(date2.getSeconds());
  const tzLabel = date2.toLocaleTimeString(void 0, { timeZoneName: "short" }).split(" ").pop() || "UTC";
  return `${day}.${month}.${year} - ${hour}:${minute}:${second} ${tzLabel}`;
}
function getTasksStatusInfo(tasksStatus, node2) {
  if (!tasksStatus) {
    return { taskStatus: null, taskDuration: null };
  }
  const statusKey = Object.keys(tasksStatus).find(
    (key) => tasksStatus[key][node2.id]
  );
  if (!statusKey) {
    return { taskStatus: null, taskDuration: null };
  }
  const status = tasksStatus[statusKey][node2.id];
  return {
    taskStatus: (status == null ? void 0 : status.status) ?? null,
    taskDuration: (status == null ? void 0 : status.duration) ?? null
  };
}
function getDatasetStatusInfo(datasetStatus, node2) {
  if (!datasetStatus || node2.type !== "data") {
    return { datasetStatus: null, datasetSize: null };
  }
  const statusKey = Object.keys(datasetStatus).find(
    (key) => datasetStatus[key][node2.id]
  );
  if (!statusKey) {
    return { datasetStatus: null, datasetSize: null };
  }
  const dataset = datasetStatus[statusKey][node2.id];
  return {
    datasetStatus: (dataset == null ? void 0 : dataset.status) ?? null,
    datasetSize: (dataset == null ? void 0 : dataset.size) ?? null
  };
}
const DETAILS_LABEL_X_OFFSET = 15;
const STATUS_VALUE_X_OFFSET = 80;
const STATUS_LABEL_Y_OFFSET = 20;
const SIZE_LABEL_Y_OFFSET = 45;
function appendDetailsText(group, classNames, text, x2, y2) {
  group.append("text").attr("class", classNames).text(text).attr("text-anchor", "start").attr("x", x2).attr("y", y2);
}
function renderNodeDetailsContainer(parentGroup, node2, tasksStatus, dataSetsStatus) {
  const nodeWidth = node2.width - 5;
  const nodeHeight = node2.height - 5;
  const detailsSectionHeight = nodeHeight / 2 + workflowNodeDetailsHeight;
  const { taskStatus, taskDuration } = getTasksStatusInfo(tasksStatus, node2);
  const { datasetStatus, datasetSize } = getDatasetStatusInfo(
    dataSetsStatus,
    node2
  );
  const detailsContainer = parentGroup.insert("g", ":first-child").attr("class", "pipeline-node__details-container");
  detailsContainer.append("rect").attr("class", "pipeline-node__details-bg").attr("width", nodeWidth).attr("height", detailsSectionHeight).attr("x", nodeWidth / -2).attr("y", 0);
  detailsContainer.append("path").attr("class", "pipeline-node__details-outline").attr("d", () => {
    if (node2.type === "task") {
      return `
        M ${nodeWidth / -2} ${nodeHeight / 2} 
        V ${detailsSectionHeight} 
        H ${nodeWidth / 2} 
        V ${nodeHeight / 2}`;
    } else {
      const curveX = 10;
      const curveY = detailsSectionHeight - curveX;
      const leftX = nodeWidth / -2;
      const rightX = nodeWidth / 2;
      const bottomY = detailsSectionHeight;
      return `
          M ${leftX} 0 
          V ${curveY} 
          Q ${leftX} ${bottomY} ${leftX + curveX} ${bottomY} 
          H ${rightX - curveX} 
          Q ${rightX} ${bottomY} ${rightX} ${curveY} 
          V 0`;
    }
  });
  const statusGroup = detailsContainer.append("g").attr("class", "pipeline-node__details-status-group");
  appendDetailsText(
    statusGroup,
    "pipeline-node__details-label",
    "Status:",
    nodeWidth / -2 + DETAILS_LABEL_X_OFFSET,
    nodeHeight / 2 + STATUS_LABEL_Y_OFFSET
  );
  appendDetailsText(
    statusGroup,
    "pipeline-node__details-value",
    datasetStatus ? `${datasetStatus}` : taskStatus ?? "Skipped",
    nodeWidth / 2 - STATUS_VALUE_X_OFFSET,
    nodeHeight / 2 + STATUS_LABEL_Y_OFFSET
  );
  const metricsGroup = detailsContainer.append("g").attr("class", "pipeline-node__details-metrics-group");
  appendDetailsText(
    metricsGroup,
    "pipeline-node__details-label",
    node2.type === "task" || node2.type === "modularPipeline" ? "Duration:" : "Size:",
    nodeWidth / -2 + DETAILS_LABEL_X_OFFSET,
    nodeHeight / 2 + SIZE_LABEL_Y_OFFSET
  );
  appendDetailsText(
    metricsGroup,
    "pipeline-node__details-value",
    node2.type === "task" || node2.type === "modularPipeline" ? taskDuration != null ? formatDuration(taskDuration) : "N/A" : datasetSize != null ? formatSize(datasetSize) : "N/A",
    nodeWidth / 2 - STATUS_VALUE_X_OFFSET,
    nodeHeight / 2 + SIZE_LABEL_Y_OFFSET
  );
}
function setNodeRectAttrs(nodeRects, widthFn) {
  return nodeRects.attr("width", widthFn).attr("height", (node2) => node2.height - 5).attr("x", (node2) => -widthFn(node2) / 2).attr("y", (node2) => (node2.height - 5) / -2).attr(
    "rx",
    (node2) => node2.type === "task" || node2.type === "modularPipeline" ? 0 : node2.height / 2
  );
}
const updateNodeRects = (nodeRects, showRunStatus, tasksStatus, dataSetsStatus) => {
  if (showRunStatus) {
    setNodeRectAttrs(nodeRects, (node2) => node2.width - 5);
    nodeRects.each(function(node2) {
      const parentGroup = select(this.parentNode);
      parentGroup.selectAll(".pipeline-node__details-container").remove();
      renderNodeDetailsContainer(
        parentGroup,
        node2,
        tasksStatus,
        dataSetsStatus
      );
    });
  } else {
    return setNodeRectAttrs(nodeRects, (node2) => node2.width - 5);
  }
};
const updateParameterRect = (nodeRects, orientation) => nodeRects.attr("width", 12).attr("height", 12).attr(
  "x",
  (node2) => orientation === "vertical" ? (node2.width + 20) / -2 : -(node2.width / 2) + 10
).attr("y", (node2) => orientation === "vertical" ? -6 : -node2.height + 12);
const DURATION = 700;
const MARGIN = 500;
const MIN_SCALE = 0.8;
const MAX_SCALE = 2;
function getNodeStatusKey(statusObj, node2, statusConfig) {
  if (!statusObj || !statusConfig) {
    return null;
  }
  const foundKey = statusConfig.find(
    (statusKey) => statusObj[statusKey] && statusObj[statusKey][node2.id]
  );
  return foundKey || "skipped";
}
function DrawNodes({
  nodes = [],
  nodeActive = {},
  nodeSelected = {},
  nodeTypeDisabled = {},
  nodeStyleOverrides = {},
  hoveredParameters = null,
  hoveredFocusMode = null,
  nodesWithInputParams = {},
  inputOutputDataNodes = {},
  focusMode = null,
  orientation = "vertical",
  onNodeClick,
  onNodeMouseOver,
  onNodeMouseOut,
  onNodeFocus,
  onNodeBlur,
  onNodeKeyDown,
  onParamsIndicatorMouseOver,
  isSlicingPipelineApplied = false,
  slicedPipelineFromTo = {},
  slicedPipelineRange = {},
  isInputOutputNode = () => false,
  clickedNode = null,
  linkedNodes = {},
  showRunStatus = false,
  tasksStatus = {},
  datasetsStatus = {}
}) {
  const groupRef = reactExports.useRef();
  const getNodeSelections = (groupRef2, nodes2) => {
    const svg = select(groupRef2.current);
    const nodeSel = svg.selectAll(".pipeline-node").data(nodes2, (node2) => node2.id);
    const updateNodes = nodeSel;
    const enterNodes = nodeSel.enter().append("g");
    const exitNodes = nodeSel.exit();
    const allNodes = updateNodes.merge(enterNodes).merge(exitNodes).filter((node2) => typeof node2 !== "undefined");
    return { svg, nodeSel, updateNodes, enterNodes, exitNodes, allNodes };
  };
  reactExports.useEffect(() => {
    const { updateNodes, enterNodes, exitNodes } = getNodeSelections(
      groupRef,
      nodes
    );
    if (nodes.length === 0) {
      exitNodes.transition("exit-nodes").duration(DURATION).style("opacity", 0).remove();
      return;
    }
    enterNodes.attr("tabindex", "0").attr("class", (node2) => {
      let baseClass = "pipeline-node";
      if (node2.type) {
        baseClass += ` pipeline-node--${node2.type}`;
      }
      if (showRunStatus) {
        const statusSource = node2.type === "data" ? datasetsStatus : tasksStatus;
        let finalStatus = getNodeStatusKey(
          statusSource,
          node2,
          workFlowStatuses
        );
        baseClass += ` pipeline-node--status-${finalStatus}`;
      }
      return baseClass;
    }).attr("transform", (node2) => `translate(${node2.x}, ${node2.y})`).attr("data-id", (node2) => node2.id).classed(
      "pipeline-node--parameters",
      (node2) => node2.type === "parameters"
    ).classed("pipeline-node--data", (node2) => node2.type === "data").classed("pipeline-node--task", (node2) => node2.type === "task").on("click", onNodeClick).on("mouseover", onNodeMouseOver).on("mouseout", onNodeMouseOut).on("focus", onNodeFocus || onNodeMouseOver).on("blur", onNodeBlur || onNodeMouseOut).on("keydown", onNodeKeyDown);
    enterNodes.attr("opacity", 0).transition("show-nodes").duration(DURATION).attr("opacity", 1);
    enterNodes.append("rect").attr(
      "class",
      (node2) => `pipeline-node__bg pipeline-node__bg--${node2.type} pipeline-node__bg--${node2.icon}`
    );
    enterNodes.append("rect").attr("class", "pipeline-node__parameter-indicator").on("mouseover", onParamsIndicatorMouseOver).call(updateParameterRect, orientation);
    enterNodes.append("path").attr("class", "pipeline-node__icon").attr("d", (node2) => paths[node2.icon]);
    enterNodes.append("text").attr("class", "pipeline-node__text").text((node2) => node2.name).attr("text-anchor", "middle").attr("dy", 5).attr("dx", (node2) => node2.textOffset);
    exitNodes.transition("exit-nodes").duration(DURATION).style("opacity", 0).remove();
    updateNodes.transition("exit-nodes").style("opacity", null);
  }, [
    nodes,
    onNodeClick,
    onNodeMouseOver,
    onNodeMouseOut,
    onNodeFocus,
    onNodeBlur,
    onNodeKeyDown,
    onParamsIndicatorMouseOver,
    orientation
  ]);
  reactExports.useEffect(() => {
    const selections = getNodeSelections(groupRef, nodes);
    if (!selections) {
      return;
    }
    const { allNodes } = selections;
    allNodes.classed("pipeline-node--active", (node2) => nodeActive[node2.id]).classed("pipeline-node--selected", (node2) => nodeSelected[node2.id]).classed(
      "pipeline-node--sliced-pipeline",
      (node2) => !isSlicingPipelineApplied && slicedPipelineRange[node2.id]
    ).classed(
      "pipeline-node--from-to-sliced-pipeline",
      (node2) => !isSlicingPipelineApplied && slicedPipelineFromTo && slicedPipelineFromTo[node2.id]
    ).classed(
      "pipeline-node--collapsed-hint",
      (node2) => hoveredParameters && nodesWithInputParams[node2.id] && nodeTypeDisabled.parameters
    ).classed(
      "pipeline-node--dataset-input",
      (node2) => isInputOutputNode(node2.id) && node2.type === "data"
    ).classed(
      "pipeline-node--parameter-input",
      (node2) => isInputOutputNode(node2.id) && node2.type === "parameters"
    ).classed(
      "pipeline-node-input--active",
      (node2) => isInputOutputNode(node2.id) && nodeActive[node2.id]
    ).classed(
      "pipeline-node-input--selected",
      (node2) => isInputOutputNode(node2.id) && nodeSelected[node2.id]
    ).classed(
      "pipeline-node--faded",
      (node2) => hoveredFocusMode && !nodeActive[node2.id] || clickedNode && !linkedNodes[node2.id]
    );
  }, [
    nodes,
    nodeTypeDisabled,
    nodeActive,
    nodeSelected,
    hoveredParameters,
    hoveredFocusMode,
    nodesWithInputParams,
    clickedNode,
    linkedNodes,
    focusMode,
    inputOutputDataNodes,
    isSlicingPipelineApplied,
    slicedPipelineRange,
    slicedPipelineFromTo,
    isInputOutputNode
  ]);
  reactExports.useEffect(() => {
    const selections = getNodeSelections(groupRef, nodes);
    if (!selections) {
      return;
    }
    const { updateNodes, enterNodes, allNodes } = selections;
    allNodes.transition("update-nodes").duration(DURATION).attr("transform", (node2) => `translate(${node2.x}, ${node2.y})`).on("end", () => {
      try {
        allNodes.sort((a, b) => a.order - b.order);
      } catch (err) {
      }
    });
    enterNodes.select(".pipeline-node__bg").call(updateNodeRects, showRunStatus, tasksStatus, datasetsStatus);
    updateNodes.select(".pipeline-node__bg").transition("node-rect").duration((node2) => node2.showText ? 200 : 600).call(updateNodeRects, showRunStatus, tasksStatus, datasetsStatus);
    allNodes.select(".pipeline-node__parameter-indicator").classed(
      "pipeline-node__parameter-indicator--visible",
      (node2) => nodeTypeDisabled.parameters && nodesWithInputParams[node2.id]
    ).transition("node-rect").duration((node2) => node2.showText ? 200 : 600).call(updateParameterRect, orientation);
    allNodes.select(".pipeline-node__icon").style("transition-delay", (node2) => node2.showText ? "0ms" : "200ms").style(
      "transform",
      (node2) => `translate(${node2.iconOffset}px, ${-node2.iconSize / 2}px) scale(${node2.iconSize / 24})`
    );
    allNodes.select(".pipeline-node__text").text((node2) => node2.name).style("transition-delay", (node2) => node2.showText ? "200ms" : "0ms").style("opacity", (node2) => node2.showText ? 1 : 0);
  }, [nodes, orientation]);
  reactExports.useEffect(() => {
    const selections = getNodeSelections(groupRef, nodes);
    if (!selections) {
      return;
    }
    const { allNodes } = selections;
    allNodes.each(function(node2) {
      const nodeGroup = select(this);
      const appliedOverrides = nodeGroup.node().__appliedStyleOverrides;
      if (appliedOverrides) {
        Object.entries(appliedOverrides).forEach(
          ([elementSelector, styles2]) => {
            const element = nodeGroup.select(elementSelector);
            Object.keys(styles2).forEach((cssProperty) => {
              element.style(cssProperty, null);
            });
          }
        );
        delete nodeGroup.node().__appliedStyleOverrides;
        nodeGroup.classed("kedro-viz-custom-styled", false);
      }
    });
    allNodes.each(function(node2) {
      if (node2.extras && node2.extras.styles && Object.keys(node2.extras.styles).length > 0) {
        const nodeGroup = select(this);
        const nodeStyles = nodeStyleOverrides[node2.id];
        if (nodeStyles) {
          const appliedOverrides = {};
          Object.entries(nodeStyles).forEach(([key, value]) => {
            const cssProperty = key.replace(/([A-Z])/g, "-$1").toLowerCase();
            if (key.toLowerCase().includes("background") || ["fill", "stroke", "strokeWidth", "opacity"].includes(key)) {
              const bgElement = nodeGroup.select(".pipeline-node__bg");
              bgElement.style(cssProperty, value, "important");
              if (!appliedOverrides[".pipeline-node__bg"]) {
                appliedOverrides[".pipeline-node__bg"] = {};
              }
              appliedOverrides[".pipeline-node__bg"][cssProperty] = value;
            } else if (key.toLowerCase().includes("text") || key.toLowerCase().includes("font") || ["color"].includes(key)) {
              const textElement = nodeGroup.select(".pipeline-node__text");
              const iconElement = nodeGroup.select(".pipeline-node__icon");
              [
                { element: textElement, selector: ".pipeline-node__text" },
                { element: iconElement, selector: ".pipeline-node__icon" }
              ].forEach(({ element, selector: selector2 }) => {
                const finalProperty = key === "color" ? "fill" : cssProperty;
                element.style(finalProperty, value, "important");
                if (!appliedOverrides[selector2]) {
                  appliedOverrides[selector2] = {};
                }
                appliedOverrides[selector2][finalProperty] = value;
              });
            }
          });
          nodeGroup.node().__appliedStyleOverrides = appliedOverrides;
        }
        nodeGroup.classed("kedro-viz-custom-styled", true);
      }
    });
  }, [nodeStyleOverrides]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "nodes", className: "pipeline-flowchart__nodes", ref: groupRef });
}
function ownKeys(object2, enumerableOnly) {
  var keys = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends$1() {
  _extends$1 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
      if (it) o = it;
      var i = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = it.call(o);
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function decasteljau(points, t) {
  var left = [];
  var right = [];
  function decasteljauRecurse(points2, t2) {
    if (points2.length === 1) {
      left.push(points2[0]);
      right.push(points2[0]);
    } else {
      var newPoints = Array(points2.length - 1);
      for (var i = 0; i < newPoints.length; i++) {
        if (i === 0) {
          left.push(points2[0]);
        }
        if (i === newPoints.length - 1) {
          right.push(points2[i + 1]);
        }
        newPoints[i] = [(1 - t2) * points2[i][0] + t2 * points2[i + 1][0], (1 - t2) * points2[i][1] + t2 * points2[i + 1][1]];
      }
      decasteljauRecurse(newPoints, t2);
    }
  }
  if (points.length) {
    decasteljauRecurse(points, t);
  }
  return {
    left,
    right: right.reverse()
  };
}
function pointsToCommand(points) {
  var command = {};
  if (points.length === 4) {
    command.x2 = points[2][0];
    command.y2 = points[2][1];
  }
  if (points.length >= 3) {
    command.x1 = points[1][0];
    command.y1 = points[1][1];
  }
  command.x = points[points.length - 1][0];
  command.y = points[points.length - 1][1];
  if (points.length === 4) {
    command.type = "C";
  } else if (points.length === 3) {
    command.type = "Q";
  } else {
    command.type = "L";
  }
  return command;
}
function splitCurveAsPoints(points, segmentCount) {
  segmentCount = segmentCount || 2;
  var segments = [];
  var remainingCurve = points;
  var tIncrement = 1 / segmentCount;
  for (var i = 0; i < segmentCount - 1; i++) {
    var tRelative = tIncrement / (1 - tIncrement * i);
    var split = decasteljau(remainingCurve, tRelative);
    segments.push(split.left);
    remainingCurve = split.right;
  }
  segments.push(remainingCurve);
  return segments;
}
function splitCurve(commandStart, commandEnd, segmentCount) {
  var points = [[commandStart.x, commandStart.y]];
  if (commandEnd.x1 != null) {
    points.push([commandEnd.x1, commandEnd.y1]);
  }
  if (commandEnd.x2 != null) {
    points.push([commandEnd.x2, commandEnd.y2]);
  }
  points.push([commandEnd.x, commandEnd.y]);
  return splitCurveAsPoints(points, segmentCount).map(pointsToCommand);
}
var commandTokenRegex = /[MLCSTQAHVZmlcstqahv]|-?[\d.e+-]+/g;
var typeMap = {
  M: ["x", "y"],
  L: ["x", "y"],
  H: ["x"],
  V: ["y"],
  C: ["x1", "y1", "x2", "y2", "x", "y"],
  S: ["x2", "y2", "x", "y"],
  Q: ["x1", "y1", "x", "y"],
  T: ["x", "y"],
  A: ["rx", "ry", "xAxisRotation", "largeArcFlag", "sweepFlag", "x", "y"],
  Z: []
};
Object.keys(typeMap).forEach(function(key) {
  typeMap[key.toLowerCase()] = typeMap[key];
});
function arrayOfLength(length2, value) {
  var array2 = Array(length2);
  for (var i = 0; i < length2; i++) {
    array2[i] = value;
  }
  return array2;
}
function commandToString(command) {
  return "".concat(command.type).concat(typeMap[command.type].map(function(p) {
    return command[p];
  }).join(","));
}
function convertToSameType(aCommand, bCommand) {
  var conversionMap = {
    x1: "x",
    y1: "y",
    x2: "x",
    y2: "y"
  };
  var readFromBKeys = ["xAxisRotation", "largeArcFlag", "sweepFlag"];
  if (aCommand.type !== bCommand.type && bCommand.type.toUpperCase() !== "M") {
    var aConverted = {};
    Object.keys(bCommand).forEach(function(bKey) {
      var bValue = bCommand[bKey];
      var aValue = aCommand[bKey];
      if (aValue === void 0) {
        if (readFromBKeys.includes(bKey)) {
          aValue = bValue;
        } else {
          if (aValue === void 0 && conversionMap[bKey]) {
            aValue = aCommand[conversionMap[bKey]];
          }
          if (aValue === void 0) {
            aValue = 0;
          }
        }
      }
      aConverted[bKey] = aValue;
    });
    aConverted.type = bCommand.type;
    aCommand = aConverted;
  }
  return aCommand;
}
function splitSegment(commandStart, commandEnd, segmentCount) {
  var segments = [];
  if (commandEnd.type === "L" || commandEnd.type === "Q" || commandEnd.type === "C") {
    segments = segments.concat(splitCurve(commandStart, commandEnd, segmentCount));
  } else {
    var copyCommand = _extends$1({}, commandStart);
    if (copyCommand.type === "M") {
      copyCommand.type = "L";
    }
    segments = segments.concat(arrayOfLength(segmentCount - 1).map(function() {
      return copyCommand;
    }));
    segments.push(commandEnd);
  }
  return segments;
}
function extend(commandsToExtend, referenceCommands, excludeSegment) {
  var numSegmentsToExtend = commandsToExtend.length - 1;
  var numReferenceSegments = referenceCommands.length - 1;
  var segmentRatio = numSegmentsToExtend / numReferenceSegments;
  var countPointsPerSegment = arrayOfLength(numReferenceSegments).reduce(function(accum, d2, i) {
    var insertIndex = Math.floor(segmentRatio * i);
    if (excludeSegment && insertIndex < commandsToExtend.length - 1 && excludeSegment(commandsToExtend[insertIndex], commandsToExtend[insertIndex + 1])) {
      var addToPriorSegment = segmentRatio * i % 1 < 0.5;
      if (accum[insertIndex]) {
        if (addToPriorSegment) {
          if (insertIndex > 0) {
            insertIndex -= 1;
          } else if (insertIndex < commandsToExtend.length - 1) {
            insertIndex += 1;
          }
        } else if (insertIndex < commandsToExtend.length - 1) {
          insertIndex += 1;
        } else if (insertIndex > 0) {
          insertIndex -= 1;
        }
      }
    }
    accum[insertIndex] = (accum[insertIndex] || 0) + 1;
    return accum;
  }, []);
  var extended = countPointsPerSegment.reduce(function(extended2, segmentCount, i) {
    if (i === commandsToExtend.length - 1) {
      var lastCommandCopies = arrayOfLength(segmentCount, _extends$1({}, commandsToExtend[commandsToExtend.length - 1]));
      if (lastCommandCopies[0].type === "M") {
        lastCommandCopies.forEach(function(d2) {
          d2.type = "L";
        });
      }
      return extended2.concat(lastCommandCopies);
    }
    return extended2.concat(splitSegment(commandsToExtend[i], commandsToExtend[i + 1], segmentCount));
  }, []);
  extended.unshift(commandsToExtend[0]);
  return extended;
}
function pathCommandsFromString(d2) {
  var tokens = (d2 || "").match(commandTokenRegex) || [];
  var commands = [];
  var commandArgs;
  var command;
  for (var i = 0; i < tokens.length; ++i) {
    commandArgs = typeMap[tokens[i]];
    if (commandArgs) {
      command = {
        type: tokens[i]
      };
      for (var a = 0; a < commandArgs.length; ++a) {
        command[commandArgs[a]] = +tokens[i + a + 1];
      }
      i += commandArgs.length;
      commands.push(command);
    }
  }
  return commands;
}
function interpolatePathCommands(aCommandsInput, bCommandsInput, interpolateOptions) {
  var aCommands = aCommandsInput == null ? [] : aCommandsInput.slice();
  var bCommands = bCommandsInput == null ? [] : bCommandsInput.slice();
  var _ref = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref.excludeSegment, snapEndsToInput = _ref.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return [];
    };
  }
  var addZ = (aCommands.length === 0 || aCommands[aCommands.length - 1].type === "Z") && (bCommands.length === 0 || bCommands[bCommands.length - 1].type === "Z");
  if (aCommands.length > 0 && aCommands[aCommands.length - 1].type === "Z") {
    aCommands.pop();
  }
  if (bCommands.length > 0 && bCommands[bCommands.length - 1].type === "Z") {
    bCommands.pop();
  }
  if (!aCommands.length) {
    aCommands.push(bCommands[0]);
  } else if (!bCommands.length) {
    bCommands.push(aCommands[0]);
  }
  var numPointsToExtend = Math.abs(bCommands.length - aCommands.length);
  if (numPointsToExtend !== 0) {
    if (bCommands.length > aCommands.length) {
      aCommands = extend(aCommands, bCommands, excludeSegment);
    } else if (bCommands.length < aCommands.length) {
      bCommands = extend(bCommands, aCommands, excludeSegment);
    }
  }
  aCommands = aCommands.map(function(aCommand, i) {
    return convertToSameType(aCommand, bCommands[i]);
  });
  var interpolatedCommands = aCommands.map(function(aCommand) {
    return _objectSpread2({}, aCommand);
  });
  if (addZ) {
    interpolatedCommands.push({
      type: "Z"
    });
    aCommands.push({
      type: "Z"
    });
  }
  return function pathCommandInterpolator(t) {
    if (t === 1 && snapEndsToInput) {
      return bCommandsInput == null ? [] : bCommandsInput;
    }
    if (t === 0) {
      return aCommands;
    }
    for (var i = 0; i < interpolatedCommands.length; ++i) {
      var aCommand = aCommands[i];
      var bCommand = bCommands[i];
      var interpolatedCommand = interpolatedCommands[i];
      var _iterator = _createForOfIteratorHelper(typeMap[interpolatedCommand.type]), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var arg = _step.value;
          interpolatedCommand[arg] = (1 - t) * aCommand[arg] + t * bCommand[arg];
          if (arg === "largeArcFlag" || arg === "sweepFlag") {
            interpolatedCommand[arg] = Math.round(interpolatedCommand[arg]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return interpolatedCommands;
  };
}
function interpolatePath(a, b, interpolateOptions) {
  var aCommands = pathCommandsFromString(a);
  var bCommands = pathCommandsFromString(b);
  var _ref2 = _typeof(interpolateOptions) === "object" ? interpolateOptions : {
    excludeSegment: interpolateOptions,
    snapEndsToInput: true
  }, excludeSegment = _ref2.excludeSegment, snapEndsToInput = _ref2.snapEndsToInput;
  if (!aCommands.length && !bCommands.length) {
    return function nullInterpolator() {
      return "";
    };
  }
  var commandInterpolator = interpolatePathCommands(aCommands, bCommands, {
    excludeSegment,
    snapEndsToInput
  });
  return function pathStringInterpolator(t) {
    if (t === 1 && snapEndsToInput) {
      return b == null ? "" : b;
    }
    var interpolatedCommands = commandInterpolator(t);
    var interpolatedString = "";
    var _iterator2 = _createForOfIteratorHelper(interpolatedCommands), _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
        var interpolatedCommand = _step2.value;
        interpolatedString += commandToString(interpolatedCommand);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return interpolatedString;
  };
}
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r2 < 0) throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r2 + "," + r2 + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    var dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r2 < 0) throw new Error("negative radius: " + r2);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r2) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r2 + "," + r2 + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r2 + "," + r2 + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r2 + "," + r2 + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r2 * Math.cos(a1)) + "," + (this._y1 = y2 + r2 * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
function constant(x2) {
  return function constant2() {
    return x2;
  };
}
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context2) {
  this._context = context2;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      // proceed
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context2) {
  return new Linear(context2);
}
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
function line$1(x$1, y$1) {
  var defined = constant(true), context2 = null, curve = curveLinear, output = null;
  x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant(x$1);
  y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant(y$1);
  function line2(data) {
    var i, n = (data = array(data)).length, d2, defined0 = false, buffer;
    if (context2 == null) output = curve(buffer = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d2 = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$1(d2, i, data), +y$1(d2, i, data));
    }
    if (buffer) return output = null, buffer + "" || null;
  }
  line2.x = function(_) {
    return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant(+_), line2) : x$1;
  };
  line2.y = function(_) {
    return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant(+_), line2) : y$1;
  };
  line2.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line2) : defined;
  };
  line2.curve = function(_) {
    return arguments.length ? (curve = _, context2 != null && (output = curve(context2)), line2) : curve;
  };
  line2.context = function(_) {
    return arguments.length ? (_ == null ? context2 = output = null : output = curve(context2 = _), line2) : context2;
  };
  return line2;
}
function point(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context2) {
  this._context = context2;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // proceed
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      // proceed
      default:
        point(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context2) {
  return new Basis(context2);
}
const matchFloats = /\d+\.\d+/g;
const toSinglePoint = (value) => parseFloat(value).toFixed(1);
const limitPrecision = (path2) => path2.replace(matchFloats, toSinglePoint);
const lineShape = line$1().x((d2) => d2.x).y((d2) => d2.y).curve(curveBasis);
function DrawEdges({
  edges = [],
  clickedNode = null,
  linkedNodes = {},
  focusMode = null,
  inputOutputDataEdges = {}
}) {
  const groupRef = reactExports.useRef();
  const isInputOutputEdge = reactExports.useCallback(
    (edgeID) => focusMode !== null && inputOutputDataEdges[edgeID],
    [focusMode, inputOutputDataEdges]
  );
  reactExports.useEffect(() => {
    const svg = select(groupRef.current);
    const edgeSel = svg.selectAll(".pipeline-edge").data(edges, (d2) => d2.id);
    const updateEdges = edgeSel;
    const enterEdges = edgeSel.enter().append("g");
    const exitEdges = edgeSel.exit();
    const allEdges = edgeSel.merge(enterEdges).merge(exitEdges).filter((edge) => edge);
    enterEdges.append("path");
    enterEdges.attr("data-id", (edge) => edge.id).attr("class", "pipeline-edge").attr("opacity", 0).transition("show-edges").duration(DURATION).attr("opacity", 1);
    exitEdges.transition("exit-edges").duration(DURATION).style("opacity", 0).remove();
    updateEdges.transition("exit-edges").style("opacity", null);
    allEdges.select("path").attr(
      "marker-end",
      (edge) => edge.sourceNode.type === "parameters" ? isInputOutputEdge(edge.id) ? `url(#pipeline-arrowhead--accent--input)` : `url(#pipeline-arrowhead--accent)` : isInputOutputEdge(edge.id) ? `url(#pipeline-arrowhead--input)` : `url(#pipeline-arrowhead)`
    ).transition("update-edges").duration(DURATION).attrTween("d", function(edge) {
      let current = edge.points && limitPrecision(lineShape(edge.points));
      const previous = select(this).attr("d") || current;
      return interpolatePath(previous, current);
    });
    allEdges.classed(
      "pipeline-edge--parameters",
      (edge) => edge.sourceNode.type === "parameters" && !isInputOutputEdge(edge.id)
    ).classed(
      "pipeline-edge--parameters-input",
      (edge) => edge.sourceNode.type === "parameters" && isInputOutputEdge(edge.id)
    ).classed(
      "pipeline-edge--dataset--input",
      (edge) => isInputOutputEdge(edge.id)
    ).classed(
      "pipeline-edge--faded",
      (edge) => edge && clickedNode && (!linkedNodes[edge.source] || !linkedNodes[edge.target])
    );
  }, [
    edges,
    clickedNode,
    linkedNodes,
    focusMode,
    inputOutputDataEdges,
    isInputOutputEdge
  ]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "pipeline-flowchart__edges", ref: groupRef });
}
function DrawLayers({
  layers = [],
  onLayerMouseOver,
  onLayerMouseOut,
  layersRef
}) {
  reactExports.useEffect(() => {
    if (!(layersRef == null ? void 0 : layersRef.current) || !layers.length) {
      return;
    }
    const svg = select(layersRef.current);
    const layerSel = svg.selectAll(".pipeline-layer").data(layers, (d2) => d2.id);
    const enterLayers = layerSel.enter().append("rect").attr("class", "pipeline-layer");
    if (onLayerMouseOver) {
      enterLayers.on("mouseover", onLayerMouseOver);
    }
    if (onLayerMouseOut) {
      enterLayers.on("mouseout", onLayerMouseOut);
    }
    layerSel.exit().remove();
    const allLayers = layerSel.merge(enterLayers);
    allLayers.attr("x", (d2) => d2.x).attr("y", (d2) => d2.y).attr("height", (d2) => d2.height).attr("width", (d2) => d2.width);
  }, [layers, onLayerMouseOver, onLayerMouseOut, layersRef]);
  return null;
}
function DrawLayersGroup({
  layers,
  layersRef,
  onLayerMouseOver,
  onLayerMouseOut
}) {
  if (!layers.length) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("g", { className: "pipeline-flowchart__layers", ref: layersRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DrawLayers,
    {
      layers,
      layersRef,
      onLayerMouseOver,
      onLayerMouseOut
    }
  ) });
}
function DrawLayerNames({
  layers = [],
  chartSize = {},
  orientation = "vertical",
  layerNameDuration = 400,
  layerNamesRef
}) {
  reactExports.useEffect(() => {
    if (!(layerNamesRef == null ? void 0 : layerNamesRef.current) || !layers.length) {
      return;
    }
    const svg = select(layerNamesRef.current);
    const layerPaddingVerticalMode = 20;
    const layerNamePosition = orientation === "vertical" ? (chartSize.sidebarWidth || 0) + layerPaddingVerticalMode : 100;
    const transformValue = orientation === "vertical" ? (
      // In vertical mode, layer names are positioned along the X-axis at sidebarWidth
      `translateX(${layerNamePosition}px)`
    ) : (
      // In horizontal mode, layer names are positioned at a fixed Y = 100px
      `translateY(${layerNamePosition}px)`
    );
    svg.transition("layer-names-sidebar-width").duration(layerNameDuration).style("transform", transformValue);
    const layerNameElement = svg.selectAll(".pipeline-layer-name").data(layers, (d2) => d2.id);
    const enterLayerNames = layerNameElement.enter().append("li").attr("class", "pipeline-layer-name").attr("data-id", (d2) => `layer-label--${d2.name}`);
    enterLayerNames.style("opacity", 0).transition("enter-layer-names").duration(layerNameDuration).style("opacity", 0.55);
    layerNameElement.exit().style("opacity", 0.55).transition("exit-layer-names").duration(layerNameDuration).style("opacity", 0).remove();
    const allNames = layerNameElement.merge(enterLayerNames);
    allNames.text((d2) => d2.name).style("opacity", 0.55);
  }, [layers, chartSize, orientation, layerNameDuration, layerNamesRef]);
  return null;
}
function DrawLayerNamesGroup({
  layers,
  chartSize,
  orientation,
  displayGlobalNavigation,
  displaySidebar,
  layerNamesRef
}) {
  if (!layers.length) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ul",
    {
      className: classnames("pipeline-flowchart__layer-names", {
        "pipeline-flowchart__layer-names--visible": layers.length,
        "pipeline-flowchart__layer-names--no-global-toolbar": !displayGlobalNavigation,
        "pipeline-flowchart__layer-names--no-sidebar": !displaySidebar
      }),
      ref: layerNamesRef,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DrawLayerNames,
        {
          layers,
          chartSize,
          orientation,
          layerNamesRef
        }
      )
    }
  );
}
function createNodeStateMap(nodes, values2) {
  const valueSet = new Set(values2);
  return nodes.reduce((acc, { id: id2 }) => {
    acc[id2] = valueSet.has(id2);
    return acc;
  }, {});
}
const processNodeStyles = (nodeStyles, currentTheme) => {
  const processedStyles = {};
  Object.keys(nodeStyles).forEach((key) => {
    if (key !== "themes") {
      processedStyles[key] = nodeStyles[key];
    }
  });
  if (nodeStyles.themes && nodeStyles.themes[currentTheme]) {
    Object.assign(processedStyles, nodeStyles.themes[currentTheme]);
  }
  return Object.keys(processedStyles).length > 0 ? processedStyles : null;
};
const feedbacks = {
  slicingPipeline: {
    formTitle: [
      "How satisfied are you with",
      /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}, "1"),
      "pipeline slicing?"
    ],
    buttonTittle: "Feedback for pipeline slicing",
    usageContext: "slicing-pipeline"
  }
};
let FlowChart$1 = class FlowChart extends reactExports.Component {
  constructor(props) {
    super(props);
    /**
     * Handle window resize
     */
    __publicField(this, "handleWindowResize", () => {
      this.updateChartSize();
    });
    /**
     * Add viewBox on window print so that the SVG can be scaled to fit
     */
    __publicField(this, "handleBeforePrint", () => {
      const graphSize = this.props.graphSize;
      const width2 = graphSize.width + graphSize.marginx * 2;
      const height2 = graphSize.height + graphSize.marginy * 2;
      select(this.svgRef.current).attr("viewBox", `0 0 ${width2} ${height2}`);
    });
    /**
     * Remove viewBox once printing is done
     */
    __publicField(this, "handleAfterPrint", () => {
      select(this.svgRef.current).attr("viewBox", null);
    });
    /**
     * Returns parameter count when there are more
     * than one parameters and parameter name if there's a single parameter
     * @param {Array} parameterNames
     * @returns {String}
     */
    __publicField(this, "getHoveredParameterLabel", (parameterNames) => parameterNames.length > 1 ? `Parameters:${parameterNames.length}` : parameterNames[0]);
    /**
     * Enable a node's focus state and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeClick", (event, node2) => {
      const { type, id: id2 } = node2;
      const { onClickToExpandModularPipeline } = this.props;
      if (type === "modularPipeline") {
        onClickToExpandModularPipeline(id2);
      } else {
        this.handleSingleNodeClick(node2);
        if (event.shiftKey && !this.props.isSlicingPipelineApplied) {
          this.handleMultipleNodesClick(node2);
        }
      }
      event.stopPropagation();
    });
    __publicField(this, "resetSlicedPipeline", () => {
      this.props.onResetSlicePipeline();
      this.updateSlicedPipelineState(null, null, []);
      this.props.toSelectedPipeline();
    });
    __publicField(this, "handleSingleNodeClick", (node2) => {
      const { id: id2 } = node2;
      const {
        displayMetadataPanel,
        onLoadNodeData,
        onToggleNodeClicked,
        toSelectedNode
      } = this.props;
      displayMetadataPanel ? onLoadNodeData(id2) : onToggleNodeClicked(id2);
      toSelectedNode(node2);
      const { from: from2, to, range: range2 } = this.state.slicedPipelineState;
      this.updateSlicedPipelineState(id2, to, range2);
      if (!this.props.isSlicingPipelineApplied) {
        this.setState({ showSlicingNotification: true });
      }
      if (from2 && to && !this.props.isSlicingPipelineApplied) {
        this.props.onResetSlicePipeline();
        this.updateSlicedPipelineState(id2, null, []);
        this.setState({ showSlicingNotification: true });
      }
    });
    /**
     * Determines the correct order of nodes based on their positions.
     * @param {string} fromNodeId - 'From' node ID.
     * @param {string} toNodeId - 'To' node ID.
     * @returns {Object} - Object containing updatedFromNodeId and updatedToNodeId.
     */
    __publicField(this, "determineNodesOrder", (fromNodeId, toNodeId) => {
      const fromNodeElement = document.querySelector(`[data-id="${fromNodeId}"]`);
      const toNodeElement = document.querySelector(`[data-id="${toNodeId}"]`);
      if (!fromNodeElement || !toNodeElement) {
        return {
          updatedFromNodeId: null,
          updatedToNodeId: null
        };
      }
      const fromNodeRect = fromNodeElement.getBoundingClientRect();
      const toNodeRect = toNodeElement.getBoundingClientRect();
      return fromNodeRect.y < toNodeRect.y ? { updatedFromNodeId: fromNodeId, updatedToNodeId: toNodeId } : { updatedFromNodeId: toNodeId, updatedToNodeId: fromNodeId };
    });
    __publicField(this, "handleMultipleNodesClick", (node2) => {
      this.props.onLoadNodeData(null);
      const { from: fromNodeIdState, range: range2 } = this.state.slicedPipelineState;
      const fromNodeId = fromNodeIdState || node2.id;
      const toNodeId = node2.id;
      this.updateSlicedPipelineState(fromNodeId, toNodeId, range2);
      const { updatedFromNodeId, updatedToNodeId } = this.determineNodesOrder(
        fromNodeId,
        toNodeId
      );
      if (updatedFromNodeId && updatedToNodeId) {
        this.props.onSlicePipeline(updatedFromNodeId, updatedToNodeId);
      } else {
        this.props.onSlicePipeline(fromNodeId, toNodeId);
      }
      this.props.onApplySlice(false);
      this.setState({ showSlicingNotification: false });
      getHeap().track(getDataTestAttribute("flowchart", "multiple-nodes-click"), {
        fromNodeId,
        toNodeId
      });
    });
    /**
     * Remove a node's focus state and dim linked nodes
     */
    __publicField(this, "handleChartClick", (event) => {
      if (this.props.clickedNode) {
        this.props.onLoadNodeData(null);
        this.props.toSelectedPipeline();
      }
      const isSliceButtonClicked = this.slicedPipelineActionBarRef.current && this.slicedPipelineActionBarRef.current.contains(event.target);
      if (!isSliceButtonClicked && !this.props.isSlicingPipelineApplied) {
        this.resetSlicedPipeline();
        this.setState({ showSlicingNotification: false });
      }
    });
    /**
     * Enable a node's active state, show tooltip, and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeMouseOver", (event, node2) => {
      if (node2.type === "modularPipeline") {
        this.props.onToggleModularPipelineActive(node2.id, true);
      } else {
        this.props.onToggleNodeHovered(node2.id);
      }
      node2 && this.showTooltip(event, node2.fullName);
    });
    /**
     * Enable a layer's active state when hovering it, update labelName's active className accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleLayerMouseOver", (event, node2) => {
      if (!node2) {
        return;
      }
      const layerName = document.querySelector(
        `[data-id="layer-label--${node2.name}"]`
      );
      if (layerName) {
        layerName.classList.add("pipeline-layer-name--active");
      }
    });
    /**
     * Remove the current labelName's active className when not hovering, and update layer's active state accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleLayerMouseOut", (event, node2) => {
      if (!node2) {
        return;
      }
      const layerName = document.querySelector(
        `[data-id="layer-label--${node2.name}"]`
      );
      if (layerName) {
        layerName.classList.remove("pipeline-layer-name--active");
      }
      this.setState({
        activeLayer: void 0
      });
    });
    /**
     * Shows tooltip when the parameter indicator is hovered on
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleParamsIndicatorMouseOver", (event, node2) => {
      const parameterNames = this.props.nodesWithInputParams[node2.id];
      if (parameterNames) {
        const label = this.getHoveredParameterLabel(parameterNames);
        this.showTooltip(event, label);
      }
      event.stopPropagation();
    });
    /**
     * Remove a node's active state, hide tooltip, and dim linked nodes
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeMouseOut", (event, node2) => {
      if (node2.type === "modularPipeline") {
        this.props.onToggleModularPipelineActive(node2.id, false);
      } else {
        this.props.onToggleNodeHovered(null);
      }
      this.hideTooltip();
    });
    /**
     * Handle keydown event when a node is focused
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeKeyDown", (event, node2) => {
      const ENTER = 13;
      const ESCAPE = 27;
      if (event.keyCode === ENTER) {
        this.handleNodeClick(event, node2);
      }
      if (event.keyCode === ESCAPE) {
        this.handleChartClick(event);
        this.handleNodeMouseOut();
      }
    });
    /**
     * Create node style overrides map for theme-based styling
     */
    __publicField(this, "createNodeStyleOverrides", (nodes, theme) => {
      const nodeStyleOverrides = {};
      nodes.forEach((node2) => {
        if (node2.extras && node2.extras.styles && Object.keys(node2.extras.styles).length > 0) {
          const processedStyles = processNodeStyles(node2.extras.styles, theme);
          if (processedStyles) {
            nodeStyleOverrides[node2.id] = processedStyles;
          }
        }
      });
      return nodeStyleOverrides;
    });
    /**
     * Get memoized node style overrides map for theme-based styling
     */
    __publicField(this, "getMemoizedNodeStyleOverrides", (nodes, theme) => {
      if (this.prevNodesForStyles !== nodes || this.prevThemeForStyles !== theme || this.nodeStyleOverridesCache === null) {
        this.nodeStyleOverridesCache = this.createNodeStyleOverrides(
          nodes,
          theme
        );
        this.prevNodesForStyles = nodes;
        this.prevThemeForStyles = theme;
        return { ...this.nodeStyleOverridesCache };
      }
      return this.nodeStyleOverridesCache;
    });
    this.state = {
      tooltip: { visible: false },
      activeLayer: void 0,
      slicedPipelineState: {
        from: null,
        to: null,
        range: []
      },
      showSlicingNotification: false,
      resetSlicingPipelineBtnClicked: false,
      showFeedbackForm: false
    };
    this.onViewChange = this.onViewChange.bind(this);
    this.onViewChangeEnd = this.onViewChangeEnd.bind(this);
    this.containerRef = React.createRef();
    this.svgRef = React.createRef();
    this.wrapperRef = React.createRef();
    this.slicedPipelineActionBarRef = React.createRef();
    this.layersRef = React.createRef();
    this.layerNamesRef = React.createRef();
    this.nodeStyleOverridesCache = null;
    this.prevNodesForStyles = null;
    this.prevThemeForStyles = null;
  }
  componentDidMount() {
    this.updateChartSize();
    this.view = viewing({
      container: this.svgRef,
      wrapper: this.wrapperRef,
      onViewChanged: this.onViewChange,
      onViewEnd: this.onViewChangeEnd
    });
    this.updateViewExtents();
    this.addGlobalEventListeners();
    this.update();
    if (this.props.tooltip) {
      this.showTooltip(null, null, this.props.tooltip);
    } else {
      this.hideTooltip();
    }
  }
  /**
   *  Updates the state of the sliced pipeline with new values for 'from', 'to', and 'range'.
   */
  updateSlicedPipelineState(from2, to, range2) {
    this.setState({
      slicedPipelineState: {
        ...this.state.slicedPipelineState,
        from: from2,
        to,
        range: range2
      }
    });
  }
  componentWillUnmount() {
    this.removeGlobalEventListeners();
  }
  componentDidUpdate(prevProps) {
    this.update(prevProps);
    const { from: from2, to } = this.state.slicedPipelineState;
    const isSlicedPipelineChanged = this.props.slicedPipeline !== prevProps.slicedPipeline;
    const isSlicedPipelineEmpty = this.props.slicedPipeline.length === 0;
    const isSlicedPipelineStateDefined = from2 !== null && to !== null;
    if (isSlicedPipelineChanged) {
      if (isSlicedPipelineEmpty && isSlicedPipelineStateDefined) {
        this.updateSlicedPipelineState(null, null, []);
      } else {
        this.updateSlicedPipelineState(from2, to, this.props.slicedPipeline);
      }
    }
    if (this.props.clickedNode !== prevProps.clickedNode && !this.props.clickedNode) {
      this.setState({ showSlicingNotification: false });
    }
  }
  /**
   * Updates drawing and zoom if props have changed
   */
  update(prevProps = {}) {
    const { chartZoom } = this.props;
    const changed = (...names) => this.changed(names, prevProps, this.props);
    const preventZoom = this.props.visibleMetaSidebar;
    if (changed("visibleSidebar", "visibleCode", "visibleMetaSidebar")) {
      this.updateChartSize();
    }
    if (changed("edges", "nodes", "layers", "chartSize", "clickedNode")) {
      const metaSidebarViewChanged = prevProps.visibleMetaSidebar !== this.props.visibleMetaSidebar;
      const codeViewChangedWithoutMetaSidebar = prevProps.visibleCode !== this.props.visibleCode && !this.props.visibleMetaSidebar;
      const clickedNodeChangedWithoutReFocus = prevProps.clickedNode !== this.props.clickedNode && !this.props.nodeReFocus;
      if (metaSidebarViewChanged || codeViewChangedWithoutMetaSidebar || clickedNodeChangedWithoutReFocus) {
        return;
      }
      this.resetView(preventZoom);
    } else {
      this.onChartZoomChanged(chartZoom);
    }
  }
  /**
   * Returns true if any of the given props are different between given objects.
   * Only shallow changes are detected.
   */
  changed(props, objectA, objectB) {
    return objectA && objectB && props.some((prop) => objectA[prop] !== objectB[prop]);
  }
  /**
   * Update the chart size in state from chart container bounds.
   * This is emulated in tests with a constant fixed size.
   */
  updateChartSize() {
    if (typeof jest !== "undefined") {
      this.props.onUpdateChartSize(chartSizeTestFallback$1);
    } else {
      this.props.onUpdateChartSize(
        this.containerRef.current.getBoundingClientRect()
      );
    }
  }
  /**
   * Add window event listeners on mount
   */
  addGlobalEventListeners() {
    if (window.ResizeObserver) {
      this.resizeObserver = this.resizeObserver || new window.ResizeObserver(this.handleWindowResize);
      this.resizeObserver.observe(this.containerRef.current);
    } else {
      window.addEventListener("resize", this.handleWindowResize);
    }
    window.addEventListener("beforeprint", this.handleBeforePrint);
    window.addEventListener("afterprint", this.handleAfterPrint);
  }
  /**
   * Remove window event listeners on unmount
   */
  removeGlobalEventListeners() {
    if (window.ResizeObserver) {
      this.resizeObserver.unobserve(this.containerRef.current);
    } else {
      window.removeEventListener("resize", this.handleWindowResize);
    }
    window.removeEventListener("beforeprint", this.handleBeforePrint);
    window.removeEventListener("afterprint", this.handleAfterPrint);
  }
  /**
   * On every frame of every view transform change (from reset, pan, zoom etc.)
   * @param {Object} transform The current view transform
   */
  onViewChange(transform2) {
    var _a;
    const { k: scale, x: x2, y: y2 } = transform2;
    select(this.wrapperRef.current).classed(
      "pipeline-flowchart__zoom-wrapper--animating",
      true
    );
    if ((_a = this.layerNamesRef) == null ? void 0 : _a.current) {
      const layerNames = this.layerNamesRef.current.querySelectorAll(
        ".pipeline-layer-name"
      );
      this.props.layers.forEach((layer, i) => {
        const el = layerNames[i];
        if (!el) {
          return;
        }
        if (this.props.orientation === "vertical") {
          const updateY = y2 + (layer.y + (layer.height || 0) / 2) * scale;
          el.style.transform = `translateY(${updateY}px)`;
        } else {
          const updateX = x2 + (layer.x + (layer.width || 0) / 2) * scale;
          el.style.transform = `translateX(${updateX}px) translateX(-50%)`;
        }
      });
    }
    this.updateViewExtents(transform2);
    const extents = getViewExtents(this.view);
    this.props.onUpdateZoom({
      scale,
      x: x2,
      y: y2,
      applied: true,
      transition: false,
      relative: false,
      minScale: extents.scale.minK,
      maxScale: extents.scale.maxK
    });
  }
  /**
   * Called when the view changes have ended (i.e. after transition ends)
   */
  onViewChangeEnd() {
    select(this.wrapperRef.current).classed(
      "pipeline-flowchart__zoom-wrapper--animating",
      false
    );
  }
  /**
   * Updates view extents based on the current view transform.
   * Offsets the extents considering any open sidebars.
   * Allows additional margin for user panning within limits.
   * Zoom scale is limited to a practical range for usability.
   * @param {?Object} transform Current transform override
   */
  updateViewExtents(transform2) {
    const { k: scale } = transform2 || getViewTransform(this.view);
    const {
      sidebarWidth: sidebarWidth2 = 0,
      metaSidebarWidth: metaSidebarWidth2 = 0,
      codeSidebarWidth: codeSidebarWidth2 = 0,
      width: chartWidth = 0,
      height: chartHeight = 0
    } = this.props.chartSize;
    const { width: graphWidth = 0, height: graphHeight = 0 } = this.props.graphSize;
    const leftSidebarOffset = sidebarWidth2 / scale;
    const rightSidebarOffset = (metaSidebarWidth2 + codeSidebarWidth2) / scale;
    const margin2 = MARGIN;
    const minScale = Math.min(
      chartWidth / (graphWidth || 1),
      chartHeight / (graphHeight || 1)
    );
    setViewExtents(this.view, {
      translate: {
        minX: -leftSidebarOffset - margin2,
        maxX: graphWidth + margin2 + rightSidebarOffset,
        minY: -margin2,
        maxY: graphHeight + margin2
      },
      scale: {
        minK: MIN_SCALE * minScale,
        maxK: MAX_SCALE
      }
    });
  }
  /**
   * Applies the given zoom state as necessary
   * @param {Object} chartZoom The new zoom state
   */
  onChartZoomChanged(chartZoom) {
    if (chartZoom.applied) {
      return;
    }
    if (chartZoom.reset === true) {
      this.resetView(true);
      return;
    }
    setViewTransform(
      this.view,
      { x: chartZoom.x, y: chartZoom.y, k: chartZoom.scale },
      chartZoom.transition ? DURATION * 0.3 : 0,
      chartZoom.relative
    );
  }
  /**
   * Zoom and scale to fit graph and any selected node in view
   */
  resetView(preventZoom) {
    const { chartSize, graphSize, clickedNode, nodes, orientation } = this.props;
    const { width: chartWidth, height: chartHeight } = chartSize;
    const { width: graphWidth, height: graphHeight } = graphSize;
    if (!chartWidth || !graphWidth) {
      return;
    }
    const offset = { x: chartSize.sidebarWidth, y: 0 };
    const focus = clickedNode ? nodes.find((node2) => node2.id === clickedNode) : null;
    const transform2 = viewTransformToFit({
      offset,
      focus,
      viewWidth: chartWidth,
      viewHeight: chartHeight,
      objectWidth: graphWidth,
      objectHeight: graphHeight,
      sidebarWidth: chartSize.sidebarWidth,
      minScaleX: 0.05,
      minScaleFocus: this.props.visibleMetaSidebar ? this.props.chartZoom.scale : 0.1,
      focusOffset: 0,
      preventZoom
    });
    const isFirstTransform = isOrigin(getViewTransform(this.view));
    setViewTransformExact(
      this.view,
      transform2,
      isFirstTransform ? 0 : DURATION
    );
  }
  /**
   * Show, fill and and position the tooltip
   * @param {Object} event Event object
   * @param {Object} text Text to show on the tooltip
   * @param {?Object} options Options for the tooltip if required
   */
  showTooltip(event, text, options = {}) {
    this.setState({
      tooltip: {
        targetRect: event && event.target.getBoundingClientRect(),
        text,
        visible: true,
        ...options
      }
    });
  }
  /**
   * Hide the tooltip
   */
  hideTooltip() {
    if (this.state.tooltip.visible) {
      this.setState({
        tooltip: {
          ...this.state.tooltip,
          visible: false
        }
      });
    }
  }
  /**
   * Render React elements
   */
  render() {
    const {
      chartSize,
      displayGlobalNavigation,
      displaySidebar,
      isSlicingPipelineApplied,
      layers,
      onApplySlice,
      runCommand,
      visibleGraph,
      slicedPipeline,
      visibleSidebar,
      clickedNode,
      modularPipelineIds,
      visibleSlicing,
      nodes,
      nodeActive,
      nodeSelected,
      nodeTypeDisabled,
      hoveredParameters,
      hoveredFocusMode,
      nodesWithInputParams,
      inputOutputDataNodes,
      focusMode,
      orientation,
      edges,
      linkedNodes,
      inputOutputDataEdges,
      theme
    } = this.props;
    const { outerWidth = 0, outerHeight = 0 } = chartSize;
    const {
      showSlicingNotification,
      resetSlicingPipelineBtnClicked,
      showFeedbackForm,
      slicedPipelineState
    } = this.state;
    const {
      from: slicedPipelineFromId,
      to: slicedPipelineToId,
      range: range2
    } = slicedPipelineState;
    const slicedPipelineFromTo = slicedPipelineFromId && slicedPipelineToId && createNodeStateMap(nodes, [slicedPipelineFromId, slicedPipelineToId]);
    const slicedPipelineRange = createNodeStateMap(nodes, range2);
    const isInputOutputNode = (nodeID) => focusMode !== null && inputOutputDataNodes[nodeID];
    const numberOfNodesInSlicedPipeline = slicedPipeline.filter(
      (id2) => !modularPipelineIds.includes(id2)
    ).length;
    const isFirstTimeFeedbackAfterResetSlicing = resetSlicingPipelineBtnClicked && loadLocalStorage(localStorageFeedbackSeen)["slicing-pipeline"] === void 0;
    const seenSlicingFeedbackBefore = loadLocalStorage(localStorageFeedbackSeen)["slicing-pipeline"] === false;
    const nodeStyleOverrides = this.getMemoizedNodeStyleOverrides(nodes, theme);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "pipeline-flowchart kedro",
        ref: this.containerRef,
        onClick: this.handleChartClick,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            GraphSVG,
            {
              width: outerWidth,
              height: outerHeight,
              svgRef: this.svgRef,
              wrapperRef: this.wrapperRef,
              visibleGraph,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DrawLayersGroup,
                  {
                    layers,
                    layersRef: this.layersRef,
                    onLayerMouseOver: this.handleLayerMouseOver,
                    onLayerMouseOut: this.handleLayerMouseOut
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DrawEdges,
                  {
                    edges,
                    clickedNode,
                    linkedNodes,
                    focusMode,
                    inputOutputDataEdges
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DrawNodes,
                  {
                    nodes,
                    nodeActive,
                    nodeSelected,
                    nodeTypeDisabled,
                    hoveredParameters,
                    hoveredFocusMode,
                    nodesWithInputParams,
                    nodeStyleOverrides,
                    inputOutputDataNodes,
                    focusMode,
                    orientation,
                    onNodeClick: this.handleNodeClick,
                    onNodeMouseOver: this.handleNodeMouseOver,
                    onNodeMouseOut: this.handleNodeMouseOut,
                    onNodeFocus: this.handleNodeMouseOver,
                    onNodeBlur: this.handleNodeMouseOut,
                    onNodeKeyDown: this.handleNodeKeyDown,
                    onParamsIndicatorMouseOver: this.handleParamsIndicatorMouseOver,
                    isSlicingPipelineApplied,
                    slicedPipelineFromTo,
                    slicedPipelineRange,
                    isInputOutputNode,
                    clickedNode,
                    linkedNodes
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DrawLayerNamesGroup,
            {
              layers,
              displayGlobalNavigation,
              displaySidebar,
              chartSize,
              orientation,
              layerNamesRef: this.layerNamesRef
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FeedbackButton,
            {
              onClick: () => this.setState({ showFeedbackForm: true }),
              title: feedbacks.slicingPipeline.buttonTittle,
              visible: isSlicingPipelineApplied && seenSlicingFeedbackBefore && !showFeedbackForm
            }
          ),
          (isFirstTimeFeedbackAfterResetSlicing || showFeedbackForm) && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FeedbackForm,
            {
              hideForm: () => this.setState({ showFeedbackForm: false }),
              title: feedbacks.slicingPipeline.formTitle,
              usageContext: feedbacks.slicingPipeline.usageContext
            }
          ),
          showSlicingNotification && visibleSlicing && /* @__PURE__ */ jsxRuntimeExports.jsx(
            SlicedPipelineNotification,
            {
              notification: "Hold Shift + Click on another node to slice pipeline",
              visibleSidebar
            }
          ),
          numberOfNodesInSlicedPipeline > 0 && runCommand.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: this.slicedPipelineActionBarRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            SlicedPipelineActionBar,
            {
              chartSize,
              displayMetadataPanel: Boolean(clickedNode),
              isSlicingPipelineApplied,
              onApplySlicingPipeline: () => onApplySlice(true),
              onResetSlicingPipeline: () => {
                this.resetSlicedPipeline();
                this.setState({ resetSlicingPipelineBtnClicked: true });
              },
              ref: this.slicedPipelineActionBarRef,
              runCommand,
              slicedPipelineLength: numberOfNodesInSlicedPipeline,
              visibleSidebar
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Tooltip,
            {
              chartSize,
              ...this.state.tooltip,
              style: { fontSize: "1.5em" }
            }
          )
        ]
      }
    );
  }
};
const chartSizeTestFallback$1 = {
  left: 0,
  top: 0,
  right: 1280,
  bottom: 1024,
  width: 1280,
  height: 1024
};
const emptyEdges$1 = [];
const emptyNodes$2 = [];
const emptyGraphSize$2 = {};
const mapStateToProps$k = (state, ownProps) => ({
  clickedNode: state.node.clicked,
  chartSize: getChartSize(state),
  chartZoom: getChartZoom(state),
  displayGlobalNavigation: state.display.globalNavigation,
  displaySidebar: state.display.sidebar,
  displayMetadataPanel: state.display.metadataPanel,
  edges: state.graph.edges || emptyEdges$1,
  focusMode: state.visible.modularPipelineFocusMode,
  graphSize: state.graph.size || emptyGraphSize$2,
  hoveredParameters: state.hoveredParameters,
  hoveredFocusMode: state.hoveredFocusMode,
  layers: getLayers(state),
  linkedNodes: getLinkedNodes(state),
  nodes: state.graph.nodes || emptyNodes$2,
  nodeTypeDisabled: state.nodeType.disabled,
  nodeActive: getNodeActive(state),
  nodeSelected: getNodeSelected(state),
  nodesWithInputParams: getNodesWithInputParams(state),
  modularPipelineIds: state.modularPipeline.ids,
  orientation: state.orientation,
  inputOutputDataNodes: getInputOutputNodesForFocusedModularPipeline(state),
  inputOutputDataEdges: getInputOutputDataEdges(state),
  visibleGraph: state.visible.graph,
  visibleSidebar: state.visible.sidebar,
  visibleCode: state.visible.code,
  visibleMetaSidebar: getVisibleMetaSidebar(state),
  slicedPipeline: getSlicedPipeline(state),
  isSlicingPipelineApplied: state.slice.apply,
  visibleSlicing: state.visible.slicing,
  nodeReFocus: state.behaviour.reFocus,
  runCommand: getRunCommand(state),
  theme: state.theme,
  ...ownProps
});
const mapDispatchToProps$d = (dispatch2, ownProps) => ({
  onClickToExpandModularPipeline: (modularPipelineId) => {
    dispatch2(toggleSingleModularPipelineExpanded(modularPipelineId));
  },
  onLoadNodeData: (nodeClicked) => {
    dispatch2(loadNodeData(nodeClicked));
  },
  onToggleNodeClicked: (id2) => {
    dispatch2(toggleNodeClicked(id2));
  },
  onToggleModularPipelineActive: (modularPipelineIDs, active) => {
    dispatch2(toggleModularPipelineActive(modularPipelineIDs, active));
  },
  onToggleNodeHovered: (nodeHovered) => {
    dispatch2(toggleNodeHovered(nodeHovered));
  },
  onUpdateChartSize: (chartSize) => {
    dispatch2(updateChartSize(chartSize));
  },
  onUpdateZoom: (transform2) => {
    dispatch2(updateZoom(transform2));
  },
  onApplySlice: (apply) => {
    dispatch2(applySlicePipeline(apply));
  },
  onSlicePipeline: (fromID, toID) => {
    dispatch2(setSlicePipeline(fromID, toID));
  },
  onResetSlicePipeline: () => {
    dispatch2(resetSlicePipeline());
  },
  ...ownProps
});
const FlowChart$2 = connect(mapStateToProps$k, mapDispatchToProps$d)(FlowChart$1);
const getCurrentActivePipeline = () => {
  var _a, _b;
  const localStorage2 = window.localStorage.getItem(localStorageName);
  return (_b = (_a = JSON.parse(localStorage2)) == null ? void 0 : _a.pipeline) == null ? void 0 : _b.active;
};
const retainDefaultQueryParams = (searchParams) => {
  const searchParamsEntries = [...searchParams.keys()];
  for (const key of searchParamsEntries) {
    if (!defaultQueryParams.includes(key)) {
      searchParams.delete(key);
    }
  }
};
const useGeneratePathname = () => {
  const history = useHistory();
  const updateURLWithSearchParams = reactExports.useCallback(
    (updateFunction) => {
      const searchParams = new URLSearchParams(history.location.search);
      updateFunction(searchParams);
      const url = decodeURIComponent(
        history.location.pathname + "?" + searchParams.toString()
      );
      history.push(url);
    },
    [history]
  );
  const toFlowchartPage = reactExports.useCallback(() => {
    updateURLWithSearchParams(retainDefaultQueryParams);
  }, [updateURLWithSearchParams]);
  const toSelectedPipeline = reactExports.useCallback(
    (pipelineValue) => {
      updateURLWithSearchParams((searchParams) => {
        retainDefaultQueryParams(searchParams);
        const activePipeline = pipelineValue ? pipelineValue : getCurrentActivePipeline();
        searchParams.set(params.pipeline, activePipeline);
      });
    },
    [updateURLWithSearchParams]
  );
  const toSelectedNode = reactExports.useCallback(
    (item) => {
      updateURLWithSearchParams((searchParams) => {
        searchParams.set(params.selected, item.id);
      });
    },
    [updateURLWithSearchParams]
  );
  const toFocusedModularPipeline = reactExports.useCallback(
    (item) => {
      updateURLWithSearchParams((searchParams) => {
        searchParams.set(params.focused, item.id);
      });
    },
    [updateURLWithSearchParams]
  );
  const toSetQueryParam = reactExports.useCallback(
    (param, value) => {
      updateURLWithSearchParams((searchParams) => {
        if (Array.isArray(value) && value.length === 0) {
          searchParams.delete(param);
        } else {
          searchParams.set(param, value);
        }
      });
    },
    [updateURLWithSearchParams]
  );
  const toUpdateUrlParamsOnResetFilter = reactExports.useCallback(() => {
    updateURLWithSearchParams((searchParams) => {
      searchParams.delete(params.tags);
      searchParams.set(
        params.types,
        `${NODE_TYPES.task.name},${NODE_TYPES.data.name}`
      );
    });
  }, [updateURLWithSearchParams]);
  const toUpdateUrlParamsOnFilter = (item, paramName, existingValues) => {
    const mapItemId = mapNodeType(item.id);
    if (item.checked) {
      existingValues.delete(mapItemId);
    } else {
      existingValues.add(mapItemId);
    }
    toSetQueryParam(paramName, Array.from(existingValues));
  };
  return {
    toSelectedPipeline,
    toFlowchartPage,
    toSelectedNode,
    toFocusedModularPipeline,
    toSetQueryParam,
    toUpdateUrlParamsOnResetFilter,
    toUpdateUrlParamsOnFilter
  };
};
const withHooksHOC = (Component) => {
  return (props) => {
    const { toSelectedPipeline, toSelectedNode, toFocusedModularPipeline } = useGeneratePathname();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Component,
      {
        toSelectedPipeline,
        toSelectedNode,
        toFocusedModularPipeline,
        ...props
      }
    );
  };
};
const FlowChart2 = withHooksHOC(FlowChart$2);
const PipelineWarningContent = ({
  isVisible,
  title,
  subtitle,
  buttons = [],
  sidebarVisible
}) => {
  if (!isVisible) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("kedro", "pipeline-warning", {
        "pipeline-warning--sidebar-visible": sidebarVisible
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "pipeline-warning__title", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "pipeline-warning__subtitle", children: subtitle }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-warning__button-wrapper", children: buttons.map((buttonProps, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { ...buttonProps }, index)) })
      ]
    }
  );
};
const PipelineWarning = ({
  errorMessage,
  invalidUrl,
  nodes,
  onDisable,
  onHide,
  sidebarVisible,
  visible,
  onResetClick
}) => {
  const [componentLoaded, setComponentLoaded] = reactExports.useState(false);
  const isEmptyPipeline = nodes.length === 0;
  const { toFlowchartPage } = useGeneratePathname();
  reactExports.useEffect(() => {
    const timer2 = setTimeout(() => {
      setComponentLoaded(true);
    }, 1500);
    return () => clearTimeout(timer2);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PipelineWarningContent,
      {
        isVisible: visible,
        title: "Whoa, thats a chonky pipeline!",
        subtitle: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          "This graph contains ",
          /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: nodes.length }),
          " elements, which will take a while to render. You can use the sidebar controls to select a smaller graph."
        ] }),
        buttons: [
          { onClick: onHide, children: "Render it anyway" },
          {
            mode: "secondary",
            onClick: onDisable,
            size: "small",
            children: "Don't show this again"
          }
        ],
        sidebarVisible
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PipelineWarningContent,
      {
        isVisible: isEmptyPipeline && componentLoaded,
        title: "Oops, there's nothing to see here",
        subtitle: "This selection has nothing. Please unselect your filters or modular pipeline selection to see pipeline elements.",
        sidebarVisible
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PipelineWarningContent,
      {
        isVisible: invalidUrl && componentLoaded,
        title: "Oops, this URL isn't valid",
        subtitle: `${errorMessage}. Perhaps you've deleted the entity  or it may be a typo `,
        buttons: [
          {
            onClick: () => {
              toFlowchartPage();
              onResetClick();
            },
            children: "Reset view"
          }
        ],
        sidebarVisible
      }
    )
  ] });
};
const mapStateToProps$j = (state) => ({
  nodes: getVisibleNodes(state),
  sidebarVisible: state.visible.sidebar,
  theme: state.theme,
  visible: getTriggerLargeGraphWarning(state)
});
const mapDispatchToProps$c = (dispatch2) => ({
  onDisable: () => {
    dispatch2(changeFlag("sizewarning", false));
  },
  onHide: () => {
    dispatch2(toggleIgnoreLargeWarning(true));
  }
});
const PipelineWarning$1 = connect(mapStateToProps$j, mapDispatchToProps$c)(PipelineWarning);
const d = "M 50 50 100 100 50 150 0 100 Z";
const LoadingIcon = ({ className, visible }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: classnames(className, "pipeline-loading-icon", {
      "pipeline-loading-icon--visible": visible
    }),
    viewBox: "-10 45 120 100",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d })
    ]
  }
);
const PipelineLoading = ({ loading, sidebarVisible }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: classnames("pipeline-wrapper__loading", {
      "pipeline-wrapper__loading--sidebar-visible": sidebarVisible
    }),
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, { visible: loading })
  }
);
const InfoBannerIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "path",
  {
    d: "M11.25 16.75H12.75V11H11.25V16.75ZM12 9.28848C12.2288 9.28848 12.4207 9.21108 12.5755 9.05628C12.7303 8.90148 12.8077 8.70966 12.8077 8.48081C12.8077 8.25197 12.7303 8.06015 12.5755 7.90533C12.4207 7.75053 12.2288 7.67313 12 7.67313C11.7711 7.67313 11.5793 7.75053 11.4245 7.90533C11.2697 8.06015 11.1923 8.25197 11.1923 8.48081C11.1923 8.70966 11.2697 8.90148 11.4245 9.05628C11.5793 9.21108 11.7711 9.28848 12 9.28848ZM12.0016 21.5C10.6877 21.5 9.45268 21.2506 8.29655 20.752C7.1404 20.2533 6.13472 19.5766 5.2795 18.7217C4.42427 17.8669 3.74721 16.8616 3.24833 15.706C2.74944 14.5504 2.5 13.3156 2.5 12.0017C2.5 10.6877 2.74933 9.45271 3.248 8.29658C3.74667 7.14043 4.42342 6.13475 5.27825 5.27953C6.1331 4.4243 7.13834 3.74724 8.29398 3.24836C9.44959 2.74947 10.6844 2.50003 11.9983 2.50003C13.3122 2.50003 14.5473 2.74936 15.7034 3.24803C16.8596 3.7467 17.8652 4.42345 18.7205 5.27828C19.5757 6.13313 20.2527 7.13837 20.7516 8.29401C21.2505 9.44962 21.5 10.6844 21.5 11.9983C21.5 13.3123 21.2506 14.5473 20.752 15.7034C20.2533 16.8596 19.5765 17.8653 18.7217 18.7205C17.8669 19.5757 16.8616 20.2528 15.706 20.7517C14.5504 21.2505 13.3156 21.5 12.0016 21.5ZM12 20C14.2333 20 16.125 19.225 17.675 17.675C19.225 16.125 20 14.2333 20 12C20 9.76667 19.225 7.87501 17.675 6.32501C16.125 4.77501 14.2333 4.00001 12 4.00001C9.76664 4.00001 7.87498 4.77501 6.32498 6.32501C4.77498 7.87501 3.99998 9.76667 3.99998 12C3.99998 14.2333 4.77498 16.125 6.32498 17.675C7.87498 19.225 9.76664 20 12 20Z",
    fill: "black"
  }
) });
const PreviewTable = ({ data, size = "small", onClick }) => {
  var _a, _b;
  const [hoveredHeaderIndex, setHoveredHeaderIndex] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "table",
    {
      className: classnames("preview-table", {
        "preview-table__small": size === "small",
        "preview-table__large": size === "large"
      }),
      cellSpacing: 0,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { className: "preview-table__row-header", children: (_a = data.columns) == null ? void 0 : _a.map((column2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "th",
          {
            className: "preview-table__header",
            onClick,
            onMouseOut: () => setHoveredHeaderIndex(null),
            onMouseOver: () => setHoveredHeaderIndex(index),
            children: column2
          },
          column2
        )) }),
        (_b = data.data) == null ? void 0 : _b.map((row, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { className: "preview-table__row", children: row.map((content, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          "td",
          {
            className: classnames("preview-table__data", {
              "preview-table__data-hovered": i === hoveredHeaderIndex
            }),
            onClick,
            children: String(content)
          },
          i
        )) }, index))
      ] })
    }
  );
};
var main$1 = { exports: {} };
var main = main$1.exports;
var hasRequiredMain;
function requireMain() {
  if (hasRequiredMain) return main$1.exports;
  hasRequiredMain = 1;
  (function(module, exports) {
    !function(e, t) {
      module.exports = t(requireReact());
    }(main, function(e) {
      return function(e2) {
        var t = {};
        function n(a) {
          if (t[a]) return t[a].exports;
          var r2 = t[a] = { i: a, l: false, exports: {} };
          return e2[a].call(r2.exports, r2, r2.exports, n), r2.l = true, r2.exports;
        }
        return n.m = e2, n.c = t, n.d = function(e3, t2, a) {
          n.o(e3, t2) || Object.defineProperty(e3, t2, { enumerable: true, get: a });
        }, n.r = function(e3) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
        }, n.t = function(e3, t2) {
          if (1 & t2 && (e3 = n(e3)), 8 & t2) return e3;
          if (4 & t2 && "object" == typeof e3 && e3 && e3.__esModule) return e3;
          var a = /* @__PURE__ */ Object.create(null);
          if (n.r(a), Object.defineProperty(a, "default", { enumerable: true, value: e3 }), 2 & t2 && "string" != typeof e3) for (var r2 in e3) n.d(a, r2, (function(t3) {
            return e3[t3];
          }).bind(null, r2));
          return a;
        }, n.n = function(e3) {
          var t2 = e3 && e3.__esModule ? function() {
            return e3.default;
          } : function() {
            return e3;
          };
          return n.d(t2, "a", t2), t2;
        }, n.o = function(e3, t2) {
          return Object.prototype.hasOwnProperty.call(e3, t2);
        }, n.p = "", n(n.s = 48);
      }([function(t, n) {
        t.exports = e;
      }, function(e2, t) {
        var n = e2.exports = { version: "2.6.12" };
        "number" == typeof __e && (__e = n);
      }, function(e2, t, n) {
        var a = n(26)("wks"), r2 = n(17), o = n(3).Symbol, i = "function" == typeof o;
        (e2.exports = function(e3) {
          return a[e3] || (a[e3] = i && o[e3] || (i ? o : r2)("Symbol." + e3));
        }).store = a;
      }, function(e2, t) {
        var n = e2.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = n);
      }, function(e2, t, n) {
        e2.exports = !n(8)(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e2, t) {
        var n = {}.hasOwnProperty;
        e2.exports = function(e3, t2) {
          return n.call(e3, t2);
        };
      }, function(e2, t, n) {
        var a = n(7), r2 = n(16);
        e2.exports = n(4) ? function(e3, t2, n2) {
          return a.f(e3, t2, r2(1, n2));
        } : function(e3, t2, n2) {
          return e3[t2] = n2, e3;
        };
      }, function(e2, t, n) {
        var a = n(10), r2 = n(35), o = n(23), i = Object.defineProperty;
        t.f = n(4) ? Object.defineProperty : function(e3, t2, n2) {
          if (a(e3), t2 = o(t2, true), a(n2), r2) try {
            return i(e3, t2, n2);
          } catch (e4) {
          }
          if ("get" in n2 || "set" in n2) throw TypeError("Accessors not supported!");
          return "value" in n2 && (e3[t2] = n2.value), e3;
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          try {
            return !!e3();
          } catch (e4) {
            return true;
          }
        };
      }, function(e2, t, n) {
        var a = n(40), r2 = n(22);
        e2.exports = function(e3) {
          return a(r2(e3));
        };
      }, function(e2, t, n) {
        var a = n(11);
        e2.exports = function(e3) {
          if (!a(e3)) throw TypeError(e3 + " is not an object!");
          return e3;
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          return "object" == typeof e3 ? null !== e3 : "function" == typeof e3;
        };
      }, function(e2, t) {
        e2.exports = {};
      }, function(e2, t, n) {
        var a = n(39), r2 = n(27);
        e2.exports = Object.keys || function(e3) {
          return a(e3, r2);
        };
      }, function(e2, t) {
        e2.exports = true;
      }, function(e2, t, n) {
        var a = n(3), r2 = n(1), o = n(53), i = n(6), s = n(5), c = function(e3, t2, n2) {
          var l, u, f, p = e3 & c.F, d2 = e3 & c.G, b = e3 & c.S, h = e3 & c.P, v = e3 & c.B, m = e3 & c.W, y2 = d2 ? r2 : r2[t2] || (r2[t2] = {}), g = y2.prototype, E = d2 ? a : b ? a[t2] : (a[t2] || {}).prototype;
          for (l in d2 && (n2 = t2), n2) (u = !p && E && void 0 !== E[l]) && s(y2, l) || (f = u ? E[l] : n2[l], y2[l] = d2 && "function" != typeof E[l] ? n2[l] : v && u ? o(f, a) : m && E[l] == f ? function(e4) {
            var t3 = function(t4, n3, a2) {
              if (this instanceof e4) {
                switch (arguments.length) {
                  case 0:
                    return new e4();
                  case 1:
                    return new e4(t4);
                  case 2:
                    return new e4(t4, n3);
                }
                return new e4(t4, n3, a2);
              }
              return e4.apply(this, arguments);
            };
            return t3.prototype = e4.prototype, t3;
          }(f) : h && "function" == typeof f ? o(Function.call, f) : f, h && ((y2.virtual || (y2.virtual = {}))[l] = f, e3 & c.R && g && !g[l] && i(g, l, f)));
        };
        c.F = 1, c.G = 2, c.S = 4, c.P = 8, c.B = 16, c.W = 32, c.U = 64, c.R = 128, e2.exports = c;
      }, function(e2, t) {
        e2.exports = function(e3, t2) {
          return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
        };
      }, function(e2, t) {
        var n = 0, a = Math.random();
        e2.exports = function(e3) {
          return "Symbol(".concat(void 0 === e3 ? "" : e3, ")_", (++n + a).toString(36));
        };
      }, function(e2, t, n) {
        var a = n(22);
        e2.exports = function(e3) {
          return Object(a(e3));
        };
      }, function(e2, t) {
        t.f = {}.propertyIsEnumerable;
      }, function(e2, t, n) {
        var a = n(52)(true);
        n(34)(String, "String", function(e3) {
          this._t = String(e3), this._i = 0;
        }, function() {
          var e3, t2 = this._t, n2 = this._i;
          return n2 >= t2.length ? { value: void 0, done: true } : (e3 = a(t2, n2), this._i += e3.length, { value: e3, done: false });
        });
      }, function(e2, t) {
        var n = Math.ceil, a = Math.floor;
        e2.exports = function(e3) {
          return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? a : n)(e3);
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          if (null == e3) throw TypeError("Can't call method on  " + e3);
          return e3;
        };
      }, function(e2, t, n) {
        var a = n(11);
        e2.exports = function(e3, t2) {
          if (!a(e3)) return e3;
          var n2, r2;
          if (t2 && "function" == typeof (n2 = e3.toString) && !a(r2 = n2.call(e3))) return r2;
          if ("function" == typeof (n2 = e3.valueOf) && !a(r2 = n2.call(e3))) return r2;
          if (!t2 && "function" == typeof (n2 = e3.toString) && !a(r2 = n2.call(e3))) return r2;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e2, t) {
        var n = {}.toString;
        e2.exports = function(e3) {
          return n.call(e3).slice(8, -1);
        };
      }, function(e2, t, n) {
        var a = n(26)("keys"), r2 = n(17);
        e2.exports = function(e3) {
          return a[e3] || (a[e3] = r2(e3));
        };
      }, function(e2, t, n) {
        var a = n(1), r2 = n(3), o = r2["__core-js_shared__"] || (r2["__core-js_shared__"] = {});
        (e2.exports = function(e3, t2) {
          return o[e3] || (o[e3] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: a.version, mode: n(14) ? "pure" : "global", copyright: " 2020 Denis Pushkarev (zloirock.ru)" });
      }, function(e2, t) {
        e2.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, function(e2, t, n) {
        var a = n(7).f, r2 = n(5), o = n(2)("toStringTag");
        e2.exports = function(e3, t2, n2) {
          e3 && !r2(e3 = n2 ? e3 : e3.prototype, o) && a(e3, o, { configurable: true, value: t2 });
        };
      }, function(e2, t, n) {
        n(62);
        for (var a = n(3), r2 = n(6), o = n(12), i = n(2)("toStringTag"), s = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), c = 0; c < s.length; c++) {
          var l = s[c], u = a[l], f = u && u.prototype;
          f && !f[i] && r2(f, i, l), o[l] = o.Array;
        }
      }, function(e2, t, n) {
        t.f = n(2);
      }, function(e2, t, n) {
        var a = n(3), r2 = n(1), o = n(14), i = n(30), s = n(7).f;
        e2.exports = function(e3) {
          var t2 = r2.Symbol || (r2.Symbol = o ? {} : a.Symbol || {});
          "_" == e3.charAt(0) || e3 in t2 || s(t2, e3, { value: i.f(e3) });
        };
      }, function(e2, t) {
        t.f = Object.getOwnPropertySymbols;
      }, function(e2, t) {
        e2.exports = function(e3, t2, n) {
          return Math.min(Math.max(e3, t2), n);
        };
      }, function(e2, t, n) {
        var a = n(14), r2 = n(15), o = n(37), i = n(6), s = n(12), c = n(55), l = n(28), u = n(61), f = n(2)("iterator"), p = !([].keys && "next" in [].keys()), d2 = function() {
          return this;
        };
        e2.exports = function(e3, t2, n2, b, h, v, m) {
          c(n2, t2, b);
          var y2, g, E, j = function(e4) {
            if (!p && e4 in O) return O[e4];
            switch (e4) {
              case "keys":
              case "values":
                return function() {
                  return new n2(this, e4);
                };
            }
            return function() {
              return new n2(this, e4);
            };
          }, x2 = t2 + " Iterator", _ = "values" == h, k = false, O = e3.prototype, C = O[f] || O["@@iterator"] || h && O[h], S = C || j(h), w = h ? _ ? j("entries") : S : void 0, A = "Array" == t2 && O.entries || C;
          if (A && (E = u(A.call(new e3()))) !== Object.prototype && E.next && (l(E, x2, true), a || "function" == typeof E[f] || i(E, f, d2)), _ && C && "values" !== C.name && (k = true, S = function() {
            return C.call(this);
          }), a && !m || !p && !k && O[f] || i(O, f, S), s[t2] = S, s[x2] = d2, h) if (y2 = { values: _ ? S : j("values"), keys: v ? S : j("keys"), entries: w }, m) for (g in y2) g in O || o(O, g, y2[g]);
          else r2(r2.P + r2.F * (p || k), t2, y2);
          return y2;
        };
      }, function(e2, t, n) {
        e2.exports = !n(4) && !n(8)(function() {
          return 7 != Object.defineProperty(n(36)("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e2, t, n) {
        var a = n(11), r2 = n(3).document, o = a(r2) && a(r2.createElement);
        e2.exports = function(e3) {
          return o ? r2.createElement(e3) : {};
        };
      }, function(e2, t, n) {
        e2.exports = n(6);
      }, function(e2, t, n) {
        var a = n(10), r2 = n(56), o = n(27), i = n(25)("IE_PROTO"), s = function() {
        }, c = function() {
          var e3, t2 = n(36)("iframe"), a2 = o.length;
          for (t2.style.display = "none", n(60).appendChild(t2), t2.src = "javascript:", (e3 = t2.contentWindow.document).open(), e3.write("<script>document.F=Object<\/script>"), e3.close(), c = e3.F; a2--; ) delete c.prototype[o[a2]];
          return c();
        };
        e2.exports = Object.create || function(e3, t2) {
          var n2;
          return null !== e3 ? (s.prototype = a(e3), n2 = new s(), s.prototype = null, n2[i] = e3) : n2 = c(), void 0 === t2 ? n2 : r2(n2, t2);
        };
      }, function(e2, t, n) {
        var a = n(5), r2 = n(9), o = n(57)(false), i = n(25)("IE_PROTO");
        e2.exports = function(e3, t2) {
          var n2, s = r2(e3), c = 0, l = [];
          for (n2 in s) n2 != i && a(s, n2) && l.push(n2);
          for (; t2.length > c; ) a(s, n2 = t2[c++]) && (~o(l, n2) || l.push(n2));
          return l;
        };
      }, function(e2, t, n) {
        var a = n(24);
        e2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e3) {
          return "String" == a(e3) ? e3.split("") : Object(e3);
        };
      }, function(e2, t, n) {
        var a = n(39), r2 = n(27).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function(e3) {
          return a(e3, r2);
        };
      }, function(e2, t, n) {
        var a = n(24), r2 = n(2)("toStringTag"), o = "Arguments" == a(/* @__PURE__ */ function() {
          return arguments;
        }());
        e2.exports = function(e3) {
          var t2, n2, i;
          return void 0 === e3 ? "Undefined" : null === e3 ? "Null" : "string" == typeof (n2 = function(e4, t3) {
            try {
              return e4[t3];
            } catch (e5) {
            }
          }(t2 = Object(e3), r2)) ? n2 : o ? a(t2) : "Object" == (i = a(t2)) && "function" == typeof t2.callee ? "Arguments" : i;
        };
      }, function(e2, t) {
        var n;
        n = /* @__PURE__ */ function() {
          return this;
        }();
        try {
          n = n || new Function("return this")();
        } catch (e3) {
          "object" == typeof window && (n = window);
        }
        e2.exports = n;
      }, function(e2, t) {
        var n = /-?\d+(\.\d+)?%?/g;
        e2.exports = function(e3) {
          return e3.match(n);
        };
      }, function(e2, t, n) {
        Object.defineProperty(t, "__esModule", { value: true }), t.getBase16Theme = t.createStyling = t.invertTheme = void 0;
        var a = d2(n(49)), r2 = d2(n(76)), o = d2(n(81)), i = d2(n(89)), s = d2(n(93)), c = function(e3) {
          if (e3 && e3.__esModule) return e3;
          var t2 = {};
          if (null != e3) for (var n2 in e3) Object.prototype.hasOwnProperty.call(e3, n2) && (t2[n2] = e3[n2]);
          return t2.default = e3, t2;
        }(n(94)), l = d2(n(132)), u = d2(n(133)), f = d2(n(138)), p = n(139);
        function d2(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var b = c.default, h = (0, i.default)(b), v = (0, f.default)(u.default, p.rgb2yuv, function(e3) {
          var t2, n2 = (0, o.default)(e3, 3), a2 = n2[0], r3 = n2[1], i2 = n2[2];
          return [(t2 = a2, t2 < 0.25 ? 1 : t2 < 0.5 ? 0.9 - t2 : 1.1 - t2), r3, i2];
        }, p.yuv2rgb, l.default), m = function(e3) {
          return function(t2) {
            return { className: [t2.className, e3.className].filter(Boolean).join(" "), style: (0, r2.default)({}, t2.style || {}, e3.style || {}) };
          };
        }, y2 = function(e3, t2) {
          var n2 = (0, i.default)(t2);
          for (var o2 in e3) -1 === n2.indexOf(o2) && n2.push(o2);
          return n2.reduce(function(n3, o3) {
            return n3[o3] = function(e4, t3) {
              if (void 0 === e4) return t3;
              if (void 0 === t3) return e4;
              var n4 = void 0 === e4 ? "undefined" : (0, a.default)(e4), o4 = void 0 === t3 ? "undefined" : (0, a.default)(t3);
              switch (n4) {
                case "string":
                  switch (o4) {
                    case "string":
                      return [t3, e4].filter(Boolean).join(" ");
                    case "object":
                      return m({ className: e4, style: t3 });
                    case "function":
                      return function(n5) {
                        for (var a2 = arguments.length, r3 = Array(a2 > 1 ? a2 - 1 : 0), o5 = 1; o5 < a2; o5++) r3[o5 - 1] = arguments[o5];
                        return m({ className: e4 })(t3.apply(void 0, [n5].concat(r3)));
                      };
                  }
                case "object":
                  switch (o4) {
                    case "string":
                      return m({ className: t3, style: e4 });
                    case "object":
                      return (0, r2.default)({}, t3, e4);
                    case "function":
                      return function(n5) {
                        for (var a2 = arguments.length, r3 = Array(a2 > 1 ? a2 - 1 : 0), o5 = 1; o5 < a2; o5++) r3[o5 - 1] = arguments[o5];
                        return m({ style: e4 })(t3.apply(void 0, [n5].concat(r3)));
                      };
                  }
                case "function":
                  switch (o4) {
                    case "string":
                      return function(n5) {
                        for (var a2 = arguments.length, r3 = Array(a2 > 1 ? a2 - 1 : 0), o5 = 1; o5 < a2; o5++) r3[o5 - 1] = arguments[o5];
                        return e4.apply(void 0, [m(n5)({ className: t3 })].concat(r3));
                      };
                    case "object":
                      return function(n5) {
                        for (var a2 = arguments.length, r3 = Array(a2 > 1 ? a2 - 1 : 0), o5 = 1; o5 < a2; o5++) r3[o5 - 1] = arguments[o5];
                        return e4.apply(void 0, [m(n5)({ style: t3 })].concat(r3));
                      };
                    case "function":
                      return function(n5) {
                        for (var a2 = arguments.length, r3 = Array(a2 > 1 ? a2 - 1 : 0), o5 = 1; o5 < a2; o5++) r3[o5 - 1] = arguments[o5];
                        return e4.apply(void 0, [t3.apply(void 0, [n5].concat(r3))].concat(r3));
                      };
                  }
              }
            }(e3[o3], t2[o3]), n3;
          }, {});
        }, g = function(e3, t2) {
          for (var n2 = arguments.length, o2 = Array(n2 > 2 ? n2 - 2 : 0), s2 = 2; s2 < n2; s2++) o2[s2 - 2] = arguments[s2];
          if (null === t2) return e3;
          Array.isArray(t2) || (t2 = [t2]);
          var c2 = t2.map(function(t3) {
            return e3[t3];
          }).filter(Boolean), l2 = c2.reduce(function(e4, t3) {
            return "string" == typeof t3 ? e4.className = [e4.className, t3].filter(Boolean).join(" ") : "object" === (void 0 === t3 ? "undefined" : (0, a.default)(t3)) ? e4.style = (0, r2.default)({}, e4.style, t3) : "function" == typeof t3 && (e4 = (0, r2.default)({}, e4, t3.apply(void 0, [e4].concat(o2)))), e4;
          }, { className: "", style: {} });
          return l2.className || delete l2.className, 0 === (0, i.default)(l2.style).length && delete l2.style, l2;
        }, E = t.invertTheme = function(e3) {
          return (0, i.default)(e3).reduce(function(t2, n2) {
            return t2[n2] = /^base/.test(n2) ? v(e3[n2]) : "scheme" === n2 ? e3[n2] + ":inverted" : e3[n2], t2;
          }, {});
        }, j = (t.createStyling = (0, s.default)(function(e3) {
          for (var t2 = arguments.length, n2 = Array(t2 > 3 ? t2 - 3 : 0), a2 = 3; a2 < t2; a2++) n2[a2 - 3] = arguments[a2];
          var o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, l2 = o2.defaultBase16, u2 = void 0 === l2 ? b : l2, f2 = o2.base16Themes, p2 = void 0 === f2 ? null : f2, d3 = j(c2, p2);
          d3 && (c2 = (0, r2.default)({}, d3, c2));
          var v2 = h.reduce(function(e4, t3) {
            return e4[t3] = c2[t3] || u2[t3], e4;
          }, {}), m2 = (0, i.default)(c2).reduce(function(e4, t3) {
            return -1 === h.indexOf(t3) ? (e4[t3] = c2[t3], e4) : e4;
          }, {}), E2 = e3(v2), x2 = y2(m2, E2);
          return (0, s.default)(g, 2).apply(void 0, [x2].concat(n2));
        }, 3), t.getBase16Theme = function(e3, t2) {
          if (e3 && e3.extend && (e3 = e3.extend), "string" == typeof e3) {
            var n2 = e3.split(":"), a2 = (0, o.default)(n2, 2), r3 = a2[0], i2 = a2[1];
            e3 = (t2 || {})[r3] || c[r3], "inverted" === i2 && (e3 = E(e3));
          }
          return e3 && e3.hasOwnProperty("base00") ? e3 : void 0;
        });
      }, function(e2, t, n) {
        var a, r2 = "object" == typeof Reflect ? Reflect : null, o = r2 && "function" == typeof r2.apply ? r2.apply : function(e3, t2, n2) {
          return Function.prototype.apply.call(e3, t2, n2);
        };
        a = r2 && "function" == typeof r2.ownKeys ? r2.ownKeys : Object.getOwnPropertySymbols ? function(e3) {
          return Object.getOwnPropertyNames(e3).concat(Object.getOwnPropertySymbols(e3));
        } : function(e3) {
          return Object.getOwnPropertyNames(e3);
        };
        var i = Number.isNaN || function(e3) {
          return e3 != e3;
        };
        function s() {
          s.init.call(this);
        }
        e2.exports = s, e2.exports.once = function(e3, t2) {
          return new Promise(function(n2, a2) {
            function r3() {
              void 0 !== o2 && e3.removeListener("error", o2), n2([].slice.call(arguments));
            }
            var o2;
            "error" !== t2 && (o2 = function(n3) {
              e3.removeListener(t2, r3), a2(n3);
            }, e3.once("error", o2)), e3.once(t2, r3);
          });
        }, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
        var c = 10;
        function l(e3) {
          if ("function" != typeof e3) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e3);
        }
        function u(e3) {
          return void 0 === e3._maxListeners ? s.defaultMaxListeners : e3._maxListeners;
        }
        function f(e3, t2, n2, a2) {
          var r3, o2, i2, s2;
          if (l(n2), void 0 === (o2 = e3._events) ? (o2 = e3._events = /* @__PURE__ */ Object.create(null), e3._eventsCount = 0) : (void 0 !== o2.newListener && (e3.emit("newListener", t2, n2.listener ? n2.listener : n2), o2 = e3._events), i2 = o2[t2]), void 0 === i2) i2 = o2[t2] = n2, ++e3._eventsCount;
          else if ("function" == typeof i2 ? i2 = o2[t2] = a2 ? [n2, i2] : [i2, n2] : a2 ? i2.unshift(n2) : i2.push(n2), (r3 = u(e3)) > 0 && i2.length > r3 && !i2.warned) {
            i2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + i2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c2.name = "MaxListenersExceededWarning", c2.emitter = e3, c2.type = t2, c2.count = i2.length, s2 = c2, console && console.warn && console.warn(s2);
          }
          return e3;
        }
        function p() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function d2(e3, t2, n2) {
          var a2 = { fired: false, wrapFn: void 0, target: e3, type: t2, listener: n2 }, r3 = p.bind(a2);
          return r3.listener = n2, a2.wrapFn = r3, r3;
        }
        function b(e3, t2, n2) {
          var a2 = e3._events;
          if (void 0 === a2) return [];
          var r3 = a2[t2];
          return void 0 === r3 ? [] : "function" == typeof r3 ? n2 ? [r3.listener || r3] : [r3] : n2 ? function(e4) {
            for (var t3 = new Array(e4.length), n3 = 0; n3 < t3.length; ++n3) t3[n3] = e4[n3].listener || e4[n3];
            return t3;
          }(r3) : v(r3, r3.length);
        }
        function h(e3) {
          var t2 = this._events;
          if (void 0 !== t2) {
            var n2 = t2[e3];
            if ("function" == typeof n2) return 1;
            if (void 0 !== n2) return n2.length;
          }
          return 0;
        }
        function v(e3, t2) {
          for (var n2 = new Array(t2), a2 = 0; a2 < t2; ++a2) n2[a2] = e3[a2];
          return n2;
        }
        Object.defineProperty(s, "defaultMaxListeners", { enumerable: true, get: function() {
          return c;
        }, set: function(e3) {
          if ("number" != typeof e3 || e3 < 0 || i(e3)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e3 + ".");
          c = e3;
        } }), s.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, s.prototype.setMaxListeners = function(e3) {
          if ("number" != typeof e3 || e3 < 0 || i(e3)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e3 + ".");
          return this._maxListeners = e3, this;
        }, s.prototype.getMaxListeners = function() {
          return u(this);
        }, s.prototype.emit = function(e3) {
          for (var t2 = [], n2 = 1; n2 < arguments.length; n2++) t2.push(arguments[n2]);
          var a2 = "error" === e3, r3 = this._events;
          if (void 0 !== r3) a2 = a2 && void 0 === r3.error;
          else if (!a2) return false;
          if (a2) {
            var i2;
            if (t2.length > 0 && (i2 = t2[0]), i2 instanceof Error) throw i2;
            var s2 = new Error("Unhandled error." + (i2 ? " (" + i2.message + ")" : ""));
            throw s2.context = i2, s2;
          }
          var c2 = r3[e3];
          if (void 0 === c2) return false;
          if ("function" == typeof c2) o(c2, this, t2);
          else {
            var l2 = c2.length, u2 = v(c2, l2);
            for (n2 = 0; n2 < l2; ++n2) o(u2[n2], this, t2);
          }
          return true;
        }, s.prototype.addListener = function(e3, t2) {
          return f(this, e3, t2, false);
        }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(e3, t2) {
          return f(this, e3, t2, true);
        }, s.prototype.once = function(e3, t2) {
          return l(t2), this.on(e3, d2(this, e3, t2)), this;
        }, s.prototype.prependOnceListener = function(e3, t2) {
          return l(t2), this.prependListener(e3, d2(this, e3, t2)), this;
        }, s.prototype.removeListener = function(e3, t2) {
          var n2, a2, r3, o2, i2;
          if (l(t2), void 0 === (a2 = this._events)) return this;
          if (void 0 === (n2 = a2[e3])) return this;
          if (n2 === t2 || n2.listener === t2) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete a2[e3], a2.removeListener && this.emit("removeListener", e3, n2.listener || t2));
          else if ("function" != typeof n2) {
            for (r3 = -1, o2 = n2.length - 1; o2 >= 0; o2--) if (n2[o2] === t2 || n2[o2].listener === t2) {
              i2 = n2[o2].listener, r3 = o2;
              break;
            }
            if (r3 < 0) return this;
            0 === r3 ? n2.shift() : function(e4, t3) {
              for (; t3 + 1 < e4.length; t3++) e4[t3] = e4[t3 + 1];
              e4.pop();
            }(n2, r3), 1 === n2.length && (a2[e3] = n2[0]), void 0 !== a2.removeListener && this.emit("removeListener", e3, i2 || t2);
          }
          return this;
        }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(e3) {
          var t2, n2, a2;
          if (void 0 === (n2 = this._events)) return this;
          if (void 0 === n2.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n2[e3] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e3]), this;
          if (0 === arguments.length) {
            var r3, o2 = Object.keys(n2);
            for (a2 = 0; a2 < o2.length; ++a2) "removeListener" !== (r3 = o2[a2]) && this.removeAllListeners(r3);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = n2[e3])) this.removeListener(e3, t2);
          else if (void 0 !== t2) for (a2 = t2.length - 1; a2 >= 0; a2--) this.removeListener(e3, t2[a2]);
          return this;
        }, s.prototype.listeners = function(e3) {
          return b(this, e3, true);
        }, s.prototype.rawListeners = function(e3) {
          return b(this, e3, false);
        }, s.listenerCount = function(e3, t2) {
          return "function" == typeof e3.listenerCount ? e3.listenerCount(t2) : h.call(e3, t2);
        }, s.prototype.listenerCount = h, s.prototype.eventNames = function() {
          return this._eventsCount > 0 ? a(this._events) : [];
        };
      }, function(e2, t, n) {
        e2.exports.Dispatcher = n(140);
      }, function(e2, t, n) {
        e2.exports = n(142);
      }, function(e2, t, n) {
        t.__esModule = true;
        var a = i(n(50)), r2 = i(n(65)), o = "function" == typeof r2.default && "symbol" == typeof a.default ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof r2.default && e3.constructor === r2.default && e3 !== r2.default.prototype ? "symbol" : typeof e3;
        };
        function i(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        t.default = "function" == typeof r2.default && "symbol" === o(a.default) ? function(e3) {
          return void 0 === e3 ? "undefined" : o(e3);
        } : function(e3) {
          return e3 && "function" == typeof r2.default && e3.constructor === r2.default && e3 !== r2.default.prototype ? "symbol" : void 0 === e3 ? "undefined" : o(e3);
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(51), __esModule: true };
      }, function(e2, t, n) {
        n(20), n(29), e2.exports = n(30).f("iterator");
      }, function(e2, t, n) {
        var a = n(21), r2 = n(22);
        e2.exports = function(e3) {
          return function(t2, n2) {
            var o, i, s = String(r2(t2)), c = a(n2), l = s.length;
            return c < 0 || c >= l ? e3 ? "" : void 0 : (o = s.charCodeAt(c)) < 55296 || o > 56319 || c + 1 === l || (i = s.charCodeAt(c + 1)) < 56320 || i > 57343 ? e3 ? s.charAt(c) : o : e3 ? s.slice(c, c + 2) : i - 56320 + (o - 55296 << 10) + 65536;
          };
        };
      }, function(e2, t, n) {
        var a = n(54);
        e2.exports = function(e3, t2, n2) {
          if (a(e3), void 0 === t2) return e3;
          switch (n2) {
            case 1:
              return function(n3) {
                return e3.call(t2, n3);
              };
            case 2:
              return function(n3, a2) {
                return e3.call(t2, n3, a2);
              };
            case 3:
              return function(n3, a2, r2) {
                return e3.call(t2, n3, a2, r2);
              };
          }
          return function() {
            return e3.apply(t2, arguments);
          };
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          if ("function" != typeof e3) throw TypeError(e3 + " is not a function!");
          return e3;
        };
      }, function(e2, t, n) {
        var a = n(38), r2 = n(16), o = n(28), i = {};
        n(6)(i, n(2)("iterator"), function() {
          return this;
        }), e2.exports = function(e3, t2, n2) {
          e3.prototype = a(i, { next: r2(1, n2) }), o(e3, t2 + " Iterator");
        };
      }, function(e2, t, n) {
        var a = n(7), r2 = n(10), o = n(13);
        e2.exports = n(4) ? Object.defineProperties : function(e3, t2) {
          r2(e3);
          for (var n2, i = o(t2), s = i.length, c = 0; s > c; ) a.f(e3, n2 = i[c++], t2[n2]);
          return e3;
        };
      }, function(e2, t, n) {
        var a = n(9), r2 = n(58), o = n(59);
        e2.exports = function(e3) {
          return function(t2, n2, i) {
            var s, c = a(t2), l = r2(c.length), u = o(i, l);
            if (e3 && n2 != n2) {
              for (; l > u; ) if ((s = c[u++]) != s) return true;
            } else for (; l > u; u++) if ((e3 || u in c) && c[u] === n2) return e3 || u || 0;
            return !e3 && -1;
          };
        };
      }, function(e2, t, n) {
        var a = n(21), r2 = Math.min;
        e2.exports = function(e3) {
          return e3 > 0 ? r2(a(e3), 9007199254740991) : 0;
        };
      }, function(e2, t, n) {
        var a = n(21), r2 = Math.max, o = Math.min;
        e2.exports = function(e3, t2) {
          return (e3 = a(e3)) < 0 ? r2(e3 + t2, 0) : o(e3, t2);
        };
      }, function(e2, t, n) {
        var a = n(3).document;
        e2.exports = a && a.documentElement;
      }, function(e2, t, n) {
        var a = n(5), r2 = n(18), o = n(25)("IE_PROTO"), i = Object.prototype;
        e2.exports = Object.getPrototypeOf || function(e3) {
          return e3 = r2(e3), a(e3, o) ? e3[o] : "function" == typeof e3.constructor && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? i : null;
        };
      }, function(e2, t, n) {
        var a = n(63), r2 = n(64), o = n(12), i = n(9);
        e2.exports = n(34)(Array, "Array", function(e3, t2) {
          this._t = i(e3), this._i = 0, this._k = t2;
        }, function() {
          var e3 = this._t, t2 = this._k, n2 = this._i++;
          return !e3 || n2 >= e3.length ? (this._t = void 0, r2(1)) : r2(0, "keys" == t2 ? n2 : "values" == t2 ? e3[n2] : [n2, e3[n2]]);
        }, "values"), o.Arguments = o.Array, a("keys"), a("values"), a("entries");
      }, function(e2, t) {
        e2.exports = function() {
        };
      }, function(e2, t) {
        e2.exports = function(e3, t2) {
          return { value: t2, done: !!e3 };
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(66), __esModule: true };
      }, function(e2, t, n) {
        n(67), n(73), n(74), n(75), e2.exports = n(1).Symbol;
      }, function(e2, t, n) {
        var a = n(3), r2 = n(5), o = n(4), i = n(15), s = n(37), c = n(68).KEY, l = n(8), u = n(26), f = n(28), p = n(17), d2 = n(2), b = n(30), h = n(31), v = n(69), m = n(70), y2 = n(10), g = n(11), E = n(18), j = n(9), x2 = n(23), _ = n(16), k = n(38), O = n(71), C = n(72), S = n(32), w = n(7), A = n(13), M = C.f, P = w.f, F = O.f, D = a.Symbol, I = a.JSON, R = I && I.stringify, L = d2("_hidden"), B = d2("toPrimitive"), N = {}.propertyIsEnumerable, z = u("symbol-registry"), T = u("symbols"), q = u("op-symbols"), V = Object.prototype, K = "function" == typeof D && !!S.f, W = a.QObject, H = !W || !W.prototype || !W.prototype.findChild, U = o && l(function() {
          return 7 != k(P({}, "a", { get: function() {
            return P(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e3, t2, n2) {
          var a2 = M(V, t2);
          a2 && delete V[t2], P(e3, t2, n2), a2 && e3 !== V && P(V, t2, a2);
        } : P, G = function(e3) {
          var t2 = T[e3] = k(D.prototype);
          return t2._k = e3, t2;
        }, J = K && "symbol" == typeof D.iterator ? function(e3) {
          return "symbol" == typeof e3;
        } : function(e3) {
          return e3 instanceof D;
        }, Y = function(e3, t2, n2) {
          return e3 === V && Y(q, t2, n2), y2(e3), t2 = x2(t2, true), y2(n2), r2(T, t2) ? (n2.enumerable ? (r2(e3, L) && e3[L][t2] && (e3[L][t2] = false), n2 = k(n2, { enumerable: _(0, false) })) : (r2(e3, L) || P(e3, L, _(1, {})), e3[L][t2] = true), U(e3, t2, n2)) : P(e3, t2, n2);
        }, $ = function(e3, t2) {
          y2(e3);
          for (var n2, a2 = v(t2 = j(t2)), r3 = 0, o2 = a2.length; o2 > r3; ) Y(e3, n2 = a2[r3++], t2[n2]);
          return e3;
        }, Q = function(e3) {
          var t2 = N.call(this, e3 = x2(e3, true));
          return !(this === V && r2(T, e3) && !r2(q, e3)) && (!(t2 || !r2(this, e3) || !r2(T, e3) || r2(this, L) && this[L][e3]) || t2);
        }, Z = function(e3, t2) {
          if (e3 = j(e3), t2 = x2(t2, true), e3 !== V || !r2(T, t2) || r2(q, t2)) {
            var n2 = M(e3, t2);
            return !n2 || !r2(T, t2) || r2(e3, L) && e3[L][t2] || (n2.enumerable = true), n2;
          }
        }, X = function(e3) {
          for (var t2, n2 = F(j(e3)), a2 = [], o2 = 0; n2.length > o2; ) r2(T, t2 = n2[o2++]) || t2 == L || t2 == c || a2.push(t2);
          return a2;
        }, ee = function(e3) {
          for (var t2, n2 = e3 === V, a2 = F(n2 ? q : j(e3)), o2 = [], i2 = 0; a2.length > i2; ) !r2(T, t2 = a2[i2++]) || n2 && !r2(V, t2) || o2.push(T[t2]);
          return o2;
        };
        K || (s((D = function() {
          if (this instanceof D) throw TypeError("Symbol is not a constructor!");
          var e3 = p(arguments.length > 0 ? arguments[0] : void 0), t2 = function(n2) {
            this === V && t2.call(q, n2), r2(this, L) && r2(this[L], e3) && (this[L][e3] = false), U(this, e3, _(1, n2));
          };
          return o && H && U(V, e3, { configurable: true, set: t2 }), G(e3);
        }).prototype, "toString", function() {
          return this._k;
        }), C.f = Z, w.f = Y, n(41).f = O.f = X, n(19).f = Q, S.f = ee, o && !n(14) && s(V, "propertyIsEnumerable", Q, true), b.f = function(e3) {
          return G(d2(e3));
        }), i(i.G + i.W + i.F * !K, { Symbol: D });
        for (var te = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ne = 0; te.length > ne; ) d2(te[ne++]);
        for (var ae = A(d2.store), re = 0; ae.length > re; ) h(ae[re++]);
        i(i.S + i.F * !K, "Symbol", { for: function(e3) {
          return r2(z, e3 += "") ? z[e3] : z[e3] = D(e3);
        }, keyFor: function(e3) {
          if (!J(e3)) throw TypeError(e3 + " is not a symbol!");
          for (var t2 in z) if (z[t2] === e3) return t2;
        }, useSetter: function() {
          H = true;
        }, useSimple: function() {
          H = false;
        } }), i(i.S + i.F * !K, "Object", { create: function(e3, t2) {
          return void 0 === t2 ? k(e3) : $(k(e3), t2);
        }, defineProperty: Y, defineProperties: $, getOwnPropertyDescriptor: Z, getOwnPropertyNames: X, getOwnPropertySymbols: ee });
        var oe = l(function() {
          S.f(1);
        });
        i(i.S + i.F * oe, "Object", { getOwnPropertySymbols: function(e3) {
          return S.f(E(e3));
        } }), I && i(i.S + i.F * (!K || l(function() {
          var e3 = D();
          return "[null]" != R([e3]) || "{}" != R({ a: e3 }) || "{}" != R(Object(e3));
        })), "JSON", { stringify: function(e3) {
          for (var t2, n2, a2 = [e3], r3 = 1; arguments.length > r3; ) a2.push(arguments[r3++]);
          if (n2 = t2 = a2[1], (g(t2) || void 0 !== e3) && !J(e3)) return m(t2) || (t2 = function(e4, t3) {
            if ("function" == typeof n2 && (t3 = n2.call(this, e4, t3)), !J(t3)) return t3;
          }), a2[1] = t2, R.apply(I, a2);
        } }), D.prototype[B] || n(6)(D.prototype, B, D.prototype.valueOf), f(D, "Symbol"), f(Math, "Math", true), f(a.JSON, "JSON", true);
      }, function(e2, t, n) {
        var a = n(17)("meta"), r2 = n(11), o = n(5), i = n(7).f, s = 0, c = Object.isExtensible || function() {
          return true;
        }, l = !n(8)(function() {
          return c(Object.preventExtensions({}));
        }), u = function(e3) {
          i(e3, a, { value: { i: "O" + ++s, w: {} } });
        }, f = e2.exports = { KEY: a, NEED: false, fastKey: function(e3, t2) {
          if (!r2(e3)) return "symbol" == typeof e3 ? e3 : ("string" == typeof e3 ? "S" : "P") + e3;
          if (!o(e3, a)) {
            if (!c(e3)) return "F";
            if (!t2) return "E";
            u(e3);
          }
          return e3[a].i;
        }, getWeak: function(e3, t2) {
          if (!o(e3, a)) {
            if (!c(e3)) return true;
            if (!t2) return false;
            u(e3);
          }
          return e3[a].w;
        }, onFreeze: function(e3) {
          return l && f.NEED && c(e3) && !o(e3, a) && u(e3), e3;
        } };
      }, function(e2, t, n) {
        var a = n(13), r2 = n(32), o = n(19);
        e2.exports = function(e3) {
          var t2 = a(e3), n2 = r2.f;
          if (n2) for (var i, s = n2(e3), c = o.f, l = 0; s.length > l; ) c.call(e3, i = s[l++]) && t2.push(i);
          return t2;
        };
      }, function(e2, t, n) {
        var a = n(24);
        e2.exports = Array.isArray || function(e3) {
          return "Array" == a(e3);
        };
      }, function(e2, t, n) {
        var a = n(9), r2 = n(41).f, o = {}.toString, i = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        e2.exports.f = function(e3) {
          return i && "[object Window]" == o.call(e3) ? function(e4) {
            try {
              return r2(e4);
            } catch (e5) {
              return i.slice();
            }
          }(e3) : r2(a(e3));
        };
      }, function(e2, t, n) {
        var a = n(19), r2 = n(16), o = n(9), i = n(23), s = n(5), c = n(35), l = Object.getOwnPropertyDescriptor;
        t.f = n(4) ? l : function(e3, t2) {
          if (e3 = o(e3), t2 = i(t2, true), c) try {
            return l(e3, t2);
          } catch (e4) {
          }
          if (s(e3, t2)) return r2(!a.f.call(e3, t2), e3[t2]);
        };
      }, function(e2, t) {
      }, function(e2, t, n) {
        n(31)("asyncIterator");
      }, function(e2, t, n) {
        n(31)("observable");
      }, function(e2, t, n) {
        t.__esModule = true;
        var a, r2 = n(77), o = (a = r2) && a.__esModule ? a : { default: a };
        t.default = o.default || function(e3) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = arguments[t2];
            for (var a2 in n2) Object.prototype.hasOwnProperty.call(n2, a2) && (e3[a2] = n2[a2]);
          }
          return e3;
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(78), __esModule: true };
      }, function(e2, t, n) {
        n(79), e2.exports = n(1).Object.assign;
      }, function(e2, t, n) {
        var a = n(15);
        a(a.S + a.F, "Object", { assign: n(80) });
      }, function(e2, t, n) {
        var a = n(4), r2 = n(13), o = n(32), i = n(19), s = n(18), c = n(40), l = Object.assign;
        e2.exports = !l || n(8)(function() {
          var e3 = {}, t2 = {}, n2 = Symbol(), a2 = "abcdefghijklmnopqrst";
          return e3[n2] = 7, a2.split("").forEach(function(e4) {
            t2[e4] = e4;
          }), 7 != l({}, e3)[n2] || Object.keys(l({}, t2)).join("") != a2;
        }) ? function(e3, t2) {
          for (var n2 = s(e3), l2 = arguments.length, u = 1, f = o.f, p = i.f; l2 > u; ) for (var d2, b = c(arguments[u++]), h = f ? r2(b).concat(f(b)) : r2(b), v = h.length, m = 0; v > m; ) d2 = h[m++], a && !p.call(b, d2) || (n2[d2] = b[d2]);
          return n2;
        } : l;
      }, function(e2, t, n) {
        t.__esModule = true;
        var a = o(n(82)), r2 = o(n(85));
        function o(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        t.default = function(e3, t2) {
          if (Array.isArray(e3)) return e3;
          if ((0, a.default)(Object(e3))) return function(e4, t3) {
            var n2 = [], a2 = true, o2 = false, i = void 0;
            try {
              for (var s, c = (0, r2.default)(e4); !(a2 = (s = c.next()).done) && (n2.push(s.value), !t3 || n2.length !== t3); a2 = true) ;
            } catch (e5) {
              o2 = true, i = e5;
            } finally {
              try {
                !a2 && c.return && c.return();
              } finally {
                if (o2) throw i;
              }
            }
            return n2;
          }(e3, t2);
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(83), __esModule: true };
      }, function(e2, t, n) {
        n(29), n(20), e2.exports = n(84);
      }, function(e2, t, n) {
        var a = n(42), r2 = n(2)("iterator"), o = n(12);
        e2.exports = n(1).isIterable = function(e3) {
          var t2 = Object(e3);
          return void 0 !== t2[r2] || "@@iterator" in t2 || o.hasOwnProperty(a(t2));
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(86), __esModule: true };
      }, function(e2, t, n) {
        n(29), n(20), e2.exports = n(87);
      }, function(e2, t, n) {
        var a = n(10), r2 = n(88);
        e2.exports = n(1).getIterator = function(e3) {
          var t2 = r2(e3);
          if ("function" != typeof t2) throw TypeError(e3 + " is not iterable!");
          return a(t2.call(e3));
        };
      }, function(e2, t, n) {
        var a = n(42), r2 = n(2)("iterator"), o = n(12);
        e2.exports = n(1).getIteratorMethod = function(e3) {
          if (null != e3) return e3[r2] || e3["@@iterator"] || o[a(e3)];
        };
      }, function(e2, t, n) {
        e2.exports = { default: n(90), __esModule: true };
      }, function(e2, t, n) {
        n(91), e2.exports = n(1).Object.keys;
      }, function(e2, t, n) {
        var a = n(18), r2 = n(13);
        n(92)("keys", function() {
          return function(e3) {
            return r2(a(e3));
          };
        });
      }, function(e2, t, n) {
        var a = n(15), r2 = n(1), o = n(8);
        e2.exports = function(e3, t2) {
          var n2 = (r2.Object || {})[e3] || Object[e3], i = {};
          i[e3] = t2(n2), a(a.S + a.F * o(function() {
            n2(1);
          }), "Object", i);
        };
      }, function(e2, t, n) {
        (function(t2) {
          var n2 = [["ary", 128], ["bind", 1], ["bindKey", 2], ["curry", 8], ["curryRight", 16], ["flip", 512], ["partial", 32], ["partialRight", 64], ["rearg", 256]], a = /^\s+|\s+$/g, r2 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, o = /\{\n\/\* \[wrapped with (.+)\] \*/, i = /,? & /, s = /^[-+]0x[0-9a-f]+$/i, c = /^0b[01]+$/i, l = /^\[object .+?Constructor\]$/, u = /^0o[0-7]+$/i, f = /^(?:0|[1-9]\d*)$/, p = parseInt, d2 = "object" == typeof t2 && t2 && t2.Object === Object && t2, b = "object" == typeof self && self && self.Object === Object && self, h = d2 || b || Function("return this")();
          function v(e3, t3, n3) {
            switch (n3.length) {
              case 0:
                return e3.call(t3);
              case 1:
                return e3.call(t3, n3[0]);
              case 2:
                return e3.call(t3, n3[0], n3[1]);
              case 3:
                return e3.call(t3, n3[0], n3[1], n3[2]);
            }
            return e3.apply(t3, n3);
          }
          function m(e3, t3) {
            return !!(e3 ? e3.length : 0) && function(e4, t4, n3) {
              if (t4 != t4) return function(e5, t5, n4, a3) {
                var r4 = e5.length, o2 = n4 + -1;
                for (; ++o2 < r4; ) if (t5(e5[o2], o2, e5)) return o2;
                return -1;
              }(e4, y2, n3);
              var a2 = n3 - 1, r3 = e4.length;
              for (; ++a2 < r3; ) if (e4[a2] === t4) return a2;
              return -1;
            }(e3, t3, 0) > -1;
          }
          function y2(e3) {
            return e3 != e3;
          }
          function g(e3, t3) {
            for (var n3 = e3.length, a2 = 0; n3--; ) e3[n3] === t3 && a2++;
            return a2;
          }
          function E(e3, t3) {
            for (var n3 = -1, a2 = e3.length, r3 = 0, o2 = []; ++n3 < a2; ) {
              var i2 = e3[n3];
              i2 !== t3 && "__lodash_placeholder__" !== i2 || (e3[n3] = "__lodash_placeholder__", o2[r3++] = n3);
            }
            return o2;
          }
          var j, x2, _, k = Function.prototype, O = Object.prototype, C = h["__core-js_shared__"], S = (j = /[^.]+$/.exec(C && C.keys && C.keys.IE_PROTO || "")) ? "Symbol(src)_1." + j : "", w = k.toString, A = O.hasOwnProperty, M = O.toString, P = RegExp("^" + w.call(A).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), F = Object.create, D = Math.max, I = Math.min, R = (x2 = H(Object, "defineProperty"), (_ = H.name) && _.length > 2 ? x2 : void 0);
          function L(e3) {
            return X(e3) ? F(e3) : {};
          }
          function B(e3) {
            return !(!X(e3) || function(e4) {
              return !!S && S in e4;
            }(e3)) && (function(e4) {
              var t3 = X(e4) ? M.call(e4) : "";
              return "[object Function]" == t3 || "[object GeneratorFunction]" == t3;
            }(e3) || function(e4) {
              var t3 = false;
              if (null != e4 && "function" != typeof e4.toString) try {
                t3 = !!(e4 + "");
              } catch (e5) {
              }
              return t3;
            }(e3) ? P : l).test(function(e4) {
              if (null != e4) {
                try {
                  return w.call(e4);
                } catch (e5) {
                }
                try {
                  return e4 + "";
                } catch (e5) {
                }
              }
              return "";
            }(e3));
          }
          function N(e3, t3, n3, a2) {
            for (var r3 = -1, o2 = e3.length, i2 = n3.length, s2 = -1, c2 = t3.length, l2 = D(o2 - i2, 0), u2 = Array(c2 + l2), f2 = !a2; ++s2 < c2; ) u2[s2] = t3[s2];
            for (; ++r3 < i2; ) (f2 || r3 < o2) && (u2[n3[r3]] = e3[r3]);
            for (; l2--; ) u2[s2++] = e3[r3++];
            return u2;
          }
          function z(e3, t3, n3, a2) {
            for (var r3 = -1, o2 = e3.length, i2 = -1, s2 = n3.length, c2 = -1, l2 = t3.length, u2 = D(o2 - s2, 0), f2 = Array(u2 + l2), p2 = !a2; ++r3 < u2; ) f2[r3] = e3[r3];
            for (var d3 = r3; ++c2 < l2; ) f2[d3 + c2] = t3[c2];
            for (; ++i2 < s2; ) (p2 || r3 < o2) && (f2[d3 + n3[i2]] = e3[r3++]);
            return f2;
          }
          function T(e3) {
            return function() {
              var t3 = arguments;
              switch (t3.length) {
                case 0:
                  return new e3();
                case 1:
                  return new e3(t3[0]);
                case 2:
                  return new e3(t3[0], t3[1]);
                case 3:
                  return new e3(t3[0], t3[1], t3[2]);
                case 4:
                  return new e3(t3[0], t3[1], t3[2], t3[3]);
                case 5:
                  return new e3(t3[0], t3[1], t3[2], t3[3], t3[4]);
                case 6:
                  return new e3(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5]);
                case 7:
                  return new e3(t3[0], t3[1], t3[2], t3[3], t3[4], t3[5], t3[6]);
              }
              var n3 = L(e3.prototype), a2 = e3.apply(n3, t3);
              return X(a2) ? a2 : n3;
            };
          }
          function q(e3, t3, n3, a2, r3, o2, i2, s2, c2, l2) {
            var u2 = 128 & t3, f2 = 1 & t3, p2 = 2 & t3, d3 = 24 & t3, b2 = 512 & t3, v2 = p2 ? void 0 : T(e3);
            return function m2() {
              for (var y3 = arguments.length, j2 = Array(y3), x3 = y3; x3--; ) j2[x3] = arguments[x3];
              if (d3) var _2 = W(m2), k2 = g(j2, _2);
              if (a2 && (j2 = N(j2, a2, r3, d3)), o2 && (j2 = z(j2, o2, i2, d3)), y3 -= k2, d3 && y3 < l2) {
                var O2 = E(j2, _2);
                return V(e3, t3, q, m2.placeholder, n3, j2, O2, s2, c2, l2 - y3);
              }
              var C2 = f2 ? n3 : this, S2 = p2 ? C2[e3] : e3;
              return y3 = j2.length, s2 ? j2 = Y(j2, s2) : b2 && y3 > 1 && j2.reverse(), u2 && c2 < y3 && (j2.length = c2), this && this !== h && this instanceof m2 && (S2 = v2 || T(S2)), S2.apply(C2, j2);
            };
          }
          function V(e3, t3, n3, a2, r3, o2, i2, s2, c2, l2) {
            var u2 = 8 & t3;
            t3 |= u2 ? 32 : 64, 4 & (t3 &= ~(u2 ? 64 : 32)) || (t3 &= -4);
            var f2 = n3(e3, t3, r3, u2 ? o2 : void 0, u2 ? i2 : void 0, u2 ? void 0 : o2, u2 ? void 0 : i2, s2, c2, l2);
            return f2.placeholder = a2, $(f2, e3, t3);
          }
          function K(e3, t3, n3, a2, r3, o2, i2, s2) {
            var c2 = 2 & t3;
            if (!c2 && "function" != typeof e3) throw new TypeError("Expected a function");
            var l2 = a2 ? a2.length : 0;
            if (l2 || (t3 &= -97, a2 = r3 = void 0), i2 = void 0 === i2 ? i2 : D(te(i2), 0), s2 = void 0 === s2 ? s2 : te(s2), l2 -= r3 ? r3.length : 0, 64 & t3) {
              var u2 = a2, f2 = r3;
              a2 = r3 = void 0;
            }
            var p2 = [e3, t3, n3, a2, r3, u2, f2, o2, i2, s2];
            if (e3 = p2[0], t3 = p2[1], n3 = p2[2], a2 = p2[3], r3 = p2[4], !(s2 = p2[9] = null == p2[9] ? c2 ? 0 : e3.length : D(p2[9] - l2, 0)) && 24 & t3 && (t3 &= -25), t3 && 1 != t3) d3 = 8 == t3 || 16 == t3 ? function(e4, t4, n4) {
              var a3 = T(e4);
              return function r4() {
                for (var o3 = arguments.length, i3 = Array(o3), s3 = o3, c3 = W(r4); s3--; ) i3[s3] = arguments[s3];
                var l3 = o3 < 3 && i3[0] !== c3 && i3[o3 - 1] !== c3 ? [] : E(i3, c3);
                if ((o3 -= l3.length) < n4) return V(e4, t4, q, r4.placeholder, void 0, i3, l3, void 0, void 0, n4 - o3);
                var u3 = this && this !== h && this instanceof r4 ? a3 : e4;
                return v(u3, this, i3);
              };
            }(e3, t3, s2) : 32 != t3 && 33 != t3 || r3.length ? q.apply(void 0, p2) : function(e4, t4, n4, a3) {
              var r4 = 1 & t4, o3 = T(e4);
              return function t5() {
                for (var i3 = -1, s3 = arguments.length, c3 = -1, l3 = a3.length, u3 = Array(l3 + s3), f3 = this && this !== h && this instanceof t5 ? o3 : e4; ++c3 < l3; ) u3[c3] = a3[c3];
                for (; s3--; ) u3[c3++] = arguments[++i3];
                return v(f3, r4 ? n4 : this, u3);
              };
            }(e3, t3, n3, a2);
            else var d3 = function(e4, t4, n4) {
              var a3 = 1 & t4, r4 = T(e4);
              return function t5() {
                var o3 = this && this !== h && this instanceof t5 ? r4 : e4;
                return o3.apply(a3 ? n4 : this, arguments);
              };
            }(e3, t3, n3);
            return $(d3, e3, t3);
          }
          function W(e3) {
            return e3.placeholder;
          }
          function H(e3, t3) {
            var n3 = function(e4, t4) {
              return null == e4 ? void 0 : e4[t4];
            }(e3, t3);
            return B(n3) ? n3 : void 0;
          }
          function U(e3) {
            var t3 = e3.match(o);
            return t3 ? t3[1].split(i) : [];
          }
          function G(e3, t3) {
            var n3 = t3.length, a2 = n3 - 1;
            return t3[a2] = (n3 > 1 ? "& " : "") + t3[a2], t3 = t3.join(n3 > 2 ? ", " : " "), e3.replace(r2, "{\n/* [wrapped with " + t3 + "] */\n");
          }
          function J(e3, t3) {
            return !!(t3 = null == t3 ? 9007199254740991 : t3) && ("number" == typeof e3 || f.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t3;
          }
          function Y(e3, t3) {
            for (var n3 = e3.length, a2 = I(t3.length, n3), r3 = function(e4, t4) {
              var n4 = -1, a3 = e4.length;
              for (t4 || (t4 = Array(a3)); ++n4 < a3; ) t4[n4] = e4[n4];
              return t4;
            }(e3); a2--; ) {
              var o2 = t3[a2];
              e3[a2] = J(o2, n3) ? r3[o2] : void 0;
            }
            return e3;
          }
          var $ = R ? function(e3, t3, n3) {
            var a2, r3 = t3 + "";
            return R(e3, "toString", { configurable: true, enumerable: false, value: (a2 = G(r3, Q(U(r3), n3)), function() {
              return a2;
            }) });
          } : function(e3) {
            return e3;
          };
          function Q(e3, t3) {
            return function(e4, t4) {
              for (var n3 = -1, a2 = e4 ? e4.length : 0; ++n3 < a2 && false !== t4(e4[n3], n3, e4); ) ;
            }(n2, function(n3) {
              var a2 = "_." + n3[0];
              t3 & n3[1] && !m(e3, a2) && e3.push(a2);
            }), e3.sort();
          }
          function Z(e3, t3, n3) {
            var a2 = K(e3, 8, void 0, void 0, void 0, void 0, void 0, t3 = n3 ? void 0 : t3);
            return a2.placeholder = Z.placeholder, a2;
          }
          function X(e3) {
            var t3 = typeof e3;
            return !!e3 && ("object" == t3 || "function" == t3);
          }
          function ee(e3) {
            return e3 ? (e3 = function(e4) {
              if ("number" == typeof e4) return e4;
              if (function(e5) {
                return "symbol" == typeof e5 || /* @__PURE__ */ function(e6) {
                  return !!e6 && "object" == typeof e6;
                }(e5) && "[object Symbol]" == M.call(e5);
              }(e4)) return NaN;
              if (X(e4)) {
                var t3 = "function" == typeof e4.valueOf ? e4.valueOf() : e4;
                e4 = X(t3) ? t3 + "" : t3;
              }
              if ("string" != typeof e4) return 0 === e4 ? e4 : +e4;
              e4 = e4.replace(a, "");
              var n3 = c.test(e4);
              return n3 || u.test(e4) ? p(e4.slice(2), n3 ? 2 : 8) : s.test(e4) ? NaN : +e4;
            }(e3)) === 1 / 0 || e3 === -1 / 0 ? 17976931348623157e292 * (e3 < 0 ? -1 : 1) : e3 == e3 ? e3 : 0 : 0 === e3 ? e3 : 0;
          }
          function te(e3) {
            var t3 = ee(e3), n3 = t3 % 1;
            return t3 == t3 ? n3 ? t3 - n3 : t3 : 0;
          }
          Z.placeholder = {}, e2.exports = Z;
        }).call(this, n(43));
      }, function(e2, t, n) {
        function a(e3) {
          return e3 && e3.__esModule ? e3.default : e3;
        }
        t.__esModule = true;
        var r2 = n(95);
        t.threezerotwofour = a(r2);
        var o = n(96);
        t.apathy = a(o);
        var i = n(97);
        t.ashes = a(i);
        var s = n(98);
        t.atelierDune = a(s);
        var c = n(99);
        t.atelierForest = a(c);
        var l = n(100);
        t.atelierHeath = a(l);
        var u = n(101);
        t.atelierLakeside = a(u);
        var f = n(102);
        t.atelierSeaside = a(f);
        var p = n(103);
        t.bespin = a(p);
        var d2 = n(104);
        t.brewer = a(d2);
        var b = n(105);
        t.bright = a(b);
        var h = n(106);
        t.chalk = a(h);
        var v = n(107);
        t.codeschool = a(v);
        var m = n(108);
        t.colors = a(m);
        var y2 = n(109);
        t.default = a(y2);
        var g = n(110);
        t.eighties = a(g);
        var E = n(111);
        t.embers = a(E);
        var j = n(112);
        t.flat = a(j);
        var x2 = n(113);
        t.google = a(x2);
        var _ = n(114);
        t.grayscale = a(_);
        var k = n(115);
        t.greenscreen = a(k);
        var O = n(116);
        t.harmonic = a(O);
        var C = n(117);
        t.hopscotch = a(C);
        var S = n(118);
        t.isotope = a(S);
        var w = n(119);
        t.marrakesh = a(w);
        var A = n(120);
        t.mocha = a(A);
        var M = n(121);
        t.monokai = a(M);
        var P = n(122);
        t.ocean = a(P);
        var F = n(123);
        t.paraiso = a(F);
        var D = n(124);
        t.pop = a(D);
        var I = n(125);
        t.railscasts = a(I);
        var R = n(126);
        t.shapeshifter = a(R);
        var L = n(127);
        t.solarized = a(L);
        var B = n(128);
        t.summerfruit = a(B);
        var N = n(129);
        t.tomorrow = a(N);
        var z = n(130);
        t.tube = a(z);
        var T = n(131);
        t.twilight = a(T);
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "threezerotwofour", author: "jan t. sott (http://github.com/idleberg)", base00: "#090300", base01: "#3a3432", base02: "#4a4543", base03: "#5c5855", base04: "#807d7c", base05: "#a5a2a2", base06: "#d6d5d4", base07: "#f7f7f7", base08: "#db2d20", base09: "#e8bbd0", base0A: "#fded02", base0B: "#01a252", base0C: "#b5e4f4", base0D: "#01a0e4", base0E: "#a16a94", base0F: "#cdab53" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "apathy", author: "jannik siebert (https://github.com/janniks)", base00: "#031A16", base01: "#0B342D", base02: "#184E45", base03: "#2B685E", base04: "#5F9C92", base05: "#81B5AC", base06: "#A7CEC8", base07: "#D2E7E4", base08: "#3E9688", base09: "#3E7996", base0A: "#3E4C96", base0B: "#883E96", base0C: "#963E4C", base0D: "#96883E", base0E: "#4C963E", base0F: "#3E965B" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "ashes", author: "jannik siebert (https://github.com/janniks)", base00: "#1C2023", base01: "#393F45", base02: "#565E65", base03: "#747C84", base04: "#ADB3BA", base05: "#C7CCD1", base06: "#DFE2E5", base07: "#F3F4F5", base08: "#C7AE95", base09: "#C7C795", base0A: "#AEC795", base0B: "#95C7AE", base0C: "#95AEC7", base0D: "#AE95C7", base0E: "#C795AE", base0F: "#C79595" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "atelier dune", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune)", base00: "#20201d", base01: "#292824", base02: "#6e6b5e", base03: "#7d7a68", base04: "#999580", base05: "#a6a28c", base06: "#e8e4cf", base07: "#fefbec", base08: "#d73737", base09: "#b65611", base0A: "#cfb017", base0B: "#60ac39", base0C: "#1fad83", base0D: "#6684e1", base0E: "#b854d4", base0F: "#d43552" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "atelier forest", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest)", base00: "#1b1918", base01: "#2c2421", base02: "#68615e", base03: "#766e6b", base04: "#9c9491", base05: "#a8a19f", base06: "#e6e2e0", base07: "#f1efee", base08: "#f22c40", base09: "#df5320", base0A: "#d5911a", base0B: "#5ab738", base0C: "#00ad9c", base0D: "#407ee7", base0E: "#6666ea", base0F: "#c33ff3" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "atelier heath", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/heath)", base00: "#1b181b", base01: "#292329", base02: "#695d69", base03: "#776977", base04: "#9e8f9e", base05: "#ab9bab", base06: "#d8cad8", base07: "#f7f3f7", base08: "#ca402b", base09: "#a65926", base0A: "#bb8a35", base0B: "#379a37", base0C: "#159393", base0D: "#516aec", base0E: "#7b59c0", base0F: "#cc33cc" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "atelier lakeside", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/lakeside/)", base00: "#161b1d", base01: "#1f292e", base02: "#516d7b", base03: "#5a7b8c", base04: "#7195a8", base05: "#7ea2b4", base06: "#c1e4f6", base07: "#ebf8ff", base08: "#d22d72", base09: "#935c25", base0A: "#8a8a0f", base0B: "#568c3b", base0C: "#2d8f6f", base0D: "#257fad", base0E: "#5d5db1", base0F: "#b72dd2" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "atelier seaside", author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/seaside/)", base00: "#131513", base01: "#242924", base02: "#5e6e5e", base03: "#687d68", base04: "#809980", base05: "#8ca68c", base06: "#cfe8cf", base07: "#f0fff0", base08: "#e6193c", base09: "#87711d", base0A: "#c3c322", base0B: "#29a329", base0C: "#1999b3", base0D: "#3d62f5", base0E: "#ad2bee", base0F: "#e619c3" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "bespin", author: "jan t. sott", base00: "#28211c", base01: "#36312e", base02: "#5e5d5c", base03: "#666666", base04: "#797977", base05: "#8a8986", base06: "#9d9b97", base07: "#baae9e", base08: "#cf6a4c", base09: "#cf7d34", base0A: "#f9ee98", base0B: "#54be0d", base0C: "#afc4db", base0D: "#5ea6ea", base0E: "#9b859d", base0F: "#937121" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "brewer", author: "timothe poisot (http://github.com/tpoisot)", base00: "#0c0d0e", base01: "#2e2f30", base02: "#515253", base03: "#737475", base04: "#959697", base05: "#b7b8b9", base06: "#dadbdc", base07: "#fcfdfe", base08: "#e31a1c", base09: "#e6550d", base0A: "#dca060", base0B: "#31a354", base0C: "#80b1d3", base0D: "#3182bd", base0E: "#756bb1", base0F: "#b15928" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "bright", author: "chris kempson (http://chriskempson.com)", base00: "#000000", base01: "#303030", base02: "#505050", base03: "#b0b0b0", base04: "#d0d0d0", base05: "#e0e0e0", base06: "#f5f5f5", base07: "#ffffff", base08: "#fb0120", base09: "#fc6d24", base0A: "#fda331", base0B: "#a1c659", base0C: "#76c7b7", base0D: "#6fb3d2", base0E: "#d381c3", base0F: "#be643c" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "chalk", author: "chris kempson (http://chriskempson.com)", base00: "#151515", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#b0b0b0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#f5f5f5", base08: "#fb9fb1", base09: "#eda987", base0A: "#ddb26f", base0B: "#acc267", base0C: "#12cfc0", base0D: "#6fc2ef", base0E: "#e1a3ee", base0F: "#deaf8f" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "codeschool", author: "brettof86", base00: "#232c31", base01: "#1c3657", base02: "#2a343a", base03: "#3f4944", base04: "#84898c", base05: "#9ea7a6", base06: "#a7cfa3", base07: "#b5d8f6", base08: "#2a5491", base09: "#43820d", base0A: "#a03b1e", base0B: "#237986", base0C: "#b02f30", base0D: "#484d79", base0E: "#c59820", base0F: "#c98344" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "colors", author: "mrmrs (http://clrs.cc)", base00: "#111111", base01: "#333333", base02: "#555555", base03: "#777777", base04: "#999999", base05: "#bbbbbb", base06: "#dddddd", base07: "#ffffff", base08: "#ff4136", base09: "#ff851b", base0A: "#ffdc00", base0B: "#2ecc40", base0C: "#7fdbff", base0D: "#0074d9", base0E: "#b10dc9", base0F: "#85144b" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "default", author: "chris kempson (http://chriskempson.com)", base00: "#181818", base01: "#282828", base02: "#383838", base03: "#585858", base04: "#b8b8b8", base05: "#d8d8d8", base06: "#e8e8e8", base07: "#f8f8f8", base08: "#ab4642", base09: "#dc9656", base0A: "#f7ca88", base0B: "#a1b56c", base0C: "#86c1b9", base0D: "#7cafc2", base0E: "#ba8baf", base0F: "#a16946" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "eighties", author: "chris kempson (http://chriskempson.com)", base00: "#2d2d2d", base01: "#393939", base02: "#515151", base03: "#747369", base04: "#a09f93", base05: "#d3d0c8", base06: "#e8e6df", base07: "#f2f0ec", base08: "#f2777a", base09: "#f99157", base0A: "#ffcc66", base0B: "#99cc99", base0C: "#66cccc", base0D: "#6699cc", base0E: "#cc99cc", base0F: "#d27b53" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "embers", author: "jannik siebert (https://github.com/janniks)", base00: "#16130F", base01: "#2C2620", base02: "#433B32", base03: "#5A5047", base04: "#8A8075", base05: "#A39A90", base06: "#BEB6AE", base07: "#DBD6D1", base08: "#826D57", base09: "#828257", base0A: "#6D8257", base0B: "#57826D", base0C: "#576D82", base0D: "#6D5782", base0E: "#82576D", base0F: "#825757" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "flat", author: "chris kempson (http://chriskempson.com)", base00: "#2C3E50", base01: "#34495E", base02: "#7F8C8D", base03: "#95A5A6", base04: "#BDC3C7", base05: "#e0e0e0", base06: "#f5f5f5", base07: "#ECF0F1", base08: "#E74C3C", base09: "#E67E22", base0A: "#F1C40F", base0B: "#2ECC71", base0C: "#1ABC9C", base0D: "#3498DB", base0E: "#9B59B6", base0F: "#be643c" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "google", author: "seth wright (http://sethawright.com)", base00: "#1d1f21", base01: "#282a2e", base02: "#373b41", base03: "#969896", base04: "#b4b7b4", base05: "#c5c8c6", base06: "#e0e0e0", base07: "#ffffff", base08: "#CC342B", base09: "#F96A38", base0A: "#FBA922", base0B: "#198844", base0C: "#3971ED", base0D: "#3971ED", base0E: "#A36AC7", base0F: "#3971ED" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "grayscale", author: "alexandre gavioli (https://github.com/alexx2/)", base00: "#101010", base01: "#252525", base02: "#464646", base03: "#525252", base04: "#ababab", base05: "#b9b9b9", base06: "#e3e3e3", base07: "#f7f7f7", base08: "#7c7c7c", base09: "#999999", base0A: "#a0a0a0", base0B: "#8e8e8e", base0C: "#868686", base0D: "#686868", base0E: "#747474", base0F: "#5e5e5e" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "green screen", author: "chris kempson (http://chriskempson.com)", base00: "#001100", base01: "#003300", base02: "#005500", base03: "#007700", base04: "#009900", base05: "#00bb00", base06: "#00dd00", base07: "#00ff00", base08: "#007700", base09: "#009900", base0A: "#007700", base0B: "#00bb00", base0C: "#005500", base0D: "#009900", base0E: "#00bb00", base0F: "#005500" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "harmonic16", author: "jannik siebert (https://github.com/janniks)", base00: "#0b1c2c", base01: "#223b54", base02: "#405c79", base03: "#627e99", base04: "#aabcce", base05: "#cbd6e2", base06: "#e5ebf1", base07: "#f7f9fb", base08: "#bf8b56", base09: "#bfbf56", base0A: "#8bbf56", base0B: "#56bf8b", base0C: "#568bbf", base0D: "#8b56bf", base0E: "#bf568b", base0F: "#bf5656" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "hopscotch", author: "jan t. sott", base00: "#322931", base01: "#433b42", base02: "#5c545b", base03: "#797379", base04: "#989498", base05: "#b9b5b8", base06: "#d5d3d5", base07: "#ffffff", base08: "#dd464c", base09: "#fd8b19", base0A: "#fdcc59", base0B: "#8fc13e", base0C: "#149b93", base0D: "#1290bf", base0E: "#c85e7c", base0F: "#b33508" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "isotope", author: "jan t. sott", base00: "#000000", base01: "#404040", base02: "#606060", base03: "#808080", base04: "#c0c0c0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#ffffff", base08: "#ff0000", base09: "#ff9900", base0A: "#ff0099", base0B: "#33ff00", base0C: "#00ffff", base0D: "#0066ff", base0E: "#cc00ff", base0F: "#3300ff" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "marrakesh", author: "alexandre gavioli (http://github.com/alexx2/)", base00: "#201602", base01: "#302e00", base02: "#5f5b17", base03: "#6c6823", base04: "#86813b", base05: "#948e48", base06: "#ccc37a", base07: "#faf0a5", base08: "#c35359", base09: "#b36144", base0A: "#a88339", base0B: "#18974e", base0C: "#75a738", base0D: "#477ca1", base0E: "#8868b3", base0F: "#b3588e" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "mocha", author: "chris kempson (http://chriskempson.com)", base00: "#3B3228", base01: "#534636", base02: "#645240", base03: "#7e705a", base04: "#b8afad", base05: "#d0c8c6", base06: "#e9e1dd", base07: "#f5eeeb", base08: "#cb6077", base09: "#d28b71", base0A: "#f4bc87", base0B: "#beb55b", base0C: "#7bbda4", base0D: "#8ab3b5", base0E: "#a89bb9", base0F: "#bb9584" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "monokai", author: "wimer hazenberg (http://www.monokai.nl)", base00: "#272822", base01: "#383830", base02: "#49483e", base03: "#75715e", base04: "#a59f85", base05: "#f8f8f2", base06: "#f5f4f1", base07: "#f9f8f5", base08: "#f92672", base09: "#fd971f", base0A: "#f4bf75", base0B: "#a6e22e", base0C: "#a1efe4", base0D: "#66d9ef", base0E: "#ae81ff", base0F: "#cc6633" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "ocean", author: "chris kempson (http://chriskempson.com)", base00: "#2b303b", base01: "#343d46", base02: "#4f5b66", base03: "#65737e", base04: "#a7adba", base05: "#c0c5ce", base06: "#dfe1e8", base07: "#eff1f5", base08: "#bf616a", base09: "#d08770", base0A: "#ebcb8b", base0B: "#a3be8c", base0C: "#96b5b4", base0D: "#8fa1b3", base0E: "#b48ead", base0F: "#ab7967" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "paraiso", author: "jan t. sott", base00: "#2f1e2e", base01: "#41323f", base02: "#4f424c", base03: "#776e71", base04: "#8d8687", base05: "#a39e9b", base06: "#b9b6b0", base07: "#e7e9db", base08: "#ef6155", base09: "#f99b15", base0A: "#fec418", base0B: "#48b685", base0C: "#5bc4bf", base0D: "#06b6ef", base0E: "#815ba4", base0F: "#e96ba8" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "pop", author: "chris kempson (http://chriskempson.com)", base00: "#000000", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#b0b0b0", base05: "#d0d0d0", base06: "#e0e0e0", base07: "#ffffff", base08: "#eb008a", base09: "#f29333", base0A: "#f8ca12", base0B: "#37b349", base0C: "#00aabb", base0D: "#0e5a94", base0E: "#b31e8d", base0F: "#7a2d00" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "railscasts", author: "ryan bates (http://railscasts.com)", base00: "#2b2b2b", base01: "#272935", base02: "#3a4055", base03: "#5a647e", base04: "#d4cfc9", base05: "#e6e1dc", base06: "#f4f1ed", base07: "#f9f7f3", base08: "#da4939", base09: "#cc7833", base0A: "#ffc66d", base0B: "#a5c261", base0C: "#519f50", base0D: "#6d9cbe", base0E: "#b6b3eb", base0F: "#bc9458" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "shapeshifter", author: "tyler benziger (http://tybenz.com)", base00: "#000000", base01: "#040404", base02: "#102015", base03: "#343434", base04: "#555555", base05: "#ababab", base06: "#e0e0e0", base07: "#f9f9f9", base08: "#e92f2f", base09: "#e09448", base0A: "#dddd13", base0B: "#0ed839", base0C: "#23edda", base0D: "#3b48e3", base0E: "#f996e2", base0F: "#69542d" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "solarized", author: "ethan schoonover (http://ethanschoonover.com/solarized)", base00: "#002b36", base01: "#073642", base02: "#586e75", base03: "#657b83", base04: "#839496", base05: "#93a1a1", base06: "#eee8d5", base07: "#fdf6e3", base08: "#dc322f", base09: "#cb4b16", base0A: "#b58900", base0B: "#859900", base0C: "#2aa198", base0D: "#268bd2", base0E: "#6c71c4", base0F: "#d33682" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "summerfruit", author: "christopher corley (http://cscorley.github.io/)", base00: "#151515", base01: "#202020", base02: "#303030", base03: "#505050", base04: "#B0B0B0", base05: "#D0D0D0", base06: "#E0E0E0", base07: "#FFFFFF", base08: "#FF0086", base09: "#FD8900", base0A: "#ABA800", base0B: "#00C918", base0C: "#1faaaa", base0D: "#3777E6", base0E: "#AD00A1", base0F: "#cc6633" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "tomorrow", author: "chris kempson (http://chriskempson.com)", base00: "#1d1f21", base01: "#282a2e", base02: "#373b41", base03: "#969896", base04: "#b4b7b4", base05: "#c5c8c6", base06: "#e0e0e0", base07: "#ffffff", base08: "#cc6666", base09: "#de935f", base0A: "#f0c674", base0B: "#b5bd68", base0C: "#8abeb7", base0D: "#81a2be", base0E: "#b294bb", base0F: "#a3685a" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "london tube", author: "jan t. sott", base00: "#231f20", base01: "#1c3f95", base02: "#5a5758", base03: "#737171", base04: "#959ca1", base05: "#d9d8d8", base06: "#e7e7e8", base07: "#ffffff", base08: "#ee2e24", base09: "#f386a1", base0A: "#ffd204", base0B: "#00853e", base0C: "#85cebc", base0D: "#009ddc", base0E: "#98005d", base0F: "#b06110" }, e2.exports = t.default;
      }, function(e2, t, n) {
        t.__esModule = true, t.default = { scheme: "twilight", author: "david hart (http://hart-dev.com)", base00: "#1e1e1e", base01: "#323537", base02: "#464b50", base03: "#5f5a60", base04: "#838184", base05: "#a7a7a7", base06: "#c3c3c3", base07: "#ffffff", base08: "#cf6a4c", base09: "#cda869", base0A: "#f9ee98", base0B: "#8f9d6a", base0C: "#afc4db", base0D: "#7587a6", base0E: "#9b859d", base0F: "#9b703f" }, e2.exports = t.default;
      }, function(e2, t, n) {
        var a = n(33);
        function r2(e3) {
          var t2 = Math.round(a(e3, 0, 255)).toString(16);
          return 1 == t2.length ? "0" + t2 : t2;
        }
        e2.exports = function(e3) {
          var t2 = 4 === e3.length ? r2(255 * e3[3]) : "";
          return "#" + r2(e3[0]) + r2(e3[1]) + r2(e3[2]) + t2;
        };
      }, function(e2, t, n) {
        var a = n(134), r2 = n(135), o = n(136), i = n(137);
        var s = { "#": r2, hsl: function(e3) {
          var t2 = a(e3), n2 = i(t2);
          return 4 === t2.length && n2.push(t2[3]), n2;
        }, rgb: o };
        function c(e3) {
          for (var t2 in s) if (0 === e3.indexOf(t2)) return s[t2](e3);
        }
        c.rgb = o, c.hsl = a, c.hex = r2, e2.exports = c;
      }, function(e2, t, n) {
        var a = n(44), r2 = n(33);
        function o(e3, t2) {
          switch (e3 = parseFloat(e3), t2) {
            case 0:
              return r2(e3, 0, 360);
            case 1:
            case 2:
              return r2(e3, 0, 100);
            case 3:
              return r2(e3, 0, 1);
          }
        }
        e2.exports = function(e3) {
          return a(e3).map(o);
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          4 !== e3.length && 5 !== e3.length || (e3 = function(e4) {
            for (var t3 = "#", n2 = 1; n2 < e4.length; n2++) {
              var a = e4.charAt(n2);
              t3 += a + a;
            }
            return t3;
          }(e3));
          var t2 = [parseInt(e3.substring(1, 3), 16), parseInt(e3.substring(3, 5), 16), parseInt(e3.substring(5, 7), 16)];
          if (9 === e3.length) {
            var n = parseFloat((parseInt(e3.substring(7, 9), 16) / 255).toFixed(2));
            t2.push(n);
          }
          return t2;
        };
      }, function(e2, t, n) {
        var a = n(44), r2 = n(33);
        function o(e3, t2) {
          return t2 < 3 ? -1 != e3.indexOf("%") ? Math.round(255 * r2(parseInt(e3, 10), 0, 100) / 100) : r2(parseInt(e3, 10), 0, 255) : r2(parseFloat(e3), 0, 1);
        }
        e2.exports = function(e3) {
          return a(e3).map(o);
        };
      }, function(e2, t) {
        e2.exports = function(e3) {
          var t2, n, a, r2, o, i = e3[0] / 360, s = e3[1] / 100, c = e3[2] / 100;
          if (0 == s) return [o = 255 * c, o, o];
          t2 = 2 * c - (n = c < 0.5 ? c * (1 + s) : c + s - c * s), r2 = [0, 0, 0];
          for (var l = 0; l < 3; l++) (a = i + 1 / 3 * -(l - 1)) < 0 && a++, a > 1 && a--, o = 6 * a < 1 ? t2 + 6 * (n - t2) * a : 2 * a < 1 ? n : 3 * a < 2 ? t2 + (n - t2) * (2 / 3 - a) * 6 : t2, r2[l] = 255 * o;
          return r2;
        };
      }, function(e2, t, n) {
        (function(t2) {
          var n2 = "object" == typeof t2 && t2 && t2.Object === Object && t2, a = "object" == typeof self && self && self.Object === Object && self, r2 = n2 || a || Function("return this")();
          function o(e3, t3, n3) {
            switch (n3.length) {
              case 0:
                return e3.call(t3);
              case 1:
                return e3.call(t3, n3[0]);
              case 2:
                return e3.call(t3, n3[0], n3[1]);
              case 3:
                return e3.call(t3, n3[0], n3[1], n3[2]);
            }
            return e3.apply(t3, n3);
          }
          function i(e3, t3) {
            for (var n3 = -1, a2 = t3.length, r3 = e3.length; ++n3 < a2; ) e3[r3 + n3] = t3[n3];
            return e3;
          }
          var s = Object.prototype, c = s.hasOwnProperty, l = s.toString, u = r2.Symbol, f = s.propertyIsEnumerable, p = u ? u.isConcatSpreadable : void 0, d2 = Math.max;
          function b(e3) {
            return h(e3) || function(e4) {
              return function(e5) {
                return /* @__PURE__ */ function(e6) {
                  return !!e6 && "object" == typeof e6;
                }(e5) && function(e6) {
                  return null != e6 && function(e7) {
                    return "number" == typeof e7 && e7 > -1 && e7 % 1 == 0 && e7 <= 9007199254740991;
                  }(e6.length) && !function(e7) {
                    var t3 = function(e8) {
                      var t4 = typeof e8;
                      return !!e8 && ("object" == t4 || "function" == t4);
                    }(e7) ? l.call(e7) : "";
                    return "[object Function]" == t3 || "[object GeneratorFunction]" == t3;
                  }(e6);
                }(e5);
              }(e4) && c.call(e4, "callee") && (!f.call(e4, "callee") || "[object Arguments]" == l.call(e4));
            }(e3) || !!(p && e3 && e3[p]);
          }
          var h = Array.isArray;
          var v, m, y2, g = (m = function(e3) {
            var t3 = (e3 = function e4(t4, n4, a2, r3, o2) {
              var s2 = -1, c2 = t4.length;
              for (a2 || (a2 = b), o2 || (o2 = []); ++s2 < c2; ) {
                var l2 = t4[s2];
                a2(l2) ? i(o2, l2) : o2[o2.length] = l2;
              }
              return o2;
            }(e3)).length, n3 = t3;
            for (v; n3--; ) if ("function" != typeof e3[n3]) throw new TypeError("Expected a function");
            return function() {
              for (var n4 = 0, a2 = t3 ? e3[n4].apply(this, arguments) : arguments[0]; ++n4 < t3; ) a2 = e3[n4].call(this, a2);
              return a2;
            };
          }, y2 = d2(void 0 === y2 ? m.length - 1 : y2, 0), function() {
            for (var e3 = arguments, t3 = -1, n3 = d2(e3.length - y2, 0), a2 = Array(n3); ++t3 < n3; ) a2[t3] = e3[y2 + t3];
            t3 = -1;
            for (var r3 = Array(y2 + 1); ++t3 < y2; ) r3[t3] = e3[t3];
            return r3[y2] = a2, o(m, this, r3);
          });
          e2.exports = g;
        }).call(this, n(43));
      }, function(e2, t, n) {
        Object.defineProperty(t, "__esModule", { value: true }), t.yuv2rgb = function(e3) {
          var t2, n2, a, r2 = e3[0], o = e3[1], i = e3[2];
          return t2 = 1 * r2 + 0 * o + 1.13983 * i, n2 = 1 * r2 + -0.39465 * o + -0.5806 * i, a = 1 * r2 + 2.02311 * o + 0 * i, t2 = Math.min(Math.max(0, t2), 1), n2 = Math.min(Math.max(0, n2), 1), a = Math.min(Math.max(0, a), 1), [255 * t2, 255 * n2, 255 * a];
        }, t.rgb2yuv = function(e3) {
          var t2 = e3[0] / 255, n2 = e3[1] / 255, a = e3[2] / 255;
          return [0.299 * t2 + 0.587 * n2 + 0.114 * a, -0.14713 * t2 + -0.28886 * n2 + 0.436 * a, 0.615 * t2 + -0.51499 * n2 + -0.10001 * a];
        };
      }, function(e2, t, n) {
        function a(e3, t2, n2) {
          return t2 in e3 ? Object.defineProperty(e3, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t2] = n2, e3;
        }
        var r2 = n(141), o = function() {
          function e3() {
            a(this, "_callbacks", void 0), a(this, "_isDispatching", void 0), a(this, "_isHandled", void 0), a(this, "_isPending", void 0), a(this, "_lastID", void 0), a(this, "_pendingPayload", void 0), this._callbacks = {}, this._isDispatching = false, this._isHandled = {}, this._isPending = {}, this._lastID = 1;
          }
          var t2 = e3.prototype;
          return t2.register = function(e4) {
            var t3 = "ID_" + this._lastID++;
            return this._callbacks[t3] = e4, t3;
          }, t2.unregister = function(e4) {
            this._callbacks[e4] || r2(false), delete this._callbacks[e4];
          }, t2.waitFor = function(e4) {
            this._isDispatching || r2(false);
            for (var t3 = 0; t3 < e4.length; t3++) {
              var n2 = e4[t3];
              this._isPending[n2] ? this._isHandled[n2] || r2(false) : (this._callbacks[n2] || r2(false), this._invokeCallback(n2));
            }
          }, t2.dispatch = function(e4) {
            this._isDispatching && r2(false), this._startDispatching(e4);
            try {
              for (var t3 in this._callbacks) this._isPending[t3] || this._invokeCallback(t3);
            } finally {
              this._stopDispatching();
            }
          }, t2.isDispatching = function() {
            return this._isDispatching;
          }, t2._invokeCallback = function(e4) {
            this._isPending[e4] = true, this._callbacks[e4](this._pendingPayload), this._isHandled[e4] = true;
          }, t2._startDispatching = function(e4) {
            for (var t3 in this._callbacks) this._isPending[t3] = false, this._isHandled[t3] = false;
            this._pendingPayload = e4, this._isDispatching = true;
          }, t2._stopDispatching = function() {
            delete this._pendingPayload, this._isDispatching = false;
          }, e3;
        }();
        e2.exports = o;
      }, function(e2, t, n) {
        e2.exports = function(e3, t2) {
          for (var n2 = arguments.length, r2 = new Array(n2 > 2 ? n2 - 2 : 0), o = 2; o < n2; o++) r2[o - 2] = arguments[o];
          if (!e3) {
            var i;
            if (void 0 === t2) i = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
            else {
              var s = 0;
              (i = new Error(t2.replace(/%s/g, function() {
                return String(r2[s++]);
              }))).name = "Invariant Violation";
            }
            throw i.framesToPop = 1, i;
          }
        };
      }, function(e2, t, n) {
        function a(e3, t2, n2) {
          return t2 in e3 ? Object.defineProperty(e3, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e3[t2] = n2, e3;
        }
        function r2(e3, t2) {
          var n2 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var a2 = Object.getOwnPropertySymbols(e3);
            t2 && (a2 = a2.filter(function(t3) {
              return Object.getOwnPropertyDescriptor(e3, t3).enumerable;
            })), n2.push.apply(n2, a2);
          }
          return n2;
        }
        function o(e3) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var n2 = null != arguments[t2] ? arguments[t2] : {};
            t2 % 2 ? r2(Object(n2), true).forEach(function(t3) {
              a(e3, t3, n2[t3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n2)) : r2(Object(n2)).forEach(function(t3) {
              Object.defineProperty(e3, t3, Object.getOwnPropertyDescriptor(n2, t3));
            });
          }
          return e3;
        }
        function i(e3, t2) {
          if (!(e3 instanceof t2)) throw new TypeError("Cannot call a class as a function");
        }
        function s(e3, t2) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var a2 = t2[n2];
            a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(e3, a2.key, a2);
          }
        }
        function c(e3, t2, n2) {
          return t2 && s(e3.prototype, t2), n2 && s(e3, n2), e3;
        }
        function l(e3, t2) {
          return (l = Object.setPrototypeOf || function(e4, t3) {
            return e4.__proto__ = t3, e4;
          })(e3, t2);
        }
        function u(e3, t2) {
          if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
          e3.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e3, writable: true, configurable: true } }), t2 && l(e3, t2);
        }
        function f(e3) {
          return (f = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
            return e4.__proto__ || Object.getPrototypeOf(e4);
          })(e3);
        }
        function p(e3) {
          return (p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          })(e3);
        }
        function d2(e3) {
          if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return e3;
        }
        function b(e3, t2) {
          return !t2 || "object" !== p(t2) && "function" != typeof t2 ? d2(e3) : t2;
        }
        function h(e3) {
          var t2 = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct) return false;
            if (Reflect.construct.sham) return false;
            if ("function" == typeof Proxy) return true;
            try {
              return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              })), true;
            } catch (e4) {
              return false;
            }
          }();
          return function() {
            var n2, a2 = f(e3);
            if (t2) {
              var r3 = f(this).constructor;
              n2 = Reflect.construct(a2, arguments, r3);
            } else n2 = a2.apply(this, arguments);
            return b(this, n2);
          };
        }
        n.r(t);
        var v = n(0), m = n.n(v);
        function y2() {
          var e3 = this.constructor.getDerivedStateFromProps(this.props, this.state);
          null != e3 && this.setState(e3);
        }
        function g(e3) {
          this.setState((function(t2) {
            var n2 = this.constructor.getDerivedStateFromProps(e3, t2);
            return null != n2 ? n2 : null;
          }).bind(this));
        }
        function E(e3, t2) {
          try {
            var n2 = this.props, a2 = this.state;
            this.props = e3, this.state = t2, this.__reactInternalSnapshotFlag = true, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(n2, a2);
          } finally {
            this.props = n2, this.state = a2;
          }
        }
        function j(e3) {
          var t2 = e3.prototype;
          if (!t2 || !t2.isReactComponent) throw new Error("Can only polyfill class components");
          if ("function" != typeof e3.getDerivedStateFromProps && "function" != typeof t2.getSnapshotBeforeUpdate) return e3;
          var n2 = null, a2 = null, r3 = null;
          if ("function" == typeof t2.componentWillMount ? n2 = "componentWillMount" : "function" == typeof t2.UNSAFE_componentWillMount && (n2 = "UNSAFE_componentWillMount"), "function" == typeof t2.componentWillReceiveProps ? a2 = "componentWillReceiveProps" : "function" == typeof t2.UNSAFE_componentWillReceiveProps && (a2 = "UNSAFE_componentWillReceiveProps"), "function" == typeof t2.componentWillUpdate ? r3 = "componentWillUpdate" : "function" == typeof t2.UNSAFE_componentWillUpdate && (r3 = "UNSAFE_componentWillUpdate"), null !== n2 || null !== a2 || null !== r3) {
            var o2 = e3.displayName || e3.name, i2 = "function" == typeof e3.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + o2 + " uses " + i2 + " but also contains the following legacy lifecycles:" + (null !== n2 ? "\n  " + n2 : "") + (null !== a2 ? "\n  " + a2 : "") + (null !== r3 ? "\n  " + r3 : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks");
          }
          if ("function" == typeof e3.getDerivedStateFromProps && (t2.componentWillMount = y2, t2.componentWillReceiveProps = g), "function" == typeof t2.getSnapshotBeforeUpdate) {
            if ("function" != typeof t2.componentDidUpdate) throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
            t2.componentWillUpdate = E;
            var s2 = t2.componentDidUpdate;
            t2.componentDidUpdate = function(e4, t3, n3) {
              var a3 = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : n3;
              s2.call(this, e4, t3, a3);
            };
          }
          return e3;
        }
        function x2(e3, t2) {
          if (null == e3) return {};
          var n2, a2, r3 = function(e4, t3) {
            if (null == e4) return {};
            var n3, a3, r4 = {}, o3 = Object.keys(e4);
            for (a3 = 0; a3 < o3.length; a3++) n3 = o3[a3], t3.indexOf(n3) >= 0 || (r4[n3] = e4[n3]);
            return r4;
          }(e3, t2);
          if (Object.getOwnPropertySymbols) {
            var o2 = Object.getOwnPropertySymbols(e3);
            for (a2 = 0; a2 < o2.length; a2++) n2 = o2[a2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e3, n2) && (r3[n2] = e3[n2]);
          }
          return r3;
        }
        function _(e3) {
          var t2 = function(e4) {
            return {}.toString.call(e4).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
          }(e3);
          return "number" === t2 && (t2 = isNaN(e3) ? "nan" : (0 | e3) != e3 ? "float" : "integer"), t2;
        }
        y2.__suppressDeprecationWarning = true, g.__suppressDeprecationWarning = true, E.__suppressDeprecationWarning = true;
        var k = { scheme: "rjv-default", author: "mac gainor", base00: "rgba(0, 0, 0, 0)", base01: "rgb(245, 245, 245)", base02: "rgb(235, 235, 235)", base03: "#93a1a1", base04: "rgba(0, 0, 0, 0.3)", base05: "#586e75", base06: "#073642", base07: "#002b36", base08: "#d33682", base09: "#cb4b16", base0A: "#dc322f", base0B: "#859900", base0C: "#6c71c4", base0D: "#586e75", base0E: "#2aa198", base0F: "#268bd2" }, O = { scheme: "rjv-grey", author: "mac gainor", base00: "rgba(1, 1, 1, 0)", base01: "rgba(1, 1, 1, 0.1)", base02: "rgba(0, 0, 0, 0.2)", base03: "rgba(1, 1, 1, 0.3)", base04: "rgba(0, 0, 0, 0.4)", base05: "rgba(1, 1, 1, 0.5)", base06: "rgba(1, 1, 1, 0.6)", base07: "rgba(1, 1, 1, 0.7)", base08: "rgba(1, 1, 1, 0.8)", base09: "rgba(1, 1, 1, 0.8)", base0A: "rgba(1, 1, 1, 0.8)", base0B: "rgba(1, 1, 1, 0.8)", base0C: "rgba(1, 1, 1, 0.8)", base0D: "rgba(1, 1, 1, 0.8)", base0E: "rgba(1, 1, 1, 0.8)", base0F: "rgba(1, 1, 1, 0.8)" }, C = { globalFontFamily: "monospace", globalCursor: "default", braceFontWeight: "bold", braceCursor: "pointer", ellipsisFontSize: "18px", ellipsisLineHeight: "10px", ellipsisCursor: "pointer", keyMargin: "0px 5px", keyLetterSpacing: "0.5px", keyFontStyle: "none", keyVerticalAlign: "top", keyOpacity: "0.85", keyOpacityHover: "1", keyValPaddingTop: "3px", keyValPaddingBottom: "3px", keyValPaddingRight: "5px", keyValBorderLeft: "1px solid", keyValBorderHover: "2px solid", pushedContentMarginLeft: "6px", variableValuePaddingRight: "6px", nullFontSize: "11px", nullFontWeight: "bold", nullPadding: "1px 2px", nullBorderRadius: "3px", nanFontSize: "11px", nanFontWeight: "bold", nanPadding: "1px 2px", nanBorderRadius: "3px", undefinedFontSize: "11px", undefinedPadding: "1px 2px", undefinedBorderRadius: "3px", dataTypeFontSize: "11px", dataTypeMarginRight: "4px", datatypeOpacity: "0.8", objectSizeBorderRadius: "3px", objectSizeFontStyle: "italic", objectSizeMargin: "0px 6px 0px 0px", clipboardCursor: "pointer", clipboardCheckMarginLeft: "-12px", metaDataPadding: "0px 0px 0px 10px", arrayGroupMetaPadding: "0px 0px 0px 4px", iconContainerWidth: "17px", tooltipPadding: "4px", editInputMinWidth: "130px", editInputBorderRadius: "2px", editInputPadding: "5px", editInputMarginRight: "4px", editInputFontFamily: "monospace", iconCursor: "pointer", iconFontSize: "15px", iconPaddingRight: "1px", dateValueMarginLeft: "2px", iconMarginRight: "3px", detectedRowPaddingTop: "3px", addKeyCoverBackground: "rgba(255, 255, 255, 0.3)", addKeyCoverPosition: "absolute", addKeyCoverPositionPx: "0px", addKeyModalWidth: "200px", addKeyModalMargin: "auto", addKeyModalPadding: "10px", addKeyModalRadius: "3px" }, S = n(45), w = function(e3) {
          var t2 = function(e4) {
            return { backgroundColor: e4.base00, ellipsisColor: e4.base09, braceColor: e4.base07, expandedIcon: e4.base0D, collapsedIcon: e4.base0E, keyColor: e4.base07, arrayKeyColor: e4.base0C, objectSize: e4.base04, copyToClipboard: e4.base0F, copyToClipboardCheck: e4.base0D, objectBorder: e4.base02, dataTypes: { boolean: e4.base0E, date: e4.base0D, float: e4.base0B, function: e4.base0D, integer: e4.base0F, string: e4.base09, nan: e4.base08, null: e4.base0A, undefined: e4.base05, regexp: e4.base0A, background: e4.base02 }, editVariable: { editIcon: e4.base0E, cancelIcon: e4.base09, removeIcon: e4.base09, addIcon: e4.base0E, checkIcon: e4.base0E, background: e4.base01, color: e4.base0A, border: e4.base07 }, addKeyModal: { background: e4.base05, border: e4.base04, color: e4.base0A, labelColor: e4.base01 }, validationFailure: { background: e4.base09, iconColor: e4.base01, fontColor: e4.base01 } };
          }(e3);
          return { "app-container": { fontFamily: C.globalFontFamily, cursor: C.globalCursor, backgroundColor: t2.backgroundColor, position: "relative" }, ellipsis: { display: "inline-block", color: t2.ellipsisColor, fontSize: C.ellipsisFontSize, lineHeight: C.ellipsisLineHeight, cursor: C.ellipsisCursor }, "brace-row": { display: "inline-block", cursor: "pointer" }, brace: { display: "inline-block", cursor: C.braceCursor, fontWeight: C.braceFontWeight, color: t2.braceColor }, "expanded-icon": { color: t2.expandedIcon }, "collapsed-icon": { color: t2.collapsedIcon }, colon: { display: "inline-block", margin: C.keyMargin, color: t2.keyColor, verticalAlign: "top" }, objectKeyVal: function(e4, n2) {
            return { style: o({ paddingTop: C.keyValPaddingTop, paddingRight: C.keyValPaddingRight, paddingBottom: C.keyValPaddingBottom, borderLeft: C.keyValBorderLeft + " " + t2.objectBorder, ":hover": { paddingLeft: n2.paddingLeft - 1 + "px", borderLeft: C.keyValBorderHover + " " + t2.objectBorder } }, n2) };
          }, "object-key-val-no-border": { padding: C.keyValPadding }, "pushed-content": { marginLeft: C.pushedContentMarginLeft }, variableValue: function(e4, t3) {
            return { style: o({ display: "inline-block", paddingRight: C.variableValuePaddingRight, position: "relative" }, t3) };
          }, "object-name": { display: "inline-block", color: t2.keyColor, letterSpacing: C.keyLetterSpacing, fontStyle: C.keyFontStyle, verticalAlign: C.keyVerticalAlign, opacity: C.keyOpacity, ":hover": { opacity: C.keyOpacityHover } }, "array-key": { display: "inline-block", color: t2.arrayKeyColor, letterSpacing: C.keyLetterSpacing, fontStyle: C.keyFontStyle, verticalAlign: C.keyVerticalAlign, opacity: C.keyOpacity, ":hover": { opacity: C.keyOpacityHover } }, "object-size": { color: t2.objectSize, borderRadius: C.objectSizeBorderRadius, fontStyle: C.objectSizeFontStyle, margin: C.objectSizeMargin, cursor: "default" }, "data-type-label": { fontSize: C.dataTypeFontSize, marginRight: C.dataTypeMarginRight, opacity: C.datatypeOpacity }, boolean: { display: "inline-block", color: t2.dataTypes.boolean }, date: { display: "inline-block", color: t2.dataTypes.date }, "date-value": { marginLeft: C.dateValueMarginLeft }, float: { display: "inline-block", color: t2.dataTypes.float }, function: { display: "inline-block", color: t2.dataTypes.function, cursor: "pointer", whiteSpace: "pre-line" }, "function-value": { fontStyle: "italic" }, integer: { display: "inline-block", color: t2.dataTypes.integer }, string: { display: "inline-block", color: t2.dataTypes.string }, nan: { display: "inline-block", color: t2.dataTypes.nan, fontSize: C.nanFontSize, fontWeight: C.nanFontWeight, backgroundColor: t2.dataTypes.background, padding: C.nanPadding, borderRadius: C.nanBorderRadius }, null: { display: "inline-block", color: t2.dataTypes.null, fontSize: C.nullFontSize, fontWeight: C.nullFontWeight, backgroundColor: t2.dataTypes.background, padding: C.nullPadding, borderRadius: C.nullBorderRadius }, undefined: { display: "inline-block", color: t2.dataTypes.undefined, fontSize: C.undefinedFontSize, padding: C.undefinedPadding, borderRadius: C.undefinedBorderRadius, backgroundColor: t2.dataTypes.background }, regexp: { display: "inline-block", color: t2.dataTypes.regexp }, "copy-to-clipboard": { cursor: C.clipboardCursor }, "copy-icon": { color: t2.copyToClipboard, fontSize: C.iconFontSize, marginRight: C.iconMarginRight, verticalAlign: "top" }, "copy-icon-copied": { color: t2.copyToClipboardCheck, marginLeft: C.clipboardCheckMarginLeft }, "array-group-meta-data": { display: "inline-block", padding: C.arrayGroupMetaPadding }, "object-meta-data": { display: "inline-block", padding: C.metaDataPadding }, "icon-container": { display: "inline-block", width: C.iconContainerWidth }, tooltip: { padding: C.tooltipPadding }, removeVarIcon: { verticalAlign: "top", display: "inline-block", color: t2.editVariable.removeIcon, cursor: C.iconCursor, fontSize: C.iconFontSize, marginRight: C.iconMarginRight }, addVarIcon: { verticalAlign: "top", display: "inline-block", color: t2.editVariable.addIcon, cursor: C.iconCursor, fontSize: C.iconFontSize, marginRight: C.iconMarginRight }, editVarIcon: { verticalAlign: "top", display: "inline-block", color: t2.editVariable.editIcon, cursor: C.iconCursor, fontSize: C.iconFontSize, marginRight: C.iconMarginRight }, "edit-icon-container": { display: "inline-block", verticalAlign: "top" }, "check-icon": { display: "inline-block", cursor: C.iconCursor, color: t2.editVariable.checkIcon, fontSize: C.iconFontSize, paddingRight: C.iconPaddingRight }, "cancel-icon": { display: "inline-block", cursor: C.iconCursor, color: t2.editVariable.cancelIcon, fontSize: C.iconFontSize, paddingRight: C.iconPaddingRight }, "edit-input": { display: "inline-block", minWidth: C.editInputMinWidth, borderRadius: C.editInputBorderRadius, backgroundColor: t2.editVariable.background, color: t2.editVariable.color, padding: C.editInputPadding, marginRight: C.editInputMarginRight, fontFamily: C.editInputFontFamily }, "detected-row": { paddingTop: C.detectedRowPaddingTop }, "key-modal-request": { position: C.addKeyCoverPosition, top: C.addKeyCoverPositionPx, left: C.addKeyCoverPositionPx, right: C.addKeyCoverPositionPx, bottom: C.addKeyCoverPositionPx, backgroundColor: C.addKeyCoverBackground }, "key-modal": { width: C.addKeyModalWidth, backgroundColor: t2.addKeyModal.background, marginLeft: C.addKeyModalMargin, marginRight: C.addKeyModalMargin, padding: C.addKeyModalPadding, borderRadius: C.addKeyModalRadius, marginTop: "15px", position: "relative" }, "key-modal-label": { color: t2.addKeyModal.labelColor, marginLeft: "2px", marginBottom: "5px", fontSize: "11px" }, "key-modal-input-container": { overflow: "hidden" }, "key-modal-input": { width: "100%", padding: "3px 6px", fontFamily: "monospace", color: t2.addKeyModal.color, border: "none", boxSizing: "border-box", borderRadius: "2px" }, "key-modal-cancel": { backgroundColor: t2.editVariable.removeIcon, position: "absolute", top: "0px", right: "0px", borderRadius: "0px 3px 0px 3px", cursor: "pointer" }, "key-modal-cancel-icon": { color: t2.addKeyModal.labelColor, fontSize: C.iconFontSize, transform: "rotate(45deg)" }, "key-modal-submit": { color: t2.editVariable.addIcon, fontSize: C.iconFontSize, position: "absolute", right: "2px", top: "3px", cursor: "pointer" }, "function-ellipsis": { display: "inline-block", color: t2.ellipsisColor, fontSize: C.ellipsisFontSize, lineHeight: C.ellipsisLineHeight, cursor: C.ellipsisCursor }, "validation-failure": { float: "right", padding: "3px 6px", borderRadius: "2px", cursor: "pointer", color: t2.validationFailure.fontColor, backgroundColor: t2.validationFailure.background }, "validation-failure-label": { marginRight: "6px" }, "validation-failure-clear": { position: "relative", verticalAlign: "top", cursor: "pointer", color: t2.validationFailure.iconColor, fontSize: C.iconFontSize, transform: "rotate(45deg)" } };
        };
        function A(e3, t2, n2) {
          return e3 || console.error("theme has not been set"), function(e4) {
            var t3 = k;
            return false !== e4 && "none" !== e4 || (t3 = O), Object(S.createStyling)(w, { defaultBase16: t3 })(e4);
          }(e3)(t2, n2);
        }
        var M = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = (e4.rjvId, e4.type_name), n3 = e4.displayDataTypes, a2 = e4.theme;
            return n3 ? m.a.createElement("span", Object.assign({ className: "data-type-label" }, A(a2, "data-type-label")), t3) : null;
          } }]), n2;
        }(m.a.PureComponent), P = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props;
            return m.a.createElement("div", A(e4.theme, "boolean"), m.a.createElement(M, Object.assign({ type_name: "bool" }, e4)), e4.value ? "true" : "false");
          } }]), n2;
        }(m.a.PureComponent), F = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props;
            return m.a.createElement("div", A(e4.theme, "date"), m.a.createElement(M, Object.assign({ type_name: "date" }, e4)), m.a.createElement("span", Object.assign({ className: "date-value" }, A(e4.theme, "date-value")), e4.value.toLocaleTimeString("en-us", { weekday: "short", year: "numeric", month: "short", day: "numeric", hour: "2-digit", minute: "2-digit" })));
          } }]), n2;
        }(m.a.PureComponent), D = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props;
            return m.a.createElement("div", A(e4.theme, "float"), m.a.createElement(M, Object.assign({ type_name: "float" }, e4)), this.props.value);
          } }]), n2;
        }(m.a.PureComponent);
        function I(e3, t2) {
          (null == t2 || t2 > e3.length) && (t2 = e3.length);
          for (var n2 = 0, a2 = new Array(t2); n2 < t2; n2++) a2[n2] = e3[n2];
          return a2;
        }
        function R(e3, t2) {
          if (e3) {
            if ("string" == typeof e3) return I(e3, t2);
            var n2 = Object.prototype.toString.call(e3).slice(8, -1);
            return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? I(e3, t2) : void 0;
          }
        }
        function L(e3, t2) {
          var n2;
          if ("undefined" == typeof Symbol || null == e3[Symbol.iterator]) {
            if (Array.isArray(e3) || (n2 = R(e3)) || t2) {
              n2 && (e3 = n2);
              var a2 = 0, r3 = function() {
              };
              return { s: r3, n: function() {
                return a2 >= e3.length ? { done: true } : { done: false, value: e3[a2++] };
              }, e: function(e4) {
                throw e4;
              }, f: r3 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var o2, i2 = true, s2 = false;
          return { s: function() {
            n2 = e3[Symbol.iterator]();
          }, n: function() {
            var e4 = n2.next();
            return i2 = e4.done, e4;
          }, e: function(e4) {
            s2 = true, o2 = e4;
          }, f: function() {
            try {
              i2 || null == n2.return || n2.return();
            } finally {
              if (s2) throw o2;
            }
          } };
        }
        function B(e3) {
          return function(e4) {
            if (Array.isArray(e4)) return I(e4);
          }(e3) || function(e4) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4)) return Array.from(e4);
          }(e3) || R(e3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        var N = n(46), z = new (n(47)).Dispatcher(), T = new (function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            var e4;
            i(this, n2);
            for (var a2 = arguments.length, r3 = new Array(a2), s2 = 0; s2 < a2; s2++) r3[s2] = arguments[s2];
            return (e4 = t2.call.apply(t2, [this].concat(r3))).objects = {}, e4.set = function(t3, n3, a3, r4) {
              void 0 === e4.objects[t3] && (e4.objects[t3] = {}), void 0 === e4.objects[t3][n3] && (e4.objects[t3][n3] = {}), e4.objects[t3][n3][a3] = r4;
            }, e4.get = function(t3, n3, a3, r4) {
              return void 0 === e4.objects[t3] || void 0 === e4.objects[t3][n3] || null == e4.objects[t3][n3][a3] ? r4 : e4.objects[t3][n3][a3];
            }, e4.handleAction = function(t3) {
              var n3 = t3.rjvId, a3 = t3.data;
              switch (t3.name) {
                case "RESET":
                  e4.emit("reset-" + n3);
                  break;
                case "VARIABLE_UPDATED":
                  t3.data.updated_src = e4.updateSrc(n3, a3), e4.set(n3, "action", "variable-update", o(o({}, a3), {}, { type: "variable-edited" })), e4.emit("variable-update-" + n3);
                  break;
                case "VARIABLE_REMOVED":
                  t3.data.updated_src = e4.updateSrc(n3, a3), e4.set(n3, "action", "variable-update", o(o({}, a3), {}, { type: "variable-removed" })), e4.emit("variable-update-" + n3);
                  break;
                case "VARIABLE_ADDED":
                  t3.data.updated_src = e4.updateSrc(n3, a3), e4.set(n3, "action", "variable-update", o(o({}, a3), {}, { type: "variable-added" })), e4.emit("variable-update-" + n3);
                  break;
                case "ADD_VARIABLE_KEY_REQUEST":
                  e4.set(n3, "action", "new-key-request", a3), e4.emit("add-key-request-" + n3);
              }
            }, e4.updateSrc = function(t3, n3) {
              var a3 = n3.name, r4 = n3.namespace, o2 = n3.new_value, i2 = (n3.existing_value, n3.variable_removed);
              r4.shift();
              var s3, c2 = e4.get(t3, "global", "src"), l2 = e4.deepCopy(c2, B(r4)), u2 = l2, f2 = L(r4);
              try {
                for (f2.s(); !(s3 = f2.n()).done; ) {
                  u2 = u2[s3.value];
                }
              } catch (e5) {
                f2.e(e5);
              } finally {
                f2.f();
              }
              return i2 ? "array" == _(u2) ? u2.splice(a3, 1) : delete u2[a3] : null !== a3 ? u2[a3] = o2 : l2 = o2, e4.set(t3, "global", "src", l2), l2;
            }, e4.deepCopy = function(t3, n3) {
              var a3, r4 = _(t3), i2 = n3.shift();
              return "array" == r4 ? a3 = B(t3) : "object" == r4 && (a3 = o({}, t3)), void 0 !== i2 && (a3[i2] = e4.deepCopy(t3[i2], n3)), a3;
            }, e4;
          }
          return n2;
        }(N.EventEmitter))();
        z.register(T.handleAction.bind(T));
        var q = T, V = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).toggleCollapsed = function() {
              a2.setState({ collapsed: !a2.state.collapsed }, function() {
                q.set(a2.props.rjvId, a2.props.namespace, "collapsed", a2.state.collapsed);
              });
            }, a2.getFunctionDisplay = function(e5) {
              var t3 = d2(a2).props;
              return e5 ? m.a.createElement("span", null, a2.props.value.toString().slice(9, -1).replace(/\{[\s\S]+/, ""), m.a.createElement("span", { className: "function-collapsed", style: { fontWeight: "bold" } }, m.a.createElement("span", null, "{"), m.a.createElement("span", A(t3.theme, "ellipsis"), "..."), m.a.createElement("span", null, "}"))) : a2.props.value.toString().slice(9, -1);
            }, a2.state = { collapsed: q.get(e4.rjvId, e4.namespace, "collapsed", true) }, a2;
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = this.state.collapsed;
            return m.a.createElement("div", A(e4.theme, "function"), m.a.createElement(M, Object.assign({ type_name: "function" }, e4)), m.a.createElement("span", Object.assign({}, A(e4.theme, "function-value"), { className: "rjv-function-container", onClick: this.toggleCollapsed }), this.getFunctionDisplay(t3)));
          } }]), n2;
        }(m.a.PureComponent), K = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            return m.a.createElement("div", A(this.props.theme, "nan"), "NaN");
          } }]), n2;
        }(m.a.PureComponent), W = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            return m.a.createElement("div", A(this.props.theme, "null"), "NULL");
          } }]), n2;
        }(m.a.PureComponent), H = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props;
            return m.a.createElement("div", A(e4.theme, "integer"), m.a.createElement(M, Object.assign({ type_name: "int" }, e4)), this.props.value);
          } }]), n2;
        }(m.a.PureComponent), U = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props;
            return m.a.createElement("div", A(e4.theme, "regexp"), m.a.createElement(M, Object.assign({ type_name: "regexp" }, e4)), this.props.value.toString());
          } }]), n2;
        }(m.a.PureComponent), G = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).toggleCollapsed = function() {
              a2.setState({ collapsed: !a2.state.collapsed }, function() {
                q.set(a2.props.rjvId, a2.props.namespace, "collapsed", a2.state.collapsed);
              });
            }, a2.state = { collapsed: q.get(e4.rjvId, e4.namespace, "collapsed", true) }, a2;
          }
          return c(n2, [{ key: "render", value: function() {
            this.state.collapsed;
            var e4 = this.props, t3 = e4.collapseStringsAfterLength, n3 = e4.theme, a2 = e4.value, r3 = { style: { cursor: "default" } };
            return "integer" === _(t3) && a2.length > t3 && (r3.style.cursor = "pointer", this.state.collapsed && (a2 = m.a.createElement("span", null, a2.substring(0, t3), m.a.createElement("span", A(n3, "ellipsis"), " ...")))), m.a.createElement("div", A(n3, "string"), m.a.createElement(M, Object.assign({ type_name: "string" }, e4)), m.a.createElement("span", Object.assign({ className: "string-value" }, r3, { onClick: this.toggleCollapsed }), '"', a2, '"'));
          } }]), n2;
        }(m.a.PureComponent), J = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            return m.a.createElement("div", A(this.props.theme, "undefined"), "undefined");
          } }]), n2;
        }(m.a.PureComponent);
        function Y() {
          return (Y = Object.assign || function(e3) {
            for (var t2 = 1; t2 < arguments.length; t2++) {
              var n2 = arguments[t2];
              for (var a2 in n2) Object.prototype.hasOwnProperty.call(n2, a2) && (e3[a2] = n2[a2]);
            }
            return e3;
          }).apply(this, arguments);
        }
        var $ = v.useLayoutEffect, Q = function(e3) {
          var t2 = Object(v.useRef)(e3);
          return $(function() {
            t2.current = e3;
          }), t2;
        }, Z = function(e3, t2) {
          "function" != typeof e3 ? e3.current = t2 : e3(t2);
        }, X = function(e3, t2) {
          var n2 = Object(v.useRef)();
          return Object(v.useCallback)(function(a2) {
            e3.current = a2, n2.current && Z(n2.current, null), n2.current = t2, t2 && Z(t2, a2);
          }, [t2]);
        }, ee = { "min-height": "0", "max-height": "none", height: "0", visibility: "hidden", overflow: "hidden", position: "absolute", "z-index": "-1000", top: "0", right: "0" }, te = function(e3) {
          Object.keys(ee).forEach(function(t2) {
            e3.style.setProperty(t2, ee[t2], "important");
          });
        }, ne = null;
        var ae = function() {
        }, re = ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth", "boxSizing", "fontFamily", "fontSize", "fontStyle", "fontWeight", "letterSpacing", "lineHeight", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "tabSize", "textIndent", "textRendering", "textTransform", "width"], oe = !!document.documentElement.currentStyle, ie = function(e3, t2) {
          var n2 = e3.cacheMeasurements, a2 = e3.maxRows, r3 = e3.minRows, o2 = e3.onChange, i2 = void 0 === o2 ? ae : o2, s2 = e3.onHeightChange, c2 = void 0 === s2 ? ae : s2, l2 = function(e4, t3) {
            if (null == e4) return {};
            var n3, a3, r4 = {}, o3 = Object.keys(e4);
            for (a3 = 0; a3 < o3.length; a3++) n3 = o3[a3], t3.indexOf(n3) >= 0 || (r4[n3] = e4[n3]);
            return r4;
          }(e3, ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"]);
          var u2, f2 = void 0 !== l2.value, p2 = Object(v.useRef)(null), d3 = X(p2, t2), b2 = Object(v.useRef)(0), h2 = Object(v.useRef)(), m2 = function() {
            var e4 = p2.current, t3 = n2 && h2.current ? h2.current : function(e5) {
              var t4 = window.getComputedStyle(e5);
              if (null === t4) return null;
              var n3, a3 = (n3 = t4, re.reduce(function(e6, t5) {
                return e6[t5] = n3[t5], e6;
              }, {})), r4 = a3.boxSizing;
              return "" === r4 ? null : (oe && "border-box" === r4 && (a3.width = parseFloat(a3.width) + parseFloat(a3.borderRightWidth) + parseFloat(a3.borderLeftWidth) + parseFloat(a3.paddingRight) + parseFloat(a3.paddingLeft) + "px"), { sizingStyle: a3, paddingSize: parseFloat(a3.paddingBottom) + parseFloat(a3.paddingTop), borderSize: parseFloat(a3.borderBottomWidth) + parseFloat(a3.borderTopWidth) });
            }(e4);
            if (t3) {
              h2.current = t3;
              var o3 = function(e5, t4, n3, a3) {
                void 0 === n3 && (n3 = 1), void 0 === a3 && (a3 = 1 / 0), ne || ((ne = document.createElement("textarea")).setAttribute("tab-index", "-1"), ne.setAttribute("aria-hidden", "true"), te(ne)), null === ne.parentNode && document.body.appendChild(ne);
                var r4 = e5.paddingSize, o4 = e5.borderSize, i4 = e5.sizingStyle, s4 = i4.boxSizing;
                Object.keys(i4).forEach(function(e6) {
                  var t5 = e6;
                  ne.style[t5] = i4[t5];
                }), te(ne), ne.value = t4;
                var c3 = function(e6, t5) {
                  var n4 = e6.scrollHeight;
                  return "border-box" === t5.sizingStyle.boxSizing ? n4 + t5.borderSize : n4 - t5.paddingSize;
                }(ne, e5);
                ne.value = "x";
                var l3 = ne.scrollHeight - r4, u3 = l3 * n3;
                "border-box" === s4 && (u3 = u3 + r4 + o4), c3 = Math.max(u3, c3);
                var f3 = l3 * a3;
                return "border-box" === s4 && (f3 = f3 + r4 + o4), [c3 = Math.min(f3, c3), l3];
              }(t3, e4.value || e4.placeholder || "x", r3, a2), i3 = o3[0], s3 = o3[1];
              b2.current !== i3 && (b2.current = i3, e4.style.setProperty("height", i3 + "px", "important"), c2(i3, { rowHeight: s3 }));
            }
          };
          return Object(v.useLayoutEffect)(m2), u2 = Q(m2), Object(v.useLayoutEffect)(function() {
            var e4 = function(e5) {
              u2.current(e5);
            };
            return window.addEventListener("resize", e4), function() {
              window.removeEventListener("resize", e4);
            };
          }, []), Object(v.createElement)("textarea", Y({}, l2, { onChange: function(e4) {
            f2 || m2(), i2(e4);
          }, ref: d3 }));
        }, se = Object(v.forwardRef)(ie);
        function ce(e3) {
          e3 = e3.trim();
          try {
            if ("[" === (e3 = JSON.stringify(JSON.parse(e3)))[0]) return le("array", JSON.parse(e3));
            if ("{" === e3[0]) return le("object", JSON.parse(e3));
            if (e3.match(/\-?\d+\.\d+/) && e3.match(/\-?\d+\.\d+/)[0] === e3) return le("float", parseFloat(e3));
            if (e3.match(/\-?\d+e-\d+/) && e3.match(/\-?\d+e-\d+/)[0] === e3) return le("float", Number(e3));
            if (e3.match(/\-?\d+/) && e3.match(/\-?\d+/)[0] === e3) return le("integer", parseInt(e3));
            if (e3.match(/\-?\d+e\+\d+/) && e3.match(/\-?\d+e\+\d+/)[0] === e3) return le("integer", Number(e3));
          } catch (e4) {
          }
          switch (e3 = e3.toLowerCase()) {
            case "undefined":
              return le("undefined", void 0);
            case "nan":
              return le("nan", NaN);
            case "null":
              return le("null", null);
            case "true":
              return le("boolean", true);
            case "false":
              return le("boolean", false);
            default:
              if (e3 = Date.parse(e3)) return le("date", new Date(e3));
          }
          return le(false, null);
        }
        function le(e3, t2) {
          return { type: e3, value: t2 };
        }
        var ue = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 24 24", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("path", { d: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,13H17V11H7" })));
          } }]), n2;
        }(m.a.PureComponent), fe = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 24 24", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("path", { d: "M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z" })));
          } }]), n2;
        }(m.a.PureComponent), pe = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]), a2 = xe(t3).style;
            return m.a.createElement("span", n3, m.a.createElement("svg", { fill: a2.color, width: a2.height, height: a2.width, style: a2, viewBox: "0 0 1792 1792" }, m.a.createElement("path", { d: "M1344 800v64q0 14-9 23t-23 9h-832q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h832q14 0 23 9t9 23zm128 448v-832q0-66-47-113t-113-47h-832q-66 0-113 47t-47 113v832q0 66 47 113t113 47h832q66 0 113-47t47-113zm128-832v832q0 119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119 84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" })));
          } }]), n2;
        }(m.a.PureComponent), de = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]), a2 = xe(t3).style;
            return m.a.createElement("span", n3, m.a.createElement("svg", { fill: a2.color, width: a2.height, height: a2.width, style: a2, viewBox: "0 0 1792 1792" }, m.a.createElement("path", { d: "M1344 800v64q0 14-9 23t-23 9h-352v352q0 14-9 23t-23 9h-64q-14 0-23-9t-9-23v-352h-352q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h352v-352q0-14 9-23t23-9h64q14 0 23 9t9 23v352h352q14 0 23 9t9 23zm128 448v-832q0-66-47-113t-113-47h-832q-66 0-113 47t-47 113v832q0 66 47 113t113 47h832q66 0 113-47t47-113zm128-832v832q0 119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119 84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z" })));
          } }]), n2;
        }(m.a.PureComponent), be = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", { style: o(o({}, xe(t3).style), {}, { paddingLeft: "2px", verticalAlign: "top" }), viewBox: "0 0 15 15", fill: "currentColor" }, m.a.createElement("path", { d: "M0 14l6-6-6-6z" })));
          } }]), n2;
        }(m.a.PureComponent), he = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", { style: o(o({}, xe(t3).style), {}, { paddingLeft: "2px", verticalAlign: "top" }), viewBox: "0 0 15 15", fill: "currentColor" }, m.a.createElement("path", { d: "M0 5l6 6 6-6z" })));
          } }]), n2;
        }(m.a.PureComponent), ve = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m30 35h-25v-22.5h25v7.5h2.5v-12.5c0-1.4-1.1-2.5-2.5-2.5h-7.5c0-2.8-2.2-5-5-5s-5 2.2-5 5h-7.5c-1.4 0-2.5 1.1-2.5 2.5v27.5c0 1.4 1.1 2.5 2.5 2.5h25c1.4 0 2.5-1.1 2.5-2.5v-5h-2.5v5z m-20-27.5h2.5s2.5-1.1 2.5-2.5 1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5 1.3 2.5 2.5 2.5h2.5s2.5 1.1 2.5 2.5h-20c0-1.5 1.1-2.5 2.5-2.5z m-2.5 20h5v-2.5h-5v2.5z m17.5-5v-5l-10 7.5 10 7.5v-5h12.5v-5h-12.5z m-17.5 10h7.5v-2.5h-7.5v2.5z m12.5-17.5h-12.5v2.5h12.5v-2.5z m-7.5 5h-5v2.5h5v-2.5z" }))));
          } }]), n2;
        }(m.a.PureComponent), me = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m28.6 25q0-0.5-0.4-1l-4-4 4-4q0.4-0.5 0.4-1 0-0.6-0.4-1.1l-2-2q-0.4-0.4-1-0.4-0.6 0-1 0.4l-4.1 4.1-4-4.1q-0.4-0.4-1-0.4-0.6 0-1 0.4l-2 2q-0.5 0.5-0.5 1.1 0 0.5 0.5 1l4 4-4 4q-0.5 0.5-0.5 1 0 0.7 0.5 1.1l2 2q0.4 0.4 1 0.4 0.6 0 1-0.4l4-4.1 4.1 4.1q0.4 0.4 1 0.4 0.6 0 1-0.4l2-2q0.4-0.4 0.4-1z m8.7-5q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
          } }]), n2;
        }(m.a.PureComponent), ye = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m30.1 21.4v-2.8q0-0.6-0.4-1t-1-0.5h-5.7v-5.7q0-0.6-0.4-1t-1-0.4h-2.9q-0.6 0-1 0.4t-0.4 1v5.7h-5.7q-0.6 0-1 0.5t-0.5 1v2.8q0 0.6 0.5 1t1 0.5h5.7v5.7q0 0.5 0.4 1t1 0.4h2.9q0.6 0 1-0.4t0.4-1v-5.7h5.7q0.6 0 1-0.5t0.4-1z m7.2-1.4q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
          } }]), n2;
        }(m.a.PureComponent), ge = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m31.6 21.6h-10v10h-3.2v-10h-10v-3.2h10v-10h3.2v10h10v3.2z" }))));
          } }]), n2;
        }(m.a.PureComponent), Ee = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m19.8 26.4l2.6-2.6-3.4-3.4-2.6 2.6v1.3h2.2v2.1h1.2z m9.8-16q-0.3-0.4-0.7 0l-7.8 7.8q-0.4 0.4 0 0.7t0.7 0l7.8-7.8q0.4-0.4 0-0.7z m1.8 13.2v4.3q0 2.6-1.9 4.5t-4.5 1.9h-18.6q-2.6 0-4.5-1.9t-1.9-4.5v-18.6q0-2.7 1.9-4.6t4.5-1.8h18.6q1.4 0 2.6 0.5 0.3 0.2 0.4 0.5 0.1 0.4-0.2 0.7l-1.1 1.1q-0.3 0.3-0.7 0.1-0.5-0.1-1-0.1h-18.6q-1.4 0-2.5 1.1t-1 2.5v18.6q0 1.4 1 2.5t2.5 1h18.6q1.5 0 2.5-1t1.1-2.5v-2.9q0-0.2 0.2-0.4l1.4-1.5q0.3-0.3 0.8-0.1t0.4 0.6z m-2.1-16.5l6.4 6.5-15 15h-6.4v-6.5z m9.9 3l-2.1 2-6.4-6.4 2.1-2q0.6-0.7 1.5-0.7t1.5 0.7l3.4 3.4q0.6 0.6 0.6 1.5t-0.6 1.5z" }))));
          } }]), n2;
        }(m.a.PureComponent), je = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.style, n3 = x2(e4, ["style"]);
            return m.a.createElement("span", n3, m.a.createElement("svg", Object.assign({}, xe(t3), { viewBox: "0 0 40 40", fill: "currentColor", preserveAspectRatio: "xMidYMid meet" }), m.a.createElement("g", null, m.a.createElement("path", { d: "m31.7 16.4q0-0.6-0.4-1l-2.1-2.1q-0.4-0.4-1-0.4t-1 0.4l-9.1 9.1-5-5q-0.5-0.4-1-0.4t-1 0.4l-2.1 2q-0.4 0.4-0.4 1 0 0.6 0.4 1l8.1 8.1q0.4 0.4 1 0.4 0.6 0 1-0.4l12.2-12.1q0.4-0.4 0.4-1z m5.6 3.6q0 4.7-2.3 8.6t-6.3 6.2-8.6 2.3-8.6-2.3-6.2-6.2-2.3-8.6 2.3-8.6 6.2-6.2 8.6-2.3 8.6 2.3 6.3 6.2 2.3 8.6z" }))));
          } }]), n2;
        }(m.a.PureComponent);
        function xe(e3) {
          return e3 || (e3 = {}), { style: o(o({ verticalAlign: "middle" }, e3), {}, { color: e3.color ? e3.color : "#000000", height: "1em", width: "1em" }) };
        }
        var _e = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).copiedTimer = null, a2.handleCopy = function() {
              var e5 = document.createElement("textarea"), t3 = a2.props, n3 = t3.clickCallback, r3 = t3.src, o2 = t3.namespace;
              e5.innerHTML = JSON.stringify(a2.clipboardValue(r3), null, "  "), document.body.appendChild(e5), e5.select(), document.execCommand("copy"), document.body.removeChild(e5), a2.copiedTimer = setTimeout(function() {
                a2.setState({ copied: false });
              }, 5500), a2.setState({ copied: true }, function() {
                "function" == typeof n3 && n3({ src: r3, namespace: o2, name: o2[o2.length - 1] });
              });
            }, a2.getClippyIcon = function() {
              var e5 = a2.props.theme;
              return a2.state.copied ? m.a.createElement("span", null, m.a.createElement(ve, Object.assign({ className: "copy-icon" }, A(e5, "copy-icon"))), m.a.createElement("span", A(e5, "copy-icon-copied"), "")) : m.a.createElement(ve, Object.assign({ className: "copy-icon" }, A(e5, "copy-icon")));
            }, a2.clipboardValue = function(e5) {
              switch (_(e5)) {
                case "function":
                case "regexp":
                  return e5.toString();
                default:
                  return e5;
              }
            }, a2.state = { copied: false }, a2;
          }
          return c(n2, [{ key: "componentWillUnmount", value: function() {
            this.copiedTimer && (clearTimeout(this.copiedTimer), this.copiedTimer = null);
          } }, { key: "render", value: function() {
            var e4 = this.props, t3 = (e4.src, e4.theme), n3 = e4.hidden, a2 = e4.rowHovered, r3 = A(t3, "copy-to-clipboard").style, i2 = "inline";
            return n3 && (i2 = "none"), m.a.createElement("span", { className: "copy-to-clipboard-container", title: "Copy to clipboard", style: { verticalAlign: "top", display: a2 ? "inline-block" : "none" } }, m.a.createElement("span", { style: o(o({}, r3), {}, { display: i2 }), onClick: this.handleCopy }, this.getClippyIcon()));
          } }]), n2;
        }(m.a.PureComponent), ke = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).getEditIcon = function() {
              var e5 = a2.props, t3 = e5.variable, n3 = e5.theme;
              return m.a.createElement("div", { className: "click-to-edit", style: { verticalAlign: "top", display: a2.state.hovered ? "inline-block" : "none" } }, m.a.createElement(Ee, Object.assign({ className: "click-to-edit-icon" }, A(n3, "editVarIcon"), { onClick: function() {
                a2.prepopInput(t3);
              } })));
            }, a2.prepopInput = function(e5) {
              if (false !== a2.props.onEdit) {
                var t3 = function(e6) {
                  var t4;
                  switch (_(e6)) {
                    case "undefined":
                      t4 = "undefined";
                      break;
                    case "nan":
                      t4 = "NaN";
                      break;
                    case "string":
                      t4 = e6;
                      break;
                    case "date":
                    case "function":
                    case "regexp":
                      t4 = e6.toString();
                      break;
                    default:
                      try {
                        t4 = JSON.stringify(e6, null, "  ");
                      } catch (e7) {
                        t4 = "";
                      }
                  }
                  return t4;
                }(e5.value), n3 = ce(t3);
                a2.setState({ editMode: true, editValue: t3, parsedInput: { type: n3.type, value: n3.value } });
              }
            }, a2.getRemoveIcon = function() {
              var e5 = a2.props, t3 = e5.variable, n3 = e5.namespace, r3 = e5.theme, o2 = e5.rjvId;
              return m.a.createElement("div", { className: "click-to-remove", style: { verticalAlign: "top", display: a2.state.hovered ? "inline-block" : "none" } }, m.a.createElement(me, Object.assign({ className: "click-to-remove-icon" }, A(r3, "removeVarIcon"), { onClick: function() {
                z.dispatch({ name: "VARIABLE_REMOVED", rjvId: o2, data: { name: t3.name, namespace: n3, existing_value: t3.value, variable_removed: true } });
              } })));
            }, a2.getValue = function(e5, t3) {
              var n3 = !t3 && e5.type, r3 = d2(a2).props;
              switch (n3) {
                case false:
                  return a2.getEditInput();
                case "string":
                  return m.a.createElement(G, Object.assign({ value: e5.value }, r3));
                case "integer":
                  return m.a.createElement(H, Object.assign({ value: e5.value }, r3));
                case "float":
                  return m.a.createElement(D, Object.assign({ value: e5.value }, r3));
                case "boolean":
                  return m.a.createElement(P, Object.assign({ value: e5.value }, r3));
                case "function":
                  return m.a.createElement(V, Object.assign({ value: e5.value }, r3));
                case "null":
                  return m.a.createElement(W, r3);
                case "nan":
                  return m.a.createElement(K, r3);
                case "undefined":
                  return m.a.createElement(J, r3);
                case "date":
                  return m.a.createElement(F, Object.assign({ value: e5.value }, r3));
                case "regexp":
                  return m.a.createElement(U, Object.assign({ value: e5.value }, r3));
                default:
                  return m.a.createElement("div", { className: "object-value" }, JSON.stringify(e5.value));
              }
            }, a2.getEditInput = function() {
              var e5 = a2.props.theme, t3 = a2.state.editValue;
              return m.a.createElement("div", null, m.a.createElement(se, Object.assign({ type: "text", inputRef: function(e6) {
                return e6 && e6.focus();
              }, value: t3, className: "variable-editor", onChange: function(e6) {
                var t4 = e6.target.value, n3 = ce(t4);
                a2.setState({ editValue: t4, parsedInput: { type: n3.type, value: n3.value } });
              }, onKeyDown: function(e6) {
                switch (e6.key) {
                  case "Escape":
                    a2.setState({ editMode: false, editValue: "" });
                    break;
                  case "Enter":
                    (e6.ctrlKey || e6.metaKey) && a2.submitEdit(true);
                }
                e6.stopPropagation();
              }, placeholder: "update this value", minRows: 2 }, A(e5, "edit-input"))), m.a.createElement("div", A(e5, "edit-icon-container"), m.a.createElement(me, Object.assign({ className: "edit-cancel" }, A(e5, "cancel-icon"), { onClick: function() {
                a2.setState({ editMode: false, editValue: "" });
              } })), m.a.createElement(je, Object.assign({ className: "edit-check string-value" }, A(e5, "check-icon"), { onClick: function() {
                a2.submitEdit();
              } })), m.a.createElement("div", null, a2.showDetected())));
            }, a2.submitEdit = function(e5) {
              var t3 = a2.props, n3 = t3.variable, r3 = t3.namespace, o2 = t3.rjvId, i2 = a2.state, s2 = i2.editValue, c2 = i2.parsedInput, l2 = s2;
              e5 && c2.type && (l2 = c2.value), a2.setState({ editMode: false }), z.dispatch({ name: "VARIABLE_UPDATED", rjvId: o2, data: { name: n3.name, namespace: r3, existing_value: n3.value, new_value: l2, variable_removed: false } });
            }, a2.showDetected = function() {
              var e5 = a2.props, t3 = e5.theme, n3 = (e5.variable, e5.namespace, e5.rjvId, a2.state.parsedInput), r3 = (n3.type, n3.value, a2.getDetectedInput());
              if (r3) return m.a.createElement("div", null, m.a.createElement("div", A(t3, "detected-row"), r3, m.a.createElement(je, { className: "edit-check detected", style: o({ verticalAlign: "top", paddingLeft: "3px" }, A(t3, "check-icon").style), onClick: function() {
                a2.submitEdit(true);
              } })));
            }, a2.getDetectedInput = function() {
              var e5 = a2.state.parsedInput, t3 = e5.type, n3 = e5.value, r3 = d2(a2).props, i2 = r3.theme;
              if (false !== t3) switch (t3.toLowerCase()) {
                case "object":
                  return m.a.createElement("span", null, m.a.createElement("span", { style: o(o({}, A(i2, "brace").style), {}, { cursor: "default" }) }, "{"), m.a.createElement("span", { style: o(o({}, A(i2, "ellipsis").style), {}, { cursor: "default" }) }, "..."), m.a.createElement("span", { style: o(o({}, A(i2, "brace").style), {}, { cursor: "default" }) }, "}"));
                case "array":
                  return m.a.createElement("span", null, m.a.createElement("span", { style: o(o({}, A(i2, "brace").style), {}, { cursor: "default" }) }, "["), m.a.createElement("span", { style: o(o({}, A(i2, "ellipsis").style), {}, { cursor: "default" }) }, "..."), m.a.createElement("span", { style: o(o({}, A(i2, "brace").style), {}, { cursor: "default" }) }, "]"));
                case "string":
                  return m.a.createElement(G, Object.assign({ value: n3 }, r3));
                case "integer":
                  return m.a.createElement(H, Object.assign({ value: n3 }, r3));
                case "float":
                  return m.a.createElement(D, Object.assign({ value: n3 }, r3));
                case "boolean":
                  return m.a.createElement(P, Object.assign({ value: n3 }, r3));
                case "function":
                  return m.a.createElement(V, Object.assign({ value: n3 }, r3));
                case "null":
                  return m.a.createElement(W, r3);
                case "nan":
                  return m.a.createElement(K, r3);
                case "undefined":
                  return m.a.createElement(J, r3);
                case "date":
                  return m.a.createElement(F, Object.assign({ value: new Date(n3) }, r3));
              }
            }, a2.state = { editMode: false, editValue: "", hovered: false, renameKey: false, parsedInput: { type: false, value: null } }, a2;
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this, t3 = this.props, n3 = t3.variable, a2 = t3.singleIndent, r3 = t3.type, i2 = t3.theme, s2 = t3.namespace, c2 = t3.indentWidth, l2 = t3.enableClipboard, u2 = t3.onEdit, f2 = t3.onDelete, p2 = t3.onSelect, d3 = t3.displayArrayKey, b2 = t3.quotesOnKeys, h2 = this.state.editMode;
            return m.a.createElement("div", Object.assign({}, A(i2, "objectKeyVal", { paddingLeft: c2 * a2 }), { onMouseEnter: function() {
              return e4.setState(o(o({}, e4.state), {}, { hovered: true }));
            }, onMouseLeave: function() {
              return e4.setState(o(o({}, e4.state), {}, { hovered: false }));
            }, className: "variable-row", key: n3.name }), "array" == r3 ? d3 ? m.a.createElement("span", Object.assign({}, A(i2, "array-key"), { key: n3.name + "_" + s2 }), n3.name, m.a.createElement("div", A(i2, "colon"), ":")) : null : m.a.createElement("span", null, m.a.createElement("span", Object.assign({}, A(i2, "object-name"), { className: "object-key", key: n3.name + "_" + s2 }), !!b2 && m.a.createElement("span", { style: { verticalAlign: "top" } }, '"'), m.a.createElement("span", { style: { display: "inline-block" } }, n3.name), !!b2 && m.a.createElement("span", { style: { verticalAlign: "top" } }, '"')), m.a.createElement("span", A(i2, "colon"), ":")), m.a.createElement("div", Object.assign({ className: "variable-value", onClick: false === p2 && false === u2 ? null : function(t4) {
              var a3 = B(s2);
              (t4.ctrlKey || t4.metaKey) && false !== u2 ? e4.prepopInput(n3) : false !== p2 && (a3.shift(), p2(o(o({}, n3), {}, { namespace: a3 })));
            } }, A(i2, "variableValue", { cursor: false === p2 ? "default" : "pointer" })), this.getValue(n3, h2)), l2 ? m.a.createElement(_e, { rowHovered: this.state.hovered, hidden: h2, src: n3.value, clickCallback: l2, theme: i2, namespace: [].concat(B(s2), [n3.name]) }) : null, false !== u2 && 0 == h2 ? this.getEditIcon() : null, false !== f2 && 0 == h2 ? this.getRemoveIcon() : null);
          } }]), n2;
        }(m.a.PureComponent), Oe = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            var e4;
            i(this, n2);
            for (var a2 = arguments.length, r3 = new Array(a2), s2 = 0; s2 < a2; s2++) r3[s2] = arguments[s2];
            return (e4 = t2.call.apply(t2, [this].concat(r3))).getObjectSize = function() {
              var t3 = e4.props, n3 = t3.size, a3 = t3.theme;
              if (t3.displayObjectSize) return m.a.createElement("span", Object.assign({ className: "object-size" }, A(a3, "object-size")), n3, " item", 1 === n3 ? "" : "s");
            }, e4.getAddAttribute = function(t3) {
              var n3 = e4.props, a3 = n3.theme, r4 = n3.namespace, i2 = n3.name, s3 = n3.src, c2 = n3.rjvId, l2 = n3.depth;
              return m.a.createElement("span", { className: "click-to-add", style: { verticalAlign: "top", display: t3 ? "inline-block" : "none" } }, m.a.createElement(ye, Object.assign({ className: "click-to-add-icon" }, A(a3, "addVarIcon"), { onClick: function() {
                var e5 = { name: l2 > 0 ? i2 : null, namespace: r4.splice(0, r4.length - 1), existing_value: s3, variable_removed: false, key_name: null };
                "object" === _(s3) ? z.dispatch({ name: "ADD_VARIABLE_KEY_REQUEST", rjvId: c2, data: e5 }) : z.dispatch({ name: "VARIABLE_ADDED", rjvId: c2, data: o(o({}, e5), {}, { new_value: [].concat(B(s3), [null]) }) });
              } })));
            }, e4.getRemoveObject = function(t3) {
              var n3 = e4.props, a3 = n3.theme, r4 = (n3.hover, n3.namespace), o2 = n3.name, i2 = n3.src, s3 = n3.rjvId;
              if (1 !== r4.length) return m.a.createElement("span", { className: "click-to-remove", style: { display: t3 ? "inline-block" : "none" } }, m.a.createElement(me, Object.assign({ className: "click-to-remove-icon" }, A(a3, "removeVarIcon"), { onClick: function() {
                z.dispatch({ name: "VARIABLE_REMOVED", rjvId: s3, data: { name: o2, namespace: r4.splice(0, r4.length - 1), existing_value: i2, variable_removed: true } });
              } })));
            }, e4.render = function() {
              var t3 = e4.props, n3 = t3.theme, a3 = t3.onDelete, r4 = t3.onAdd, o2 = t3.enableClipboard, i2 = t3.src, s3 = t3.namespace, c2 = t3.rowHovered;
              return m.a.createElement("div", Object.assign({}, A(n3, "object-meta-data"), { className: "object-meta-data", onClick: function(e5) {
                e5.stopPropagation();
              } }), e4.getObjectSize(), o2 ? m.a.createElement(_e, { rowHovered: c2, clickCallback: o2, src: i2, theme: n3, namespace: s3 }) : null, false !== r4 ? e4.getAddAttribute(c2) : null, false !== a3 ? e4.getRemoveObject(c2) : null);
            }, e4;
          }
          return n2;
        }(m.a.PureComponent);
        function Ce(e3) {
          var t2 = e3.parent_type, n2 = e3.namespace, a2 = e3.quotesOnKeys, r3 = e3.theme, o2 = e3.jsvRoot, i2 = e3.name, s2 = e3.displayArrayKey, c2 = e3.name ? e3.name : "";
          return !o2 || false !== i2 && null !== i2 ? "array" == t2 ? s2 ? m.a.createElement("span", Object.assign({}, A(r3, "array-key"), { key: n2 }), m.a.createElement("span", { className: "array-key" }, c2), m.a.createElement("span", A(r3, "colon"), ":")) : m.a.createElement("span", null) : m.a.createElement("span", Object.assign({}, A(r3, "object-name"), { key: n2 }), m.a.createElement("span", { className: "object-key" }, a2 && m.a.createElement("span", { style: { verticalAlign: "top" } }, '"'), m.a.createElement("span", null, c2), a2 && m.a.createElement("span", { style: { verticalAlign: "top" } }, '"')), m.a.createElement("span", A(r3, "colon"), ":")) : m.a.createElement("span", null);
        }
        function Se(e3) {
          var t2 = e3.theme;
          switch (e3.iconStyle) {
            case "triangle":
              return m.a.createElement(he, Object.assign({}, A(t2, "expanded-icon"), { className: "expanded-icon" }));
            case "square":
              return m.a.createElement(pe, Object.assign({}, A(t2, "expanded-icon"), { className: "expanded-icon" }));
            default:
              return m.a.createElement(ue, Object.assign({}, A(t2, "expanded-icon"), { className: "expanded-icon" }));
          }
        }
        function we(e3) {
          var t2 = e3.theme;
          switch (e3.iconStyle) {
            case "triangle":
              return m.a.createElement(be, Object.assign({}, A(t2, "collapsed-icon"), { className: "collapsed-icon" }));
            case "square":
              return m.a.createElement(de, Object.assign({}, A(t2, "collapsed-icon"), { className: "collapsed-icon" }));
            default:
              return m.a.createElement(fe, Object.assign({}, A(t2, "collapsed-icon"), { className: "collapsed-icon" }));
          }
        }
        var Ae = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).toggleCollapsed = function(e5) {
              var t3 = [];
              for (var n3 in a2.state.expanded) t3.push(a2.state.expanded[n3]);
              t3[e5] = !t3[e5], a2.setState({ expanded: t3 });
            }, a2.state = { expanded: [] }, a2;
          }
          return c(n2, [{ key: "getExpandedIcon", value: function(e4) {
            var t3 = this.props, n3 = t3.theme, a2 = t3.iconStyle;
            return this.state.expanded[e4] ? m.a.createElement(Se, { theme: n3, iconStyle: a2 }) : m.a.createElement(we, { theme: n3, iconStyle: a2 });
          } }, { key: "render", value: function() {
            var e4 = this, t3 = this.props, n3 = t3.src, a2 = t3.groupArraysAfterLength, r3 = (t3.depth, t3.name), o2 = t3.theme, i2 = t3.jsvRoot, s2 = t3.namespace, c2 = (t3.parent_type, x2(t3, ["src", "groupArraysAfterLength", "depth", "name", "theme", "jsvRoot", "namespace", "parent_type"])), l2 = 0, u2 = 5 * this.props.indentWidth;
            i2 || (l2 = 5 * this.props.indentWidth);
            var f2 = a2, p2 = Math.ceil(n3.length / f2);
            return m.a.createElement("div", Object.assign({ className: "object-key-val" }, A(o2, i2 ? "jsv-root" : "objectKeyVal", { paddingLeft: l2 })), m.a.createElement(Ce, this.props), m.a.createElement("span", null, m.a.createElement(Oe, Object.assign({ size: n3.length }, this.props))), B(Array(p2)).map(function(t4, a3) {
              return m.a.createElement("div", Object.assign({ key: a3, className: "object-key-val array-group" }, A(o2, "objectKeyVal", { marginLeft: 6, paddingLeft: u2 })), m.a.createElement("span", A(o2, "brace-row"), m.a.createElement("div", Object.assign({ className: "icon-container" }, A(o2, "icon-container"), { onClick: function(t5) {
                e4.toggleCollapsed(a3);
              } }), e4.getExpandedIcon(a3)), e4.state.expanded[a3] ? m.a.createElement(Fe, Object.assign({ key: r3 + a3, depth: 0, name: false, collapsed: false, groupArraysAfterLength: f2, index_offset: a3 * f2, src: n3.slice(a3 * f2, a3 * f2 + f2), namespace: s2, type: "array", parent_type: "array_group", theme: o2 }, c2)) : m.a.createElement("span", Object.assign({}, A(o2, "brace"), { onClick: function(t5) {
                e4.toggleCollapsed(a3);
              }, className: "array-group-brace" }), "[", m.a.createElement("div", Object.assign({}, A(o2, "array-group-meta-data"), { className: "array-group-meta-data" }), m.a.createElement("span", Object.assign({ className: "object-size" }, A(o2, "object-size")), a3 * f2, " - ", a3 * f2 + f2 > n3.length ? n3.length : a3 * f2 + f2)), "]")));
            }));
          } }]), n2;
        }(m.a.PureComponent), Me = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            i(this, n2), (a2 = t2.call(this, e4)).toggleCollapsed = function() {
              a2.setState({ expanded: !a2.state.expanded }, function() {
                q.set(a2.props.rjvId, a2.props.namespace, "expanded", a2.state.expanded);
              });
            }, a2.getObjectContent = function(e5, t3, n3) {
              return m.a.createElement("div", { className: "pushed-content object-container" }, m.a.createElement("div", Object.assign({ className: "object-content" }, A(a2.props.theme, "pushed-content")), a2.renderObjectContents(t3, n3)));
            }, a2.getEllipsis = function() {
              return 0 === a2.state.size ? null : m.a.createElement("div", Object.assign({}, A(a2.props.theme, "ellipsis"), { className: "node-ellipsis", onClick: a2.toggleCollapsed }), "...");
            }, a2.getObjectMetaData = function(e5) {
              var t3 = a2.props, n3 = (t3.rjvId, t3.theme, a2.state), r4 = n3.size, o2 = n3.hovered;
              return m.a.createElement(Oe, Object.assign({ rowHovered: o2, size: r4 }, a2.props));
            }, a2.renderObjectContents = function(e5, t3) {
              var n3, r4 = a2.props, o2 = r4.depth, i2 = r4.parent_type, s2 = r4.index_offset, c2 = r4.groupArraysAfterLength, l2 = r4.namespace, u2 = a2.state.object_type, f2 = [], p2 = Object.keys(e5 || {});
              return a2.props.sortKeys && "array" !== u2 && (p2 = p2.sort()), p2.forEach(function(r5) {
                if (n3 = new Pe(r5, e5[r5]), "array_group" === i2 && s2 && (n3.name = parseInt(n3.name) + s2), e5.hasOwnProperty(r5)) if ("object" === n3.type) f2.push(m.a.createElement(Fe, Object.assign({ key: n3.name, depth: o2 + 1, name: n3.name, src: n3.value, namespace: l2.concat(n3.name), parent_type: u2 }, t3)));
                else if ("array" === n3.type) {
                  var p3 = Fe;
                  c2 && n3.value.length > c2 && (p3 = Ae), f2.push(m.a.createElement(p3, Object.assign({ key: n3.name, depth: o2 + 1, name: n3.name, src: n3.value, namespace: l2.concat(n3.name), type: "array", parent_type: u2 }, t3)));
                } else f2.push(m.a.createElement(ke, Object.assign({ key: n3.name + "_" + l2, variable: n3, singleIndent: 5, namespace: l2, type: a2.props.type }, t3)));
              }), f2;
            };
            var r3 = n2.getState(e4);
            return a2.state = o(o({}, r3), {}, { prevProps: {} }), a2;
          }
          return c(n2, [{ key: "getBraceStart", value: function(e4, t3) {
            var n3 = this, a2 = this.props, r3 = a2.src, o2 = a2.theme, i2 = a2.iconStyle;
            if ("array_group" === a2.parent_type) return m.a.createElement("span", null, m.a.createElement("span", A(o2, "brace"), "array" === e4 ? "[" : "{"), t3 ? this.getObjectMetaData(r3) : null);
            var s2 = t3 ? Se : we;
            return m.a.createElement("span", null, m.a.createElement("span", Object.assign({ onClick: function(e5) {
              n3.toggleCollapsed();
            } }, A(o2, "brace-row")), m.a.createElement("div", Object.assign({ className: "icon-container" }, A(o2, "icon-container")), m.a.createElement(s2, { theme: o2, iconStyle: i2 })), m.a.createElement(Ce, this.props), m.a.createElement("span", A(o2, "brace"), "array" === e4 ? "[" : "{")), t3 ? this.getObjectMetaData(r3) : null);
          } }, { key: "render", value: function() {
            var e4 = this, t3 = this.props, n3 = t3.depth, a2 = t3.src, r3 = (t3.namespace, t3.name, t3.type, t3.parent_type), i2 = t3.theme, s2 = t3.jsvRoot, c2 = t3.iconStyle, l2 = x2(t3, ["depth", "src", "namespace", "name", "type", "parent_type", "theme", "jsvRoot", "iconStyle"]), u2 = this.state, f2 = u2.object_type, p2 = u2.expanded, d3 = {};
            return s2 || "array_group" === r3 ? "array_group" === r3 && (d3.borderLeft = 0, d3.display = "inline") : d3.paddingLeft = 5 * this.props.indentWidth, m.a.createElement("div", Object.assign({ className: "object-key-val", onMouseEnter: function() {
              return e4.setState(o(o({}, e4.state), {}, { hovered: true }));
            }, onMouseLeave: function() {
              return e4.setState(o(o({}, e4.state), {}, { hovered: false }));
            } }, A(i2, s2 ? "jsv-root" : "objectKeyVal", d3)), this.getBraceStart(f2, p2), p2 ? this.getObjectContent(n3, a2, o({ theme: i2, iconStyle: c2 }, l2)) : this.getEllipsis(), m.a.createElement("span", { className: "brace-row" }, m.a.createElement("span", { style: o(o({}, A(i2, "brace").style), {}, { paddingLeft: p2 ? "3px" : "0px" }) }, "array" === f2 ? "]" : "}"), p2 ? null : this.getObjectMetaData(a2)));
          } }], [{ key: "getDerivedStateFromProps", value: function(e4, t3) {
            var a2 = t3.prevProps;
            return e4.src !== a2.src || e4.collapsed !== a2.collapsed || e4.name !== a2.name || e4.namespace !== a2.namespace || e4.rjvId !== a2.rjvId ? o(o({}, n2.getState(e4)), {}, { prevProps: e4 }) : null;
          } }]), n2;
        }(m.a.PureComponent);
        Me.getState = function(e3) {
          var t2 = Object.keys(e3.src).length, n2 = (false === e3.collapsed || true !== e3.collapsed && e3.collapsed > e3.depth) && (!e3.shouldCollapse || false === e3.shouldCollapse({ name: e3.name, src: e3.src, type: _(e3.src), namespace: e3.namespace })) && 0 !== t2;
          return { expanded: q.get(e3.rjvId, e3.namespace, "expanded", n2), object_type: "array" === e3.type ? "array" : "object", parent_type: "array" === e3.type ? "array" : "object", size: t2, hovered: false };
        };
        var Pe = function e3(t2, n2) {
          i(this, e3), this.name = t2, this.value = n2, this.type = _(n2);
        };
        j(Me);
        var Fe = Me, De = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            var e4;
            i(this, n2);
            for (var a2 = arguments.length, r3 = new Array(a2), o2 = 0; o2 < a2; o2++) r3[o2] = arguments[o2];
            return (e4 = t2.call.apply(t2, [this].concat(r3))).render = function() {
              var t3 = d2(e4).props, n3 = [t3.name], a3 = Fe;
              return Array.isArray(t3.src) && t3.groupArraysAfterLength && t3.src.length > t3.groupArraysAfterLength && (a3 = Ae), m.a.createElement("div", { className: "pretty-json-container object-container" }, m.a.createElement("div", { className: "object-content" }, m.a.createElement(a3, Object.assign({ namespace: n3, depth: 0, jsvRoot: true }, t3))));
            }, e4;
          }
          return n2;
        }(m.a.PureComponent), Ie = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).closeModal = function() {
              z.dispatch({ rjvId: a2.props.rjvId, name: "RESET" });
            }, a2.submit = function() {
              a2.props.submit(a2.state.input);
            }, a2.state = { input: e4.input ? e4.input : "" }, a2;
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this, t3 = this.props, n3 = t3.theme, a2 = t3.rjvId, r3 = t3.isValid, o2 = this.state.input, i2 = r3(o2);
            return m.a.createElement("div", Object.assign({ className: "key-modal-request" }, A(n3, "key-modal-request"), { onClick: this.closeModal }), m.a.createElement("div", Object.assign({}, A(n3, "key-modal"), { onClick: function(e5) {
              e5.stopPropagation();
            } }), m.a.createElement("div", A(n3, "key-modal-label"), "Key Name:"), m.a.createElement("div", { style: { position: "relative" } }, m.a.createElement("input", Object.assign({}, A(n3, "key-modal-input"), { className: "key-modal-input", ref: function(e5) {
              return e5 && e5.focus();
            }, spellCheck: false, value: o2, placeholder: "...", onChange: function(t4) {
              e4.setState({ input: t4.target.value });
            }, onKeyPress: function(t4) {
              i2 && "Enter" === t4.key ? e4.submit() : "Escape" === t4.key && e4.closeModal();
            } })), i2 ? m.a.createElement(je, Object.assign({}, A(n3, "key-modal-submit"), { className: "key-modal-submit", onClick: function(t4) {
              return e4.submit();
            } })) : null), m.a.createElement("span", A(n3, "key-modal-cancel"), m.a.createElement(ge, Object.assign({}, A(n3, "key-modal-cancel-icon"), { className: "key-modal-cancel", onClick: function() {
              z.dispatch({ rjvId: a2, name: "RESET" });
            } })))));
          } }]), n2;
        }(m.a.PureComponent), Re = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            var e4;
            i(this, n2);
            for (var a2 = arguments.length, r3 = new Array(a2), s2 = 0; s2 < a2; s2++) r3[s2] = arguments[s2];
            return (e4 = t2.call.apply(t2, [this].concat(r3))).isValid = function(t3) {
              var n3 = e4.props.rjvId, a3 = q.get(n3, "action", "new-key-request");
              return "" != t3 && -1 === Object.keys(a3.existing_value).indexOf(t3);
            }, e4.submit = function(t3) {
              var n3 = e4.props.rjvId, a3 = q.get(n3, "action", "new-key-request");
              a3.new_value = o({}, a3.existing_value), a3.new_value[t3] = e4.props.defaultValue, z.dispatch({ name: "VARIABLE_ADDED", rjvId: n3, data: a3 });
            }, e4;
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.active, n3 = e4.theme, a2 = e4.rjvId;
            return t3 ? m.a.createElement(Ie, { rjvId: a2, theme: n3, isValid: this.isValid, submit: this.submit }) : null;
          } }]), n2;
        }(m.a.PureComponent), Le = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2() {
            return i(this, n2), t2.apply(this, arguments);
          }
          return c(n2, [{ key: "render", value: function() {
            var e4 = this.props, t3 = e4.message, n3 = e4.active, a2 = e4.theme, r3 = e4.rjvId;
            return n3 ? m.a.createElement("div", Object.assign({ className: "validation-failure" }, A(a2, "validation-failure"), { onClick: function() {
              z.dispatch({ rjvId: r3, name: "RESET" });
            } }), m.a.createElement("span", A(a2, "validation-failure-label"), t3), m.a.createElement(ge, A(a2, "validation-failure-clear"))) : null;
          } }]), n2;
        }(m.a.PureComponent), Be = function(e3) {
          u(n2, e3);
          var t2 = h(n2);
          function n2(e4) {
            var a2;
            return i(this, n2), (a2 = t2.call(this, e4)).rjvId = Date.now().toString(), a2.getListeners = function() {
              return { reset: a2.resetState, "variable-update": a2.updateSrc, "add-key-request": a2.addKeyRequest };
            }, a2.updateSrc = function() {
              var e5, t3 = q.get(a2.rjvId, "action", "variable-update"), n3 = t3.name, r3 = t3.namespace, o2 = t3.new_value, i2 = t3.existing_value, s2 = (t3.variable_removed, t3.updated_src), c2 = t3.type, l2 = a2.props, u2 = l2.onEdit, f2 = l2.onDelete, p2 = l2.onAdd, d3 = { existing_src: a2.state.src, new_value: o2, updated_src: s2, name: n3, namespace: r3, existing_value: i2 };
              switch (c2) {
                case "variable-added":
                  e5 = p2(d3);
                  break;
                case "variable-edited":
                  e5 = u2(d3);
                  break;
                case "variable-removed":
                  e5 = f2(d3);
              }
              false !== e5 ? (q.set(a2.rjvId, "global", "src", s2), a2.setState({ src: s2 })) : a2.setState({ validationFailure: true });
            }, a2.addKeyRequest = function() {
              a2.setState({ addKeyRequest: true });
            }, a2.resetState = function() {
              a2.setState({ validationFailure: false, addKeyRequest: false });
            }, a2.state = { addKeyRequest: false, editKeyRequest: false, validationFailure: false, src: n2.defaultProps.src, name: n2.defaultProps.name, theme: n2.defaultProps.theme, validationMessage: n2.defaultProps.validationMessage, prevSrc: n2.defaultProps.src, prevName: n2.defaultProps.name, prevTheme: n2.defaultProps.theme }, a2;
          }
          return c(n2, [{ key: "componentDidMount", value: function() {
            q.set(this.rjvId, "global", "src", this.state.src);
            var e4 = this.getListeners();
            for (var t3 in e4) q.on(t3 + "-" + this.rjvId, e4[t3]);
            this.setState({ addKeyRequest: false, editKeyRequest: false });
          } }, { key: "componentDidUpdate", value: function(e4, t3) {
            false !== t3.addKeyRequest && this.setState({ addKeyRequest: false }), false !== t3.editKeyRequest && this.setState({ editKeyRequest: false }), e4.src !== this.state.src && q.set(this.rjvId, "global", "src", this.state.src);
          } }, { key: "componentWillUnmount", value: function() {
            var e4 = this.getListeners();
            for (var t3 in e4) q.removeListener(t3 + "-" + this.rjvId, e4[t3]);
          } }, { key: "render", value: function() {
            var e4 = this.state, t3 = e4.validationFailure, n3 = e4.validationMessage, a2 = e4.addKeyRequest, r3 = e4.theme, i2 = e4.src, s2 = e4.name, c2 = this.props, l2 = c2.style, u2 = c2.defaultValue;
            return m.a.createElement("div", { className: "react-json-view", style: o(o({}, A(r3, "app-container").style), l2) }, m.a.createElement(Le, { message: n3, active: t3, theme: r3, rjvId: this.rjvId }), m.a.createElement(De, Object.assign({}, this.props, { src: i2, name: s2, theme: r3, type: _(i2), rjvId: this.rjvId })), m.a.createElement(Re, { active: a2, theme: r3, rjvId: this.rjvId, defaultValue: u2 }));
          } }], [{ key: "getDerivedStateFromProps", value: function(e4, t3) {
            if (e4.src !== t3.prevSrc || e4.name !== t3.prevName || e4.theme !== t3.prevTheme) {
              var a2 = { src: e4.src, name: e4.name, theme: e4.theme, validationMessage: e4.validationMessage, prevSrc: e4.src, prevName: e4.name, prevTheme: e4.theme };
              return n2.validateState(a2);
            }
            return null;
          } }]), n2;
        }(m.a.PureComponent);
        Be.defaultProps = { src: {}, name: "root", theme: "rjv-default", collapsed: false, collapseStringsAfterLength: false, shouldCollapse: false, sortKeys: false, quotesOnKeys: true, groupArraysAfterLength: 100, indentWidth: 4, enableClipboard: true, displayObjectSize: true, displayDataTypes: true, onEdit: false, onDelete: false, onAdd: false, onSelect: false, iconStyle: "triangle", style: {}, validationMessage: "Validation Error", defaultValue: null, displayArrayKey: true }, Be.validateState = function(e3) {
          var t2 = {};
          return "object" !== _(e3.theme) || function(e4) {
            var t3 = ["base00", "base01", "base02", "base03", "base04", "base05", "base06", "base07", "base08", "base09", "base0A", "base0B", "base0C", "base0D", "base0E", "base0F"];
            if ("object" === _(e4)) {
              for (var n2 = 0; n2 < t3.length; n2++) if (!(t3[n2] in e4)) return false;
              return true;
            }
            return false;
          }(e3.theme) || (console.error("react-json-view error:", "theme prop must be a theme name or valid base-16 theme object.", 'defaulting to "rjv-default" theme'), t2.theme = "rjv-default"), "object" !== _(e3.src) && "array" !== _(e3.src) && (console.error("react-json-view error:", "src property must be a valid json object"), t2.name = "ERROR", t2.src = { message: "src property must be a valid json object" }), o(o({}, e3), t2);
        }, j(Be);
        t.default = Be;
      }]);
    });
  })(main$1);
  return main$1.exports;
}
var mainExports = requireMain();
const ReactJson = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
const darkjsonViewerTheme = {
  base00: "#122531",
  base01: "#122531",
  base02: "#122531",
  base03: "#122531",
  base04: "rgba(255,255,255,0.35)",
  base05: "#122531",
  base06: "#122531",
  base07: "rgba(255,255,255,0.85)",
  base08: "#122531",
  base09: "#ffbc00",
  base0A: "#122531",
  base0B: "rgba(255,255,255,0.85)",
  base0C: "rgba(255,255,255,0.85)",
  base0D: "#00b0f5",
  base0E: "#dcc6e0",
  base0F: "rgba(255,255,255,0.85)"
};
const lightjsonViewerTheme = {
  base00: "#f0f1f3",
  base01: "#f0f1f3",
  base02: "#f0f1f3",
  base03: "#f0f1f3",
  base04: "rgba(0,0,0,0.55)",
  base05: "#f0f1f3",
  base06: "#f0f1f3",
  base07: "rgba(0,0,0,0.85)",
  base08: "#f0f1f3",
  base09: "#a000bc",
  base0A: "#f0f1f3",
  base0B: "rgba(0,0,0,0.85)",
  base0C: "rgba(0,0,0,0.85)",
  base0D: "#00b0f5",
  base0E: "#7928a1",
  base0F: "rgba(0,0,0,0.85)"
};
const JSONObject = ({
  className,
  value,
  kind,
  theme,
  empty: empty2,
  style: style2,
  collapsed
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: modifiers("pipeline-json__object", { kind }, className), children: Object.keys(value).length === 0 ? empty2 : /* @__PURE__ */ jsxRuntimeExports.jsx(
  ReactJson,
  {
    theme: theme === "dark" ? darkjsonViewerTheme : lightjsonViewerTheme,
    name: false,
    indentWidth: 1,
    collapsed: collapsed ? collapsed : 1,
    collapseStringsAfterLength: true,
    enableClipboard: true,
    displayDataTypes: false,
    src: value,
    style: style2 ? style2 : { backgroundColor: "transparent" }
  }
) });
/*! @license DOMPurify 3.3.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.0/LICENSE */
var purify_cjs;
var hasRequiredPurify_cjs;
function requirePurify_cjs() {
  if (hasRequiredPurify_cjs) return purify_cjs;
  hasRequiredPurify_cjs = 1;
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create: create2
  } = Object;
  let {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply) {
    apply = function apply2(func, thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return func.apply(thisArg, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(Func) {
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return construct(Func, args);
    };
  }
  function addToSet(set2, array2) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set2, null);
    }
    let l = array2.length;
    while (l--) {
      let element = array2[l];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array2)) {
            array2[l] = lcElement;
          }
          element = lcElement;
        }
      }
      set2[element] = true;
    }
    return set2;
  }
  function cleanArray(array2) {
    for (let index = 0; index < array2.length; index++) {
      const isPropertyExist = objectHasOwnProperty(array2, index);
      if (!isPropertyExist) {
        array2[index] = null;
      }
    }
    return array2;
  }
  function clone(object2) {
    const newObject = create2(null);
    for (const [property, value] of entries(object2)) {
      const isPropertyExist = objectHasOwnProperty(object2, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object2, prop) {
    while (object2 !== null) {
      const desc = getOwnPropertyDescriptor(object2, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object2 = getPrototypeOf(object2);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  const text = freeze(["#text"]);
  const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  const IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  const NODE_TYPE = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  };
  const getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify2 = (root2) => createDOMPurify(root2);
    DOMPurify2.version = "3.3.0";
    DOMPurify2.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify2.isSupported = false;
      return DOMPurify2;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element,
      NodeFilter,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser,
      trustedTypes
    } = window2;
    const ElementPrototype = Element.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove2 = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify2.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create2(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    const EXTRA_ELEMENT_HANDLING = Object.seal(create2(null, {
      tagCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      }
    }));
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (typeof cfg.ADD_TAGS === "function") {
          EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
        } else {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
      }
      if (cfg.ADD_ATTR) {
        if (typeof cfg.ADD_ATTR === "function") {
          EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
        } else {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node2) {
      arrayPush(DOMPurify2.removed, {
        element: node2
      });
      try {
        getParentNode(node2).removeChild(node2);
      } catch (_) {
        remove2(node2);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify2.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_) {
        arrayPush(DOMPurify2.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root2) {
      return createNodeIterator.call(
        root2.ownerDocument || root2,
        root2,
        // eslint-disable-next-line no-bitwise
        NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify2, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i = childCount - 1; i >= 0; --i) {
              const childClone = cloneNode(childNodes[i], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content = stringReplace(content, expr, " ");
        });
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify2.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l = attributes.length;
      while (l--) {
        const attr = attributes[l];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        const initValue = attrValue;
        let value = name === "value" ? initValue : stringTrim(initValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (lcName === "attributename" && stringMatch(value, "href")) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        if (value !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify2.removed);
            }
          } catch (_) {
            _removeAttribute(name, currentNode);
          }
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify2.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify2.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify2.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify2.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify2.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify2.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify2.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify2.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index === -1 ? void 0 : arraySplice(hooks[entryPoint], index, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify2.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify2.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify2;
  }
  var purify = createDOMPurify();
  purify_cjs = purify;
  return purify_cjs;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = window.DOMPurify || (window.DOMPurify = requirePurify_cjs().default || requirePurify_cjs());
  return browser;
}
var browserExports = requireBrowser();
const DOMPurify = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
const renderMarkdownToHTML = (markdown) => {
  if (!markdown || typeof markdown !== "string") {
    return "";
  }
  let html = markdown;
  html = html.replace(
    /\|(.+)\|\n\|[-s|:]+\|\n((?:\|.+\|\n?)*)/gim,
    (match2, header, rows) => {
      const headerCells = header.split("|").map((cell) => cell.trim()).filter((cell) => cell);
      const headerRow = "<tr>" + headerCells.map((cell) => `<th>${cell}</th>`).join("") + "</tr>";
      const bodyRows = rows.trim().split("\n").map((row) => {
        const cells = row.split("|").map((cell) => cell.trim()).filter((cell) => cell);
        return "<tr>" + cells.map((cell) => `<td>${cell}</td>`).join("") + "</tr>";
      }).join("");
      return `<table><thead>${headerRow}</thead><tbody>${bodyRows}</tbody></table>`;
    }
  );
  html = html.replace(/^### (.*$)/gim, "<h3>$1</h3>");
  html = html.replace(/^## (.*$)/gim, "<h2>$1</h2>");
  html = html.replace(/^# (.*$)/gim, "<h1>$1</h1>");
  html = html.replace(/\*\*(.*?)\*\*/gim, "<strong>$1</strong>");
  html = html.replace(/__(.*?)__/gim, "<strong>$1</strong>");
  html = html.replace(/\*(.*?)\*/gim, "<em>$1</em>");
  html = html.replace(/_(.*?)_/gim, "<em>$1</em>");
  html = html.replace(
    /```(\w+)?\n([\s\S]*?)```/gim,
    '<pre><code class="language-$1">$2</code></pre>'
  );
  html = html.replace(/`([^`]+)`/gim, "<code>$1</code>");
  html = html.replace(
    /\[([^\]]+)\]\(([^)]+)\)/gim,
    '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>'
  );
  html = html.replace(/^\d+\.\s(.+)$/gim, "<li>$1</li>");
  html = html.replace(/^[*-]\s(.+)$/gim, "<li>$1</li>");
  html = html.replace(/(<li>.*<\/li>)/gims, (match2) => {
    const originalText = markdown.substring(
      markdown.indexOf(match2.replace(/<\/?li>/g, ""))
    );
    if (/^\d+\./.test(originalText)) {
      return "<ol>" + match2 + "</ol>";
    }
    return "<ul>" + match2 + "</ul>";
  });
  html = html.replace(/<\/(ul|ol)>\s*<\1>/gim, "");
  html = html.replace(/\n\s*\n/gim, "</p><p>");
  html = html.replace(/\n/gim, "<br>");
  html = "<p>" + html + "</p>";
  html = html.replace(/<p><\/p>/gim, "");
  html = html.replace(/<p><br><\/p>/gim, "");
  html = html.replace(/<p>(<table>.*?<\/table>)<\/p>/gims, "$1");
  html = html.replace(/<p>(<[uo]l>.*?<\/[uo]l>)<\/p>/gims, "$1");
  html = html.replace(/<p>(<h[1-6]>.*?<\/h[1-6]>)<\/p>/gims, "$1");
  return html;
};
const HTMLRenderer = ({ content, className = "", fontSize }) => {
  const style2 = fontSize ? { fontSize } : {};
  const sanitisedContent = DOMPurify.sanitize(content || "");
  const htmlContent = renderMarkdownToHTML(sanitisedContent);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classnames("html-renderer", className),
      style: style2,
      dangerouslySetInnerHTML: { __html: htmlContent }
    }
  );
};
var factory = {};
var hasRequiredFactory;
function requireFactory() {
  if (hasRequiredFactory) return factory;
  hasRequiredFactory = 1;
  (function(exports) {
    function _typeof2(obj) {
      "@babel/helpers - typeof";
      return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof2(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = plotComponentFactory;
    var _react = _interopRequireWildcard(requireReact());
    var _propTypes = _interopRequireDefault(/* @__PURE__ */ requirePropTypes());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
        return { "default": obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj["default"] = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass) _setPrototypeOf2(subClass, superClass);
    }
    function _setPrototypeOf2(o, p) {
      _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf2(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof2(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var eventNames = ["AfterExport", "AfterPlot", "Animated", "AnimatingFrame", "AnimationInterrupted", "AutoSize", "BeforeExport", "BeforeHover", "ButtonClicked", "Click", "ClickAnnotation", "Deselect", "DoubleClick", "Framework", "Hover", "LegendClick", "LegendDoubleClick", "Relayout", "Relayouting", "Restyle", "Redraw", "Selected", "Selecting", "SliderChange", "SliderEnd", "SliderStart", "SunburstClick", "Transitioning", "TransitionInterrupted", "Unhover", "WebGlContextLost"];
    var updateEvents = ["plotly_restyle", "plotly_redraw", "plotly_relayout", "plotly_relayouting", "plotly_doubleclick", "plotly_animated", "plotly_sunburstclick"];
    var isBrowser2 = typeof window !== "undefined";
    function plotComponentFactory(Plotly2) {
      var PlotlyComponent = /* @__PURE__ */ function(_Component) {
        _inherits(PlotlyComponent2, _Component);
        var _super = _createSuper(PlotlyComponent2);
        function PlotlyComponent2(props) {
          var _this;
          _classCallCheck(this, PlotlyComponent2);
          _this = _super.call(this, props);
          _this.p = Promise.resolve();
          _this.resizeHandler = null;
          _this.handlers = {};
          _this.syncWindowResize = _this.syncWindowResize.bind(_assertThisInitialized(_this));
          _this.syncEventHandlers = _this.syncEventHandlers.bind(_assertThisInitialized(_this));
          _this.attachUpdateEvents = _this.attachUpdateEvents.bind(_assertThisInitialized(_this));
          _this.getRef = _this.getRef.bind(_assertThisInitialized(_this));
          _this.handleUpdate = _this.handleUpdate.bind(_assertThisInitialized(_this));
          _this.figureCallback = _this.figureCallback.bind(_assertThisInitialized(_this));
          _this.updatePlotly = _this.updatePlotly.bind(_assertThisInitialized(_this));
          return _this;
        }
        _createClass(PlotlyComponent2, [{
          key: "updatePlotly",
          value: function updatePlotly(shouldInvokeResizeHandler, figureCallbackFunction, shouldAttachUpdateEvents) {
            var _this2 = this;
            this.p = this.p.then(function() {
              if (_this2.unmounting) {
                return;
              }
              if (!_this2.el) {
                throw new Error("Missing element reference");
              }
              return Plotly2.react(_this2.el, {
                data: _this2.props.data,
                layout: _this2.props.layout,
                config: _this2.props.config,
                frames: _this2.props.frames
              });
            }).then(function() {
              if (_this2.unmounting) {
                return;
              }
              _this2.syncWindowResize(shouldInvokeResizeHandler);
              _this2.syncEventHandlers();
              _this2.figureCallback(figureCallbackFunction);
              if (shouldAttachUpdateEvents) {
                _this2.attachUpdateEvents();
              }
            })["catch"](function(err) {
              if (_this2.props.onError) {
                _this2.props.onError(err);
              }
            });
          }
        }, {
          key: "componentDidMount",
          value: function componentDidMount() {
            this.unmounting = false;
            this.updatePlotly(true, this.props.onInitialized, true);
          }
        }, {
          key: "componentDidUpdate",
          value: function componentDidUpdate(prevProps) {
            this.unmounting = false;
            var numPrevFrames = prevProps.frames && prevProps.frames.length ? prevProps.frames.length : 0;
            var numNextFrames = this.props.frames && this.props.frames.length ? this.props.frames.length : 0;
            var figureChanged = !(prevProps.layout === this.props.layout && prevProps.data === this.props.data && prevProps.config === this.props.config && numNextFrames === numPrevFrames);
            var revisionDefined = prevProps.revision !== void 0;
            var revisionChanged = prevProps.revision !== this.props.revision;
            if (!figureChanged && (!revisionDefined || revisionDefined && !revisionChanged)) {
              return;
            }
            this.updatePlotly(false, this.props.onUpdate, false);
          }
        }, {
          key: "componentWillUnmount",
          value: function componentWillUnmount() {
            this.unmounting = true;
            this.figureCallback(this.props.onPurge);
            if (this.resizeHandler && isBrowser2) {
              window.removeEventListener("resize", this.resizeHandler);
              this.resizeHandler = null;
            }
            this.removeUpdateEvents();
            Plotly2.purge(this.el);
          }
        }, {
          key: "attachUpdateEvents",
          value: function attachUpdateEvents() {
            var _this3 = this;
            if (!this.el || !this.el.removeListener) {
              return;
            }
            updateEvents.forEach(function(updateEvent) {
              _this3.el.on(updateEvent, _this3.handleUpdate);
            });
          }
        }, {
          key: "removeUpdateEvents",
          value: function removeUpdateEvents() {
            var _this4 = this;
            if (!this.el || !this.el.removeListener) {
              return;
            }
            updateEvents.forEach(function(updateEvent) {
              _this4.el.removeListener(updateEvent, _this4.handleUpdate);
            });
          }
        }, {
          key: "handleUpdate",
          value: function handleUpdate() {
            this.figureCallback(this.props.onUpdate);
          }
        }, {
          key: "figureCallback",
          value: function figureCallback(callback) {
            if (typeof callback === "function") {
              var _this$el = this.el, data = _this$el.data, layout = _this$el.layout;
              var frames = this.el._transitionData ? this.el._transitionData._frames : null;
              var figure = {
                data,
                layout,
                frames
              };
              callback(figure, this.el);
            }
          }
        }, {
          key: "syncWindowResize",
          value: function syncWindowResize(invoke) {
            var _this5 = this;
            if (!isBrowser2) {
              return;
            }
            if (this.props.useResizeHandler && !this.resizeHandler) {
              this.resizeHandler = function() {
                return Plotly2.Plots.resize(_this5.el);
              };
              window.addEventListener("resize", this.resizeHandler);
              if (invoke) {
                this.resizeHandler();
              }
            } else if (!this.props.useResizeHandler && this.resizeHandler) {
              window.removeEventListener("resize", this.resizeHandler);
              this.resizeHandler = null;
            }
          }
        }, {
          key: "getRef",
          value: function getRef(el) {
            this.el = el;
            if (this.props.debug && isBrowser2) {
              window.gd = this.el;
            }
          }
          // Attach and remove event handlers as they're added or removed from props:
        }, {
          key: "syncEventHandlers",
          value: function syncEventHandlers() {
            var _this6 = this;
            eventNames.forEach(function(eventName) {
              var prop = _this6.props["on" + eventName];
              var handler = _this6.handlers[eventName];
              var hasHandler = Boolean(handler);
              if (prop && !hasHandler) {
                _this6.addEventHandler(eventName, prop);
              } else if (!prop && hasHandler) {
                _this6.removeEventHandler(eventName);
              } else if (prop && hasHandler && prop !== handler) {
                _this6.removeEventHandler(eventName);
                _this6.addEventHandler(eventName, prop);
              }
            });
          }
        }, {
          key: "addEventHandler",
          value: function addEventHandler(eventName, prop) {
            this.handlers[eventName] = prop;
            this.el.on(this.getPlotlyEventName(eventName), this.handlers[eventName]);
          }
        }, {
          key: "removeEventHandler",
          value: function removeEventHandler(eventName) {
            this.el.removeListener(this.getPlotlyEventName(eventName), this.handlers[eventName]);
            delete this.handlers[eventName];
          }
        }, {
          key: "getPlotlyEventName",
          value: function getPlotlyEventName(eventName) {
            return "plotly_" + eventName.toLowerCase();
          }
        }, {
          key: "render",
          value: function render() {
            return /* @__PURE__ */ _react["default"].createElement("div", {
              id: this.props.divId,
              style: this.props.style,
              ref: this.getRef,
              className: this.props.className
            });
          }
        }]);
        return PlotlyComponent2;
      }(_react.Component);
      PlotlyComponent.propTypes = {
        data: _propTypes["default"].arrayOf(_propTypes["default"].object),
        config: _propTypes["default"].object,
        layout: _propTypes["default"].object,
        frames: _propTypes["default"].arrayOf(_propTypes["default"].object),
        revision: _propTypes["default"].number,
        onInitialized: _propTypes["default"].func,
        onPurge: _propTypes["default"].func,
        onError: _propTypes["default"].func,
        onUpdate: _propTypes["default"].func,
        debug: _propTypes["default"].bool,
        style: _propTypes["default"].object,
        className: _propTypes["default"].string,
        useResizeHandler: _propTypes["default"].bool,
        divId: _propTypes["default"].string
      };
      eventNames.forEach(function(eventName) {
        PlotlyComponent.propTypes["on" + eventName] = _propTypes["default"].func;
      });
      PlotlyComponent.defaultProps = {
        debug: false,
        useResizeHandler: false,
        data: [],
        style: {
          position: "relative",
          display: "inline-block"
        }
      };
      return PlotlyComponent;
    }
  })(factory);
  return factory;
}
var factoryExports = requireFactory();
const createPlotlyComponent = /* @__PURE__ */ getDefaultExportFromCjs(factoryExports);
const darkTemplate = {
  autosize: true,
  annotationdefaults: {
    arrowcolor: "#2a3f5f",
    arrowhead: 0,
    arrowwidth: 1
  },
  autotypenumbers: "strict",
  coloraxis: {
    autocolorscale: false,
    colorbar: {
      thickness: 20,
      showticklabels: true,
      ticks: "outside",
      tickwidth: 1,
      tickcolor: "rgba(255,255,255,0.30)",
      ticklen: 12,
      tickfont: {
        color: "rgba(255,255,255,0.55)",
        size: 12
      },
      ticklabelposition: "outside",
      title: {
        font: {
          color: "rgba(255,255,255,0.55)",
          size: 12
        }
      }
    }
  },
  colorscale: {
    diverging: [
      "rgb(230,59,90)",
      "rgb(240,185,186)",
      "rgb(237,212,213)",
      "rgb(232,232,232)",
      "rgb(190,213,236)",
      "rgb(136,192,240)",
      "rgb(0,169,244)"
    ],
    sequential: [
      "rgb(0,169,244)",
      "rgb(60,175,245)",
      "rgb(148,203,250)",
      "rgb(195,225,254)",
      "rgb(214,235,255)"
    ],
    sequentialminus: [
      "rgb(0,169,244)",
      "rgb(60,175,245)",
      "rgb(148,203,250)",
      "rgb(195,225,254)",
      "rgb(214,235,255)"
    ]
  },
  colorway: [
    "#00a9f4",
    "#42459F",
    "#F4973B",
    "#E63B5A",
    "#948DCA",
    "#769D00",
    "#1A2E91",
    "#4F9596",
    "#F7D02A",
    "#F07179",
    "#3C7A34",
    "#B2DFE1",
    "#C1BCE5",
    "#AD544A",
    "#F4973B",
    "#B6CD70",
    "#65A6A8",
    "#F8E979"
  ],
  font: {
    color: "rgba(255,255,255,0.55)"
  },
  height: null,
  hoverlabel: {
    align: "left"
  },
  hovermode: "closest",
  legend: {
    title: {
      font: {
        color: "rgba(255,255,255,0.55)"
      }
    },
    font: {
      color: "rgba(255,255,255,0.55)"
    }
  },
  mapbox: {
    style: "DARK"
  },
  paper_bgcolor: "#111111",
  plot_bgcolor: "#111111",
  title: {
    font: {
      color: "rgba(255,255,255,0.85)",
      size: 16
    },
    xref: "paper",
    yref: "paper",
    x: 0,
    xanchor: "left",
    yanchor: "middle"
  },
  width: null,
  xaxis: {
    automargin: true,
    gridcolor: "rgba(255,255,255,0.12)",
    layer: "below traces",
    linewidth: 1,
    linecolor: "rgba(255,255,255,0.30)",
    rangemode: "normal",
    showline: true,
    showticklabels: true,
    ticks: "outside",
    tickwidth: 1,
    tickcolor: "rgba(255,255,255,0.30)",
    ticklen: 12,
    tickfont: {
      color: "rgba(255,255,255,0.55)",
      size: 12
    },
    ticklabelposition: "outside",
    title: {
      font: {
        color: "rgba(255,255,255,0.55)",
        size: 16
      }
    },
    zerolinecolor: "rgba(255,255,255,0.30)",
    zerolinewidth: 1
  },
  yaxis: {
    automargin: true,
    gridcolor: "rgba(255,255,255,0.12)",
    layer: "below traces",
    linewidth: 1,
    linecolor: "rgba(255,255,255,0.30)",
    rangemode: "normal",
    showline: true,
    showticklabels: true,
    ticks: "outside",
    tickwidth: 1,
    tickcolor: "rgba(255,255,255,0.30)",
    ticklen: 12,
    tickfont: {
      color: "rgba(255,255,255,0.55)",
      size: 12
    },
    ticklabelposition: "outside",
    title: {
      font: {
        color: "rgba(255,255,255,0.55)",
        size: 16
      }
    },
    zerolinecolor: "rgba(255,255,255,0.30)",
    zerolinewidth: 1
  },
  margin: {
    l: 72,
    r: 40,
    t: 64,
    b: 72
  }
};
const darkModalTemplate = {
  ...darkTemplate
};
const darkPreviewTemplate = {
  ...darkTemplate,
  height: 300,
  margin: {
    l: 70,
    r: 40,
    t: 60,
    b: 70
  },
  title: {
    font: {
      size: 12
    },
    x: 0.09
  },
  showlegend: false,
  width: 400,
  xaxis: {
    ...darkTemplate.xaxis,
    title: {
      ...darkTemplate.xaxis.title,
      font: {
        ...darkTemplate.xaxis.font,
        size: 8
      }
    },
    tickfont: {
      ...darkTemplate.xaxis.tickfont,
      size: 8
    },
    nticks: 5
  },
  yaxis: {
    ...darkTemplate.yaxis,
    title: {
      ...darkTemplate.yaxis.title,
      font: {
        ...darkTemplate.yaxis.font,
        size: 8
      }
    },
    tickfont: {
      ...darkTemplate.yaxis.tickfont,
      size: 8
    },
    nticks: 5
  }
};
const lightTemplate = {
  autosize: true,
  annotationdefaults: {
    arrowcolor: "#2a3f5f",
    arrowhead: 0,
    arrowwidth: 1
  },
  autotypenumbers: "strict",
  coloraxis: {
    autocolorscale: false,
    colorbar: {
      thickness: 20,
      showticklabels: true,
      ticks: "outside",
      tickwidth: 1,
      tickcolor: "rgba(0,0,0,0.30)",
      ticklen: 12,
      tickfont: {
        color: "rgba(0,0,0,0.55)",
        size: 12
      },
      ticklabelposition: "outside",
      title: {
        font: {
          color: "rgba(0,0,0,0.55)",
          size: 12
        }
      }
    }
  },
  colorscale: {
    diverging: [
      "rgb(230,59,90)",
      "rgb(240,185,186)",
      "rgb(237,212,213)",
      "rgb(232,232,232)",
      "rgb(190,213,236)",
      "rgb(136,192,240)",
      "rgb(0,169,244)"
    ],
    sequential: [
      "rgb(0,169,244)",
      "rgb(60,175,245)",
      "rgb(148,203,250)",
      "rgb(195,225,254)",
      "rgb(214,235,255)"
    ],
    sequentialminus: [
      "rgb(0,169,244)",
      "rgb(60,175,245)",
      "rgb(148,203,250)",
      "rgb(195,225,254)",
      "rgb(214,235,255)"
    ]
  },
  colorway: [
    "#00a9f4",
    "#42459F",
    "#F4973B",
    "#E63B5A",
    "#948DCA",
    "#769D00",
    "#1A2E91",
    "#4F9596",
    "#F7D02A",
    "#F07179",
    "#3C7A34",
    "#B2DFE1",
    "#C1BCE5",
    "#AD544A",
    "#F4973B",
    "#B6CD70",
    "#65A6A8",
    "#F8E979"
  ],
  font: {
    color: "rgba(0,0,0,0.55)"
  },
  height: null,
  hoverlabel: {
    align: "left"
  },
  hovermode: "closest",
  legend: {
    title: {
      font: {
        color: "rgba(0,0,0,0.55)"
      }
    },
    font: {
      color: "rgba(0,0,0,0.55)"
    }
  },
  mapbox: {
    style: "light"
  },
  paper_bgcolor: "#EEEEEE",
  plot_bgcolor: "#EEEEEE",
  title: {
    font: {
      color: "rgba(0,0,0,0.85)",
      size: 16
    },
    xref: "paper",
    yref: "paper",
    x: 0,
    xanchor: "left",
    yanchor: "middle"
  },
  width: null,
  xaxis: {
    automargin: true,
    gridcolor: "rgba(0,0,0,0.12)",
    layer: "below traces",
    linewidth: 1,
    linecolor: "rgba(0,0,0,0.30)",
    rangemode: "normal",
    showline: true,
    showticklabels: true,
    ticks: "outside",
    tickwidth: 1,
    tickcolor: "rgba(0,0,0,0.30)",
    ticklen: 12,
    tickfont: {
      color: "rgba(0,0,0,0.55)",
      size: 12
    },
    ticklabelposition: "outside",
    title: {
      font: {
        color: "rgba(0,0,0,0.55)",
        size: 16
      }
    },
    zerolinecolor: "rgba(0,0,0,0.30)",
    zerolinewidth: 1
  },
  yaxis: {
    automargin: true,
    gridcolor: "rgba(0,0,0,0.12)",
    layer: "below traces",
    linewidth: 1,
    linecolor: "rgba(0,0,0,0.30)",
    rangemode: "normal",
    showline: true,
    showticklabels: true,
    ticks: "outside",
    tickwidth: 1,
    tickcolor: "rgba(0,0,0,0.30)",
    ticklen: 12,
    tickfont: {
      color: "rgba(0,0,0,0.55)",
      size: 12
    },
    ticklabelposition: "outside",
    title: {
      font: {
        color: "rgba(0,0,0,0.55)",
        size: 16
      }
    },
    zerolinecolor: "rgba(0,0,0,0.30)",
    zerolinewidth: 1
  },
  margin: {
    l: 72,
    r: 40,
    t: 64,
    b: 72
  }
};
const lightModalTemplate = {
  ...lightTemplate
};
const lightPreviewTemplate = {
  ...lightTemplate,
  height: 300,
  margin: {
    l: 70,
    r: 40,
    t: 60,
    b: 70
  },
  showlegend: false,
  width: 400,
  title: {
    font: {
      size: 12
    },
    x: 0.09
  },
  xaxis: {
    ...lightTemplate.xaxis,
    title: {
      ...lightTemplate.xaxis.title,
      font: {
        ...lightTemplate.xaxis.font,
        size: 8
      }
    },
    tickfont: {
      ...lightTemplate.xaxis.tickfont,
      size: 8
    },
    nticks: 5
  },
  yaxis: {
    ...lightTemplate.yaxis,
    title: {
      ...lightTemplate.yaxis.title,
      font: {
        ...lightTemplate.yaxis.font,
        size: 8
      }
    },
    tickfont: {
      ...lightTemplate.yaxis.tickfont,
      size: 8
    },
    nticks: 5
  }
};
const Plot = createPlotlyComponent(Plotly);
const PlotlyChart = ({ theme, view = "", data = [], layout = {} }) => {
  const plotConfig = view.includes("preview") ? { staticPlot: true } : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: classnames(
        "pipeline-plotly-chart",
        `pipeline-plotly__${view}`
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Plot,
        {
          data,
          layout: updateLayout(theme, view, layout),
          config: plotConfig,
          style: { width: "100%", height: "100%" },
          useResizeHandler: true
        }
      )
    }
  );
};
const updateLayout = (theme, view, layout) => {
  if (theme === "dark") {
    if (view === "modal") {
      return deepmerge$2(layout, darkModalTemplate);
    }
    return deepmerge$2(layout, darkPreviewTemplate);
  } else {
    if (view === "modal") {
      return deepmerge$2(layout, lightModalTemplate);
    }
    return deepmerge$2(layout, lightPreviewTemplate);
  }
};
const mapStateToProps$i = (state) => ({
  theme: state.theme
});
const PlotlyChart$1 = connect(mapStateToProps$i)(PlotlyChart);
const ExpandIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M21 5v16H5v-8h2v6h12V7h-6.116V5H21zM8 3v2H6.415l6.292 6.293-1.414 1.414L5 6.415V8H3V3h5z" }) });
const MetaDataValue = ({
  className,
  container: Container = "span",
  empty: empty2,
  kind,
  title,
  value
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  Container,
  {
    title,
    className: modifiers("pipeline-metadata__value", { kind }, className),
    children: !value && value !== 0 ? empty2 : value
  }
) });
const MetaDataList = ({
  property,
  values: values2 = [],
  kind = "text",
  empty: empty2 = "-",
  inline = true,
  commas = true,
  limit = false
}) => {
  const [expanded, setExpanded] = reactExports.useState(false);
  const showValues = !expanded && limit ? values2.slice(0, limit) : values2;
  const remainder = values2.length - showValues.length;
  reactExports.useEffect(() => setExpanded(false), [values2]);
  return values2.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "ul",
      {
        className: modifiers("pipeline-metadata__value-list", {
          inline,
          commas
        }),
        children: showValues.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MetaDataValue,
          {
            value: property ? item[property] : item,
            kind,
            empty: empty2
          }
        ) }, index))
      }
    ),
    remainder > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        className: "pipeline-metadata__value-list-expand",
        "aria-expanded": expanded,
        onClick: () => setExpanded(true),
        children: [
          "+ ",
          remainder,
          " more"
        ]
      }
    ) : null
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MetaDataValue, { empty: empty2 });
};
const MetaDataRow = ({
  label,
  theme,
  property,
  value,
  kind = "text",
  empty: empty2 = "-",
  visible = true,
  inline = true,
  commas = true,
  limit = false,
  title = null,
  children: children2
}) => {
  const showList = Array.isArray(value);
  const showObject = typeof value === "object" && value !== null && !showList;
  return visible && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("dt", { className: "pipeline-metadata__label", children: label }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("dd", { className: "pipeline-metadata__row", "data-label": label, children: [
      showList && /* @__PURE__ */ jsxRuntimeExports.jsx(
        MetaDataList,
        {
          property,
          inline,
          commas,
          kind,
          empty: empty2,
          values: value,
          limit
        }
      ),
      !showList && !showObject && !children2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        MetaDataValue,
        {
          empty: empty2,
          kind,
          theme,
          title: title || value,
          value
        }
      ),
      showObject && /* @__PURE__ */ jsxRuntimeExports.jsx(JSONObject, { value, kind, theme, empty: empty2 }),
      children2
    ] })
  ] });
};
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  function deepFreeze(obj) {
    if (obj instanceof Map) {
      obj.clear = obj.delete = obj.set = function() {
        throw new Error("map is read-only");
      };
    } else if (obj instanceof Set) {
      obj.add = obj.clear = obj.delete = function() {
        throw new Error("set is read-only");
      };
    }
    Object.freeze(obj);
    Object.getOwnPropertyNames(obj).forEach(function(name) {
      var prop = obj[name];
      if (typeof prop == "object" && !Object.isFrozen(prop)) {
        deepFreeze(prop);
      }
    });
    return obj;
  }
  var deepFreezeEs6 = deepFreeze;
  var _default = deepFreeze;
  deepFreezeEs6.default = _default;
  class Response {
    /**
     * @param {CompiledMode} mode
     */
    constructor(mode) {
      if (mode.data === void 0) mode.data = {};
      this.data = mode.data;
      this.isMatchIgnored = false;
    }
    ignoreMatch() {
      this.isMatchIgnored = true;
    }
  }
  function escapeHTML(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function inherit2(original, ...objects) {
    const result = /* @__PURE__ */ Object.create(null);
    for (const key in original) {
      result[key] = original[key];
    }
    objects.forEach(function(obj) {
      for (const key in obj) {
        result[key] = obj[key];
      }
    });
    return (
      /** @type {T} */
      result
    );
  }
  const SPAN_CLOSE = "</span>";
  const emitsWrappingTags = (node2) => {
    return !!node2.kind;
  };
  class HTMLRenderer2 {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor(parseTree, options) {
      this.buffer = "";
      this.classPrefix = options.classPrefix;
      parseTree.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText(text) {
      this.buffer += escapeHTML(text);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode(node2) {
      if (!emitsWrappingTags(node2)) return;
      let className = node2.kind;
      if (!node2.sublanguage) {
        className = `${this.classPrefix}${className}`;
      }
      this.span(className);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode(node2) {
      if (!emitsWrappingTags(node2)) return;
      this.buffer += SPAN_CLOSE;
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span(className) {
      this.buffer += `<span class="${className}">`;
    }
  }
  class TokenTree {
    constructor() {
      this.rootNode = { children: [] };
      this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add(node2) {
      this.top.children.push(node2);
    }
    /** @param {string} kind */
    openNode(kind) {
      const node2 = { kind, children: [] };
      this.add(node2);
      this.stack.push(node2);
    }
    closeNode() {
      if (this.stack.length > 1) {
        return this.stack.pop();
      }
      return void 0;
    }
    closeAllNodes() {
      while (this.closeNode()) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk(builder) {
      return this.constructor._walk(builder, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk(builder, node2) {
      if (typeof node2 === "string") {
        builder.addText(node2);
      } else if (node2.children) {
        builder.openNode(node2);
        node2.children.forEach((child) => this._walk(builder, child));
        builder.closeNode(node2);
      }
      return builder;
    }
    /**
     * @param {Node} node
     */
    static _collapse(node2) {
      if (typeof node2 === "string") return;
      if (!node2.children) return;
      if (node2.children.every((el) => typeof el === "string")) {
        node2.children = [node2.children.join("")];
      } else {
        node2.children.forEach((child) => {
          TokenTree._collapse(child);
        });
      }
    }
  }
  class TokenTreeEmitter extends TokenTree {
    /**
     * @param {*} options
     */
    constructor(options) {
      super();
      this.options = options;
    }
    /**
     * @param {string} text
     * @param {string} kind
     */
    addKeyword(text, kind) {
      if (text === "") {
        return;
      }
      this.openNode(kind);
      this.addText(text);
      this.closeNode();
    }
    /**
     * @param {string} text
     */
    addText(text) {
      if (text === "") {
        return;
      }
      this.add(text);
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    addSublanguage(emitter, name) {
      const node2 = emitter.root;
      node2.kind = name;
      node2.sublanguage = true;
      this.add(node2);
    }
    toHTML() {
      const renderer = new HTMLRenderer2(this, this.options);
      return renderer.value();
    }
    finalize() {
      return true;
    }
  }
  function escape(value) {
    return new RegExp(value.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "m");
  }
  function source(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function concat(...args) {
    const joined = args.map((x2) => source(x2)).join("");
    return joined;
  }
  function either(...args) {
    const joined = "(" + args.map((x2) => source(x2)).join("|") + ")";
    return joined;
  }
  function countMatchGroups(re) {
    return new RegExp(re.toString() + "|").exec("").length - 1;
  }
  function startsWith(re, lexeme) {
    const match2 = re && re.exec(lexeme);
    return match2 && match2.index === 0;
  }
  const BACKREF_RE = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function join(regexps, separator = "|") {
    let numCaptures = 0;
    return regexps.map((regex) => {
      numCaptures += 1;
      const offset = numCaptures;
      let re = source(regex);
      let out = "";
      while (re.length > 0) {
        const match2 = BACKREF_RE.exec(re);
        if (!match2) {
          out += re;
          break;
        }
        out += re.substring(0, match2.index);
        re = re.substring(match2.index + match2[0].length);
        if (match2[0][0] === "\\" && match2[1]) {
          out += "\\" + String(Number(match2[1]) + offset);
        } else {
          out += match2[0];
          if (match2[0] === "(") {
            numCaptures++;
          }
        }
      }
      return out;
    }).map((re) => `(${re})`).join(separator);
  }
  const MATCH_NOTHING_RE = /\b\B/;
  const IDENT_RE = "[a-zA-Z]\\w*";
  const UNDERSCORE_IDENT_RE = "[a-zA-Z_]\\w*";
  const NUMBER_RE = "\\b\\d+(\\.\\d+)?";
  const C_NUMBER_RE = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";
  const BINARY_NUMBER_RE = "\\b(0b[01]+)";
  const RE_STARTERS_RE = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";
  const SHEBANG = (opts = {}) => {
    const beginShebang = /^#![ ]*\//;
    if (opts.binary) {
      opts.begin = concat(
        beginShebang,
        /.*\b/,
        opts.binary,
        /\b.*/
      );
    }
    return inherit2({
      className: "meta",
      begin: beginShebang,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (m, resp) => {
        if (m.index !== 0) resp.ignoreMatch();
      }
    }, opts);
  };
  const BACKSLASH_ESCAPE = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  };
  const APOS_STRING_MODE = {
    className: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const QUOTE_STRING_MODE = {
    className: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [BACKSLASH_ESCAPE]
  };
  const PHRASAL_WORDS_MODE = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  };
  const COMMENT2 = function(begin, end, modeOptions = {}) {
    const mode = inherit2(
      {
        className: "comment",
        begin,
        end,
        contains: []
      },
      modeOptions
    );
    mode.contains.push(PHRASAL_WORDS_MODE);
    mode.contains.push({
      className: "doctag",
      begin: "(?:TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",
      relevance: 0
    });
    return mode;
  };
  const C_LINE_COMMENT_MODE = COMMENT2("//", "$");
  const C_BLOCK_COMMENT_MODE = COMMENT2("/\\*", "\\*/");
  const HASH_COMMENT_MODE = COMMENT2("#", "$");
  const NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE,
    relevance: 0
  };
  const C_NUMBER_MODE = {
    className: "number",
    begin: C_NUMBER_RE,
    relevance: 0
  };
  const BINARY_NUMBER_MODE = {
    className: "number",
    begin: BINARY_NUMBER_RE,
    relevance: 0
  };
  const CSS_NUMBER_MODE = {
    className: "number",
    begin: NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  };
  const REGEXP_MODE = {
    // this outer rule makes sure we actually have a WHOLE regex and not simply
    // an expression such as:
    //
    //     3 / something
    //
    // (which will then blow up when regex's `illegal` sees the newline)
    begin: /(?=\/[^/\n]*\/)/,
    contains: [{
      className: "regexp",
      begin: /\//,
      end: /\/[gimuy]*/,
      illegal: /\n/,
      contains: [
        BACKSLASH_ESCAPE,
        {
          begin: /\[/,
          end: /\]/,
          relevance: 0,
          contains: [BACKSLASH_ESCAPE]
        }
      ]
    }]
  };
  const TITLE_MODE = {
    className: "title",
    begin: IDENT_RE,
    relevance: 0
  };
  const UNDERSCORE_TITLE_MODE = {
    className: "title",
    begin: UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const METHOD_GUARD = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + UNDERSCORE_IDENT_RE,
    relevance: 0
  };
  const END_SAME_AS_BEGIN = function(mode) {
    return Object.assign(
      mode,
      {
        /** @type {ModeCallback} */
        "on:begin": (m, resp) => {
          resp.data._beginMatch = m[1];
        },
        /** @type {ModeCallback} */
        "on:end": (m, resp) => {
          if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();
        }
      }
    );
  };
  var MODES = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    MATCH_NOTHING_RE,
    IDENT_RE,
    UNDERSCORE_IDENT_RE,
    NUMBER_RE,
    C_NUMBER_RE,
    BINARY_NUMBER_RE,
    RE_STARTERS_RE,
    SHEBANG,
    BACKSLASH_ESCAPE,
    APOS_STRING_MODE,
    QUOTE_STRING_MODE,
    PHRASAL_WORDS_MODE,
    COMMENT: COMMENT2,
    C_LINE_COMMENT_MODE,
    C_BLOCK_COMMENT_MODE,
    HASH_COMMENT_MODE,
    NUMBER_MODE,
    C_NUMBER_MODE,
    BINARY_NUMBER_MODE,
    CSS_NUMBER_MODE,
    REGEXP_MODE,
    TITLE_MODE,
    UNDERSCORE_TITLE_MODE,
    METHOD_GUARD,
    END_SAME_AS_BEGIN
  });
  function skipIfhasPrecedingDot(match2, response) {
    const before = match2.input[match2.index - 1];
    if (before === ".") {
      response.ignoreMatch();
    }
  }
  function beginKeywords(mode, parent) {
    if (!parent) return;
    if (!mode.beginKeywords) return;
    mode.begin = "\\b(" + mode.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)";
    mode.__beforeBegin = skipIfhasPrecedingDot;
    mode.keywords = mode.keywords || mode.beginKeywords;
    delete mode.beginKeywords;
    if (mode.relevance === void 0) mode.relevance = 0;
  }
  function compileIllegal(mode, _parent) {
    if (!Array.isArray(mode.illegal)) return;
    mode.illegal = either(...mode.illegal);
  }
  function compileMatch(mode, _parent) {
    if (!mode.match) return;
    if (mode.begin || mode.end) throw new Error("begin & end are not supported with match");
    mode.begin = mode.match;
    delete mode.match;
  }
  function compileRelevance(mode, _parent) {
    if (mode.relevance === void 0) mode.relevance = 1;
  }
  const COMMON_KEYWORDS = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ];
  const DEFAULT_KEYWORD_CLASSNAME = "keyword";
  function compileKeywords(rawKeywords, caseInsensitive, className = DEFAULT_KEYWORD_CLASSNAME) {
    const compiledKeywords = {};
    if (typeof rawKeywords === "string") {
      compileList(className, rawKeywords.split(" "));
    } else if (Array.isArray(rawKeywords)) {
      compileList(className, rawKeywords);
    } else {
      Object.keys(rawKeywords).forEach(function(className2) {
        Object.assign(
          compiledKeywords,
          compileKeywords(rawKeywords[className2], caseInsensitive, className2)
        );
      });
    }
    return compiledKeywords;
    function compileList(className2, keywordList) {
      if (caseInsensitive) {
        keywordList = keywordList.map((x2) => x2.toLowerCase());
      }
      keywordList.forEach(function(keyword) {
        const pair = keyword.split("|");
        compiledKeywords[pair[0]] = [className2, scoreForKeyword(pair[0], pair[1])];
      });
    }
  }
  function scoreForKeyword(keyword, providedScore) {
    if (providedScore) {
      return Number(providedScore);
    }
    return commonKeyword(keyword) ? 0 : 1;
  }
  function commonKeyword(keyword) {
    return COMMON_KEYWORDS.includes(keyword.toLowerCase());
  }
  function compileLanguage(language, { plugins }) {
    function langRe(value, global2) {
      return new RegExp(
        source(value),
        "m" + (language.case_insensitive ? "i" : "") + (global2 ? "g" : "")
      );
    }
    class MultiRegex {
      constructor() {
        this.matchIndexes = {};
        this.regexes = [];
        this.matchAt = 1;
        this.position = 0;
      }
      // @ts-ignore
      addRule(re, opts) {
        opts.position = this.position++;
        this.matchIndexes[this.matchAt] = opts;
        this.regexes.push([opts, re]);
        this.matchAt += countMatchGroups(re) + 1;
      }
      compile() {
        if (this.regexes.length === 0) {
          this.exec = () => null;
        }
        const terminators = this.regexes.map((el) => el[1]);
        this.matcherRe = langRe(join(terminators), true);
        this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(s) {
        this.matcherRe.lastIndex = this.lastIndex;
        const match2 = this.matcherRe.exec(s);
        if (!match2) {
          return null;
        }
        const i = match2.findIndex((el, i2) => i2 > 0 && el !== void 0);
        const matchData = this.matchIndexes[i];
        match2.splice(0, i);
        return Object.assign(match2, matchData);
      }
    }
    class ResumableMultiRegex {
      constructor() {
        this.rules = [];
        this.multiRegexes = [];
        this.count = 0;
        this.lastIndex = 0;
        this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(index) {
        if (this.multiRegexes[index]) return this.multiRegexes[index];
        const matcher2 = new MultiRegex();
        this.rules.slice(index).forEach(([re, opts]) => matcher2.addRule(re, opts));
        matcher2.compile();
        this.multiRegexes[index] = matcher2;
        return matcher2;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(re, opts) {
        this.rules.push([re, opts]);
        if (opts.type === "begin") this.count++;
      }
      /** @param {string} s */
      exec(s) {
        const m = this.getMatcher(this.regexIndex);
        m.lastIndex = this.lastIndex;
        let result = m.exec(s);
        if (this.resumingScanAtSamePosition()) {
          if (result && result.index === this.lastIndex) ;
          else {
            const m2 = this.getMatcher(0);
            m2.lastIndex = this.lastIndex + 1;
            result = m2.exec(s);
          }
        }
        if (result) {
          this.regexIndex += result.position + 1;
          if (this.regexIndex === this.count) {
            this.considerAll();
          }
        }
        return result;
      }
    }
    function buildModeRegex(mode) {
      const mm = new ResumableMultiRegex();
      mode.contains.forEach((term) => mm.addRule(term.begin, { rule: term, type: "begin" }));
      if (mode.terminatorEnd) {
        mm.addRule(mode.terminatorEnd, { type: "end" });
      }
      if (mode.illegal) {
        mm.addRule(mode.illegal, { type: "illegal" });
      }
      return mm;
    }
    function compileMode(mode, parent) {
      const cmode = (
        /** @type CompiledMode */
        mode
      );
      if (mode.isCompiled) return cmode;
      [
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        compileMatch
      ].forEach((ext) => ext(mode, parent));
      language.compilerExtensions.forEach((ext) => ext(mode, parent));
      mode.__beforeBegin = null;
      [
        beginKeywords,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        compileIllegal,
        // default to 1 relevance if not specified
        compileRelevance
      ].forEach((ext) => ext(mode, parent));
      mode.isCompiled = true;
      let keywordPattern = null;
      if (typeof mode.keywords === "object") {
        keywordPattern = mode.keywords.$pattern;
        delete mode.keywords.$pattern;
      }
      if (mode.keywords) {
        mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);
      }
      if (mode.lexemes && keywordPattern) {
        throw new Error("ERR: Prefer `keywords.$pattern` to `mode.lexemes`, BOTH are not allowed. (see mode reference) ");
      }
      keywordPattern = keywordPattern || mode.lexemes || /\w+/;
      cmode.keywordPatternRe = langRe(keywordPattern, true);
      if (parent) {
        if (!mode.begin) mode.begin = /\B|\b/;
        cmode.beginRe = langRe(mode.begin);
        if (mode.endSameAsBegin) mode.end = mode.begin;
        if (!mode.end && !mode.endsWithParent) mode.end = /\B|\b/;
        if (mode.end) cmode.endRe = langRe(mode.end);
        cmode.terminatorEnd = source(mode.end) || "";
        if (mode.endsWithParent && parent.terminatorEnd) {
          cmode.terminatorEnd += (mode.end ? "|" : "") + parent.terminatorEnd;
        }
      }
      if (mode.illegal) cmode.illegalRe = langRe(
        /** @type {RegExp | string} */
        mode.illegal
      );
      if (!mode.contains) mode.contains = [];
      mode.contains = [].concat(...mode.contains.map(function(c) {
        return expandOrCloneMode(c === "self" ? mode : c);
      }));
      mode.contains.forEach(function(c) {
        compileMode(
          /** @type Mode */
          c,
          cmode
        );
      });
      if (mode.starts) {
        compileMode(mode.starts, parent);
      }
      cmode.matcher = buildModeRegex(cmode);
      return cmode;
    }
    if (!language.compilerExtensions) language.compilerExtensions = [];
    if (language.contains && language.contains.includes("self")) {
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    }
    language.classNameAliases = inherit2(language.classNameAliases || {});
    return compileMode(
      /** @type Mode */
      language
    );
  }
  function dependencyOnParent(mode) {
    if (!mode) return false;
    return mode.endsWithParent || dependencyOnParent(mode.starts);
  }
  function expandOrCloneMode(mode) {
    if (mode.variants && !mode.cachedVariants) {
      mode.cachedVariants = mode.variants.map(function(variant) {
        return inherit2(mode, { variants: null }, variant);
      });
    }
    if (mode.cachedVariants) {
      return mode.cachedVariants;
    }
    if (dependencyOnParent(mode)) {
      return inherit2(mode, { starts: mode.starts ? inherit2(mode.starts) : null });
    }
    if (Object.isFrozen(mode)) {
      return inherit2(mode);
    }
    return mode;
  }
  var version = "10.7.3";
  function hasValueOrEmptyAttribute(value) {
    return Boolean(value || value === "");
  }
  function BuildVuePlugin(hljs2) {
    const Component = {
      props: ["language", "code", "autodetect"],
      data: function() {
        return {
          detectedLanguage: "",
          unknownLanguage: false
        };
      },
      computed: {
        className() {
          if (this.unknownLanguage) return "";
          return "hljs " + this.detectedLanguage;
        },
        highlighted() {
          if (!this.autoDetect && !hljs2.getLanguage(this.language)) {
            console.warn(`The language "${this.language}" you specified could not be found.`);
            this.unknownLanguage = true;
            return escapeHTML(this.code);
          }
          let result = {};
          if (this.autoDetect) {
            result = hljs2.highlightAuto(this.code);
            this.detectedLanguage = result.language;
          } else {
            result = hljs2.highlight(this.language, this.code, this.ignoreIllegals);
            this.detectedLanguage = this.language;
          }
          return result.value;
        },
        autoDetect() {
          return !this.language || hasValueOrEmptyAttribute(this.autodetect);
        },
        ignoreIllegals() {
          return true;
        }
      },
      // this avoids needing to use a whole Vue compilation pipeline just
      // to build Highlight.js
      render(createElement) {
        return createElement("pre", {}, [
          createElement("code", {
            class: this.className,
            domProps: { innerHTML: this.highlighted }
          })
        ]);
      }
      // template: `<pre><code :class="className" v-html="highlighted"></code></pre>`
    };
    const VuePlugin = {
      install(Vue) {
        Vue.component("highlightjs", Component);
      }
    };
    return { Component, VuePlugin };
  }
  const mergeHTMLPlugin = {
    "after:highlightElement": ({ el, result, text }) => {
      const originalStream = nodeStream(el);
      if (!originalStream.length) return;
      const resultNode = document.createElement("div");
      resultNode.innerHTML = result.value;
      result.value = mergeStreams(originalStream, nodeStream(resultNode), text);
    }
  };
  function tag(node2) {
    return node2.nodeName.toLowerCase();
  }
  function nodeStream(node2) {
    const result = [];
    (function _nodeStream(node3, offset) {
      for (let child = node3.firstChild; child; child = child.nextSibling) {
        if (child.nodeType === 3) {
          offset += child.nodeValue.length;
        } else if (child.nodeType === 1) {
          result.push({
            event: "start",
            offset,
            node: child
          });
          offset = _nodeStream(child, offset);
          if (!tag(child).match(/br|hr|img|input/)) {
            result.push({
              event: "stop",
              offset,
              node: child
            });
          }
        }
      }
      return offset;
    })(node2, 0);
    return result;
  }
  function mergeStreams(original, highlighted, value) {
    let processed = 0;
    let result = "";
    const nodeStack = [];
    function selectStream() {
      if (!original.length || !highlighted.length) {
        return original.length ? original : highlighted;
      }
      if (original[0].offset !== highlighted[0].offset) {
        return original[0].offset < highlighted[0].offset ? original : highlighted;
      }
      return highlighted[0].event === "start" ? original : highlighted;
    }
    function open(node2) {
      function attributeString(attr) {
        return " " + attr.nodeName + '="' + escapeHTML(attr.value) + '"';
      }
      result += "<" + tag(node2) + [].map.call(node2.attributes, attributeString).join("") + ">";
    }
    function close(node2) {
      result += "</" + tag(node2) + ">";
    }
    function render(event) {
      (event.event === "start" ? open : close)(event.node);
    }
    while (original.length || highlighted.length) {
      let stream = selectStream();
      result += escapeHTML(value.substring(processed, stream[0].offset));
      processed = stream[0].offset;
      if (stream === original) {
        nodeStack.reverse().forEach(close);
        do {
          render(stream.splice(0, 1)[0]);
          stream = selectStream();
        } while (stream === original && stream.length && stream[0].offset === processed);
        nodeStack.reverse().forEach(open);
      } else {
        if (stream[0].event === "start") {
          nodeStack.push(stream[0].node);
        } else {
          nodeStack.pop();
        }
        render(stream.splice(0, 1)[0]);
      }
    }
    return result + escapeHTML(value.substr(processed));
  }
  const seenDeprecations = {};
  const error = (message) => {
    console.error(message);
  };
  const warn = (message, ...args) => {
    console.log(`WARN: ${message}`, ...args);
  };
  const deprecated = (version2, message) => {
    if (seenDeprecations[`${version2}/${message}`]) return;
    console.log(`Deprecated as of ${version2}. ${message}`);
    seenDeprecations[`${version2}/${message}`] = true;
  };
  const escape$1 = escapeHTML;
  const inherit$1 = inherit2;
  const NO_MATCH = Symbol("nomatch");
  const HLJS = function(hljs2) {
    const languages = /* @__PURE__ */ Object.create(null);
    const aliases2 = /* @__PURE__ */ Object.create(null);
    const plugins = [];
    let SAFE_MODE = true;
    const fixMarkupRe = /(^(<[^>]+>|\t|)+|\n)/gm;
    const LANGUAGE_NOT_FOUND = "Could not find the language '{}', did you forget to load/include a language module?";
    const PLAINTEXT_LANGUAGE = { disableAutodetect: true, name: "Plain text", contains: [] };
    let options = {
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      tabReplace: null,
      useBR: false,
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: TokenTreeEmitter
    };
    function shouldNotHighlight(languageName) {
      return options.noHighlightRe.test(languageName);
    }
    function blockLanguage(block) {
      let classes = block.className + " ";
      classes += block.parentNode ? block.parentNode.className : "";
      const match2 = options.languageDetectRe.exec(classes);
      if (match2) {
        const language = getLanguage(match2[1]);
        if (!language) {
          warn(LANGUAGE_NOT_FOUND.replace("{}", match2[1]));
          warn("Falling back to no-highlight mode for this block.", block);
        }
        return language ? match2[1] : "no-highlight";
      }
      return classes.split(/\s+/).find((_class) => shouldNotHighlight(_class) || getLanguage(_class));
    }
    function highlight2(codeOrlanguageName, optionsOrCode, ignoreIllegals, continuation) {
      let code = "";
      let languageName = "";
      if (typeof optionsOrCode === "object") {
        code = codeOrlanguageName;
        ignoreIllegals = optionsOrCode.ignoreIllegals;
        languageName = optionsOrCode.language;
        continuation = void 0;
      } else {
        deprecated("10.7.0", "highlight(lang, code, ...args) has been deprecated.");
        deprecated("10.7.0", "Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277");
        languageName = codeOrlanguageName;
        code = optionsOrCode;
      }
      const context2 = {
        code,
        language: languageName
      };
      fire("before:highlight", context2);
      const result = context2.result ? context2.result : _highlight(context2.language, context2.code, ignoreIllegals, continuation);
      result.code = context2.code;
      fire("after:highlight", result);
      return result;
    }
    function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {
      function keywordData(mode, match2) {
        const matchText = language.case_insensitive ? match2[0].toLowerCase() : match2[0];
        return Object.prototype.hasOwnProperty.call(mode.keywords, matchText) && mode.keywords[matchText];
      }
      function processKeywords() {
        if (!top.keywords) {
          emitter.addText(modeBuffer);
          return;
        }
        let lastIndex = 0;
        top.keywordPatternRe.lastIndex = 0;
        let match2 = top.keywordPatternRe.exec(modeBuffer);
        let buf = "";
        while (match2) {
          buf += modeBuffer.substring(lastIndex, match2.index);
          const data = keywordData(top, match2);
          if (data) {
            const [kind, keywordRelevance] = data;
            emitter.addText(buf);
            buf = "";
            relevance += keywordRelevance;
            if (kind.startsWith("_")) {
              buf += match2[0];
            } else {
              const cssClass = language.classNameAliases[kind] || kind;
              emitter.addKeyword(match2[0], cssClass);
            }
          } else {
            buf += match2[0];
          }
          lastIndex = top.keywordPatternRe.lastIndex;
          match2 = top.keywordPatternRe.exec(modeBuffer);
        }
        buf += modeBuffer.substr(lastIndex);
        emitter.addText(buf);
      }
      function processSubLanguage() {
        if (modeBuffer === "") return;
        let result2 = null;
        if (typeof top.subLanguage === "string") {
          if (!languages[top.subLanguage]) {
            emitter.addText(modeBuffer);
            return;
          }
          result2 = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);
          continuations[top.subLanguage] = /** @type {CompiledMode} */
          result2.top;
        } else {
          result2 = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);
        }
        if (top.relevance > 0) {
          relevance += result2.relevance;
        }
        emitter.addSublanguage(result2.emitter, result2.language);
      }
      function processBuffer() {
        if (top.subLanguage != null) {
          processSubLanguage();
        } else {
          processKeywords();
        }
        modeBuffer = "";
      }
      function startNewMode(mode) {
        if (mode.className) {
          emitter.openNode(language.classNameAliases[mode.className] || mode.className);
        }
        top = Object.create(mode, { parent: { value: top } });
        return top;
      }
      function endOfMode(mode, match2, matchPlusRemainder) {
        let matched = startsWith(mode.endRe, matchPlusRemainder);
        if (matched) {
          if (mode["on:end"]) {
            const resp = new Response(mode);
            mode["on:end"](match2, resp);
            if (resp.isMatchIgnored) matched = false;
          }
          if (matched) {
            while (mode.endsParent && mode.parent) {
              mode = mode.parent;
            }
            return mode;
          }
        }
        if (mode.endsWithParent) {
          return endOfMode(mode.parent, match2, matchPlusRemainder);
        }
      }
      function doIgnore(lexeme) {
        if (top.matcher.regexIndex === 0) {
          modeBuffer += lexeme[0];
          return 1;
        } else {
          resumeScanAtSamePosition = true;
          return 0;
        }
      }
      function doBeginMatch(match2) {
        const lexeme = match2[0];
        const newMode = match2.rule;
        const resp = new Response(newMode);
        const beforeCallbacks = [newMode.__beforeBegin, newMode["on:begin"]];
        for (const cb of beforeCallbacks) {
          if (!cb) continue;
          cb(match2, resp);
          if (resp.isMatchIgnored) return doIgnore(lexeme);
        }
        if (newMode && newMode.endSameAsBegin) {
          newMode.endRe = escape(lexeme);
        }
        if (newMode.skip) {
          modeBuffer += lexeme;
        } else {
          if (newMode.excludeBegin) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (!newMode.returnBegin && !newMode.excludeBegin) {
            modeBuffer = lexeme;
          }
        }
        startNewMode(newMode);
        return newMode.returnBegin ? 0 : lexeme.length;
      }
      function doEndMatch(match2) {
        const lexeme = match2[0];
        const matchPlusRemainder = codeToHighlight.substr(match2.index);
        const endMode = endOfMode(top, match2, matchPlusRemainder);
        if (!endMode) {
          return NO_MATCH;
        }
        const origin2 = top;
        if (origin2.skip) {
          modeBuffer += lexeme;
        } else {
          if (!(origin2.returnEnd || origin2.excludeEnd)) {
            modeBuffer += lexeme;
          }
          processBuffer();
          if (origin2.excludeEnd) {
            modeBuffer = lexeme;
          }
        }
        do {
          if (top.className) {
            emitter.closeNode();
          }
          if (!top.skip && !top.subLanguage) {
            relevance += top.relevance;
          }
          top = top.parent;
        } while (top !== endMode.parent);
        if (endMode.starts) {
          if (endMode.endSameAsBegin) {
            endMode.starts.endRe = endMode.endRe;
          }
          startNewMode(endMode.starts);
        }
        return origin2.returnEnd ? 0 : lexeme.length;
      }
      function processContinuations() {
        const list = [];
        for (let current = top; current !== language; current = current.parent) {
          if (current.className) {
            list.unshift(current.className);
          }
        }
        list.forEach((item) => emitter.openNode(item));
      }
      let lastMatch = {};
      function processLexeme(textBeforeMatch, match2) {
        const lexeme = match2 && match2[0];
        modeBuffer += textBeforeMatch;
        if (lexeme == null) {
          processBuffer();
          return 0;
        }
        if (lastMatch.type === "begin" && match2.type === "end" && lastMatch.index === match2.index && lexeme === "") {
          modeBuffer += codeToHighlight.slice(match2.index, match2.index + 1);
          if (!SAFE_MODE) {
            const err = new Error("0 width match regex");
            err.languageName = languageName;
            err.badRule = lastMatch.rule;
            throw err;
          }
          return 1;
        }
        lastMatch = match2;
        if (match2.type === "begin") {
          return doBeginMatch(match2);
        } else if (match2.type === "illegal" && !ignoreIllegals) {
          const err = new Error('Illegal lexeme "' + lexeme + '" for mode "' + (top.className || "<unnamed>") + '"');
          err.mode = top;
          throw err;
        } else if (match2.type === "end") {
          const processed = doEndMatch(match2);
          if (processed !== NO_MATCH) {
            return processed;
          }
        }
        if (match2.type === "illegal" && lexeme === "") {
          return 1;
        }
        if (iterations > 1e5 && iterations > match2.index * 3) {
          const err = new Error("potential infinite loop, way more iterations than matches");
          throw err;
        }
        modeBuffer += lexeme;
        return lexeme.length;
      }
      const language = getLanguage(languageName);
      if (!language) {
        error(LANGUAGE_NOT_FOUND.replace("{}", languageName));
        throw new Error('Unknown language: "' + languageName + '"');
      }
      const md = compileLanguage(language, { plugins });
      let result = "";
      let top = continuation || md;
      const continuations = {};
      const emitter = new options.__emitter(options);
      processContinuations();
      let modeBuffer = "";
      let relevance = 0;
      let index = 0;
      let iterations = 0;
      let resumeScanAtSamePosition = false;
      try {
        top.matcher.considerAll();
        for (; ; ) {
          iterations++;
          if (resumeScanAtSamePosition) {
            resumeScanAtSamePosition = false;
          } else {
            top.matcher.considerAll();
          }
          top.matcher.lastIndex = index;
          const match2 = top.matcher.exec(codeToHighlight);
          if (!match2) break;
          const beforeMatch = codeToHighlight.substring(index, match2.index);
          const processedCount = processLexeme(beforeMatch, match2);
          index = match2.index + processedCount;
        }
        processLexeme(codeToHighlight.substr(index));
        emitter.closeAllNodes();
        emitter.finalize();
        result = emitter.toHTML();
        return {
          // avoid possible breakage with v10 clients expecting
          // this to always be an integer
          relevance: Math.floor(relevance),
          value: result,
          language: languageName,
          illegal: false,
          emitter,
          top
        };
      } catch (err) {
        if (err.message && err.message.includes("Illegal")) {
          return {
            illegal: true,
            illegalBy: {
              msg: err.message,
              context: codeToHighlight.slice(index - 100, index + 100),
              mode: err.mode
            },
            sofar: result,
            relevance: 0,
            value: escape$1(codeToHighlight),
            emitter
          };
        } else if (SAFE_MODE) {
          return {
            illegal: false,
            relevance: 0,
            value: escape$1(codeToHighlight),
            emitter,
            language: languageName,
            top,
            errorRaised: err
          };
        } else {
          throw err;
        }
      }
    }
    function justTextHighlightResult(code) {
      const result = {
        relevance: 0,
        emitter: new options.__emitter(options),
        value: escape$1(code),
        illegal: false,
        top: PLAINTEXT_LANGUAGE
      };
      result.emitter.addText(code);
      return result;
    }
    function highlightAuto(code, languageSubset) {
      languageSubset = languageSubset || options.languages || Object.keys(languages);
      const plaintext = justTextHighlightResult(code);
      const results = languageSubset.filter(getLanguage).filter(autoDetection).map(
        (name) => _highlight(name, code, false)
      );
      results.unshift(plaintext);
      const sorted = results.sort((a, b) => {
        if (a.relevance !== b.relevance) return b.relevance - a.relevance;
        if (a.language && b.language) {
          if (getLanguage(a.language).supersetOf === b.language) {
            return 1;
          } else if (getLanguage(b.language).supersetOf === a.language) {
            return -1;
          }
        }
        return 0;
      });
      const [best, secondBest] = sorted;
      const result = best;
      result.second_best = secondBest;
      return result;
    }
    function fixMarkup(html) {
      if (!(options.tabReplace || options.useBR)) {
        return html;
      }
      return html.replace(fixMarkupRe, (match2) => {
        if (match2 === "\n") {
          return options.useBR ? "<br>" : match2;
        } else if (options.tabReplace) {
          return match2.replace(/\t/g, options.tabReplace);
        }
        return match2;
      });
    }
    function updateClassName(element, currentLang, resultLang) {
      const language = currentLang ? aliases2[currentLang] : resultLang;
      element.classList.add("hljs");
      if (language) element.classList.add(language);
    }
    const brPlugin = {
      "before:highlightElement": ({ el }) => {
        if (options.useBR) {
          el.innerHTML = el.innerHTML.replace(/\n/g, "").replace(/<br[ /]*>/g, "\n");
        }
      },
      "after:highlightElement": ({ result }) => {
        if (options.useBR) {
          result.value = result.value.replace(/\n/g, "<br>");
        }
      }
    };
    const TAB_REPLACE_RE = /^(<[^>]+>|\t)+/gm;
    const tabReplacePlugin = {
      "after:highlightElement": ({ result }) => {
        if (options.tabReplace) {
          result.value = result.value.replace(
            TAB_REPLACE_RE,
            (m) => m.replace(/\t/g, options.tabReplace)
          );
        }
      }
    };
    function highlightElement(element) {
      let node2 = null;
      const language = blockLanguage(element);
      if (shouldNotHighlight(language)) return;
      fire(
        "before:highlightElement",
        { el: element, language }
      );
      node2 = element;
      const text = node2.textContent;
      const result = language ? highlight2(text, { language, ignoreIllegals: true }) : highlightAuto(text);
      fire("after:highlightElement", { el: element, result, text });
      element.innerHTML = result.value;
      updateClassName(element, language, result.language);
      element.result = {
        language: result.language,
        // TODO: remove with version 11.0
        re: result.relevance,
        relavance: result.relevance
      };
      if (result.second_best) {
        element.second_best = {
          language: result.second_best.language,
          // TODO: remove with version 11.0
          re: result.second_best.relevance,
          relavance: result.second_best.relevance
        };
      }
    }
    function configure(userOptions) {
      if (userOptions.useBR) {
        deprecated("10.3.0", "'useBR' will be removed entirely in v11.0");
        deprecated("10.3.0", "Please see https://github.com/highlightjs/highlight.js/issues/2559");
      }
      options = inherit$1(options, userOptions);
    }
    const initHighlighting = () => {
      if (initHighlighting.called) return;
      initHighlighting.called = true;
      deprecated("10.6.0", "initHighlighting() is deprecated.  Use highlightAll() instead.");
      const blocks = document.querySelectorAll("pre code");
      blocks.forEach(highlightElement);
    };
    function initHighlightingOnLoad() {
      deprecated("10.6.0", "initHighlightingOnLoad() is deprecated.  Use highlightAll() instead.");
      wantsHighlight = true;
    }
    let wantsHighlight = false;
    function highlightAll() {
      if (document.readyState === "loading") {
        wantsHighlight = true;
        return;
      }
      const blocks = document.querySelectorAll("pre code");
      blocks.forEach(highlightElement);
    }
    function boot() {
      if (wantsHighlight) highlightAll();
    }
    if (typeof window !== "undefined" && window.addEventListener) {
      window.addEventListener("DOMContentLoaded", boot, false);
    }
    function registerLanguage(languageName, languageDefinition) {
      let lang = null;
      try {
        lang = languageDefinition(hljs2);
      } catch (error$1) {
        error("Language definition for '{}' could not be registered.".replace("{}", languageName));
        if (!SAFE_MODE) {
          throw error$1;
        } else {
          error(error$1);
        }
        lang = PLAINTEXT_LANGUAGE;
      }
      if (!lang.name) lang.name = languageName;
      languages[languageName] = lang;
      lang.rawDefinition = languageDefinition.bind(null, hljs2);
      if (lang.aliases) {
        registerAliases(lang.aliases, { languageName });
      }
    }
    function unregisterLanguage(languageName) {
      delete languages[languageName];
      for (const alias of Object.keys(aliases2)) {
        if (aliases2[alias] === languageName) {
          delete aliases2[alias];
        }
      }
    }
    function listLanguages() {
      return Object.keys(languages);
    }
    function requireLanguage(name) {
      deprecated("10.4.0", "requireLanguage will be removed entirely in v11.");
      deprecated("10.4.0", "Please see https://github.com/highlightjs/highlight.js/pull/2844");
      const lang = getLanguage(name);
      if (lang) {
        return lang;
      }
      const err = new Error("The '{}' language is required, but not loaded.".replace("{}", name));
      throw err;
    }
    function getLanguage(name) {
      name = (name || "").toLowerCase();
      return languages[name] || languages[aliases2[name]];
    }
    function registerAliases(aliasList, { languageName }) {
      if (typeof aliasList === "string") {
        aliasList = [aliasList];
      }
      aliasList.forEach((alias) => {
        aliases2[alias.toLowerCase()] = languageName;
      });
    }
    function autoDetection(name) {
      const lang = getLanguage(name);
      return lang && !lang.disableAutodetect;
    }
    function upgradePluginAPI(plugin) {
      if (plugin["before:highlightBlock"] && !plugin["before:highlightElement"]) {
        plugin["before:highlightElement"] = (data) => {
          plugin["before:highlightBlock"](
            Object.assign({ block: data.el }, data)
          );
        };
      }
      if (plugin["after:highlightBlock"] && !plugin["after:highlightElement"]) {
        plugin["after:highlightElement"] = (data) => {
          plugin["after:highlightBlock"](
            Object.assign({ block: data.el }, data)
          );
        };
      }
    }
    function addPlugin(plugin) {
      upgradePluginAPI(plugin);
      plugins.push(plugin);
    }
    function fire(event, args) {
      const cb = event;
      plugins.forEach(function(plugin) {
        if (plugin[cb]) {
          plugin[cb](args);
        }
      });
    }
    function deprecateFixMarkup(arg) {
      deprecated("10.2.0", "fixMarkup will be removed entirely in v11.0");
      deprecated("10.2.0", "Please see https://github.com/highlightjs/highlight.js/issues/2534");
      return fixMarkup(arg);
    }
    function deprecateHighlightBlock(el) {
      deprecated("10.7.0", "highlightBlock will be removed entirely in v12.0");
      deprecated("10.7.0", "Please use highlightElement now.");
      return highlightElement(el);
    }
    Object.assign(hljs2, {
      highlight: highlight2,
      highlightAuto,
      highlightAll,
      fixMarkup: deprecateFixMarkup,
      highlightElement,
      // TODO: Remove with v12 API
      highlightBlock: deprecateHighlightBlock,
      configure,
      initHighlighting,
      initHighlightingOnLoad,
      registerLanguage,
      unregisterLanguage,
      listLanguages,
      getLanguage,
      registerAliases,
      requireLanguage,
      autoDetection,
      inherit: inherit$1,
      addPlugin,
      // plugins for frameworks
      vuePlugin: BuildVuePlugin(hljs2).VuePlugin
    });
    hljs2.debugMode = function() {
      SAFE_MODE = false;
    };
    hljs2.safeMode = function() {
      SAFE_MODE = true;
    };
    hljs2.versionString = version;
    for (const key in MODES) {
      if (typeof MODES[key] === "object") {
        deepFreezeEs6(MODES[key]);
      }
    }
    Object.assign(hljs2, MODES);
    hljs2.addPlugin(brPlugin);
    hljs2.addPlugin(mergeHTMLPlugin);
    hljs2.addPlugin(tabReplacePlugin);
    return hljs2;
  };
  var highlight = HLJS({});
  core = highlight;
  return core;
}
var coreExports = requireCore();
const hljs = /* @__PURE__ */ getDefaultExportFromCjs(coreExports);
var python_1;
var hasRequiredPython;
function requirePython() {
  if (hasRequiredPython) return python_1;
  hasRequiredPython = 1;
  function source(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead(re) {
    return concat("(?=", re, ")");
  }
  function concat(...args) {
    const joined = args.map((x2) => source(x2)).join("");
    return joined;
  }
  function python2(hljs2) {
    const RESERVED_WORDS = [
      "and",
      "as",
      "assert",
      "async",
      "await",
      "break",
      "class",
      "continue",
      "def",
      "del",
      "elif",
      "else",
      "except",
      "finally",
      "for",
      "from",
      "global",
      "if",
      "import",
      "in",
      "is",
      "lambda",
      "nonlocal|10",
      "not",
      "or",
      "pass",
      "raise",
      "return",
      "try",
      "while",
      "with",
      "yield"
    ];
    const BUILT_INS = [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ];
    const LITERALS = [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ];
    const TYPES = [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ];
    const KEYWORDS = {
      $pattern: /[A-Za-z]\w+|__\w+__/,
      keyword: RESERVED_WORDS,
      built_in: BUILT_INS,
      literal: LITERALS,
      type: TYPES
    };
    const PROMPT = {
      className: "meta",
      begin: /^(>>>|\.\.\.) /
    };
    const SUBST = {
      className: "subst",
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS,
      illegal: /#/
    };
    const LITERAL_BRACKET = {
      begin: /\{\{/,
      relevance: 0
    };
    const STRING = {
      className: "string",
      contains: [hljs2.BACKSLASH_ESCAPE],
      variants: [
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
          end: /'''/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            PROMPT
          ],
          relevance: 10
        },
        {
          begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
          end: /"""/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            PROMPT
          ],
          relevance: 10
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'''/,
          end: /'''/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            PROMPT,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"""/,
          end: /"""/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            PROMPT,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([uU]|[rR])'/,
          end: /'/,
          relevance: 10
        },
        {
          begin: /([uU]|[rR])"/,
          end: /"/,
          relevance: 10
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])'/,
          end: /'/
        },
        {
          begin: /([bB]|[bB][rR]|[rR][bB])"/,
          end: /"/
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])'/,
          end: /'/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        {
          begin: /([fF][rR]|[rR][fF]|[fF])"/,
          end: /"/,
          contains: [
            hljs2.BACKSLASH_ESCAPE,
            LITERAL_BRACKET,
            SUBST
          ]
        },
        hljs2.APOS_STRING_MODE,
        hljs2.QUOTE_STRING_MODE
      ]
    };
    const digitpart = "[0-9](_?[0-9])*";
    const pointfloat = `(\\b(${digitpart}))?\\.(${digitpart})|\\b(${digitpart})\\.`;
    const NUMBER = {
      className: "number",
      relevance: 0,
      variants: [
        // exponentfloat, pointfloat
        // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
        // optionally imaginary
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        // Note: no leading \b because floats can start with a decimal point
        // and we don't want to mishandle e.g. `fn(.5)`,
        // no trailing \b for pointfloat because it can end with a decimal point
        // and we don't want to mishandle e.g. `0..hex()`; this should be safe
        // because both MUST contain a decimal point and so cannot be confused with
        // the interior part of an identifier
        {
          begin: `(\\b(${digitpart})|(${pointfloat}))[eE][+-]?(${digitpart})[jJ]?\\b`
        },
        {
          begin: `(${pointfloat})[jJ]?`
        },
        // decinteger, bininteger, octinteger, hexinteger
        // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
        // optionally "long" in Python 2
        // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
        // decinteger is optionally imaginary
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        {
          begin: "\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?\\b"
        },
        {
          begin: "\\b0[bB](_?[01])+[lL]?\\b"
        },
        {
          begin: "\\b0[oO](_?[0-7])+[lL]?\\b"
        },
        {
          begin: "\\b0[xX](_?[0-9a-fA-F])+[lL]?\\b"
        },
        // imagnumber (digitpart-based)
        // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
        {
          begin: `\\b(${digitpart})[jJ]\\b`
        }
      ]
    };
    const COMMENT_TYPE = {
      className: "comment",
      begin: lookahead(/# type:/),
      end: /$/,
      keywords: KEYWORDS,
      contains: [
        {
          // prevent keywords from coloring `type`
          begin: /# type:/
        },
        // comment within a datatype comment includes no keywords
        {
          begin: /#/,
          end: /\b\B/,
          endsWithParent: true
        }
      ]
    };
    const PARAMS = {
      className: "params",
      variants: [
        // Exclude params in functions without params
        {
          className: "",
          begin: /\(\s*\)/,
          skip: true
        },
        {
          begin: /\(/,
          end: /\)/,
          excludeBegin: true,
          excludeEnd: true,
          keywords: KEYWORDS,
          contains: [
            "self",
            PROMPT,
            NUMBER,
            STRING,
            hljs2.HASH_COMMENT_MODE
          ]
        }
      ]
    };
    SUBST.contains = [
      STRING,
      NUMBER,
      PROMPT
    ];
    return {
      name: "Python",
      aliases: [
        "py",
        "gyp",
        "ipython"
      ],
      keywords: KEYWORDS,
      illegal: /(<\/|->|\?)|=>/,
      contains: [
        PROMPT,
        NUMBER,
        {
          // very common convention
          begin: /\bself\b/
        },
        {
          // eat "if" prior to string so that it won't accidentally be
          // labeled as an f-string
          beginKeywords: "if",
          relevance: 0
        },
        STRING,
        COMMENT_TYPE,
        hljs2.HASH_COMMENT_MODE,
        {
          variants: [
            {
              className: "function",
              beginKeywords: "def"
            },
            {
              className: "class",
              beginKeywords: "class"
            }
          ],
          end: /:/,
          illegal: /[${=;\n,]/,
          contains: [
            hljs2.UNDERSCORE_TITLE_MODE,
            PARAMS,
            {
              begin: /->/,
              endsWithParent: true,
              keywords: KEYWORDS
            }
          ]
        },
        {
          className: "meta",
          begin: /^[\t ]*@/,
          end: /(?=#)|$/,
          contains: [
            NUMBER,
            PARAMS,
            STRING
          ]
        }
      ]
    };
  }
  python_1 = python2;
  return python_1;
}
var pythonExports = requirePython();
const python = /* @__PURE__ */ getDefaultExportFromCjs(pythonExports);
var yaml_1;
var hasRequiredYaml;
function requireYaml() {
  if (hasRequiredYaml) return yaml_1;
  hasRequiredYaml = 1;
  function yaml2(hljs2) {
    var LITERALS = "true false yes no null";
    var URI_CHARACTERS = "[\\w#;/?:@&=+$,.~*'()[\\]]+";
    var KEY = {
      className: "attr",
      variants: [
        { begin: "\\w[\\w :\\/.-]*:(?=[ 	]|$)" },
        { begin: '"\\w[\\w :\\/.-]*":(?=[ 	]|$)' },
        // double quoted keys
        { begin: "'\\w[\\w :\\/.-]*':(?=[ 	]|$)" }
        // single quoted keys
      ]
    };
    var TEMPLATE_VARIABLES = {
      className: "template-variable",
      variants: [
        { begin: /\{\{/, end: /\}\}/ },
        // jinja templates Ansible
        { begin: /%\{/, end: /\}/ }
        // Ruby i18n
      ]
    };
    var STRING = {
      className: "string",
      relevance: 0,
      variants: [
        { begin: /'/, end: /'/ },
        { begin: /"/, end: /"/ },
        { begin: /\S+/ }
      ],
      contains: [
        hljs2.BACKSLASH_ESCAPE,
        TEMPLATE_VARIABLES
      ]
    };
    var CONTAINER_STRING = hljs2.inherit(STRING, {
      variants: [
        { begin: /'/, end: /'/ },
        { begin: /"/, end: /"/ },
        { begin: /[^\s,{}[\]]+/ }
      ]
    });
    var DATE_RE = "[0-9]{4}(-[0-9][0-9]){0,2}";
    var TIME_RE = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?";
    var FRACTION_RE = "(\\.[0-9]*)?";
    var ZONE_RE = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?";
    var TIMESTAMP = {
      className: "number",
      begin: "\\b" + DATE_RE + TIME_RE + FRACTION_RE + ZONE_RE + "\\b"
    };
    var VALUE_CONTAINER = {
      end: ",",
      endsWithParent: true,
      excludeEnd: true,
      keywords: LITERALS,
      relevance: 0
    };
    var OBJECT = {
      begin: /\{/,
      end: /\}/,
      contains: [VALUE_CONTAINER],
      illegal: "\\n",
      relevance: 0
    };
    var ARRAY = {
      begin: "\\[",
      end: "\\]",
      contains: [VALUE_CONTAINER],
      illegal: "\\n",
      relevance: 0
    };
    var MODES = [
      KEY,
      {
        className: "meta",
        begin: "^---\\s*$",
        relevance: 10
      },
      {
        // multi line string
        // Blocks start with a | or > followed by a newline
        //
        // Indentation of subsequent lines must be the same to
        // be considered part of the block
        className: "string",
        begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
      },
      {
        // Ruby/Rails erb
        begin: "<%[%=-]?",
        end: "[%-]?%>",
        subLanguage: "ruby",
        excludeBegin: true,
        excludeEnd: true,
        relevance: 0
      },
      {
        // named tags
        className: "type",
        begin: "!\\w+!" + URI_CHARACTERS
      },
      // https://yaml.org/spec/1.2/spec.html#id2784064
      {
        // verbatim tags
        className: "type",
        begin: "!<" + URI_CHARACTERS + ">"
      },
      {
        // primary tags
        className: "type",
        begin: "!" + URI_CHARACTERS
      },
      {
        // secondary tags
        className: "type",
        begin: "!!" + URI_CHARACTERS
      },
      {
        // fragment id &ref
        className: "meta",
        begin: "&" + hljs2.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // fragment reference *ref
        className: "meta",
        begin: "\\*" + hljs2.UNDERSCORE_IDENT_RE + "$"
      },
      {
        // array listing
        className: "bullet",
        // TODO: remove |$ hack when we have proper look-ahead support
        begin: "-(?=[ ]|$)",
        relevance: 0
      },
      hljs2.HASH_COMMENT_MODE,
      {
        beginKeywords: LITERALS,
        keywords: { literal: LITERALS }
      },
      TIMESTAMP,
      // numbers are any valid C-style number that
      // sit isolated from other words
      {
        className: "number",
        begin: hljs2.C_NUMBER_RE + "\\b",
        relevance: 0
      },
      OBJECT,
      ARRAY,
      STRING
    ];
    var VALUE_MODES = [...MODES];
    VALUE_MODES.pop();
    VALUE_MODES.push(CONTAINER_STRING);
    VALUE_CONTAINER.contains = VALUE_MODES;
    return {
      name: "YAML",
      case_insensitive: true,
      aliases: ["yml"],
      contains: MODES
    };
  }
  yaml_1 = yaml2;
  return yaml_1;
}
var yamlExports = requireYaml();
const yaml = /* @__PURE__ */ getDefaultExportFromCjs(yamlExports);
var javascript_1;
var hasRequiredJavascript;
function requireJavascript() {
  if (hasRequiredJavascript) return javascript_1;
  hasRequiredJavascript = 1;
  const IDENT_RE = "[A-Za-z$_][0-9A-Za-z$_]*";
  const KEYWORDS = [
    "as",
    // for exports
    "in",
    "of",
    "if",
    "for",
    "while",
    "finally",
    "var",
    "new",
    "function",
    "do",
    "return",
    "void",
    "else",
    "break",
    "catch",
    "instanceof",
    "with",
    "throw",
    "case",
    "default",
    "try",
    "switch",
    "continue",
    "typeof",
    "delete",
    "let",
    "yield",
    "const",
    "class",
    // JS handles these with a special rule
    // "get",
    // "set",
    "debugger",
    "async",
    "await",
    "static",
    "import",
    "from",
    "export",
    "extends"
  ];
  const LITERALS = [
    "true",
    "false",
    "null",
    "undefined",
    "NaN",
    "Infinity"
  ];
  const TYPES = [
    "Intl",
    "DataView",
    "Number",
    "Math",
    "Date",
    "String",
    "RegExp",
    "Object",
    "Function",
    "Boolean",
    "Error",
    "Symbol",
    "Set",
    "Map",
    "WeakSet",
    "WeakMap",
    "Proxy",
    "Reflect",
    "JSON",
    "Promise",
    "Float64Array",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Uint16Array",
    "Uint32Array",
    "Float32Array",
    "Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "ArrayBuffer",
    "BigInt64Array",
    "BigUint64Array",
    "BigInt"
  ];
  const ERROR_TYPES = [
    "EvalError",
    "InternalError",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError"
  ];
  const BUILT_IN_GLOBALS = [
    "setInterval",
    "setTimeout",
    "clearInterval",
    "clearTimeout",
    "require",
    "exports",
    "eval",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "unescape"
  ];
  const BUILT_IN_VARIABLES = [
    "arguments",
    "this",
    "super",
    "console",
    "window",
    "document",
    "localStorage",
    "module",
    "global"
    // Node.js
  ];
  const BUILT_INS = [].concat(
    BUILT_IN_GLOBALS,
    BUILT_IN_VARIABLES,
    TYPES,
    ERROR_TYPES
  );
  function source(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
  }
  function lookahead(re) {
    return concat("(?=", re, ")");
  }
  function concat(...args) {
    const joined = args.map((x2) => source(x2)).join("");
    return joined;
  }
  function javascript2(hljs2) {
    const hasClosingTag = (match2, { after }) => {
      const tag = "</" + match2[0].slice(1);
      const pos = match2.input.indexOf(tag, after);
      return pos !== -1;
    };
    const IDENT_RE$1 = IDENT_RE;
    const FRAGMENT = {
      begin: "<>",
      end: "</>"
    };
    const XML_TAG = {
      begin: /<[A-Za-z0-9\\._:-]+/,
      end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
      /**
       * @param {RegExpMatchArray} match
       * @param {CallbackResponse} response
       */
      isTrulyOpeningTag: (match2, response) => {
        const afterMatchIndex = match2[0].length + match2.index;
        const nextChar = match2.input[afterMatchIndex];
        if (nextChar === "<") {
          response.ignoreMatch();
          return;
        }
        if (nextChar === ">") {
          if (!hasClosingTag(match2, { after: afterMatchIndex })) {
            response.ignoreMatch();
          }
        }
      }
    };
    const KEYWORDS$1 = {
      $pattern: IDENT_RE,
      keyword: KEYWORDS,
      literal: LITERALS,
      built_in: BUILT_INS
    };
    const decimalDigits = "[0-9](_?[0-9])*";
    const frac = `\\.(${decimalDigits})`;
    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;
    const NUMBER = {
      className: "number",
      variants: [
        // DecimalLiteral
        { begin: `(\\b(${decimalInteger})((${frac})|\\.)?|(${frac}))[eE][+-]?(${decimalDigits})\\b` },
        { begin: `\\b(${decimalInteger})\\b((${frac})\\b|\\.)?|(${frac})\\b` },
        // DecimalBigIntegerLiteral
        { begin: `\\b(0|[1-9](_?[0-9])*)n\\b` },
        // NonDecimalIntegerLiteral
        { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
        { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
        { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
        // LegacyOctalIntegerLiteral (does not include underscore separators)
        // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
        { begin: "\\b0[0-7]+n?\\b" }
      ],
      relevance: 0
    };
    const SUBST = {
      className: "subst",
      begin: "\\$\\{",
      end: "\\}",
      keywords: KEYWORDS$1,
      contains: []
      // defined later
    };
    const HTML_TEMPLATE = {
      begin: "html`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs2.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "xml"
      }
    };
    const CSS_TEMPLATE = {
      begin: "css`",
      end: "",
      starts: {
        end: "`",
        returnEnd: false,
        contains: [
          hljs2.BACKSLASH_ESCAPE,
          SUBST
        ],
        subLanguage: "css"
      }
    };
    const TEMPLATE_STRING = {
      className: "string",
      begin: "`",
      end: "`",
      contains: [
        hljs2.BACKSLASH_ESCAPE,
        SUBST
      ]
    };
    const JSDOC_COMMENT = hljs2.COMMENT(
      /\/\*\*(?!\/)/,
      "\\*/",
      {
        relevance: 0,
        contains: [
          {
            className: "doctag",
            begin: "@[A-Za-z]+",
            contains: [
              {
                className: "type",
                begin: "\\{",
                end: "\\}",
                relevance: 0
              },
              {
                className: "variable",
                begin: IDENT_RE$1 + "(?=\\s*(-)|$)",
                endsParent: true,
                relevance: 0
              },
              // eat spaces (not newlines) so we can find
              // types or variables
              {
                begin: /(?=[^\n])\s/,
                relevance: 0
              }
            ]
          }
        ]
      }
    );
    const COMMENT2 = {
      className: "comment",
      variants: [
        JSDOC_COMMENT,
        hljs2.C_BLOCK_COMMENT_MODE,
        hljs2.C_LINE_COMMENT_MODE
      ]
    };
    const SUBST_INTERNALS = [
      hljs2.APOS_STRING_MODE,
      hljs2.QUOTE_STRING_MODE,
      HTML_TEMPLATE,
      CSS_TEMPLATE,
      TEMPLATE_STRING,
      NUMBER,
      hljs2.REGEXP_MODE
    ];
    SUBST.contains = SUBST_INTERNALS.concat({
      // we need to pair up {} inside our subst to prevent
      // it from ending too early by matching another }
      begin: /\{/,
      end: /\}/,
      keywords: KEYWORDS$1,
      contains: [
        "self"
      ].concat(SUBST_INTERNALS)
    });
    const SUBST_AND_COMMENTS = [].concat(COMMENT2, SUBST.contains);
    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([
      // eat recursive parens in sub expressions
      {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS$1,
        contains: ["self"].concat(SUBST_AND_COMMENTS)
      }
    ]);
    const PARAMS = {
      className: "params",
      begin: /\(/,
      end: /\)/,
      excludeBegin: true,
      excludeEnd: true,
      keywords: KEYWORDS$1,
      contains: PARAMS_CONTAINS
    };
    return {
      name: "Javascript",
      aliases: ["js", "jsx", "mjs", "cjs"],
      keywords: KEYWORDS$1,
      // this will be extended by TypeScript
      exports: { PARAMS_CONTAINS },
      illegal: /#(?![$_A-z])/,
      contains: [
        hljs2.SHEBANG({
          label: "shebang",
          binary: "node",
          relevance: 5
        }),
        {
          label: "use_strict",
          className: "meta",
          relevance: 10,
          begin: /^\s*['"]use (strict|asm)['"]/
        },
        hljs2.APOS_STRING_MODE,
        hljs2.QUOTE_STRING_MODE,
        HTML_TEMPLATE,
        CSS_TEMPLATE,
        TEMPLATE_STRING,
        COMMENT2,
        NUMBER,
        {
          // object attr container
          begin: concat(
            /[{,\n]\s*/,
            // we need to look ahead to make sure that we actually have an
            // attribute coming up so we don't steal a comma from a potential
            // "value" container
            //
            // NOTE: this might not work how you think.  We don't actually always
            // enter this mode and stay.  Instead it might merely match `,
            // <comments up next>` and then immediately end after the , because it
            // fails to find any actual attrs. But this still does the job because
            // it prevents the value contain rule from grabbing this instead and
            // prevening this rule from firing when we actually DO have keys.
            lookahead(concat(
              // we also need to allow for multiple possible comments inbetween
              // the first key:value pairing
              /(((\/\/.*$)|(\/\*(\*[^/]|[^*])*\*\/))\s*)*/,
              IDENT_RE$1 + "\\s*:"
            ))
          ),
          relevance: 0,
          contains: [
            {
              className: "attr",
              begin: IDENT_RE$1 + lookahead("\\s*:"),
              relevance: 0
            }
          ]
        },
        {
          // "value" container
          begin: "(" + hljs2.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
          keywords: "return throw case",
          contains: [
            COMMENT2,
            hljs2.REGEXP_MODE,
            {
              className: "function",
              // we have to count the parens to make sure we actually have the
              // correct bounding ( ) before the =>.  There could be any number of
              // sub-expressions inside also surrounded by parens.
              begin: "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + hljs2.UNDERSCORE_IDENT_RE + ")\\s*=>",
              returnBegin: true,
              end: "\\s*=>",
              contains: [
                {
                  className: "params",
                  variants: [
                    {
                      begin: hljs2.UNDERSCORE_IDENT_RE,
                      relevance: 0
                    },
                    {
                      className: null,
                      begin: /\(\s*\)/,
                      skip: true
                    },
                    {
                      begin: /\(/,
                      end: /\)/,
                      excludeBegin: true,
                      excludeEnd: true,
                      keywords: KEYWORDS$1,
                      contains: PARAMS_CONTAINS
                    }
                  ]
                }
              ]
            },
            {
              // could be a comma delimited list of params to a function call
              begin: /,/,
              relevance: 0
            },
            {
              className: "",
              begin: /\s/,
              end: /\s*/,
              skip: true
            },
            {
              // JSX
              variants: [
                { begin: FRAGMENT.begin, end: FRAGMENT.end },
                {
                  begin: XML_TAG.begin,
                  // we carefully check the opening tag to see if it truly
                  // is a tag and not a false positive
                  "on:begin": XML_TAG.isTrulyOpeningTag,
                  end: XML_TAG.end
                }
              ],
              subLanguage: "xml",
              contains: [
                {
                  begin: XML_TAG.begin,
                  end: XML_TAG.end,
                  skip: true,
                  contains: ["self"]
                }
              ]
            }
          ],
          relevance: 0
        },
        {
          className: "function",
          beginKeywords: "function",
          end: /[{;]/,
          excludeEnd: true,
          keywords: KEYWORDS$1,
          contains: [
            "self",
            hljs2.inherit(hljs2.TITLE_MODE, { begin: IDENT_RE$1 }),
            PARAMS
          ],
          illegal: /%/
        },
        {
          // prevent this from getting swallowed up by function
          // since they appear "function like"
          beginKeywords: "while if switch catch for"
        },
        {
          className: "function",
          // we have to count the parens to make sure we actually have the correct
          // bounding ( ).  There could be any number of sub-expressions inside
          // also surrounded by parens.
          begin: hljs2.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
          // end parens
          returnBegin: true,
          contains: [
            PARAMS,
            hljs2.inherit(hljs2.TITLE_MODE, { begin: IDENT_RE$1 })
          ]
        },
        // hack: prevents detection of keywords in some circumstances
        // .keyword()
        // $keyword = x
        {
          variants: [
            { begin: "\\." + IDENT_RE$1 },
            { begin: "\\$" + IDENT_RE$1 }
          ],
          relevance: 0
        },
        {
          // ES6 class
          className: "class",
          beginKeywords: "class",
          end: /[{;=]/,
          excludeEnd: true,
          illegal: /[:"[\]]/,
          contains: [
            { beginKeywords: "extends" },
            hljs2.UNDERSCORE_TITLE_MODE
          ]
        },
        {
          begin: /\b(?=constructor)/,
          end: /[{;]/,
          excludeEnd: true,
          contains: [
            hljs2.inherit(hljs2.TITLE_MODE, { begin: IDENT_RE$1 }),
            "self",
            PARAMS
          ]
        },
        {
          begin: "(get|set)\\s+(?=" + IDENT_RE$1 + "\\()",
          end: /\{/,
          keywords: "get set",
          contains: [
            hljs2.inherit(hljs2.TITLE_MODE, { begin: IDENT_RE$1 }),
            { begin: /\(\)/ },
            // eat to avoid empty params
            PARAMS
          ]
        },
        {
          begin: /\$[(.]/
          // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
        }
      ]
    };
  }
  javascript_1 = javascript2;
  return javascript_1;
}
var javascriptExports = requireJavascript();
const javascript = /* @__PURE__ */ getDefaultExportFromCjs(javascriptExports);
hljs.registerLanguage("python", python);
hljs.registerLanguage("yaml", yaml);
hljs.registerLanguage("javascript", javascript);
const MetaDataCode = ({
  sidebarVisible,
  visible = true,
  value = "",
  title = ""
}) => {
  const codeRef = reactExports.useRef();
  const highlighted = reactExports.useMemo(() => {
    const detected = hljs.highlightAuto(value);
    const language = detected.language || detected.second_best.language;
    return language ? hljs.highlight(value, { language }).value : value;
  }, [value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: modifiers(
        "pipeline-metadata-code",
        { visible, sidebarVisible },
        "kedro"
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "pipeline-metadata-code__title", children: title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { className: "pipeline-metadata-code__code", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { ref: codeRef, dangerouslySetInnerHTML: { __html: highlighted } }) })
      ]
    }
  );
};
const mapStateToProps$h = (state) => ({
  sidebarVisible: state.visible.sidebar
});
const MetaDataCode$1 = connect(mapStateToProps$h)(MetaDataCode);
const Toggle = ({
  id: id2 = "",
  checked,
  enabled = true,
  title,
  onChange,
  className = "",
  dataTest
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "div",
  {
    className: modifiers(classnames("pipeline-toggle", className), {
      enabled
    }),
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          id: `pipeline-toggle-input-${id2}`,
          "data-test": dataTest,
          className: "pipeline-toggle-input",
          type: "checkbox",
          checked,
          disabled: !enabled,
          onChange
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "label",
        {
          className: modifiers("pipeline-toggle-label", {
            checked: enabled && checked
          }),
          htmlFor: `pipeline-toggle-input-${id2}`,
          children: title
        }
      )
    ]
  }
);
const ERROR_MESSAGES = {
  noError: "No error details available.",
  unknownError: "An unknown error occurred.",
  genericDataError: "Failed while loading/saving data to/from dataset.",
  genericFunctionError: (name) => `Failed while performing function: ${name || "Unknown"}`,
  loadingOrSaving: (operation) => `Failed while ${operation} data ${operation === "loading" ? "from" : "to"} dataset.`,
  footer: "Please refer to the CLI for the full error log and details."
};
function ErrorLog({
  errorDetails,
  className = "",
  onToggleCode,
  dataTest = "error-log",
  visibleTraceback = false,
  isDataNode = false,
  nodeName = ""
}) {
  if (!errorDetails) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classnames("error-log--wrapper", className), children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-log--message", children: ERROR_MESSAGES.noError }) });
  }
  const errorMessage = errorDetails.message || ERROR_MESSAGES.unknownError;
  const getErrorHeader = () => {
    if (isDataNode) {
      const operation = errorDetails.error_operation;
      if (operation) {
        return ERROR_MESSAGES.loadingOrSaving(operation);
      }
      return ERROR_MESSAGES.genericDataError;
    }
    return ERROR_MESSAGES.genericFunctionError(nodeName);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: classnames("error-log--wrapper", className), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        id: "code",
        dataTest,
        title: "Show traceback",
        onChange: onToggleCode,
        checked: visibleTraceback
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-log--header", children: getErrorHeader() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-log--details", children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { dangerouslySetInnerHTML: { __html: errorMessage } }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "error-log--footer", children: ERROR_MESSAGES.footer })
  ] });
}
const MetaDataStats = ({ stats }) => {
  const [hasOverflow, setHasOverflow] = reactExports.useState(false);
  const statsContainerRef = reactExports.useRef(null);
  reactExports.useLayoutEffect(() => {
    const statsContainer = statsContainerRef.current;
    if (!statsContainer) {
      return;
    }
    const statsLen = Array.from(statsContainer.children).reduce(
      (total, item) => {
        var _a;
        return total + ((_a = item.outerText) == null ? void 0 : _a.length);
      },
      0
    );
    setHasOverflow(statsLen > statsRowLen);
  }, [stats]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "ul",
    {
      ref: statsContainerRef,
      className: `stats-container__${hasOverflow ? "overflow" : "no-overflow"}`,
      children: datasetStatLabels.map((statLabel) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "li",
          {
            className: "pipeline-metadata__value pipeline-metadata-value__stats",
            "data-test": `metadata-stats-value-${statLabel}`,
            children: (stats == null ? void 0 : stats.hasOwnProperty(statLabel)) ? statLabel !== "file_size" ? formatNumberWithCommas(stats[statLabel]) : formatFileSize(stats[statLabel]) : "N/A"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            className: "pipeline-metadata__label pipeline-metadata-label__stats",
            "data-test": `metadata-stats-label-${statLabel}`,
            children: statLabel && statLabel.replace(/_/g, " ")
          }
        )
      ] }, statLabel))
    }
  );
};
const MetaData = ({
  isPrettyName,
  metadata,
  onToggleCode,
  onToggleTraceback,
  onToggleMetadataModal,
  onToggleNodeSelected,
  theme,
  visible = true,
  visibleCode,
  visibleTraceback,
  showDatasetPreviews,
  getDatasetError: getDatasetError2,
  getNodeError: getNodeError2,
  view
}) => {
  const { toSelectedPipeline } = useGeneratePathname();
  reactExports.useEffect(() => onToggleCode(false), [metadata, onToggleCode]);
  reactExports.useEffect(() => onToggleTraceback(false), [metadata, onToggleTraceback]);
  reactExports.useEffect(
    () => onToggleMetadataModal(false),
    [metadata, onToggleMetadataModal]
  );
  const isTaskNode = (metadata == null ? void 0 : metadata.type) === "task";
  const isDataNode = (metadata == null ? void 0 : metadata.type) === "data";
  const isParametersNode = (metadata == null ? void 0 : metadata.type) === "parameters";
  const nodeTypeIcon = getShortType(metadata == null ? void 0 : metadata.datasetType, metadata == null ? void 0 : metadata.type);
  const hasPreview = showDatasetPreviews && (metadata == null ? void 0 : metadata.preview);
  const hasPlot = hasPreview && (metadata == null ? void 0 : metadata.previewType) === "PlotlyPreview";
  const hasImage = hasPreview && (metadata == null ? void 0 : metadata.previewType) === "ImagePreview";
  const hasTablePreview = hasPreview && (metadata == null ? void 0 : metadata.previewType) === "TablePreview";
  const hasJSONPreview = hasPreview && (metadata == null ? void 0 : metadata.previewType) === "JSONPreview";
  const hasHTMLPreview = hasPreview && (metadata == null ? void 0 : metadata.previewType) === "HTMLPreview";
  const hasCode = Boolean(metadata == null ? void 0 : metadata.code);
  const isTranscoded = Boolean(metadata == null ? void 0 : metadata.originalType);
  const isWorkflowView = view === VIEW.WORKFLOW;
  const showCodePanel = visible && visibleCode && hasCode;
  const showTracebackPanel = isWorkflowView && visibleTraceback;
  const showCodeSwitch = hasCode;
  let runCommand = metadata == null ? void 0 : metadata.runCommand;
  if (!runCommand) {
    runCommand = isTaskNode ? "Please provide a name argument for this node in order to see a run command." : null;
  }
  const translateMetadataType = (metadataType) => {
    if (metadataType === "task") {
      return "node";
    } else if (metadataType === "data") {
      return "dataset";
    }
    return metadataType;
  };
  const onCloseClick = () => {
    onToggleNodeSelected(null);
    toSelectedPipeline();
  };
  const onExpandMetaDataClick = () => {
    onToggleMetadataModal(true);
  };
  const removeInitialSlash = (string) => {
    return string == null ? void 0 : string.replace(/^\//g, "");
  };
  const shortenDatasetType = (value) => {
    const isList = Array.isArray(value);
    const getQualifier = (val) => {
      if (typeof val === "string" && val.includes(".")) {
        const parts = val.split(".");
        return `${parts[0]}.${parts.pop()}`;
      }
      return val;
    };
    return isList ? value.map(getQualifier) : getQualifier(value);
  };
  const getErrorDetails = (nodeId) => {
    if (!nodeId) {
      return null;
    }
    return isDataNode ? getDatasetError2(nodeId) : getNodeError2(nodeId);
  };
  const currentErrorDetails = (metadata == null ? void 0 : metadata.id) ? getErrorDetails(metadata.id) : null;
  const hasError = Boolean(currentErrorDetails);
  const getCodeValue = () => {
    if (isWorkflowView) {
      return (currentErrorDetails == null ? void 0 : currentErrorDetails.traceback) || "";
    }
    return (metadata == null ? void 0 : metadata.code) || "";
  };
  const shouldShowPanel = () => {
    return isWorkflowView ? showTracebackPanel : showCodePanel;
  };
  const getPanelTitle = () => {
    return isWorkflowView ? "Error traceback" : "Code block";
  };
  const handleErrorLogToggle = (event) => {
    if (event == null ? void 0 : event.target) {
      onToggleTraceback(event.target.checked);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      MetaDataCode$1,
      {
        visible: shouldShowPanel(),
        value: getCodeValue(),
        title: getPanelTitle()
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: modifiers("pipeline-metadata", { visible }, "kedro"), children: metadata && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__header-toolbox", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__header", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodeIcon,
            {
              className: "pipeline-metadata__icon",
              icon: nodeTypeIcon
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "pipeline-metadata__title", children: metadata.name })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            ariaLabel: "Close Metadata Panel",
            className: modifiers("pipeline-metadata__close-button", {
              hasCode
            }),
            container: React.Fragment,
            icon: CloseIcon,
            onClick: onCloseClick
          }
        ),
        !isWorkflowView && showCodeSwitch && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Toggle,
          {
            id: "code",
            dataTest: `metadata-code-toggle-${visibleCode}`,
            checked: visibleCode,
            enabled: hasCode,
            title: "Show Code",
            onChange: (event) => {
              onToggleCode(event.target.checked);
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__list", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("dl", { className: "pipeline-metadata__properties", children: [
          isPrettyName ? /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Original node name:",
              value: metadata.fullName
            }
          ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Pretty node name:",
              value: metadata.prettyName
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Type:",
              value: translateMetadataType(metadata.type)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Error Log:",
              visible: isWorkflowView && hasError,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                ErrorLog,
                {
                  errorDetails: currentErrorDetails,
                  className: "pipeline-metadata__error-log",
                  onToggleCode: handleErrorLogToggle,
                  dataTest: getDataTestAttribute("metadata", "error-log"),
                  visibleTraceback,
                  isDataNode,
                  nodeName: metadata.name
                }
              )
            }
          ),
          !isTranscoded && /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Dataset Type:",
              visible: isDataNode,
              kind: "type",
              title: metadata.datasetType,
              value: shortenDatasetType(metadata.datasetType)
            }
          ),
          isTranscoded && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MetaDataRow,
              {
                label: "Original Type:",
                visible: isDataNode,
                value: shortenDatasetType(metadata.originalType)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              MetaDataRow,
              {
                label: "Transcoded Types:",
                visible: isDataNode,
                value: shortenDatasetType(metadata.transcodedTypes)
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "File Path:",
              kind: "path",
              empty: "N/A",
              value: removeInitialSlash(metadata.filepath)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Parameters:",
              theme,
              visible: isParametersNode || isTaskNode,
              kind: "parameters",
              commas: false,
              inline: false,
              value: metadata.parameters,
              limit: 10
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Inputs:",
              visible: isTaskNode,
              value: metadata.inputs
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Outputs:",
              visible: isTaskNode,
              value: metadata.outputs
            }
          ),
          metadata.type === "task" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            MetaDataRow,
            {
              label: "Tags:",
              kind: "token",
              commas: false,
              value: metadata.tags
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MetaDataRow, { label: "Run Command:", visible: Boolean(runCommand), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CommandCopier,
            {
              command: runCommand,
              classNames: "pipeline-metadata__value",
              isCommand: metadata == null ? void 0 : metadata.runCommand,
              dataTest: "metadata-copy-command"
            }
          ) }),
          isDataNode && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "span",
              {
                className: "pipeline-metadata__label",
                "data-label": "Dataset statistics:",
                children: "Dataset statistics:"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MetaDataStats, { stats: metadata == null ? void 0 : metadata.stats })
          ] })
        ] }),
        hasPlot && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "pipeline-metadata__plot",
              onClick: onExpandMetaDataClick,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PlotlyChart$1,
                {
                  data: metadata == null ? void 0 : metadata.preview.data,
                  layout: metadata == null ? void 0 : metadata.preview.layout,
                  view: "preview"
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "pipeline-metadata__link",
              onClick: onExpandMetaDataClick,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { className: "pipeline-metadata__link-icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata__link-text", children: "Expand preview" })
              ]
            }
          )
        ] }),
        hasImage && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: "pipeline-metadata__plot",
              onClick: onExpandMetaDataClick,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                "img",
                {
                  alt: "Matplotlib rendering",
                  className: "pipeline-metadata__plot-image",
                  src: `data:image/png;base64,${metadata == null ? void 0 : metadata.preview}`
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "pipeline-metadata__link",
              onClick: onExpandMetaDataClick,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { className: "pipeline-metadata__link-icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata__link-text", children: "Expand preview" })
              ]
            }
          )
        ] }),
        hasTablePreview && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__preview", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "scrollable-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              PreviewTable,
              {
                data: metadata == null ? void 0 : metadata.preview,
                size: "small",
                onClick: onExpandMetaDataClick
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-right" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-bottom" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "pipeline-metadata__link",
              onClick: onExpandMetaDataClick,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { className: "pipeline-metadata__link-icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata__link-text", children: "Expand preview" })
              ]
            }
          )
        ] }),
        hasJSONPreview && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__preview-json", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "scrollable-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              JSONObject,
              {
                value: JSON.parse(metadata.preview),
                theme,
                style: { background: "transparent", fontSize: "14px" },
                collapsed: 3
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-right" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-bottom" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "pipeline-metadata__link",
              onClick: onExpandMetaDataClick,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { className: "pipeline-metadata__link-icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata__link-text", children: "Expand preview" })
              ]
            }
          )
        ] }),
        hasHTMLPreview && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata__preview-html", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "scrollable-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLRenderer, { content: metadata.preview }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-right" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__preview-shadow-box-bottom" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "button",
            {
              className: "pipeline-metadata__link",
              onClick: onExpandMetaDataClick,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { className: "pipeline-metadata__link-icon" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata__link-text", children: "Expand preview" })
              ]
            }
          )
        ] })
      ] })
    ] }) })
  ] });
};
const mapStateToProps$g = (state, ownProps) => ({
  isPrettyName: state.isPrettyName,
  metadata: getClickedNodeMetaData(state),
  theme: state.theme,
  visible: getVisibleMetaSidebar(state),
  visibleCode: state.visible.code,
  visibleTraceback: state.visible.traceback,
  showDatasetPreviews: state.showDatasetPreviews,
  getDatasetError: (nodeId) => getDatasetError(state, nodeId),
  getNodeError: (nodeId) => getNodeError(state, nodeId),
  view: state.view,
  ...ownProps
});
const mapDispatchToProps$b = (dispatch2) => ({
  onToggleNodeSelected: (nodeID) => {
    dispatch2(toggleNodeClicked(nodeID));
  },
  onToggleCode: (visible) => {
    dispatch2(toggleCode(visible));
  },
  onToggleTraceback: (visible) => {
    dispatch2(toggleTraceback(visible));
  },
  onToggleMetadataModal: (visible) => {
    dispatch2(togglePlotModal(visible));
  }
});
const MetaData$1 = connect(mapStateToProps$g, mapDispatchToProps$b)(MetaData);
const BackIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M14.312 5.244c.387.336.454.905.172 1.318l-.071.093-3.574 4.122 31.684-.058c.552-.001 1 .446 1.002.998 0 .513-.385.936-.882.995l-.117.007-31.323.058 3.225 3.9c.326.395.298.967-.048 1.328l-.086.08c-.395.326-.967.298-1.328-.048l-.08-.086-5.326-6.443L12.9 5.345c.362-.417.994-.462 1.41-.1z" }) });
const MetadataModal = ({ metadata, onToggle, visible, theme }) => {
  const hasPlot = (metadata == null ? void 0 : metadata.previewType) === "PlotlyPreview";
  const hasImage = (metadata == null ? void 0 : metadata.previewType) === "ImagePreview";
  const hasTable = (metadata == null ? void 0 : metadata.previewType) === "TablePreview";
  const hasJSON = (metadata == null ? void 0 : metadata.previewType) === "JSONPreview";
  const hasHTML = (metadata == null ? void 0 : metadata.previewType) === "HTMLPreview";
  const hasMetadataContent = hasPlot || hasImage || hasTable || hasJSON || hasHTML;
  if (!visible.metadataModal || !hasMetadataContent) {
    return null;
  }
  const nodeTypeIcon = getShortType(metadata == null ? void 0 : metadata.datasetType, metadata == null ? void 0 : metadata.type);
  const onCollapsePlotClick = () => {
    onToggle(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata-modal", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata-modal__top", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          className: "pipeline-metadata-modal__back",
          onClick: onCollapsePlotClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BackIcon, { className: "pipeline-metadata-modal__back-icon" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata-modal__back-text", children: "Back" })
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata-modal__header", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NodeIcon,
          {
            className: "pipeline-metadata-modal__icon",
            icon: nodeTypeIcon
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "pipeline-metadata-modal__title", children: metadata.name })
      ] }),
      hasTable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-metadata-modal__preview-text", children: [
        "Previewing first",
        " ",
        metadata.preview.data && metadata.preview.data.length,
        " rows"
      ] })
    ] }),
    hasPlot && /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PlotlyChart$1,
      {
        data: metadata.preview.data,
        layout: metadata.preview.layout,
        view: "modal"
      }
    ) }),
    hasImage && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-matplotlib-chart", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata__plot-image-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "img",
      {
        alt: "Matplotlib rendering",
        className: "pipeline-metadata__plot-image--expanded",
        src: `data:image/png;base64,${metadata.preview}`
      }
    ) }) }),
    hasTable && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata-modal__preview", children: /* @__PURE__ */ jsxRuntimeExports.jsx(PreviewTable, { data: metadata.preview, size: "large" }) }),
    hasJSON && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata-modal__preview-json", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      JSONObject,
      {
        value: JSON.parse(metadata.preview),
        theme,
        style: { background: "transparent", fontSize: "15px" },
        collapsed: 3
      }
    ) }),
    hasHTML && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-metadata-modal__preview-markdown", children: /* @__PURE__ */ jsxRuntimeExports.jsx(HTMLRenderer, { content: metadata.preview, fontSize: "15px" }) })
  ] });
};
const mapStateToProps$f = (state) => ({
  metadata: getClickedNodeMetaData(state),
  theme: state.theme,
  visible: state.visible
});
const mapDispatchToProps$a = (dispatch2) => ({
  onToggle: (value) => {
    dispatch2(togglePlotModal(value));
  }
});
const MetadataModal$1 = connect(mapStateToProps$f, mapDispatchToProps$a)(MetadataModal);
const ShareableUrlMetadata = () => {
  const [metadata, setMetadata] = reactExports.useState(null);
  reactExports.useEffect(() => {
    async function fetchData() {
      try {
        const request = await fetch(
          `${sanitizedPathname()}api/deploy-viz-metadata`,
          {
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json"
            }
          }
        );
        const response = await request.json();
        if (request.ok) {
          setMetadata(response);
        }
      } catch (error) {
        console.log("deploy-viz-metadata fetch error: ", error);
      }
    }
    fetchData();
  }, []);
  if (metadata === null) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-timestamp", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: `Kedro-Viz ${metadata.version}  ${metadata.timestamp.split(" ").join("  ")} UTC` }) });
};
const LabelIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M22 3v18H8.333L2 12l6.333-9H22zm-6.155 4h-3.69L10 17h1.944l.38-1.809h3.352l.38 1.809H18L15.845 7zm-1.507 1.676l.972 4.75h-2.62l.972-4.75h.676z" }) });
const ExportIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M5 16v4h14v-4h2v4c0 1-.8 2-1.9 2H5a2 2 0 01-2-2v-4h2zm8-14v11l3.5-3.5L18 11l-6 6-6-6 1.5-1.5L11 13V2h2z" }) });
const LayersIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 3l9 4.82-3.6 2.07 3.6 1.93-3.6 2.07 3.6 1.93L12 21l-9-5.18 3.6-1.93L3 11.82 6.6 9.9 3 7.82 12 3zM8.72 15.11l-1.45.78L12 18.6l4.73-2.72-1.45-.78L12 17l-3.28-1.89zm0-4l-1.45.78L12 14.6l4.73-2.72-1.45-.78L12 13l-3.28-1.89zM12 5.35L7.27 7.9 12 10.6l4.73-2.72L12 5.36z" }) });
const LeftRightIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "icon-orientation horizontal", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "icon-orientation-arrow__vertical",
      d: "M7.84676 17.4288L7.84837 7.84841V4.93823L4.93857 4.93861L4.93696 17.4288L3.05754 15.549L1 17.6066L6.39347 23L11.7869 17.6066L9.7294 15.549L7.84676 17.4288Z"
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "icon-orientation-arrow__horizontal",
      d: "M23 6.39347L17.6066 1L15.549 3.05754L17.4288 4.93696L4.93857 4.93861L4.93823 7.84837L7.84837 7.84841L17.4288 7.84676L15.549 9.7294L17.6066 11.7869L23 6.39347Z"
    }
  )
] });
const TopBottomIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: "icon-orientation vertical", viewBox: "0 0 24 24", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "icon-orientation-arrow__horizontal",
      d: "M23 6.39347L17.6066 1L15.549 3.05754L17.4288 4.93696L4.93861 4.93857L4.93823 7.84837H7.84841L17.4288 7.84676L15.549 9.7294L17.6066 11.7869L23 6.39347Z"
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "path",
    {
      className: "icon-orientation-arrow__vertical",
      d: "M7.84676 17.4288L7.84841 7.84837L7.84837 4.93823L4.93861 4.93857L4.93696 17.4288L3.05754 15.549L1 17.6066L6.39347 23L11.7869 17.6066L9.7294 15.549L7.84676 17.4288Z"
    }
  )
] });
const MenuIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M10.667 5 12 6.4 6.667 12 12 17.6 10.667 19 4 12l6.667-7zm8 0L20 6.4 14.667 12 20 17.6 18.667 19 12 12l6.667-7z" }) });
const PrimaryToolbar = ({
  children: children2,
  onToggleSidebar,
  dataTest,
  visible = { sidebar: true },
  display = { filterBtn: false }
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pipeline-primary-toolbar kedro", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    IconButton,
    {
      active: visible.sidebar,
      ariaLabel: `${visible.sidebar ? "Hide" : "Show"} menu`,
      className: classnames(
        "pipeline-menu-button",
        "pipeline-menu-button--menu",
        { "pipeline-menu-button--inverse": !visible.sidebar }
      ),
      dataTest,
      icon: MenuIcon,
      labelText: `${visible.sidebar ? "Hide" : "Show"} menu`,
      onClick: () => onToggleSidebar(!visible.sidebar),
      visible: !display.filterBtn
    }
  ),
  children2
] }) });
const ExpandPipelinesIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 18 18", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M0.5 17.5V10.3077H2.46151V15.5385H7.6923V17.5H0.5ZM15.5385 7.6923V2.46151H10.3077V0.5H17.5V7.6923H15.5385Z" }) });
const CollapsePipelinesIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 18 18", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.6923 10.3077V17.5H5.73079V12.2692H0.5V10.3077H7.6923ZM12.2692 0.5V5.73079H17.5V7.6923H10.3077V0.5H12.2692Z" }) });
const FlowchartPrimaryToolbar = ({
  disableLayerBtn,
  onToggleExportModal,
  onToggleLayers,
  onToggleSidebar,
  onToggleTextLabels,
  textLabels,
  visible,
  display,
  visibleLayers,
  expandedPipelines,
  onToggleExpandAllPipelines,
  orientation,
  onToggleOrientation,
  isFlowchartView
}) => {
  const { toSetQueryParam } = useGeneratePathname();
  const handleToggleExpandAllPipelines = () => {
    const isExpanded = !expandedPipelines;
    onToggleExpandAllPipelines(isExpanded);
    toSetQueryParam("expandAllPipelines", isExpanded.toString());
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    PrimaryToolbar,
    {
      onToggleSidebar,
      visible,
      display,
      dataTest: `sidebar-flowchart-visible-btn-${visible.sidebar}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            active: textLabels,
            ariaLabel: `${textLabels ? "Hide" : "Show"} text labels`,
            className: "pipeline-menu-button--labels",
            dataTest: `sidebar-flowchart-labels-btn-${textLabels}`,
            icon: LabelIcon,
            labelText: `${textLabels ? "Hide" : "Show"} text labels`,
            onClick: () => onToggleTextLabels(!textLabels),
            visible: isFlowchartView && display.labelBtn
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            active: visibleLayers,
            ariaLabel: `Turn data layers ${visibleLayers ? "off" : "on"}`,
            className: "pipeline-menu-button--layers",
            dataTest: `sidebar-flowchart-layers-btn-${visibleLayers}`,
            disabled: disableLayerBtn,
            icon: LayersIcon,
            labelText: `${visibleLayers ? "Hide" : "Show"} layers`,
            onClick: () => onToggleLayers(!visibleLayers),
            visible: display.layerBtn
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            ariaLabel: "Change flowchart orientation",
            className: "pipeline-menu-button--orientation",
            dataTest: "sidebar-flowchart-orientation-btn",
            icon: orientation === "vertical" ? TopBottomIcon : LeftRightIcon,
            labelText: "Change orientation",
            onClick: () => onToggleOrientation(
              orientation === "vertical" ? "horizontal" : "vertical"
            ),
            visible: display.orientationBtn
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            active: expandedPipelines,
            ariaLabel: expandedPipelines ? "Collapse all modular pipelines" : "Expand all modular pipelines",
            className: "pipeline-menu-button--pipeline",
            dataTest: `sidebar-flowchart-expand-pipeline-btn-${expandedPipelines}`,
            icon: expandedPipelines ? CollapsePipelinesIcon : ExpandPipelinesIcon,
            labelText: expandedPipelines ? "Collapse pipelines" : "Expand pipelines",
            onClick: handleToggleExpandAllPipelines,
            visible: isFlowchartView && display.expandPipelinesBtn
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconButton,
          {
            ariaLabel: "Export graph as SVG or PNG",
            className: "pipeline-menu-button--export",
            dataTest: "sidebar-flowchart-export-btn",
            icon: ExportIcon,
            labelText: "Export visualisation",
            onClick: () => onToggleExportModal(true),
            visible: display.exportBtn
          }
        )
      ]
    }
  ) });
};
const mapStateToProps$e = (state) => ({
  disableLayerBtn: !state.layer.ids.length,
  textLabels: state.textLabels,
  visible: state.visible,
  display: state.display,
  visibleLayers: Boolean(getVisibleLayerIDs(state).length),
  orientation: state.orientation,
  expandedPipelines: state.expandAllPipelines,
  isFlowchartView: state.view === VIEW.FLOWCHART
});
const mapDispatchToProps$9 = (dispatch2) => ({
  onToggleExportModal: (value) => {
    dispatch2(toggleExportModal(value));
  },
  onToggleLayers: (value) => {
    dispatch2(toggleLayers(Boolean(value)));
  },
  onToggleSidebar: (visible) => {
    dispatch2(toggleSidebar(visible));
  },
  onToggleTextLabels: (value) => {
    dispatch2(toggleTextLabels(Boolean(value)));
  },
  onToggleExpandAllPipelines: (isExpanded) => {
    dispatch2(toggleExpandAllPipelines(isExpanded));
    dispatch2(toggleModularPipelinesVisibilityState(isExpanded));
  },
  onToggleOrientation: (value) => {
    dispatch2(toggleOrientation(value));
  }
});
const FlowchartPrimaryToolbar$1 = connect(
  mapStateToProps$e,
  mapDispatchToProps$9
)(FlowchartPrimaryToolbar);
const viewportMargin = 2;
const drawViewport = function() {
  const { mapSize } = this.props;
  const { x: x2, y: y2, width: width2, height: height2 } = this.getViewport();
  const minX = Math.max(x2, viewportMargin);
  const minY = Math.max(y2, viewportMargin);
  const maxX = Math.min(x2 + width2, mapSize.width - viewportMargin);
  const maxY = Math.min(y2 + height2, mapSize.height - viewportMargin);
  this.el.viewport.enter().attr("x", 0).attr("y", 0);
  this.el.viewport.attr("transform", `translate(${minX}, ${minY})`).attr("width", Math.max(0, maxX - minX)).attr("height", Math.max(0, maxY - minY));
};
const drawNodes = function() {
  const { clickedNode, linkedNodes, nodeActive, nodeSelected, nodes } = this.props;
  this.el.nodes = this.el.nodeGroup.selectAll(".pipeline-minimap-node").data(nodes, (node2) => node2.id);
  const enterNodes = this.el.nodes.enter().append("g").attr("class", "pipeline-minimap-node");
  enterNodes.attr("transform", (node2) => `translate(${node2.x}, ${node2.y})`).attr("opacity", 0);
  enterNodes.append("rect");
  this.el.nodes.exit().transition("exit-nodes").duration(this.DURATION).attr("opacity", 0).remove();
  this.el.nodes = this.el.nodes.merge(enterNodes).attr("data-id", (node2) => node2.id).classed("pipeline-minimap-node--active", (node2) => nodeActive[node2.id]).classed("pipeline-minimap-node--selected", (node2) => nodeSelected[node2.id]).classed(
    "pipeline-minimap-node--faded",
    (node2) => clickedNode && !linkedNodes[node2.id]
  );
  this.el.nodes.transition("update-nodes").duration(this.DURATION).attr("opacity", 1).attr("transform", (node2) => `translate(${node2.x}, ${node2.y})`).end().catch(() => {
  });
  this.el.nodes.select("rect").attr("width", (node2) => node2.width - sizeOffset(node2)).attr("height", (node2) => node2.height - sizeOffset(node2)).attr("x", (node2) => (node2.width - sizeOffset(node2)) / -2).attr("y", (node2) => (node2.height - sizeOffset(node2)) / -2);
};
const sizeOffset = (node2) => node2.type === "task" ? 5 : 16;
class MiniMap extends reactExports.Component {
  constructor(props) {
    super(props);
    /**
     * Handle pointer enter
     */
    __publicField(this, "onPointerEnter", () => {
      this.isPointerInside = true;
    });
    /**
     * Handle pointer leave
     */
    __publicField(this, "onPointerLeave", () => {
      this.isPointerInside = false;
    });
    /**
     * Handle global pointer up
     */
    __publicField(this, "onPointerUpGlobal", () => {
      this.isPointerDown = false;
      this.isPointerInside = false;
    });
    /**
     * Handle pointer down
     * @param {Object} event Event object
     */
    __publicField(this, "onPointerDown", (event) => {
      this.isPointerDown = true;
      this.isPointerInside = true;
      this.onPointerMove(event, true);
    });
    /**
     * Handle pointer wheel
     * @param {Object} event Event object
     */
    __publicField(this, "onPointerWheel", (event) => {
      this.props.onUpdateChartZoom({
        relative: true,
        scale: -(event.deltaY || 0) * this.ZOOM_RATE,
        applied: false,
        transition: false
      });
    });
    /**
     * Handle global pointer wheel
     * @param {Object} event Event object
     */
    __publicField(this, "onPointerWheelGlobal", (event) => {
      const wasTarget = this.containerRef.current.contains(event.target);
      if (wasTarget) {
        event.preventDefault();
      }
    });
    /**
     * Handle pointer move
     * @param {Object} event Event object
     * @param {?Boolean} useTransition Apply with transition
     */
    __publicField(this, "onPointerMove", (event, useTransition = false) => {
      if (this.isPointerDown && this.isPointerInside) {
        const time = Number(/* @__PURE__ */ new Date());
        if (time - this.lastTransitionTime < this.TRANSITION_WAIT) {
          return;
        }
        const { scale: chartScale = 1 } = this.props.chartZoom;
        const { width: width2, height: height2 } = this.props.mapSize;
        const { width: graphWidth, height: graphHeight } = this.props.graphSize;
        const { k: scale = 1 } = getViewTransform(this.view);
        const containerRect = this.svgRef.current.getBoundingClientRect();
        const pointerX = (event.clientX - containerRect.x) / scale;
        const pointerY = (event.clientY - containerRect.y) / scale;
        const centerX = (width2 / scale - graphWidth) * 0.5;
        const centerY = (height2 / scale - graphHeight) * 0.5;
        const x2 = (pointerX - centerX) * chartScale;
        const y2 = (pointerY - centerY) * chartScale;
        this.props.onUpdateChartZoom({
          x: x2,
          y: y2,
          scale: chartScale,
          relative: false,
          applied: false,
          transition: useTransition
        });
        if (useTransition) {
          this.lastTransitionTime = time;
        }
      }
    });
    this.DURATION = 700;
    this.TRANSITION_WAIT = 200;
    this.ZOOM_RATE = 25e-4;
    this.isPointerDown = false;
    this.isPointerInside = false;
    this.lastTransitionTime = 0;
    this.containerRef = React.createRef();
    this.svgRef = React.createRef();
    this.wrapperRef = React.createRef();
    this.nodesRef = React.createRef();
    this.viewportRef = React.createRef();
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerEnter = this.onPointerEnter.bind(this);
    this.onPointerLeave = this.onPointerLeave.bind(this);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerWheel = this.onPointerWheel.bind(this);
    this.onPointerWheelGlobal = this.onPointerWheelGlobal.bind(this);
    this.onPointerUpGlobal = this.onPointerUpGlobal.bind(this);
  }
  componentDidMount() {
    this.selectD3Elements();
    this.view = viewing({
      container: this.svgRef,
      wrapper: this.wrapperRef,
      allowUserInput: false
    });
    this.addGlobalEventListeners();
    this.update();
  }
  componentWillUnmount() {
    this.removeGlobalEventListeners();
  }
  /**
   * Add window event listeners
   */
  addGlobalEventListeners() {
    window.addEventListener("wheel", this.onPointerWheelGlobal, {
      passive: false
    });
    window.addEventListener(
      pointerEventName("pointerup"),
      this.onPointerUpGlobal
    );
  }
  /**
   * Remove window event listeners
   */
  removeGlobalEventListeners() {
    window.removeEventListener("wheel", this.onPointerWheelGlobal);
    window.removeEventListener(
      pointerEventName("pointerup"),
      this.onPointerUpGlobal
    );
  }
  componentDidUpdate(prevProps) {
    this.update(prevProps);
  }
  /**
   * Updates drawing and zoom if props have changed
   */
  update(prevProps = {}) {
    const { miniMapVisible, chartZoom } = this.props;
    if (miniMapVisible) {
      const changed = (...names) => this.changed(names, prevProps, this.props);
      if (changed(
        "miniMapVisible",
        "nodes",
        "clickedNodes",
        "linkedNodes",
        "nodesActive",
        "nodeSelected"
      )) {
        drawNodes.call(this);
      }
      if (changed("miniMapVisible", "chartZoom") && chartZoom.applied) {
        drawViewport.call(this);
      }
      if (changed("miniMapVisible", "nodes", "textLabels", "chartSize")) {
        this.resetView();
      }
    }
  }
  /**
   * Returns true if any of the given props are different between given objects.
   * Only shallow changes are detected.
   */
  changed(props, objectA, objectB) {
    return objectA && objectB && props.some((prop) => objectA[prop] !== objectB[prop]);
  }
  /**
   * Create D3 element selectors
   */
  selectD3Elements() {
    this.el = {
      svg: select(this.svgRef.current),
      wrapper: select(this.wrapperRef.current),
      nodeGroup: select(this.nodesRef.current),
      viewport: select(this.viewportRef.current)
    };
  }
  /**
   * Zoom and scale to fit
   */
  resetView() {
    const { graphSize, mapSize } = this.props;
    const { width: mapWidth, height: mapHeight } = mapSize;
    const { width: graphWidth, height: graphHeight } = graphSize;
    if (!mapWidth || !graphWidth) {
      return;
    }
    const offset = { x: padding$1 * 0.5, y: padding$1 * 0.5 };
    const transform2 = viewTransformToFit({
      offset,
      viewWidth: mapWidth - padding$1,
      viewHeight: mapHeight - padding$1,
      objectWidth: graphWidth,
      objectHeight: graphHeight
    });
    const isFirstTransform = isOrigin(getViewTransform(this.view));
    setViewTransformExact(
      this.view,
      transform2,
      isFirstTransform ? 0 : this.DURATION
    );
  }
  /**
   * Get the position of the viewport relative to the minimap
   */
  getViewport() {
    const { chartZoom, chartSize } = this.props;
    const {
      k: mapScale,
      x: translateX,
      y: translateY
    } = getViewTransform(this.view);
    const scale = mapScale / chartZoom.scale;
    const width2 = chartSize.width * scale;
    const height2 = chartSize.height * scale;
    const x2 = -translateX - (chartZoom.x - chartSize.sidebarWidth) * scale;
    const y2 = -translateY - chartZoom.y * scale;
    return { x: x2, y: y2, width: width2, height: height2 };
  }
  /**
   * Render React elements
   */
  render() {
    const { width: width2, height: height2 } = this.props.mapSize;
    const transformStyle = {
      transform: `translate(calc(-100% + ${width2}px), -100%)`
    };
    const _ = pointerEventName;
    const inputEvents = {
      onWheel: this.onPointerWheel,
      [_("onPointerEnter")]: this.onPointerEnter,
      [_("onPointerLeave")]: this.onPointerLeave,
      [_("onPointerDown")]: this.onPointerDown,
      [_("onPointerMove")]: this.onPointerMove
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: "pipeline-minimap-container",
        style: this.props.miniMapVisible && this.props.displayMiniMap ? transformStyle : {},
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: "pipeline-minimap kedro",
            ref: this.containerRef,
            ...inputEvents,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "svg",
              {
                id: "pipeline-minimap-graph",
                className: "pipeline-minimap__graph",
                width: width2,
                height: height2,
                viewBox: `0 0 ${width2} ${height2}`,
                ref: this.svgRef,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("g", { id: "zoom-wrapper", ref: this.wrapperRef, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "g",
                    {
                      id: "minimap-nodes",
                      className: "pipeline-minimap__nodes",
                      ref: this.nodesRef
                    }
                  ) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "rect",
                    {
                      className: "pipeline-minimap__viewport",
                      ref: this.viewportRef
                    }
                  )
                ]
              }
            )
          }
        )
      }
    );
  }
}
const padding$1 = 32;
const height$1 = 220;
const minWidth$1 = 218;
const maxWidth$1 = 1.5 * minWidth$1;
const pointerEventName = (event) => window.PointerEvent ? event : event.replace("pointer", "mouse").replace("Pointer", "Mouse");
const getMapSize = (state) => {
  const size = state.graph.size || {};
  const graphWidth = size.width || 0;
  const graphHeight = size.height || 0;
  if (graphWidth > 0 && graphHeight > 0) {
    const scaledWidth = graphWidth * (height$1 / graphHeight);
    const width2 = Math.min(Math.max(scaledWidth, minWidth$1), maxWidth$1);
    return { width: width2, height: height$1 };
  }
  return { width: minWidth$1, height: height$1 };
};
const emptyNodes$1 = [];
const emptyGraphSize$1 = {};
const mapStateToProps$d = (state, ownProps) => ({
  miniMapVisible: state.visible.miniMap,
  displayMiniMap: state.display.miniMap,
  mapSize: getMapSize(state),
  clickedNode: state.node.clicked,
  chartSize: getChartSize(state),
  chartZoom: getChartZoom(state),
  graphSize: state.graph.size || emptyGraphSize$1,
  nodes: state.graph.nodes || emptyNodes$1,
  linkedNodes: getLinkedNodes(state),
  nodeActive: getNodeActive(state),
  nodeSelected: getNodeSelected(state),
  textLabels: state.textLabels,
  ...ownProps
});
const mapDispatchToProps$8 = (dispatch2, ownProps) => ({
  onUpdateChartZoom: (transform2) => {
    dispatch2(updateZoom(transform2));
  },
  ...ownProps
});
const MiniMap$1 = connect(mapStateToProps$d, mapDispatchToProps$8)(MiniMap);
const MapIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M9.5 3l6 3.7 6-2.1v13.9l-6.2 3.3-6-3.8L3 20.4V5.3L9.5 3zm10 4.4l-3.1 1.2v10.3l3.2-1.6V7.4zm-9.1-1.5v10.4l4 2.5V8.4l-4-2.5zm-2-.4L5 6.7v10.8l3.4-1.3V5.5z" }) });
const PlusIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "m13 4v7h7v2h-7v7h-2v-7h-7v-2h7v-7z" }) });
const MinusIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M19 13H5v-2h14z" }) });
const ResetIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M8.5 4v5.5h-2V7.7A7 7 0 0012 19v2A9 9 0 015.3 6H3V4h5.5zM12 3a9 9 0 017.1 14.5h2.4v2H16V14h2v1.6A7 7 0 0012 5z" }) });
const MiniMapToolbar = ({
  chartZoom,
  displayMiniMap,
  onToggleMiniMap,
  onUpdateChartZoom,
  visible,
  displayZoomToolbar
}) => {
  const { scale, minScale, maxScale } = chartZoom;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "pipeline-minimap-toolbar kedro", children: [
    displayMiniMap && /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        active: visible.miniMap,
        ariaLabel: `Turn minimap ${visible.miniMap ? "off" : "on"}`,
        className: "pipeline-minimap-button pipeline-minimap-button--map",
        dataTest: `sidebar-minimap-btn-${visible.miniMap}`,
        icon: MapIcon,
        id: "minimap-toggle-icon",
        labelText: `${visible.miniMap ? "Hide" : "Show"} minimap`,
        onClick: () => onToggleMiniMap(!visible.miniMap),
        visible: displayMiniMap
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        ariaLabel: "Zoom in",
        className: "pipeline-minimap-button pipeline-minimap-button--zoom-in",
        dataTest: `sidebar-zoom-in-btn`,
        disabled: scale >= maxScale,
        icon: PlusIcon,
        labelText: "Zoom in",
        onClick: () => onUpdateChartZoom(scaleZoom(chartZoom, 1.3)),
        visible: displayZoomToolbar
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        ariaLabel: "Zoom out",
        className: "pipeline-minimap-button pipeline-minimap-button--zoom-out",
        dataTest: `sidebar-zoom-out-btn`,
        disabled: scale <= minScale,
        icon: MinusIcon,
        labelText: "Zoom out",
        onClick: () => onUpdateChartZoom(scaleZoom(chartZoom, 0.7)),
        visible: displayZoomToolbar
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        ariaLabel: "Reset zoom",
        className: "pipeline-minimap-button pipeline-minimap-button--reset",
        dataTest: `sidebar-reset-zoom-btn`,
        icon: ResetIcon,
        labelText: "Reset zoom",
        onClick: () => onUpdateChartZoom(scaleZoom(chartZoom, 0)),
        visible: displayZoomToolbar
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "pipeline-minimap-toolbar__scale", title: "Zoom level", children: [
      Math.round(100 * chartZoom.scale) || 100,
      "%"
    ] }) })
  ] }) });
};
const scaleZoom = ({ scale }, factor) => ({
  scale: scale * (factor || 1),
  applied: false,
  transition: true,
  reset: factor === 0
});
const mapStateToProps$c = (state) => ({
  visible: state.visible,
  displayMiniMap: state.display.miniMap,
  displayZoomToolbar: state.display.zoomToolbar,
  chartZoom: getChartZoom(state)
});
const mapDispatchToProps$7 = (dispatch2) => ({
  onToggleMiniMap: (value) => {
    dispatch2(toggleMiniMap(value));
  },
  onUpdateChartZoom: (transform2) => {
    dispatch2(updateZoom(transform2));
  }
});
const MiniMapToolbar$1 = connect(mapStateToProps$c, mapDispatchToProps$7)(MiniMapToolbar);
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow) return now_1;
  hasRequiredNow = 1;
  var root2 = require_root();
  var now2 = function() {
    return root2.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex) return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {
    }
    return index;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim) return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber) return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var debounce_1;
var hasRequiredDebounce;
function requireDebounce() {
  if (hasRequiredDebounce) return debounce_1;
  hasRequiredDebounce = 1;
  var isObject = requireIsObject(), now2 = requireNow(), toNumber = requireToNumber();
  var FUNC_ERROR_TEXT = "Expected a function";
  var nativeMax = Math.max, nativeMin = Math.min;
  function debounce2(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now2();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now2());
    }
    function debounced() {
      var time = now2(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  debounce_1 = debounce2;
  return debounce_1;
}
var debounceExports = requireDebounce();
const debounce$1 = /* @__PURE__ */ getDefaultExportFromCjs(debounceExports);
var lib = {};
var Scrollbars = {};
var raf = { exports: {} };
var performanceNow$1 = { exports: {} };
var performanceNow = performanceNow$1.exports;
var hasRequiredPerformanceNow;
function requirePerformanceNow() {
  if (hasRequiredPerformanceNow) return performanceNow$1.exports;
  hasRequiredPerformanceNow = 1;
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
      performanceNow$1.exports = function() {
        return performance.now();
      };
    } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
      performanceNow$1.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      performanceNow$1.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      performanceNow$1.exports = function() {
        return (/* @__PURE__ */ new Date()).getTime() - loadTime;
      };
      loadTime = (/* @__PURE__ */ new Date()).getTime();
    }
  }).call(performanceNow);
  return performanceNow$1.exports;
}
var hasRequiredRaf;
function requireRaf() {
  if (hasRequiredRaf) return raf.exports;
  hasRequiredRaf = 1;
  var now2 = requirePerformanceNow(), root2 = typeof window === "undefined" ? commonjsGlobal$1 : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf$1 = root2["request" + suffix], caf = root2["cancel" + suffix] || root2["cancelRequest" + suffix];
  for (var i = 0; !raf$1 && i < vendors.length; i++) {
    raf$1 = root2[vendors[i] + "Request" + suffix];
    caf = root2[vendors[i] + "Cancel" + suffix] || root2[vendors[i] + "CancelRequest" + suffix];
  }
  if (!raf$1 || !caf) {
    var last = 0, id2 = 0, queue = [], frameDuration = 1e3 / 60;
    raf$1 = function(callback) {
      if (queue.length === 0) {
        var _now = now2(), next2 = Math.max(0, frameDuration - (_now - last));
        last = next2 + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          queue.length = 0;
          for (var i2 = 0; i2 < cp.length; i2++) {
            if (!cp[i2].cancelled) {
              try {
                cp[i2].callback(last);
              } catch (e) {
                setTimeout(function() {
                  throw e;
                }, 0);
              }
            }
          }
        }, Math.round(next2));
      }
      queue.push({
        handle: ++id2,
        callback,
        cancelled: false
      });
      return id2;
    };
    caf = function(handle) {
      for (var i2 = 0; i2 < queue.length; i2++) {
        if (queue[i2].handle === handle) {
          queue[i2].cancelled = true;
        }
      }
    };
  }
  raf.exports = function(fn) {
    return raf$1.call(root2, fn);
  };
  raf.exports.cancel = function() {
    caf.apply(root2, arguments);
  };
  raf.exports.polyfill = function(object2) {
    if (!object2) {
      object2 = root2;
    }
    object2.requestAnimationFrame = raf$1;
    object2.cancelAnimationFrame = caf;
  };
  return raf.exports;
}
var domCss = { exports: {} };
var prefixStyle;
var hasRequiredPrefixStyle;
function requirePrefixStyle() {
  if (hasRequiredPrefixStyle) return prefixStyle;
  hasRequiredPrefixStyle = 1;
  var div = null;
  var prefixes = ["Webkit", "Moz", "O", "ms"];
  prefixStyle = function prefixStyle2(prop) {
    if (!div) {
      div = document.createElement("div");
    }
    var style2 = div.style;
    if (prop in style2) {
      return prop;
    }
    var titleCase = prop.charAt(0).toUpperCase() + prop.slice(1);
    for (var i = prefixes.length; i >= 0; i--) {
      var name = prefixes[i] + titleCase;
      if (name in style2) {
        return name;
      }
    }
    return false;
  };
  return prefixStyle;
}
var toNoCase_1;
var hasRequiredToNoCase;
function requireToNoCase() {
  if (hasRequiredToNoCase) return toNoCase_1;
  hasRequiredToNoCase = 1;
  toNoCase_1 = toNoCase;
  var hasSpace = /\s/;
  var hasSeparator = /(_|-|\.|:)/;
  var hasCamel = /([a-z][A-Z]|[A-Z][a-z])/;
  function toNoCase(string) {
    if (hasSpace.test(string)) return string.toLowerCase();
    if (hasSeparator.test(string)) return (unseparate(string) || string).toLowerCase();
    if (hasCamel.test(string)) return uncamelize(string).toLowerCase();
    return string.toLowerCase();
  }
  var separatorSplitter = /[\W_]+(.|$)/g;
  function unseparate(string) {
    return string.replace(separatorSplitter, function(m, next2) {
      return next2 ? " " + next2 : "";
    });
  }
  var camelSplitter = /(.)([A-Z]+)/g;
  function uncamelize(string) {
    return string.replace(camelSplitter, function(m, previous, uppers) {
      return previous + " " + uppers.toLowerCase().split("").join(" ");
    });
  }
  return toNoCase_1;
}
var toSpaceCase_1;
var hasRequiredToSpaceCase;
function requireToSpaceCase() {
  if (hasRequiredToSpaceCase) return toSpaceCase_1;
  hasRequiredToSpaceCase = 1;
  var clean = requireToNoCase();
  toSpaceCase_1 = toSpaceCase;
  function toSpaceCase(string) {
    return clean(string).replace(/[\W_]+(.|$)/g, function(matches, match2) {
      return match2 ? " " + match2 : "";
    }).trim();
  }
  return toSpaceCase_1;
}
var toCamelCase_1;
var hasRequiredToCamelCase;
function requireToCamelCase() {
  if (hasRequiredToCamelCase) return toCamelCase_1;
  hasRequiredToCamelCase = 1;
  var space = requireToSpaceCase();
  toCamelCase_1 = toCamelCase;
  function toCamelCase(string) {
    return space(string).replace(/\s(\w)/g, function(matches, letter) {
      return letter.toUpperCase();
    });
  }
  return toCamelCase_1;
}
var addPxToStyle;
var hasRequiredAddPxToStyle;
function requireAddPxToStyle() {
  if (hasRequiredAddPxToStyle) return addPxToStyle;
  hasRequiredAddPxToStyle = 1;
  var IS_UNITLESS = {
    animationIterationCount: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridColumn: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    stopOpacity: true,
    strokeDashoffset: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  addPxToStyle = function(name, value) {
    if (typeof value === "number" && !IS_UNITLESS[name]) {
      return value + "px";
    } else {
      return value;
    }
  };
  return addPxToStyle;
}
var hasRequiredDomCss;
function requireDomCss() {
  if (hasRequiredDomCss) return domCss.exports;
  hasRequiredDomCss = 1;
  var prefix2 = requirePrefixStyle();
  var toCamelCase = requireToCamelCase();
  var cache = { "float": "cssFloat" };
  var addPxToStyle2 = requireAddPxToStyle();
  function style2(element, property, value) {
    var camel = cache[property];
    if (typeof camel === "undefined") {
      camel = detect(property);
    }
    if (camel) {
      if (value === void 0) {
        return element.style[camel];
      }
      element.style[camel] = addPxToStyle2(camel, value);
    }
  }
  function each(element, properties2) {
    for (var k in properties2) {
      if (properties2.hasOwnProperty(k)) {
        style2(element, k, properties2[k]);
      }
    }
  }
  function detect(cssProp) {
    var camel = toCamelCase(cssProp);
    var result = prefix2(camel);
    cache[camel] = cache[cssProp] = cache[result] = result;
    return result;
  }
  function set2() {
    if (arguments.length === 2) {
      if (typeof arguments[1] === "string") {
        arguments[0].style.cssText = arguments[1];
      } else {
        each(arguments[0], arguments[1]);
      }
    } else {
      style2(arguments[0], arguments[1], arguments[2]);
    }
  }
  domCss.exports = set2;
  domCss.exports.set = set2;
  domCss.exports.get = function(element, properties2) {
    if (Array.isArray(properties2)) {
      return properties2.reduce(function(obj, prop) {
        obj[prop] = style2(element, prop || "");
        return obj;
      }, {});
    } else {
      return style2(element, properties2 || "");
    }
  };
  return domCss.exports;
}
var isString = {};
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString;
  hasRequiredIsString = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = isString2;
    function isString2(maybe) {
      return typeof maybe === "string";
    }
  })(isString);
  return isString;
}
var getScrollbarWidth = {};
var hasRequiredGetScrollbarWidth;
function requireGetScrollbarWidth() {
  if (hasRequiredGetScrollbarWidth) return getScrollbarWidth;
  hasRequiredGetScrollbarWidth = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = getScrollbarWidth2;
    var _domCss = requireDomCss();
    var _domCss2 = _interopRequireDefault(_domCss);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var scrollbarWidth = false;
    function getScrollbarWidth2() {
      var cacheEnabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      if (cacheEnabled && scrollbarWidth !== false) return scrollbarWidth;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        (0, _domCss2["default"])(div, {
          width: 100,
          height: 100,
          position: "absolute",
          top: -9999,
          overflow: "scroll",
          MsOverflowStyle: "scrollbar"
        });
        document.body.appendChild(div);
        scrollbarWidth = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
      } else {
        scrollbarWidth = 0;
      }
      return scrollbarWidth || 0;
    }
  })(getScrollbarWidth);
  return getScrollbarWidth;
}
var returnFalse = {};
var hasRequiredReturnFalse;
function requireReturnFalse() {
  if (hasRequiredReturnFalse) return returnFalse;
  hasRequiredReturnFalse = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = returnFalse2;
    function returnFalse2() {
      return false;
    }
  })(returnFalse);
  return returnFalse;
}
var getInnerWidth = {};
var hasRequiredGetInnerWidth;
function requireGetInnerWidth() {
  if (hasRequiredGetInnerWidth) return getInnerWidth;
  hasRequiredGetInnerWidth = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = getInnerWidth2;
    function getInnerWidth2(el) {
      var clientWidth = el.clientWidth;
      var _getComputedStyle = getComputedStyle(el), paddingLeft = _getComputedStyle.paddingLeft, paddingRight = _getComputedStyle.paddingRight;
      return clientWidth - parseFloat(paddingLeft) - parseFloat(paddingRight);
    }
  })(getInnerWidth);
  return getInnerWidth;
}
var getInnerHeight = {};
var hasRequiredGetInnerHeight;
function requireGetInnerHeight() {
  if (hasRequiredGetInnerHeight) return getInnerHeight;
  hasRequiredGetInnerHeight = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = getInnerHeight2;
    function getInnerHeight2(el) {
      var clientHeight = el.clientHeight;
      var _getComputedStyle = getComputedStyle(el), paddingTop = _getComputedStyle.paddingTop, paddingBottom = _getComputedStyle.paddingBottom;
      return clientHeight - parseFloat(paddingTop) - parseFloat(paddingBottom);
    }
  })(getInnerHeight);
  return getInnerHeight;
}
var styles = {};
var hasRequiredStyles;
function requireStyles() {
  if (hasRequiredStyles) return styles;
  hasRequiredStyles = 1;
  Object.defineProperty(styles, "__esModule", {
    value: true
  });
  styles.containerStyleDefault = {
    position: "relative",
    overflow: "hidden",
    width: "100%",
    height: "100%"
  };
  styles.containerStyleAutoHeight = {
    height: "auto"
  };
  styles.viewStyleDefault = {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    overflow: "scroll",
    WebkitOverflowScrolling: "touch"
  };
  styles.viewStyleAutoHeight = {
    position: "relative",
    top: void 0,
    left: void 0,
    right: void 0,
    bottom: void 0
  };
  styles.viewStyleUniversalInitial = {
    overflow: "hidden",
    marginRight: 0,
    marginBottom: 0
  };
  styles.trackHorizontalStyleDefault = {
    position: "absolute",
    height: 6
  };
  styles.trackVerticalStyleDefault = {
    position: "absolute",
    width: 6
  };
  styles.thumbHorizontalStyleDefault = {
    position: "relative",
    display: "block",
    height: "100%"
  };
  styles.thumbVerticalStyleDefault = {
    position: "relative",
    display: "block",
    width: "100%"
  };
  styles.disableSelectStyle = {
    userSelect: "none"
  };
  styles.disableSelectStyleReset = {
    userSelect: ""
  };
  return styles;
}
var defaultRenderElements = {};
var hasRequiredDefaultRenderElements;
function requireDefaultRenderElements() {
  if (hasRequiredDefaultRenderElements) return defaultRenderElements;
  hasRequiredDefaultRenderElements = 1;
  Object.defineProperty(defaultRenderElements, "__esModule", {
    value: true
  });
  var _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  defaultRenderElements.renderViewDefault = renderViewDefault;
  defaultRenderElements.renderTrackHorizontalDefault = renderTrackHorizontalDefault;
  defaultRenderElements.renderTrackVerticalDefault = renderTrackVerticalDefault;
  defaultRenderElements.renderThumbHorizontalDefault = renderThumbHorizontalDefault;
  defaultRenderElements.renderThumbVerticalDefault = renderThumbVerticalDefault;
  var _react = requireReact();
  var _react2 = _interopRequireDefault(_react);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  function _objectWithoutProperties(obj, keys) {
    var target = {};
    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }
    return target;
  }
  function renderViewDefault(props) {
    return _react2["default"].createElement("div", props);
  }
  function renderTrackHorizontalDefault(_ref) {
    var style2 = _ref.style, props = _objectWithoutProperties(_ref, ["style"]);
    var finalStyle = _extends2({}, style2, {
      right: 2,
      bottom: 2,
      left: 2,
      borderRadius: 3
    });
    return _react2["default"].createElement("div", _extends2({ style: finalStyle }, props));
  }
  function renderTrackVerticalDefault(_ref2) {
    var style2 = _ref2.style, props = _objectWithoutProperties(_ref2, ["style"]);
    var finalStyle = _extends2({}, style2, {
      right: 2,
      bottom: 2,
      top: 2,
      borderRadius: 3
    });
    return _react2["default"].createElement("div", _extends2({ style: finalStyle }, props));
  }
  function renderThumbHorizontalDefault(_ref3) {
    var style2 = _ref3.style, props = _objectWithoutProperties(_ref3, ["style"]);
    var finalStyle = _extends2({}, style2, {
      cursor: "pointer",
      borderRadius: "inherit",
      backgroundColor: "rgba(0,0,0,.2)"
    });
    return _react2["default"].createElement("div", _extends2({ style: finalStyle }, props));
  }
  function renderThumbVerticalDefault(_ref4) {
    var style2 = _ref4.style, props = _objectWithoutProperties(_ref4, ["style"]);
    var finalStyle = _extends2({}, style2, {
      cursor: "pointer",
      borderRadius: "inherit",
      backgroundColor: "rgba(0,0,0,.2)"
    });
    return _react2["default"].createElement("div", _extends2({ style: finalStyle }, props));
  }
  return defaultRenderElements;
}
var hasRequiredScrollbars;
function requireScrollbars() {
  if (hasRequiredScrollbars) return Scrollbars;
  hasRequiredScrollbars = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _raf2 = requireRaf();
    var _raf3 = _interopRequireDefault(_raf2);
    var _domCss = requireDomCss();
    var _domCss2 = _interopRequireDefault(_domCss);
    var _react = requireReact();
    var _propTypes = /* @__PURE__ */ requirePropTypes();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _isString = requireIsString();
    var _isString2 = _interopRequireDefault(_isString);
    var _getScrollbarWidth = requireGetScrollbarWidth();
    var _getScrollbarWidth2 = _interopRequireDefault(_getScrollbarWidth);
    var _returnFalse = requireReturnFalse();
    var _returnFalse2 = _interopRequireDefault(_returnFalse);
    var _getInnerWidth = requireGetInnerWidth();
    var _getInnerWidth2 = _interopRequireDefault(_getInnerWidth);
    var _getInnerHeight = requireGetInnerHeight();
    var _getInnerHeight2 = _interopRequireDefault(_getInnerHeight);
    var _styles = requireStyles();
    var _defaultRenderElements = requireDefaultRenderElements();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _objectWithoutProperties(obj, keys) {
      var target = {};
      for (var i in obj) {
        if (keys.indexOf(i) >= 0) continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
        target[i] = obj[i];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Scrollbars2 = function(_Component) {
      _inherits(Scrollbars3, _Component);
      function Scrollbars3(props) {
        var _ref;
        _classCallCheck(this, Scrollbars3);
        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        var _this = _possibleConstructorReturn(this, (_ref = Scrollbars3.__proto__ || Object.getPrototypeOf(Scrollbars3)).call.apply(_ref, [this, props].concat(rest)));
        _this.getScrollLeft = _this.getScrollLeft.bind(_this);
        _this.getScrollTop = _this.getScrollTop.bind(_this);
        _this.getScrollWidth = _this.getScrollWidth.bind(_this);
        _this.getScrollHeight = _this.getScrollHeight.bind(_this);
        _this.getClientWidth = _this.getClientWidth.bind(_this);
        _this.getClientHeight = _this.getClientHeight.bind(_this);
        _this.getValues = _this.getValues.bind(_this);
        _this.getThumbHorizontalWidth = _this.getThumbHorizontalWidth.bind(_this);
        _this.getThumbVerticalHeight = _this.getThumbVerticalHeight.bind(_this);
        _this.getScrollLeftForOffset = _this.getScrollLeftForOffset.bind(_this);
        _this.getScrollTopForOffset = _this.getScrollTopForOffset.bind(_this);
        _this.scrollLeft = _this.scrollLeft.bind(_this);
        _this.scrollTop = _this.scrollTop.bind(_this);
        _this.scrollToLeft = _this.scrollToLeft.bind(_this);
        _this.scrollToTop = _this.scrollToTop.bind(_this);
        _this.scrollToRight = _this.scrollToRight.bind(_this);
        _this.scrollToBottom = _this.scrollToBottom.bind(_this);
        _this.handleTrackMouseEnter = _this.handleTrackMouseEnter.bind(_this);
        _this.handleTrackMouseLeave = _this.handleTrackMouseLeave.bind(_this);
        _this.handleHorizontalTrackMouseDown = _this.handleHorizontalTrackMouseDown.bind(_this);
        _this.handleVerticalTrackMouseDown = _this.handleVerticalTrackMouseDown.bind(_this);
        _this.handleHorizontalThumbMouseDown = _this.handleHorizontalThumbMouseDown.bind(_this);
        _this.handleVerticalThumbMouseDown = _this.handleVerticalThumbMouseDown.bind(_this);
        _this.handleWindowResize = _this.handleWindowResize.bind(_this);
        _this.handleScroll = _this.handleScroll.bind(_this);
        _this.handleDrag = _this.handleDrag.bind(_this);
        _this.handleDragEnd = _this.handleDragEnd.bind(_this);
        _this.state = {
          didMountUniversal: false
        };
        return _this;
      }
      _createClass(Scrollbars3, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          this.addListeners();
          this.update();
          this.componentDidMountUniversal();
        }
      }, {
        key: "componentDidMountUniversal",
        value: function componentDidMountUniversal() {
          var universal = this.props.universal;
          if (!universal) return;
          this.setState({ didMountUniversal: true });
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          this.update();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.removeListeners();
          (0, _raf2.cancel)(this.requestFrame);
          clearTimeout(this.hideTracksTimeout);
          clearInterval(this.detectScrollingInterval);
        }
      }, {
        key: "getScrollLeft",
        value: function getScrollLeft() {
          if (!this.view) return 0;
          return this.view.scrollLeft;
        }
      }, {
        key: "getScrollTop",
        value: function getScrollTop() {
          if (!this.view) return 0;
          return this.view.scrollTop;
        }
      }, {
        key: "getScrollWidth",
        value: function getScrollWidth() {
          if (!this.view) return 0;
          return this.view.scrollWidth;
        }
      }, {
        key: "getScrollHeight",
        value: function getScrollHeight() {
          if (!this.view) return 0;
          return this.view.scrollHeight;
        }
      }, {
        key: "getClientWidth",
        value: function getClientWidth() {
          if (!this.view) return 0;
          return this.view.clientWidth;
        }
      }, {
        key: "getClientHeight",
        value: function getClientHeight() {
          if (!this.view) return 0;
          return this.view.clientHeight;
        }
      }, {
        key: "getValues",
        value: function getValues() {
          var _ref2 = this.view || {}, _ref2$scrollLeft = _ref2.scrollLeft, scrollLeft = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTop = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop, _ref2$scrollWidth = _ref2.scrollWidth, scrollWidth = _ref2$scrollWidth === void 0 ? 0 : _ref2$scrollWidth, _ref2$scrollHeight = _ref2.scrollHeight, scrollHeight = _ref2$scrollHeight === void 0 ? 0 : _ref2$scrollHeight, _ref2$clientWidth = _ref2.clientWidth, clientWidth = _ref2$clientWidth === void 0 ? 0 : _ref2$clientWidth, _ref2$clientHeight = _ref2.clientHeight, clientHeight = _ref2$clientHeight === void 0 ? 0 : _ref2$clientHeight;
          return {
            left: scrollLeft / (scrollWidth - clientWidth) || 0,
            top: scrollTop / (scrollHeight - clientHeight) || 0,
            scrollLeft,
            scrollTop,
            scrollWidth,
            scrollHeight,
            clientWidth,
            clientHeight
          };
        }
      }, {
        key: "getThumbHorizontalWidth",
        value: function getThumbHorizontalWidth() {
          var _props = this.props, thumbSize = _props.thumbSize, thumbMinSize = _props.thumbMinSize;
          var _view = this.view, scrollWidth = _view.scrollWidth, clientWidth = _view.clientWidth;
          var trackWidth = (0, _getInnerWidth2["default"])(this.trackHorizontal);
          var width2 = Math.ceil(clientWidth / scrollWidth * trackWidth);
          if (trackWidth <= width2) return 0;
          if (thumbSize) return thumbSize;
          return Math.max(width2, thumbMinSize);
        }
      }, {
        key: "getThumbVerticalHeight",
        value: function getThumbVerticalHeight() {
          var _props2 = this.props, thumbSize = _props2.thumbSize, thumbMinSize = _props2.thumbMinSize;
          var _view2 = this.view, scrollHeight = _view2.scrollHeight, clientHeight = _view2.clientHeight;
          var trackHeight = (0, _getInnerHeight2["default"])(this.trackVertical);
          var height2 = Math.ceil(clientHeight / scrollHeight * trackHeight);
          if (trackHeight <= height2) return 0;
          if (thumbSize) return thumbSize;
          return Math.max(height2, thumbMinSize);
        }
      }, {
        key: "getScrollLeftForOffset",
        value: function getScrollLeftForOffset(offset) {
          var _view3 = this.view, scrollWidth = _view3.scrollWidth, clientWidth = _view3.clientWidth;
          var trackWidth = (0, _getInnerWidth2["default"])(this.trackHorizontal);
          var thumbWidth = this.getThumbHorizontalWidth();
          return offset / (trackWidth - thumbWidth) * (scrollWidth - clientWidth);
        }
      }, {
        key: "getScrollTopForOffset",
        value: function getScrollTopForOffset(offset) {
          var _view4 = this.view, scrollHeight = _view4.scrollHeight, clientHeight = _view4.clientHeight;
          var trackHeight = (0, _getInnerHeight2["default"])(this.trackVertical);
          var thumbHeight = this.getThumbVerticalHeight();
          return offset / (trackHeight - thumbHeight) * (scrollHeight - clientHeight);
        }
      }, {
        key: "scrollLeft",
        value: function scrollLeft() {
          var left = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (!this.view) return;
          this.view.scrollLeft = left;
        }
      }, {
        key: "scrollTop",
        value: function scrollTop() {
          var top = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (!this.view) return;
          this.view.scrollTop = top;
        }
      }, {
        key: "scrollToLeft",
        value: function scrollToLeft() {
          if (!this.view) return;
          this.view.scrollLeft = 0;
        }
      }, {
        key: "scrollToTop",
        value: function scrollToTop() {
          if (!this.view) return;
          this.view.scrollTop = 0;
        }
      }, {
        key: "scrollToRight",
        value: function scrollToRight() {
          if (!this.view) return;
          this.view.scrollLeft = this.view.scrollWidth;
        }
      }, {
        key: "scrollToBottom",
        value: function scrollToBottom() {
          if (!this.view) return;
          this.view.scrollTop = this.view.scrollHeight;
        }
      }, {
        key: "addListeners",
        value: function addListeners() {
          if (typeof document === "undefined" || !this.view) return;
          var view = this.view, trackHorizontal = this.trackHorizontal, trackVertical = this.trackVertical, thumbHorizontal = this.thumbHorizontal, thumbVertical = this.thumbVertical;
          view.addEventListener("scroll", this.handleScroll);
          if (!(0, _getScrollbarWidth2["default"])()) return;
          trackHorizontal.addEventListener("mouseenter", this.handleTrackMouseEnter);
          trackHorizontal.addEventListener("mouseleave", this.handleTrackMouseLeave);
          trackHorizontal.addEventListener("mousedown", this.handleHorizontalTrackMouseDown);
          trackVertical.addEventListener("mouseenter", this.handleTrackMouseEnter);
          trackVertical.addEventListener("mouseleave", this.handleTrackMouseLeave);
          trackVertical.addEventListener("mousedown", this.handleVerticalTrackMouseDown);
          thumbHorizontal.addEventListener("mousedown", this.handleHorizontalThumbMouseDown);
          thumbVertical.addEventListener("mousedown", this.handleVerticalThumbMouseDown);
          window.addEventListener("resize", this.handleWindowResize);
        }
      }, {
        key: "removeListeners",
        value: function removeListeners() {
          if (typeof document === "undefined" || !this.view) return;
          var view = this.view, trackHorizontal = this.trackHorizontal, trackVertical = this.trackVertical, thumbHorizontal = this.thumbHorizontal, thumbVertical = this.thumbVertical;
          view.removeEventListener("scroll", this.handleScroll);
          if (!(0, _getScrollbarWidth2["default"])()) return;
          trackHorizontal.removeEventListener("mouseenter", this.handleTrackMouseEnter);
          trackHorizontal.removeEventListener("mouseleave", this.handleTrackMouseLeave);
          trackHorizontal.removeEventListener("mousedown", this.handleHorizontalTrackMouseDown);
          trackVertical.removeEventListener("mouseenter", this.handleTrackMouseEnter);
          trackVertical.removeEventListener("mouseleave", this.handleTrackMouseLeave);
          trackVertical.removeEventListener("mousedown", this.handleVerticalTrackMouseDown);
          thumbHorizontal.removeEventListener("mousedown", this.handleHorizontalThumbMouseDown);
          thumbVertical.removeEventListener("mousedown", this.handleVerticalThumbMouseDown);
          window.removeEventListener("resize", this.handleWindowResize);
          this.teardownDragging();
        }
      }, {
        key: "handleScroll",
        value: function handleScroll(event) {
          var _this2 = this;
          var _props3 = this.props, onScroll = _props3.onScroll, onScrollFrame = _props3.onScrollFrame;
          if (onScroll) onScroll(event);
          this.update(function(values2) {
            var scrollLeft = values2.scrollLeft, scrollTop = values2.scrollTop;
            _this2.viewScrollLeft = scrollLeft;
            _this2.viewScrollTop = scrollTop;
            if (onScrollFrame) onScrollFrame(values2);
          });
          this.detectScrolling();
        }
      }, {
        key: "handleScrollStart",
        value: function handleScrollStart() {
          var onScrollStart = this.props.onScrollStart;
          if (onScrollStart) onScrollStart();
          this.handleScrollStartAutoHide();
        }
      }, {
        key: "handleScrollStartAutoHide",
        value: function handleScrollStartAutoHide() {
          var autoHide = this.props.autoHide;
          if (!autoHide) return;
          this.showTracks();
        }
      }, {
        key: "handleScrollStop",
        value: function handleScrollStop() {
          var onScrollStop = this.props.onScrollStop;
          if (onScrollStop) onScrollStop();
          this.handleScrollStopAutoHide();
        }
      }, {
        key: "handleScrollStopAutoHide",
        value: function handleScrollStopAutoHide() {
          var autoHide = this.props.autoHide;
          if (!autoHide) return;
          this.hideTracks();
        }
      }, {
        key: "handleWindowResize",
        value: function handleWindowResize() {
          (0, _getScrollbarWidth2["default"])(false);
          this.forceUpdate();
        }
      }, {
        key: "handleHorizontalTrackMouseDown",
        value: function handleHorizontalTrackMouseDown(event) {
          event.preventDefault();
          var target = event.target, clientX = event.clientX;
          var _target$getBoundingCl = target.getBoundingClientRect(), targetLeft = _target$getBoundingCl.left;
          var thumbWidth = this.getThumbHorizontalWidth();
          var offset = Math.abs(targetLeft - clientX) - thumbWidth / 2;
          this.view.scrollLeft = this.getScrollLeftForOffset(offset);
        }
      }, {
        key: "handleVerticalTrackMouseDown",
        value: function handleVerticalTrackMouseDown(event) {
          event.preventDefault();
          var target = event.target, clientY = event.clientY;
          var _target$getBoundingCl2 = target.getBoundingClientRect(), targetTop = _target$getBoundingCl2.top;
          var thumbHeight = this.getThumbVerticalHeight();
          var offset = Math.abs(targetTop - clientY) - thumbHeight / 2;
          this.view.scrollTop = this.getScrollTopForOffset(offset);
        }
      }, {
        key: "handleHorizontalThumbMouseDown",
        value: function handleHorizontalThumbMouseDown(event) {
          event.preventDefault();
          this.handleDragStart(event);
          var target = event.target, clientX = event.clientX;
          var offsetWidth = target.offsetWidth;
          var _target$getBoundingCl3 = target.getBoundingClientRect(), left = _target$getBoundingCl3.left;
          this.prevPageX = offsetWidth - (clientX - left);
        }
      }, {
        key: "handleVerticalThumbMouseDown",
        value: function handleVerticalThumbMouseDown(event) {
          event.preventDefault();
          this.handleDragStart(event);
          var target = event.target, clientY = event.clientY;
          var offsetHeight = target.offsetHeight;
          var _target$getBoundingCl4 = target.getBoundingClientRect(), top = _target$getBoundingCl4.top;
          this.prevPageY = offsetHeight - (clientY - top);
        }
      }, {
        key: "setupDragging",
        value: function setupDragging() {
          (0, _domCss2["default"])(document.body, _styles.disableSelectStyle);
          document.addEventListener("mousemove", this.handleDrag);
          document.addEventListener("mouseup", this.handleDragEnd);
          document.onselectstart = _returnFalse2["default"];
        }
      }, {
        key: "teardownDragging",
        value: function teardownDragging() {
          (0, _domCss2["default"])(document.body, _styles.disableSelectStyleReset);
          document.removeEventListener("mousemove", this.handleDrag);
          document.removeEventListener("mouseup", this.handleDragEnd);
          document.onselectstart = void 0;
        }
      }, {
        key: "handleDragStart",
        value: function handleDragStart(event) {
          this.dragging = true;
          event.stopImmediatePropagation();
          this.setupDragging();
        }
      }, {
        key: "handleDrag",
        value: function handleDrag(event) {
          if (this.prevPageX) {
            var clientX = event.clientX;
            var _trackHorizontal$getB = this.trackHorizontal.getBoundingClientRect(), trackLeft = _trackHorizontal$getB.left;
            var thumbWidth = this.getThumbHorizontalWidth();
            var clickPosition = thumbWidth - this.prevPageX;
            var offset = -trackLeft + clientX - clickPosition;
            this.view.scrollLeft = this.getScrollLeftForOffset(offset);
          }
          if (this.prevPageY) {
            var clientY = event.clientY;
            var _trackVertical$getBou = this.trackVertical.getBoundingClientRect(), trackTop = _trackVertical$getBou.top;
            var thumbHeight = this.getThumbVerticalHeight();
            var _clickPosition = thumbHeight - this.prevPageY;
            var _offset = -trackTop + clientY - _clickPosition;
            this.view.scrollTop = this.getScrollTopForOffset(_offset);
          }
          return false;
        }
      }, {
        key: "handleDragEnd",
        value: function handleDragEnd() {
          this.dragging = false;
          this.prevPageX = this.prevPageY = 0;
          this.teardownDragging();
          this.handleDragEndAutoHide();
        }
      }, {
        key: "handleDragEndAutoHide",
        value: function handleDragEndAutoHide() {
          var autoHide = this.props.autoHide;
          if (!autoHide) return;
          this.hideTracks();
        }
      }, {
        key: "handleTrackMouseEnter",
        value: function handleTrackMouseEnter() {
          this.trackMouseOver = true;
          this.handleTrackMouseEnterAutoHide();
        }
      }, {
        key: "handleTrackMouseEnterAutoHide",
        value: function handleTrackMouseEnterAutoHide() {
          var autoHide = this.props.autoHide;
          if (!autoHide) return;
          this.showTracks();
        }
      }, {
        key: "handleTrackMouseLeave",
        value: function handleTrackMouseLeave() {
          this.trackMouseOver = false;
          this.handleTrackMouseLeaveAutoHide();
        }
      }, {
        key: "handleTrackMouseLeaveAutoHide",
        value: function handleTrackMouseLeaveAutoHide() {
          var autoHide = this.props.autoHide;
          if (!autoHide) return;
          this.hideTracks();
        }
      }, {
        key: "showTracks",
        value: function showTracks() {
          clearTimeout(this.hideTracksTimeout);
          (0, _domCss2["default"])(this.trackHorizontal, { opacity: 1 });
          (0, _domCss2["default"])(this.trackVertical, { opacity: 1 });
        }
      }, {
        key: "hideTracks",
        value: function hideTracks() {
          var _this3 = this;
          if (this.dragging) return;
          if (this.scrolling) return;
          if (this.trackMouseOver) return;
          var autoHideTimeout = this.props.autoHideTimeout;
          clearTimeout(this.hideTracksTimeout);
          this.hideTracksTimeout = setTimeout(function() {
            (0, _domCss2["default"])(_this3.trackHorizontal, { opacity: 0 });
            (0, _domCss2["default"])(_this3.trackVertical, { opacity: 0 });
          }, autoHideTimeout);
        }
      }, {
        key: "detectScrolling",
        value: function detectScrolling() {
          var _this4 = this;
          if (this.scrolling) return;
          this.scrolling = true;
          this.handleScrollStart();
          this.detectScrollingInterval = setInterval(function() {
            if (_this4.lastViewScrollLeft === _this4.viewScrollLeft && _this4.lastViewScrollTop === _this4.viewScrollTop) {
              clearInterval(_this4.detectScrollingInterval);
              _this4.scrolling = false;
              _this4.handleScrollStop();
            }
            _this4.lastViewScrollLeft = _this4.viewScrollLeft;
            _this4.lastViewScrollTop = _this4.viewScrollTop;
          }, 100);
        }
      }, {
        key: "raf",
        value: function raf2(callback) {
          var _this5 = this;
          if (this.requestFrame) _raf3["default"].cancel(this.requestFrame);
          this.requestFrame = (0, _raf3["default"])(function() {
            _this5.requestFrame = void 0;
            callback();
          });
        }
      }, {
        key: "update",
        value: function update(callback) {
          var _this6 = this;
          this.raf(function() {
            return _this6._update(callback);
          });
        }
      }, {
        key: "_update",
        value: function _update(callback) {
          var _props4 = this.props, onUpdate = _props4.onUpdate, hideTracksWhenNotNeeded = _props4.hideTracksWhenNotNeeded;
          var values2 = this.getValues();
          if ((0, _getScrollbarWidth2["default"])()) {
            var scrollLeft = values2.scrollLeft, clientWidth = values2.clientWidth, scrollWidth = values2.scrollWidth;
            var trackHorizontalWidth = (0, _getInnerWidth2["default"])(this.trackHorizontal);
            var thumbHorizontalWidth = this.getThumbHorizontalWidth();
            var thumbHorizontalX = scrollLeft / (scrollWidth - clientWidth) * (trackHorizontalWidth - thumbHorizontalWidth);
            var thumbHorizontalStyle = {
              width: thumbHorizontalWidth,
              transform: "translateX(" + thumbHorizontalX + "px)"
            };
            var scrollTop = values2.scrollTop, clientHeight = values2.clientHeight, scrollHeight = values2.scrollHeight;
            var trackVerticalHeight = (0, _getInnerHeight2["default"])(this.trackVertical);
            var thumbVerticalHeight = this.getThumbVerticalHeight();
            var thumbVerticalY = scrollTop / (scrollHeight - clientHeight) * (trackVerticalHeight - thumbVerticalHeight);
            var thumbVerticalStyle = {
              height: thumbVerticalHeight,
              transform: "translateY(" + thumbVerticalY + "px)"
            };
            if (hideTracksWhenNotNeeded) {
              var trackHorizontalStyle = {
                visibility: scrollWidth > clientWidth ? "visible" : "hidden"
              };
              var trackVerticalStyle = {
                visibility: scrollHeight > clientHeight ? "visible" : "hidden"
              };
              (0, _domCss2["default"])(this.trackHorizontal, trackHorizontalStyle);
              (0, _domCss2["default"])(this.trackVertical, trackVerticalStyle);
            }
            (0, _domCss2["default"])(this.thumbHorizontal, thumbHorizontalStyle);
            (0, _domCss2["default"])(this.thumbVertical, thumbVerticalStyle);
          }
          if (onUpdate) onUpdate(values2);
          if (typeof callback !== "function") return;
          callback(values2);
        }
      }, {
        key: "render",
        value: function render() {
          var _this7 = this;
          var scrollbarWidth = (0, _getScrollbarWidth2["default"])();
          var _props5 = this.props;
          _props5.onScroll;
          _props5.onScrollFrame;
          _props5.onScrollStart;
          _props5.onScrollStop;
          _props5.onUpdate;
          var renderView = _props5.renderView, renderTrackHorizontal = _props5.renderTrackHorizontal, renderTrackVertical = _props5.renderTrackVertical, renderThumbHorizontal = _props5.renderThumbHorizontal, renderThumbVertical = _props5.renderThumbVertical, tagName = _props5.tagName;
          _props5.hideTracksWhenNotNeeded;
          var autoHide = _props5.autoHide;
          _props5.autoHideTimeout;
          var autoHideDuration = _props5.autoHideDuration;
          _props5.thumbSize;
          _props5.thumbMinSize;
          var universal = _props5.universal, autoHeight = _props5.autoHeight, autoHeightMin = _props5.autoHeightMin, autoHeightMax = _props5.autoHeightMax, style2 = _props5.style, children2 = _props5.children, props = _objectWithoutProperties(_props5, ["onScroll", "onScrollFrame", "onScrollStart", "onScrollStop", "onUpdate", "renderView", "renderTrackHorizontal", "renderTrackVertical", "renderThumbHorizontal", "renderThumbVertical", "tagName", "hideTracksWhenNotNeeded", "autoHide", "autoHideTimeout", "autoHideDuration", "thumbSize", "thumbMinSize", "universal", "autoHeight", "autoHeightMin", "autoHeightMax", "style", "children"]);
          var didMountUniversal = this.state.didMountUniversal;
          var containerStyle = _extends2({}, _styles.containerStyleDefault, autoHeight && _extends2({}, _styles.containerStyleAutoHeight, {
            minHeight: autoHeightMin,
            maxHeight: autoHeightMax
          }), style2);
          var viewStyle = _extends2({}, _styles.viewStyleDefault, {
            // Hide scrollbars by setting a negative margin
            marginRight: scrollbarWidth ? -scrollbarWidth : 0,
            marginBottom: scrollbarWidth ? -scrollbarWidth : 0
          }, autoHeight && _extends2({}, _styles.viewStyleAutoHeight, {
            // Add scrollbarWidth to autoHeight in order to compensate negative margins
            minHeight: (0, _isString2["default"])(autoHeightMin) ? "calc(" + autoHeightMin + " + " + scrollbarWidth + "px)" : autoHeightMin + scrollbarWidth,
            maxHeight: (0, _isString2["default"])(autoHeightMax) ? "calc(" + autoHeightMax + " + " + scrollbarWidth + "px)" : autoHeightMax + scrollbarWidth
          }), autoHeight && universal && !didMountUniversal && {
            minHeight: autoHeightMin,
            maxHeight: autoHeightMax
          }, universal && !didMountUniversal && _styles.viewStyleUniversalInitial);
          var trackAutoHeightStyle = {
            transition: "opacity " + autoHideDuration + "ms",
            opacity: 0
          };
          var trackHorizontalStyle = _extends2({}, _styles.trackHorizontalStyleDefault, autoHide && trackAutoHeightStyle, (!scrollbarWidth || universal && !didMountUniversal) && {
            display: "none"
          });
          var trackVerticalStyle = _extends2({}, _styles.trackVerticalStyleDefault, autoHide && trackAutoHeightStyle, (!scrollbarWidth || universal && !didMountUniversal) && {
            display: "none"
          });
          return (0, _react.createElement)(tagName, _extends2({}, props, { style: containerStyle, ref: function ref(_ref3) {
            _this7.container = _ref3;
          } }), [(0, _react.cloneElement)(renderView({ style: viewStyle }), { key: "view", ref: function ref(_ref4) {
            _this7.view = _ref4;
          } }, children2), (0, _react.cloneElement)(renderTrackHorizontal({ style: trackHorizontalStyle }), { key: "trackHorizontal", ref: function ref(_ref5) {
            _this7.trackHorizontal = _ref5;
          } }, (0, _react.cloneElement)(renderThumbHorizontal({ style: _styles.thumbHorizontalStyleDefault }), { ref: function ref(_ref6) {
            _this7.thumbHorizontal = _ref6;
          } })), (0, _react.cloneElement)(renderTrackVertical({ style: trackVerticalStyle }), { key: "trackVertical", ref: function ref(_ref7) {
            _this7.trackVertical = _ref7;
          } }, (0, _react.cloneElement)(renderThumbVertical({ style: _styles.thumbVerticalStyleDefault }), { ref: function ref(_ref8) {
            _this7.thumbVertical = _ref8;
          } }))]);
        }
      }]);
      return Scrollbars3;
    }(_react.Component);
    exports["default"] = Scrollbars2;
    Scrollbars2.propTypes = {
      onScroll: _propTypes2["default"].func,
      onScrollFrame: _propTypes2["default"].func,
      onScrollStart: _propTypes2["default"].func,
      onScrollStop: _propTypes2["default"].func,
      onUpdate: _propTypes2["default"].func,
      renderView: _propTypes2["default"].func,
      renderTrackHorizontal: _propTypes2["default"].func,
      renderTrackVertical: _propTypes2["default"].func,
      renderThumbHorizontal: _propTypes2["default"].func,
      renderThumbVertical: _propTypes2["default"].func,
      tagName: _propTypes2["default"].string,
      thumbSize: _propTypes2["default"].number,
      thumbMinSize: _propTypes2["default"].number,
      hideTracksWhenNotNeeded: _propTypes2["default"].bool,
      autoHide: _propTypes2["default"].bool,
      autoHideTimeout: _propTypes2["default"].number,
      autoHideDuration: _propTypes2["default"].number,
      autoHeight: _propTypes2["default"].bool,
      autoHeightMin: _propTypes2["default"].oneOfType([_propTypes2["default"].number, _propTypes2["default"].string]),
      autoHeightMax: _propTypes2["default"].oneOfType([_propTypes2["default"].number, _propTypes2["default"].string]),
      universal: _propTypes2["default"].bool,
      style: _propTypes2["default"].object,
      children: _propTypes2["default"].node
    };
    Scrollbars2.defaultProps = {
      renderView: _defaultRenderElements.renderViewDefault,
      renderTrackHorizontal: _defaultRenderElements.renderTrackHorizontalDefault,
      renderTrackVertical: _defaultRenderElements.renderTrackVerticalDefault,
      renderThumbHorizontal: _defaultRenderElements.renderThumbHorizontalDefault,
      renderThumbVertical: _defaultRenderElements.renderThumbVerticalDefault,
      tagName: "div",
      thumbMinSize: 30,
      hideTracksWhenNotNeeded: false,
      autoHide: false,
      autoHideTimeout: 1e3,
      autoHideDuration: 200,
      autoHeight: false,
      autoHeightMin: 0,
      autoHeightMax: 200,
      universal: false
    };
  })(Scrollbars);
  return Scrollbars;
}
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Scrollbars = void 0;
    var _Scrollbars = requireScrollbars();
    var _Scrollbars2 = _interopRequireDefault(_Scrollbars);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    exports["default"] = _Scrollbars2["default"];
    exports.Scrollbars = _Scrollbars2["default"];
  })(lib);
  return lib;
}
var libExports = requireLib();
const SearchIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" }) });
const SearchInput = ({
  disabled = false,
  id: id2,
  label,
  onBlur,
  onChange,
  onFocus,
  placeholder: placeholder2,
  theme = "light",
  value: inputValue
}) => {
  const [focused, setFocused] = reactExports.useState(false);
  const [value, setValue] = reactExports.useState(inputValue);
  reactExports.useEffect(() => {
    if (inputValue !== null) {
      setValue(inputValue);
    }
  }, [inputValue]);
  const _handleFocused = (event) => {
    setFocused(true);
    if (typeof onFocus === "function") {
      onFocus(event, { focused: true });
    }
  };
  const _handleBlurred = (event) => {
    setFocused(false);
    if (typeof onBlur === "function") {
      onBlur(event, { focused: false, value: event.target.value });
    }
  };
  const _handleChanged = (event) => {
    setValue(event.target.value);
    if (typeof onChange === "function") {
      onChange(event, { value: event.target.value });
    }
  };
  const labelWrapper = label && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-input__label", children: label });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "kedro search-input-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames(
        "search-input",
        `search-theme--${theme}`,
        { "search-input--disabled": disabled },
        { "search-input--focused": focused }
      ),
      onFocus: _handleFocused,
      onBlur: _handleBlurred,
      children: [
        labelWrapper,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            className: "search-input__field",
            disabled,
            id: id2,
            onBlur: _handleBlurred,
            onChange: _handleChanged,
            onFocus: _handleFocused,
            placeholder: placeholder2 || "",
            type: "text",
            value: value || ""
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            "aria-hidden": "true",
            className: "search-input__line",
            "data-value": value || ""
          }
        )
      ]
    }
  ) });
};
SearchInput.propTypes = {
  /**
   * Whether the input should be editable or not.
   */
  disabled: PropTypes.bool,
  /**
   * The id attribute for the input element.
   */
  id: PropTypes.string,
  /**
   * Label indicating what should be written in the input.
   */
  label: PropTypes.string,
  /**
   * Event listener which will be triggered on losing focus of the input (in other words, on blur).
   */
  onBlur: PropTypes.func,
  /**
   * Event listener which will be triggered when input will gain focus,
   */
  onFocus: PropTypes.func,
  /**
   * Event listener which will be trigerred on change of the input.
   */
  onChange: PropTypes.func,
  /**
   * Placeholder hint text which is displayed inside the input field and dissapers when something is written inside.
   */
  placeholder: PropTypes.string,
  /**
   * Theme of the input - either 'dark' or 'light'.
   */
  theme: PropTypes.oneOf(["dark", "light"]),
  /**
   * Value to be displayed inside the input field, it is editable and can change if not disabled.
   */
  value: PropTypes.string
};
const SearchBarRenderer = (props) => {
  const {
    children: children2,
    isFocused,
    placeholder: placeholder2,
    onBlur,
    onChange,
    onClear,
    onFocus,
    onSubmit,
    theme,
    showClearButton,
    value
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      className: classnames("kedro", "search-bar", `kui-theme--${theme}`, {
        "search-bar--focused": isFocused
      }),
      onSubmit,
      role: children2 ? "combobox" : "search",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "search-bar__label", htmlFor: "search-bar", children: "Search" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "search-bar__icon-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SearchIcon, { className: "icon icon__graphics" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchInput,
          {
            id: "search-bar",
            placeholder: placeholder2,
            onChange,
            onFocus,
            onBlur,
            value,
            theme,
            type: "search"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "div",
          {
            className: classnames("search-bar__dynamic-icon", {
              "search-bar__dynamic-icon--visible": showClearButton
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: "icon--close",
                onBlur,
                onClick: onClear,
                onFocus,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, { className: "icon icon__graphics" })
              }
            )
          }
        ),
        children2
      ]
    }
  );
};
SearchBarRenderer.propTypes = {
  /**
   * Child component, usually search-bar-results
   */
  children: PropTypes.node,
  /**
   * Indicating whether the search bar is focused or blurred
   */
  isFocused: PropTypes.bool.isRequired,
  /**
   * Place holder text for search input
   */
  placeholder: PropTypes.string.isRequired,
  /**
   * On blur method, triggered by clicking outside the input
   */
  onBlur: PropTypes.func.isRequired,
  /**
   * On change method called after wait time has passed
   */
  onChange: PropTypes.func.isRequired,
  /**
   * On close method, triggered by icon click
   */
  onClear: PropTypes.func.isRequired,
  /**
   * On focus method, triggered by clicking into the input
   */
  onFocus: PropTypes.func.isRequired,
  /**
   * On submit method, triggered by hitting enter on the input
   */
  onSubmit: PropTypes.func,
  /**
   * Theme of the component
   */
  theme: PropTypes.oneOf(["light", "dark"]).isRequired,
  /**
   * Show clear button on right
   */
  showClearButton: PropTypes.bool.isRequired,
  /**
   * Text value for the input
   */
  value: PropTypes.string.isRequired
};
const SearchBar = ({
  children: children2,
  onBlur,
  onChange,
  onClear,
  onFocus,
  onSubmit,
  placeholder: placeholder2 = "Search Here...",
  theme = "dark",
  value: inputValue
}) => {
  const [value, setValue] = reactExports.useState(inputValue);
  const [isFocused, setIsFocused] = reactExports.useState(false);
  const [showClearButton, setShowClearButton] = reactExports.useState(inputValue !== "");
  reactExports.useEffect(() => {
    setValue(inputValue);
    setShowClearButton(inputValue !== "");
  }, [inputValue]);
  const _handleChanged = (e) => {
    setValue(e.target.value);
    setShowClearButton(e.target.value !== "");
    if (typeof onChange === "function") {
      onChange(e.target.value);
    }
  };
  const _handleFocused = (e) => {
    setIsFocused(true);
    if (typeof onFocus === "function") {
      onFocus(e.target.value);
    }
  };
  const _handleBlurred = (e) => {
    setIsFocused(false);
    if (typeof onBlur === "function") {
      onBlur(e.target.value);
    }
  };
  const _handleCleared = (event) => {
    setValue("");
    setShowClearButton(false);
    if (typeof onClear === "function") {
      onClear();
    }
    if (typeof onChange === "function") {
      onChange("");
    }
    event.preventDefault();
  };
  const _handleSubmit = (e) => {
    if (typeof onSubmit === "function") {
      onSubmit({
        e,
        data: value
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SearchBarRenderer,
    {
      onBlur: _handleBlurred,
      isFocused,
      placeholder: placeholder2,
      onChange: _handleChanged,
      onClear: _handleCleared,
      onFocus: _handleFocused,
      onSubmit: _handleSubmit,
      showClearButton,
      value,
      theme,
      children: children2
    }
  );
};
SearchBar.propTypes = {
  /**
   * Child component, usually search-bar-results
   */
  children: PropTypes.node,
  /**
   * On blur method, triggered by clicking outside the input
   */
  onBlur: PropTypes.func,
  /**
   * Subscribe to change events from input field
   */
  onChange: PropTypes.func,
  /**
   * On clear, triggered when clear button is pressed
   */
  onClear: PropTypes.func,
  /**
   * On focus method, triggered by clicking into the input
   */
  onFocus: PropTypes.func,
  /**
   * On submit method, triggered by hitting enter on the input
   */
  onSubmit: PropTypes.func,
  /**
   * Place holder text for search input
   */
  placeholder: PropTypes.string,
  /**
   * Theme of the component
   */
  theme: PropTypes.oneOf(["light", "dark"]).isRequired,
  /**
   * Value of the inner input bar
   */
  value: PropTypes.string
};
const SearchList = ({ onUpdateSearchValue, searchValue, theme }) => {
  const container = reactExports.useRef(null);
  const handleWindowKeyDown = (event) => {
    const isKeyF = event.key === "f" || event.keyCode === 70;
    const isKeyCtrlOrCmd = event.ctrlKey || event.metaKey;
    if (isKeyF && isKeyCtrlOrCmd) {
      const input = container.current.querySelector("input");
      if (document.activeElement !== input) {
        input.focus();
        event.preventDefault();
      } else {
        input.blur();
      }
    }
  };
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleWindowKeyDown);
    return () => window.removeEventListener("keydown", handleWindowKeyDown);
  });
  const handleKeyDown2 = (event) => {
    const isKeyEscape = event.key === "Escape" || event.keyCode === 27;
    if (isKeyEscape) {
      onUpdateSearchValue("");
      container.current.querySelector("input").blur();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      className: "pipeline-search-list",
      onKeyDown: handleKeyDown2,
      ref: container,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SearchBar,
        {
          onChange: onUpdateSearchValue,
          placeholder: "Search",
          theme,
          value: searchValue
        }
      )
    }
  );
};
const mapStateToProps$b = (state) => ({
  theme: state.theme
});
const SearchList$1 = connect(mapStateToProps$b)(SearchList);
const IndicatorIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8.5", y: "9", width: "5", height: "5", rx: "1", strokeWidth: "1.5" }) });
const OffIndicatorIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "8.5", y: "9", width: "5", height: "5", rx: "1", strokeWidth: "1.9" }) });
const ToggleControl = ({
  className,
  focusChecked,
  IconComponent,
  disabled,
  id: id2,
  isChecked,
  kind,
  name,
  onChange,
  onToggleHoveredFocusMode,
  selected,
  dataIconType
}) => {
  const handleMouseHover = (isEntering) => onToggleHoveredFocusMode && onToggleHoveredFocusMode(isEntering);
  const iconClassNames = classnames(
    className,
    "toggle-control--icon",
    `toggle-control--icon--kind-${kind}`,
    {
      "toggle-control--icon--checked": isChecked,
      "toggle-control--icon--unchecked": !isChecked,
      "toggle-control--icon--focus-checked": focusChecked,
      "toggle-control--icon--disabled": disabled
    }
  );
  const labelClassNames = classnames(
    "toggle-control",
    `toggle-control--kind-${kind}`,
    {
      "toggle-control--selected": selected
    }
  );
  const dataTestValue = getDataTestAttribute(
    "toggle-control",
    kind === "focus" ? "focusMode" : "visible",
    name
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "label",
    {
      htmlFor: id2,
      className: labelClassNames,
      onClick: (e) => e.stopPropagation(),
      onMouseEnter: () => handleMouseHover(true),
      onMouseLeave: () => handleMouseHover(false),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "input",
          {
            id: id2,
            className: "toggle-control__checkbox",
            "data-test": dataTestValue,
            type: "checkbox",
            checked: isChecked,
            name,
            onChange,
            "data-icon-type": dataIconType
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          IconComponent,
          {
            "aria-label": name,
            checked: isChecked,
            className: iconClassNames
          }
        )
      ]
    }
  );
};
const RowText = ({
  dataTest,
  disabled,
  faded,
  kind,
  label,
  name,
  onClick,
  onMouseEnter,
  onMouseLeave,
  rowType
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: classnames(
        "row-text",
        `row-text--kind-${kind}`,
        `row-text--${rowType}`,
        {
          "row-text--faded": faded
        }
      ),
      "data-test": getDataTestAttribute(dataTest, label),
      onClick,
      onFocus: onMouseEnter,
      onBlur: onMouseLeave,
      title: name,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "span",
        {
          className: classnames(
            "row-text__label",
            `row-text__label--kind-${kind}`,
            {
              "row-text__label--faded": faded,
              "row-text__label--disabled": disabled
            }
          ),
          dangerouslySetInnerHTML: {
            __html: replaceAngleBracketMatches(label)
          }
        }
      )
    }
  );
};
const FiltersRow = ({
  allUnchecked,
  checked,
  children: children2,
  container: ContainerWrapper,
  count,
  dataTest,
  id: id2,
  indicatorIcon = IndicatorIcon,
  kind,
  label,
  name,
  offIndicatorIcon = OffIndicatorIcon,
  onChange,
  onClick,
  parentClassName,
  visible
}) => {
  const Icon = checked ? indicatorIcon : offIndicatorIcon;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ContainerWrapper,
    {
      className: classnames(
        "filter-row kedro",
        `filter-row--kind-${kind}`,
        parentClassName,
        {
          "filter-row--visible": visible,
          "filter-row--unchecked": !checked
        }
      ),
      title: name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RowText,
          {
            kind,
            dataTest,
            onClick,
            name: children2 ? null : name,
            label
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { onClick, className: "filter-row__count", children: count }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleControl,
          {
            allUnchecked,
            className: "filter-row__icon",
            IconComponent: Icon,
            id: id2,
            isChecked: checked,
            kind,
            name,
            onChange
          }
        ),
        children2
      ]
    }
  );
};
const FiltersSectionHeading = ({
  group,
  collapsed,
  groupItems,
  onGroupToggleChanged,
  onToggleGroupCollapsed
}) => {
  const { id: id2, kind, name, allUnchecked, checked, invisibleIcon, visibleIcon } = group;
  const disabled = groupItems.length === 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "filters-section-heading", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    FiltersRow,
    {
      allUnchecked,
      checked,
      container: "div",
      id: id2,
      offIndicatorIcon: invisibleIcon,
      kind,
      label: name,
      name,
      onChange: (e) => {
        onGroupToggleChanged(id2, !e.target.checked);
      },
      indicatorIcon: visibleIcon,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          "aria-label": `${collapsed ? "Show" : "Hide"} ${name.toLowerCase()}`,
          className: classnames("filters-section-heading__toggle-btn", {
            "filters-section-heading__toggle-btn--alt": collapsed,
            "filters-section-heading__toggle-btn--disabled": disabled
          }),
          disabled,
          onClick: () => onToggleGroupCollapsed(id2)
        }
      )
    }
  ) });
};
const LazyList = ({
  height: height2,
  total,
  children: children2,
  lazy = true,
  dispose = false,
  buffer = 0.5,
  onChange,
  container = (element) => element == null ? void 0 : element.offsetParent
}) => {
  const supported = typeof window.IntersectionObserver !== "undefined";
  const active = lazy && supported;
  const [range2, setRange] = reactExports.useState([0, 0]);
  const rangeRef = reactExports.useRef([0, 0]);
  const listRef = reactExports.useRef();
  const upperRef = reactExports.useRef();
  const lowerRef = reactExports.useRef();
  const itemHeight = reactExports.useMemo(() => height2(0, 1), [height2]);
  const totalHeight = reactExports.useMemo(() => height2(0, total), [height2, total]);
  const upperHeight = reactExports.useMemo(() => height2(0, range2[0]), [height2, range2]);
  const lowerHeight = reactExports.useMemo(
    () => height2(range2[1], total),
    [height2, range2, total]
  );
  const requestUpdate = useRequestFrameOnce(
    // Memoise the frame callback
    reactExports.useCallback(() => {
      const visibleRange = visibleRangeOf(
        // The list container
        listRef.current,
        // The list's scrolling parent container
        container(listRef.current),
        buffer,
        total,
        itemHeight
      );
      const effectiveRange = (
        // If dispose, render visible range only
        dispose ? visibleRange : (
          // If not dispose, expand current range with visible range
          rangeUnion(rangeRef.current, visibleRange)
        )
      );
      if (!rangeEqual(rangeRef.current, effectiveRange)) {
        rangeRef.current = effectiveRange;
        setRange(effectiveRange);
      }
    }, [buffer, total, itemHeight, dispose, container])
  );
  const observerOptions = reactExports.useMemo(
    () => ({
      // Create a threshold point for every item
      threshold: thresholds(total)
    }),
    [total]
  );
  useIntersection(listRef, observerOptions, requestUpdate);
  useIntersection(upperRef, observerOptions, requestUpdate);
  useIntersection(lowerRef, observerOptions, requestUpdate);
  reactExports.useLayoutEffect(
    () => requestUpdate(),
    [total, itemHeight, totalHeight, requestUpdate]
  );
  const childProps = reactExports.useMemo(
    () => ({
      listRef,
      upperRef,
      lowerRef,
      total,
      start: active ? range2[0] : 0,
      end: active ? range2[1] : total,
      listStyle: {
        // Relative for placeholder positioning
        position: "relative",
        // List must always have the correct height
        height: active ? totalHeight : void 0,
        // List must always pad missing items (upper at least)
        paddingTop: active ? upperHeight : void 0
      },
      upperStyle: {
        position: "absolute",
        display: !active ? "none" : void 0,
        height: upperHeight,
        width: "100%",
        // Upper placeholder must always snap to top edge
        top: "0"
      },
      lowerStyle: {
        position: "absolute",
        display: !active ? "none" : void 0,
        height: lowerHeight,
        width: "100%",
        // Lower placeholder must always snap to bottom edge
        bottom: "0"
      }
    }),
    [
      active,
      range2,
      total,
      listRef,
      upperRef,
      lowerRef,
      totalHeight,
      upperHeight,
      lowerHeight
    ]
  );
  onChange && onChange(childProps);
  return children2(childProps);
};
const range = (start2, end, min, max) => [
  Math.max(Math.min(start2, max), min),
  Math.max(Math.min(end, max), min)
];
const rangeUnion = (rangeA, rangeB) => [
  Math.min(rangeA[0], rangeB[0]),
  Math.max(rangeA[1], rangeB[1])
];
const rangeEqual = (rangeA, rangeB) => rangeA[0] === rangeB[0] && rangeA[1] === rangeB[1];
const visibleRangeOf = (element, container, buffer, childTotal, childHeight) => {
  if (!element) {
    return [0, 0];
  }
  if (!container) {
    container = element;
  }
  const clip = container.getBoundingClientRect();
  const list = element.getBoundingClientRect();
  const bufferCount = Math.ceil(buffer * clip.height / childHeight);
  if (clip.bottom < 0 || list.bottom < clip.top) {
    return range(childTotal - bufferCount, childTotal, 0, childTotal);
  }
  const viewport = {
    top: 0,
    bottom: window.innerHeight || document.documentElement.clientHeight
  };
  if (clip.top > viewport.bottom || list.top > clip.bottom) {
    return range(0, bufferCount, 0, childTotal);
  }
  const top = Math.max(clip.top, viewport.top);
  const bottom = Math.min(clip.bottom, viewport.bottom);
  const start2 = Math.floor((top - list.top) / childHeight);
  const end = Math.ceil((bottom - list.top) / childHeight);
  return range(start2 - bufferCount, end + bufferCount, 0, childTotal);
};
const useRequestFrameOnce = (callback) => {
  const request = reactExports.useRef();
  return reactExports.useCallback(() => {
    cancelAnimationFrame(request.current);
    request.current = requestAnimationFrame(callback);
  }, [request, callback]);
};
const thresholds = (total) => total === 0 ? [0] : [...Array.from({ length: total }, (_, i) => i / total), 1];
const useIntersection = (element, options, callback) => {
  const observer = reactExports.useRef();
  return reactExports.useLayoutEffect(() => {
    if (!element.current) {
      return;
    }
    if (observer.current) {
      observer.current.disconnect();
    }
    if (window.IntersectionObserver) {
      observer.current = new window.IntersectionObserver(callback, options);
      observer.current.observe(element.current);
    }
    callback();
  }, [callback, element, options]);
};
const FiltersGroup = ({ items = [], group, collapsed, onItemChange }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  LazyList,
  {
    height: (start2, end) => (end - start2) * nodeListRowHeight,
    total: items.length,
    children: ({ start: start2, end, listRef, listStyle }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "ul",
      {
        ref: listRef,
        style: listStyle,
        className: classnames("filters-group", {
          "filters-group--closed": collapsed
        }),
        children: items.slice(start2, end).map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          FiltersRow,
          {
            allUnchecked: group.allUnchecked,
            checked: item.checked,
            container: "li",
            count: item.count,
            dataTest: getDataTestAttribute("node-list-row", "filter-row"),
            id: item.id,
            offIndicatorIcon: item.invisibleIcon,
            kind: group.kind,
            label: item.highlightedLabel,
            name: item.name,
            onChange: (e) => onItemChange(e, item),
            onClick: (e) => onItemChange(e, item),
            parentClassName: "node-list-filter-row",
            visible: item.visible,
            indicatorIcon: item.visibleIcon
          },
          item.id
        ))
      }
    )
  }
);
const FiltersSection = ({
  group,
  groupCollapsed,
  items,
  onGroupToggleChanged,
  onItemChange,
  onToggleGroupCollapsed,
  searchValue
}) => {
  const { id: id2, allUnchecked } = group;
  const collapsed = Boolean(searchValue) ? false : groupCollapsed[id2];
  const groupItems = items[id2] || [];
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "li",
    {
      className: classnames("filters-section", `filters-section--type-${id2}`, {
        "filters-section--all-unchecked": allUnchecked
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FiltersSectionHeading,
          {
            group,
            collapsed,
            groupItems,
            onGroupToggleChanged,
            onToggleGroupCollapsed
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FiltersGroup,
          {
            collapsed,
            group,
            items: groupItems,
            onItemChange
          }
        )
      ]
    },
    id2
  );
};
const Filters = ({
  groupCollapsed,
  groups,
  isResetFilterActive,
  items,
  onGroupToggleChanged,
  onItemChange,
  onResetFilter,
  onToggleGroupCollapsed,
  searchValue
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filters-wrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "filters__header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "filters__title", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Filters" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          disabled: !isResetFilterActive,
          onClick: onResetFilter,
          className: "filters__reset-button",
          children: "Reset"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: "filters__section-wrapper", children: Object.values(groups).map((group) => {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        FiltersSection,
        {
          group,
          groupCollapsed,
          items,
          onGroupToggleChanged,
          onItemChange,
          onToggleGroupCollapsed,
          searchValue
        },
        group.id
      );
    }) })
  ] });
};
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array2, iteratee) {
    var index = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index < length2) {
      result[index] = iteratee(array2[index], index, array2);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString) return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString) return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId) return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString = requireToString();
  var idCounter = 0;
  function uniqueId2(prefix2) {
    var id2 = ++idCounter;
    return toString(prefix2) + id2;
  }
  uniqueId_1 = uniqueId2;
  return uniqueId_1;
}
var uniqueIdExports = requireUniqueId();
const uniqueId = /* @__PURE__ */ getDefaultExportFromCjs(uniqueIdExports);
function formatMuiErrorMessage$1(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i = 1; i < arguments.length; i += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
const formatMuiErrorMessage = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: formatMuiErrorMessage$1
}, Symbol.toStringTag, { value: "Module" }));
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
  return void 0;
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      var _tag$parentNode;
      return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
function combine(array2, callback) {
  return array2.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children2, length2) {
  return { value, root: root2, parent, type, props, children: children2, line, column, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index, offset, rules, points, type, props, children2, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z = value; x2 < size; ++x2)
      if (z = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k++] = z;
  return node(value, root2, parent, offset === 0 ? RULESET : type, props, children2, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children2, callback) {
  var output = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output += callback(children2[i], i, children2, callback) || "";
  return output;
}
function stringify(element, index, children2, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback)) ? element.return = element.value + "{" + children2 + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children2, callback) {
    var output = "";
    for (var i = 0; i < length2; i++)
      output += collection[i](element, index, children2, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize$1(fn) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      // fallthrough
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent) return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k = 0; i < rules.length; i++) {
    for (var j = 0; j < parentRules.length; j++, k++) {
      element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // flex, flex-direction
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (charat(value, length2 + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
        // (s)tretch
        case 115:
          return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
      }
      break;
    // position: sticky
    case 4949:
      if (charat(value, length2 + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        // stic(k)y
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        // (inline-)?fl(e)x
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children2, callback) {
  if (element.length > -1) {
    if (!element["return"]) switch (element.type) {
      case DECLARATION:
        element["return"] = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback);
      case RULESET:
        if (element.length) return combine(element.props, function(value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return serialize([copy(element, {
                props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
              })], callback);
            // :placeholder
            case "::placeholder":
              return serialize([copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
              }), copy(element, {
                props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
              })], callback);
          }
          return "";
        });
    }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector2, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector2 ? selector2 + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
  registerStyles(cache, serialized, isStringTag2);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h ^= str.charCodeAt(i) & 255;
      h = /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  }
  h ^= h >>> 13;
  h = /* Math.imul(h, m): */
  (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
  return ((h ^ h >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  var componentSelector = interpolation;
  if (componentSelector.__emotion_styles !== void 0) {
    return componentSelector;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      var keyframes2 = interpolation;
      if (keyframes2.anim === 1) {
        cursor = {
          name: keyframes2.name,
          styles: keyframes2.styles,
          next: cursor
        };
        return keyframes2.name;
      }
      var serializedStyles = interpolation;
      if (serializedStyles.styles !== void 0) {
        var next2 = serializedStyles.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = serializedStyles.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  var asString = interpolation;
  if (registered == null) {
    return asString;
  }
  var cached = registered[asString];
  return cached !== void 0 ? cached : asString;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var key in obj) {
      var value = obj[key];
      if (typeof value !== "object") {
        var asString = value;
        if (registered != null && registered[asString] !== void 0) {
          string += key + "{" + registered[asString] + "}";
        } else if (isProcessableValue(asString)) {
          string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
        }
      } else {
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (key) {
            case "animation":
            case "animationName": {
              string += processStyleName(key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
var cursor;
function serializeStyles(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    var asTemplateStringsArr = strings;
    styles2 += asTemplateStringsArr[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      var templateStringsArr = strings;
      styles2 += templateStringsArr[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
var CacheProvider = EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && true) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion$1, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag2);
  });
  return null;
};
var createStyled$3 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as") continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion2, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled = createStyled(nextTag, _extends$2({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var styled$3 = createStyled$3.bind(null);
tags.forEach(function(tagName) {
  styled$3[tagName] = styled$3(tagName);
});
function getCache(injectFirst, enableCssLayer) {
  const emotionCache = createCache({
    key: "css",
    prepend: injectFirst
  });
  if (enableCssLayer) {
    const prevInsert = emotionCache.insert;
    emotionCache.insert = (...args) => {
      if (!args[1].styles.match(/^@layer\s+[^{]*$/)) {
        args[1].styles = `@layer mui {${args[1].styles}}`;
      }
      return prevInsert(...args);
    };
  }
  return emotionCache;
}
const cacheMap = /* @__PURE__ */ new Map();
function StyledEngineProvider(props) {
  const {
    injectFirst,
    enableCssLayer,
    children: children2
  } = props;
  const cache = reactExports.useMemo(() => {
    const cacheKey = `${injectFirst}-${enableCssLayer}`;
    if (typeof document === "object" && cacheMap.has(cacheKey)) {
      return cacheMap.get(cacheKey);
    }
    const fresh = getCache(injectFirst, enableCssLayer);
    cacheMap.set(cacheKey, fresh);
    return fresh;
  }, [injectFirst, enableCssLayer]);
  if (injectFirst || enableCssLayer) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CacheProvider, {
      value: cache,
      children: children2
    });
  }
  return children2;
}
function isEmpty$1(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$1(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
function styled$2(tag, options) {
  const stylesFactory = styled$3(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
const wrapper = [];
function internal_serializeStyles(styles2) {
  wrapper[0] = styles2;
  return serializeStyles(wrapper);
}
const styledEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  GlobalStyles,
  StyledEngineProvider,
  ThemeContext,
  css,
  default: styled$2,
  internal_processStyles,
  internal_serializeStyles,
  keyframes
}, Symbol.toStringTag, { value: "Module" }));
function isPlainObject(item) {
  if (typeof item !== "object" || item === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(item);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
}
function deepClone(source) {
  if (/* @__PURE__ */ reactExports.isValidElement(source) || !isPlainObject(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge$1(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$2({}, target) : target;
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (/* @__PURE__ */ reactExports.isValidElement(source[key])) {
        output[key] = source[key];
      } else if (isPlainObject(source[key]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
        output[key] = deepmerge$1(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
const deepmerge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: deepmerge$1,
  isPlainObject
}, Symbol.toStringTag, { value: "Module" }));
const _excluded$d = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$2({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints, other = _objectWithoutPropertiesLoose(breakpoints, _excluded$d);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start2, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start2] === "number" ? values2[start2] : start2}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$2({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
function merge(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge$1(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function capitalize$1(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage$1(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
const capitalize = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: capitalize$1
}, Symbol.toStringTag, { value: "Module" }));
function getPath(obj, path2, checkVars = true) {
  if (!path2 || typeof path2 !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path2}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path2.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue(themeMapping, transform2, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform2) {
    value = transform2(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform: transform2
  } = options;
  const fn = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn.propTypes = {};
  fn.filterProps = [prop];
  return fn;
}
function memoize(fn) {
  const cache = {};
  return (arg) => {
    if (cache[arg] === void 0) {
      cache[arg] = fn(arg);
    }
    return cache[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a, b] = prop.split("");
  const property = properties[a];
  const direction = directions[b] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform2 = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform2(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn.propTypes = {};
  fn.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
function createBorderStyle(prop, transform2) {
  return style$1({
    prop,
    themeKey: "borders",
    transform: transform2
  });
}
const border = createBorderStyle("border", borderTransform);
const borderTop = createBorderStyle("borderTop", borderTransform);
const borderRight = createBorderStyle("borderRight", borderTransform);
const borderBottom = createBorderStyle("borderBottom", borderTransform);
const borderLeft = createBorderStyle("borderLeft", borderTransform);
const borderColor = createBorderStyle("borderColor");
const borderTopColor = createBorderStyle("borderTopColor");
const borderRightColor = createBorderStyle("borderRightColor");
const borderBottomColor = createBorderStyle("borderBottomColor");
const borderLeftColor = createBorderStyle("borderLeftColor");
const outline = createBorderStyle("outline", borderTransform);
const outlineColor = createBorderStyle("outlineColor");
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: borderTransform
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object2) => keys.concat(Object.keys(object2)), []);
  const union = new Set(allKeys);
  return objects.every((object2) => union.size === Object.keys(object2).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform: transform2,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue(themeMapping, transform2, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue(themeMapping, transform2, `${prop}${propValueFinal === "default" ? "" : capitalize$1(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {},
      nested
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme,
                  nested: true
                });
              } else {
                css2 = merge(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      if (!nested && theme.modularCssLayers) {
        return {
          "@layer sx": removeUnusedBreakpoints(breakpointsKeys, css2)
        };
      }
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx();
styleFunctionSx$1.filterProps = ["sx"];
function applyStyles(key, styles2) {
  const theme = this;
  if (theme.vars && typeof theme.getColorSchemeSelector === "function") {
    const selector2 = theme.getColorSchemeSelector(key).replace(/(\[[^\]]+\])/, "*:where($1)");
    return {
      [selector2]: styles2
    };
  }
  if (theme.palette.mode === key) {
    return styles2;
  }
  return {};
}
const _excluded$c = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$2(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$c);
  const breakpoints = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge$1({
    breakpoints,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$2({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$2({}, shape, shapeInput)
  }, other);
  muiTheme.applyStyles = applyStyles;
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$2({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const createTheme$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: createTheme$2,
  private_createBreakpoints: createBreakpoints,
  unstable_applyStyles: applyStyles
}, Symbol.toStringTag, { value: "Module" }));
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$2();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
const _excluded$b = ["sx"];
const splitProps = (props) => {
  var _props$theme$unstable, _props$theme;
  const result = {
    systemProps: {},
    otherProps: {}
  };
  const config2 = (_props$theme$unstable = props == null || (_props$theme = props.theme) == null ? void 0 : _props$theme.unstable_sxConfig) != null ? _props$theme$unstable : defaultSxConfig;
  Object.keys(props).forEach((prop) => {
    if (config2[prop]) {
      result.systemProps[prop] = props[prop];
    } else {
      result.otherProps[prop] = props[prop];
    }
  });
  return result;
};
function extendSxProp(props) {
  const {
    sx: inSx
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const {
    systemProps,
    otherProps
  } = splitProps(other);
  let finalSx;
  if (Array.isArray(inSx)) {
    finalSx = [systemProps, ...inSx];
  } else if (typeof inSx === "function") {
    finalSx = (...args) => {
      const result = inSx(...args);
      if (!isPlainObject(result)) {
        return systemProps;
      }
      return _extends$2({}, systemProps, result);
    };
  } else {
    finalSx = _extends$2({}, systemProps, inSx);
  }
  return _extends$2({}, otherProps, {
    sx: finalSx
  });
}
const styleFunctionSx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: styleFunctionSx$1,
  extendSxProp,
  unstable_createStyleFunctionSx,
  unstable_defaultSxConfig: defaultSxConfig
}, Symbol.toStringTag, { value: "Module" }));
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
const globalStateClasses = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClasses[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
var reactIs = { exports: {} };
var reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production;
function requireReactIs_production() {
  if (hasRequiredReactIs_production) return reactIs_production;
  hasRequiredReactIs_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function typeOf(object2) {
    if ("object" === typeof object2 && null !== object2) {
      var $$typeof = object2.$$typeof;
      switch ($$typeof) {
        case REACT_ELEMENT_TYPE:
          switch (object2 = object2.type, object2) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
            case REACT_VIEW_TRANSITION_TYPE:
              return object2;
            default:
              switch (object2 = object2 && object2.$$typeof, object2) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                  return object2;
                case REACT_CONSUMER_TYPE:
                  return object2;
                default:
                  return $$typeof;
              }
          }
        case REACT_PORTAL_TYPE:
          return $$typeof;
      }
    }
  }
  reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
  reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
  reactIs_production.Element = REACT_ELEMENT_TYPE;
  reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
  reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
  reactIs_production.Lazy = REACT_LAZY_TYPE;
  reactIs_production.Memo = REACT_MEMO_TYPE;
  reactIs_production.Portal = REACT_PORTAL_TYPE;
  reactIs_production.Profiler = REACT_PROFILER_TYPE;
  reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
  reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
  reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
  reactIs_production.isContextConsumer = function(object2) {
    return typeOf(object2) === REACT_CONSUMER_TYPE;
  };
  reactIs_production.isContextProvider = function(object2) {
    return typeOf(object2) === REACT_CONTEXT_TYPE;
  };
  reactIs_production.isElement = function(object2) {
    return "object" === typeof object2 && null !== object2 && object2.$$typeof === REACT_ELEMENT_TYPE;
  };
  reactIs_production.isForwardRef = function(object2) {
    return typeOf(object2) === REACT_FORWARD_REF_TYPE;
  };
  reactIs_production.isFragment = function(object2) {
    return typeOf(object2) === REACT_FRAGMENT_TYPE;
  };
  reactIs_production.isLazy = function(object2) {
    return typeOf(object2) === REACT_LAZY_TYPE;
  };
  reactIs_production.isMemo = function(object2) {
    return typeOf(object2) === REACT_MEMO_TYPE;
  };
  reactIs_production.isPortal = function(object2) {
    return typeOf(object2) === REACT_PORTAL_TYPE;
  };
  reactIs_production.isProfiler = function(object2) {
    return typeOf(object2) === REACT_PROFILER_TYPE;
  };
  reactIs_production.isStrictMode = function(object2) {
    return typeOf(object2) === REACT_STRICT_MODE_TYPE;
  };
  reactIs_production.isSuspense = function(object2) {
    return typeOf(object2) === REACT_SUSPENSE_TYPE;
  };
  reactIs_production.isSuspenseList = function(object2) {
    return typeOf(object2) === REACT_SUSPENSE_LIST_TYPE;
  };
  reactIs_production.isValidElementType = function(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
  };
  reactIs_production.typeOf = typeOf;
  return reactIs_production;
}
var hasRequiredReactIs;
function requireReactIs() {
  if (hasRequiredReactIs) return reactIs.exports;
  hasRequiredReactIs = 1;
  {
    reactIs.exports = /* @__PURE__ */ requireReactIs_production();
  }
  return reactIs.exports;
}
var reactIsExports = /* @__PURE__ */ requireReactIs();
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function getFunctionName(fn) {
  const match2 = `${fn}`.match(fnNameMatchRegex);
  const name = match2 && match2[1];
  return name || "";
}
function getFunctionComponentName(Component, fallback = "") {
  return Component.displayName || Component.name || getFunctionName(Component) || fallback;
}
function getWrappedName(outerType, innerType, wrapperName) {
  const functionName = getFunctionComponentName(innerType);
  return outerType.displayName || (functionName !== "" ? `${wrapperName}(${functionName})` : wrapperName);
}
function getDisplayName$1(Component) {
  if (Component == null) {
    return void 0;
  }
  if (typeof Component === "string") {
    return Component;
  }
  if (typeof Component === "function") {
    return getFunctionComponentName(Component, "Component");
  }
  if (typeof Component === "object") {
    switch (Component.$$typeof) {
      case reactIsExports.ForwardRef:
        return getWrappedName(Component, Component.render, "ForwardRef");
      case reactIsExports.Memo:
        return getWrappedName(Component, Component.type, "memo");
      default:
        return void 0;
    }
  }
  return void 0;
}
const getDisplayName = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: getDisplayName$1,
  getFunctionName
}, Symbol.toStringTag, { value: "Module" }));
const _excluded$a = ["ownerState"], _excluded2 = ["variants"], _excluded3 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
function shallowLayer(serialized, layerName) {
  if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
    serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
  }
  return serialized;
}
const systemDefaultTheme = createTheme$2();
const lowercaseFirstLetter = (string) => {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme,
  themeId
}) {
  return isEmpty(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
function processStyleArg(callableStyle, _ref, layerName) {
  let {
    ownerState
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded$a);
  const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle(_extends$2({
    ownerState
  }, props)) : callableStyle;
  if (Array.isArray(resolvedStylesArg)) {
    return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg(resolvedStyle, _extends$2({
      ownerState
    }, props), layerName));
  }
  if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
    const {
      variants = []
    } = resolvedStylesArg, otherStyles = _objectWithoutPropertiesLoose(resolvedStylesArg, _excluded2);
    let result = otherStyles;
    variants.forEach((variant) => {
      let isMatch = true;
      if (typeof variant.props === "function") {
        isMatch = variant.props(_extends$2({
          ownerState
        }, props, ownerState));
      } else {
        Object.keys(variant.props).forEach((key) => {
          if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
            isMatch = false;
          }
        });
      }
      if (isMatch) {
        if (!Array.isArray(result)) {
          result = [result];
        }
        const variantStyle = typeof variant.style === "function" ? variant.style(_extends$2({
          ownerState
        }, props, ownerState)) : variant.style;
        result.push(layerName ? shallowLayer(internal_serializeStyles(variantStyle), layerName) : variantStyle);
      }
    });
    return result;
  }
  return layerName ? shallowLayer(internal_serializeStyles(resolvedStylesArg), layerName) : resolvedStylesArg;
}
function createStyled$2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx$1(_extends$2({}, props, {
      theme: resolveTheme(_extends$2({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded3);
    const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, _extends$2({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const transformStyleArg = (stylesArg) => {
      if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || isPlainObject(stylesArg)) {
        return (props) => {
          const theme = resolveTheme({
            theme: props.theme,
            defaultTheme: defaultTheme2,
            themeId
          });
          return processStyleArg(stylesArg, _extends$2({}, props, {
            theme
          }), theme.modularCssLayers ? layerName : void 0);
        };
      }
      return stylesArg;
    };
    const muiStyledResolver = (styleArg, ...expressions) => {
      let transformedStyleArg = transformStyleArg(styleArg);
      const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
      if (componentName && overridesResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends$2({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
            return null;
          }
          const styleOverrides = theme.components[componentName].styleOverrides;
          const resolvedStyleOverrides = {};
          Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
            resolvedStyleOverrides[slotKey] = processStyleArg(slotStyle, _extends$2({}, props, {
              theme
            }), theme.modularCssLayers ? "theme" : void 0);
          });
          return overridesResolver(props, resolvedStyleOverrides);
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          var _theme$components;
          const theme = resolveTheme(_extends$2({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
          return processStyleArg({
            variants: themeVariants
          }, _extends$2({}, props, {
            theme
          }), theme.modularCssLayers ? "theme" : void 0);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
const styled$1 = createStyled$2();
function resolveProps(defaultProps, props) {
  const output = _extends$2({}, props);
  Object.keys(defaultProps).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends$2({}, defaultProps[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends$2({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps[propName];
    }
  });
  return output;
}
function getThemeProps$1(params2) {
  const {
    theme,
    name,
    props
  } = params2;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  {
    theme = theme[themeId] || theme;
  }
  const mergedProps = getThemeProps$1({
    theme,
    name,
    props
  });
  return mergedProps;
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function clamp$1(val, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER) {
  return Math.max(min, Math.min(val, max));
}
const clamp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: clamp$1
}, Symbol.toStringTag, { value: "Module" }));
function clampWrapper(value, min = 0, max = 1) {
  return clamp$1(value, min, max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n) => n + n);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage$1(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage$1(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clampWrapper(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce(func, wait = 166) {
  let timeout2;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout2);
  };
  return debounced;
}
function deprecatedPropType(validator, reason) {
  {
    return () => null;
  }
}
function isMuiElement(element, muiNames) {
  var _muiName, _element$type;
  return /* @__PURE__ */ reactExports.isValidElement(element) && muiNames.indexOf(
    // For server components `muiName` is avaialble in element.type._payload.value.muiName
    // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
    // eslint-disable-next-line no-underscore-dangle
    (_muiName = element.type.muiName) != null ? _muiName : (_element$type = element.type) == null || (_element$type = _element$type._payload) == null || (_element$type = _element$type.value) == null ? void 0 : _element$type.muiName
  ) !== -1;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function requirePropFactory(componentNameInError, Component) {
  {
    return () => null;
  }
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function unsupportedProp(props, propName, componentName, location, propFullName) {
  {
    return null;
  }
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn) {
  const ref = reactExports.useRef(fn);
  useEnhancedEffect(() => {
    ref.current = fn;
  });
  return reactExports.useRef((...args) => (
    // @ts-expect-error hide `this`
    (0, ref.current)(...args)
  )).current;
}
function useForkRef$1(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
const UNINITIALIZED = {};
function useLazyRef(init2, initArg) {
  const ref = reactExports.useRef(UNINITIALIZED);
  if (ref.current === UNINITIALIZED) {
    ref.current = init2(initArg);
  }
  return ref;
}
const EMPTY = [];
function useOnMount(fn) {
  reactExports.useEffect(fn, EMPTY);
}
class Timeout {
  constructor() {
    this.currentId = null;
    this.clear = () => {
      if (this.currentId !== null) {
        clearTimeout(this.currentId);
        this.currentId = null;
      }
    };
    this.disposeEffect = () => {
      return this.clear;
    };
  }
  static create() {
    return new Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = null;
      fn();
    }, delay);
  }
}
function useTimeout() {
  const timeout2 = useLazyRef(Timeout.create).current;
  useOnMount(timeout2.disposeEffect);
  return timeout2;
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
const hadFocusVisibleRecentlyTimeout = new Timeout();
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      hadFocusVisibleRecentlyTimeout.start(100, () => {
        hadFocusVisibleRecently = false;
      });
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function composeClasses$1(slots, getUtilityClass, classes = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const PropsContext = /* @__PURE__ */ reactExports.createContext(void 0);
function getThemeProps(params2) {
  const {
    theme,
    name,
    props
  } = params2;
  if (!theme || !theme.components || !theme.components[name]) {
    return props;
  }
  const config2 = theme.components[name];
  if (config2.defaultProps) {
    return resolveProps(config2.defaultProps, props);
  }
  if (!config2.styleOverrides && !config2.variants) {
    return resolveProps(config2, props);
  }
  return props;
}
function useDefaultProps$1({
  props,
  name
}) {
  const ctx = reactExports.useContext(PropsContext);
  return getThemeProps({
    props,
    name,
    theme: {
      components: ctx
    }
  });
}
var createStyled$1 = {};
var interopRequireDefault = { exports: {} };
var hasRequiredInteropRequireDefault;
function requireInteropRequireDefault() {
  if (hasRequiredInteropRequireDefault) return interopRequireDefault.exports;
  hasRequiredInteropRequireDefault = 1;
  (function(module) {
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : {
        "default": e
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(interopRequireDefault);
  return interopRequireDefault.exports;
}
var _extends = { exports: {} };
var hasRequired_extends;
function require_extends() {
  if (hasRequired_extends) return _extends.exports;
  hasRequired_extends = 1;
  (function(module) {
    function _extends2() {
      return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
        }
        return n;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
    }
    module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_extends);
  return _extends.exports;
}
var objectWithoutPropertiesLoose = { exports: {} };
var hasRequiredObjectWithoutPropertiesLoose;
function requireObjectWithoutPropertiesLoose() {
  if (hasRequiredObjectWithoutPropertiesLoose) return objectWithoutPropertiesLoose.exports;
  hasRequiredObjectWithoutPropertiesLoose = 1;
  (function(module) {
    function _objectWithoutPropertiesLoose2(r2, e) {
      if (null == r2) return {};
      var t = {};
      for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r2[n];
      }
      return t;
    }
    module.exports = _objectWithoutPropertiesLoose2, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(objectWithoutPropertiesLoose);
  return objectWithoutPropertiesLoose.exports;
}
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(styledEngine);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(deepmerge);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(capitalize);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(getDisplayName);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(createTheme$1);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(styleFunctionSx);
var hasRequiredCreateStyled;
function requireCreateStyled() {
  if (hasRequiredCreateStyled) return createStyled$1;
  hasRequiredCreateStyled = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(createStyled$1, "__esModule", {
    value: true
  });
  createStyled$1.default = createStyled3;
  createStyled$1.shouldForwardProp = shouldForwardProp2;
  createStyled$1.systemDefaultTheme = void 0;
  var _extends2 = _interopRequireDefault(require_extends());
  var _objectWithoutPropertiesLoose2 = _interopRequireDefault(requireObjectWithoutPropertiesLoose());
  var _styledEngine = _interopRequireWildcard(require$$3);
  var _deepmerge = require$$4;
  _interopRequireDefault(require$$5);
  _interopRequireDefault(require$$6);
  var _createTheme = _interopRequireDefault(require$$7);
  var _styleFunctionSx = _interopRequireDefault(require$$8);
  const _excluded4 = ["ownerState"], _excluded22 = ["variants"], _excluded32 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
  function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r2 = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
    return (_getRequireWildcardCache = function(e2) {
      return e2 ? t : r2;
    })(e);
  }
  function _interopRequireWildcard(e, r2) {
    if (e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
    var t = _getRequireWildcardCache(r2);
    if (t && t.has(e)) return t.get(e);
    var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
      var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
  }
  function isEmpty2(obj) {
    return Object.keys(obj).length === 0;
  }
  function isStringTag2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96;
  }
  function shouldForwardProp2(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  function shallowLayer2(serialized, layerName) {
    if (layerName && serialized && typeof serialized === "object" && serialized.styles && !serialized.styles.startsWith("@layer")) {
      serialized.styles = `@layer ${layerName}{${String(serialized.styles)}}`;
    }
    return serialized;
  }
  const systemDefaultTheme2 = createStyled$1.systemDefaultTheme = (0, _createTheme.default)();
  const lowercaseFirstLetter2 = (string) => {
    if (!string) {
      return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
  };
  function resolveTheme2({
    defaultTheme: defaultTheme2,
    theme,
    themeId
  }) {
    return isEmpty2(theme) ? defaultTheme2 : theme[themeId] || theme;
  }
  function defaultOverridesResolver2(slot) {
    if (!slot) {
      return null;
    }
    return (props, styles2) => styles2[slot];
  }
  function processStyleArg2(callableStyle, _ref, layerName) {
    let {
      ownerState
    } = _ref, props = (0, _objectWithoutPropertiesLoose2.default)(_ref, _excluded4);
    const resolvedStylesArg = typeof callableStyle === "function" ? callableStyle((0, _extends2.default)({
      ownerState
    }, props)) : callableStyle;
    if (Array.isArray(resolvedStylesArg)) {
      return resolvedStylesArg.flatMap((resolvedStyle) => processStyleArg2(resolvedStyle, (0, _extends2.default)({
        ownerState
      }, props), layerName));
    }
    if (!!resolvedStylesArg && typeof resolvedStylesArg === "object" && Array.isArray(resolvedStylesArg.variants)) {
      const {
        variants = []
      } = resolvedStylesArg, otherStyles = (0, _objectWithoutPropertiesLoose2.default)(resolvedStylesArg, _excluded22);
      let result = otherStyles;
      variants.forEach((variant) => {
        let isMatch = true;
        if (typeof variant.props === "function") {
          isMatch = variant.props((0, _extends2.default)({
            ownerState
          }, props, ownerState));
        } else {
          Object.keys(variant.props).forEach((key) => {
            if ((ownerState == null ? void 0 : ownerState[key]) !== variant.props[key] && props[key] !== variant.props[key]) {
              isMatch = false;
            }
          });
        }
        if (isMatch) {
          if (!Array.isArray(result)) {
            result = [result];
          }
          const variantStyle = typeof variant.style === "function" ? variant.style((0, _extends2.default)({
            ownerState
          }, props, ownerState)) : variant.style;
          result.push(layerName ? shallowLayer2((0, _styledEngine.internal_serializeStyles)(variantStyle), layerName) : variantStyle);
        }
      });
      return result;
    }
    return layerName ? shallowLayer2((0, _styledEngine.internal_serializeStyles)(resolvedStylesArg), layerName) : resolvedStylesArg;
  }
  function createStyled3(input = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme2 = systemDefaultTheme2,
      rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp2,
      slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp2
    } = input;
    const systemSx = (props) => {
      return (0, _styleFunctionSx.default)((0, _extends2.default)({}, props, {
        theme: resolveTheme2((0, _extends2.default)({}, props, {
          defaultTheme: defaultTheme2,
          themeId
        }))
      }));
    };
    systemSx.__mui_systemSx = true;
    return (tag, inputOptions = {}) => {
      (0, _styledEngine.internal_processStyles)(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
      const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver = defaultOverridesResolver2(lowercaseFirstLetter2(componentSlot))
      } = inputOptions, options = (0, _objectWithoutPropertiesLoose2.default)(inputOptions, _excluded32);
      const layerName = componentName && componentName.startsWith("Mui") || !!componentSlot ? "components" : "custom";
      const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
      );
      const skipSx = inputSkipSx || false;
      let label;
      let shouldForwardPropOption = shouldForwardProp2;
      if (componentSlot === "Root" || componentSlot === "root") {
        shouldForwardPropOption = rootShouldForwardProp2;
      } else if (componentSlot) {
        shouldForwardPropOption = slotShouldForwardProp2;
      } else if (isStringTag2(tag)) {
        shouldForwardPropOption = void 0;
      }
      const defaultStyledResolver = (0, _styledEngine.default)(tag, (0, _extends2.default)({
        shouldForwardProp: shouldForwardPropOption,
        label
      }, options));
      const transformStyleArg = (stylesArg) => {
        if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg || (0, _deepmerge.isPlainObject)(stylesArg)) {
          return (props) => {
            const theme = resolveTheme2({
              theme: props.theme,
              defaultTheme: defaultTheme2,
              themeId
            });
            return processStyleArg2(stylesArg, (0, _extends2.default)({}, props, {
              theme
            }), theme.modularCssLayers ? layerName : void 0);
          };
        }
        return stylesArg;
      };
      const muiStyledResolver = (styleArg, ...expressions) => {
        let transformedStyleArg = transformStyleArg(styleArg);
        const expressionsWithDefaultTheme = expressions ? expressions.map(transformStyleArg) : [];
        if (componentName && overridesResolver) {
          expressionsWithDefaultTheme.push((props) => {
            const theme = resolveTheme2((0, _extends2.default)({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            if (!theme.components || !theme.components[componentName] || !theme.components[componentName].styleOverrides) {
              return null;
            }
            const styleOverrides = theme.components[componentName].styleOverrides;
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = processStyleArg2(slotStyle, (0, _extends2.default)({}, props, {
                theme
              }), theme.modularCssLayers ? "theme" : void 0);
            });
            return overridesResolver(props, resolvedStyleOverrides);
          });
        }
        if (componentName && !skipVariantsResolver) {
          expressionsWithDefaultTheme.push((props) => {
            var _theme$components;
            const theme = resolveTheme2((0, _extends2.default)({}, props, {
              defaultTheme: defaultTheme2,
              themeId
            }));
            const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[componentName]) == null ? void 0 : _theme$components.variants;
            return processStyleArg2({
              variants: themeVariants
            }, (0, _extends2.default)({}, props, {
              theme
            }), theme.modularCssLayers ? "theme" : void 0);
          });
        }
        if (!skipSx) {
          expressionsWithDefaultTheme.push(systemSx);
        }
        const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
        if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
          const placeholders = new Array(numOfCustomFnsApplied).fill("");
          transformedStyleArg = [...styleArg, ...placeholders];
          transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
        }
        const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
        if (tag.muiName) {
          Component.muiName = tag.muiName;
        }
        return Component;
      };
      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }
      return muiStyledResolver;
    };
  }
  return createStyled$1;
}
var createStyledExports = /* @__PURE__ */ requireCreateStyled();
const createStyled2 = /* @__PURE__ */ getDefaultExportFromCjs(createStyledExports);
function createMixins(breakpoints, mixins) {
  return _extends$2({
    toolbar: {
      minHeight: 56,
      [breakpoints.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
var colorManipulator = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(formatMuiErrorMessage);
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(clamp);
var hasRequiredColorManipulator;
function requireColorManipulator() {
  if (hasRequiredColorManipulator) return colorManipulator;
  hasRequiredColorManipulator = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(colorManipulator, "__esModule", {
    value: true
  });
  colorManipulator.alpha = alpha2;
  colorManipulator.blend = blend;
  colorManipulator.colorChannel = void 0;
  colorManipulator.darken = darken;
  colorManipulator.decomposeColor = decomposeColor2;
  colorManipulator.emphasize = emphasize;
  colorManipulator.getContrastRatio = getContrastRatio;
  colorManipulator.getLuminance = getLuminance;
  colorManipulator.hexToRgb = hexToRgb2;
  colorManipulator.hslToRgb = hslToRgb;
  colorManipulator.lighten = lighten;
  colorManipulator.private_safeAlpha = private_safeAlpha;
  colorManipulator.private_safeColorChannel = void 0;
  colorManipulator.private_safeDarken = private_safeDarken;
  colorManipulator.private_safeEmphasize = private_safeEmphasize;
  colorManipulator.private_safeLighten = private_safeLighten;
  colorManipulator.recomposeColor = recomposeColor2;
  colorManipulator.rgbToHex = rgbToHex;
  var _formatMuiErrorMessage2 = _interopRequireDefault(require$$1);
  var _clamp = _interopRequireDefault(require$$2);
  function clampWrapper2(value, min = 0, max = 1) {
    return (0, _clamp.default)(value, min, max);
  }
  function hexToRgb2(color2) {
    color2 = color2.slice(1);
    const re = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
    let colors = color2.match(re);
    if (colors && colors[0].length === 1) {
      colors = colors.map((n) => n + n);
    }
    return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n, index) => {
      return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
    }).join(", ")})` : "";
  }
  function intToHex(int) {
    const hex2 = int.toString(16);
    return hex2.length === 1 ? `0${hex2}` : hex2;
  }
  function decomposeColor2(color2) {
    if (color2.type) {
      return color2;
    }
    if (color2.charAt(0) === "#") {
      return decomposeColor2(hexToRgb2(color2));
    }
    const marker = color2.indexOf("(");
    const type = color2.substring(0, marker);
    if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
      throw new Error((0, _formatMuiErrorMessage2.default)(9, color2));
    }
    let values2 = color2.substring(marker + 1, color2.length - 1);
    let colorSpace;
    if (type === "color") {
      values2 = values2.split(" ");
      colorSpace = values2.shift();
      if (values2.length === 4 && values2[3].charAt(0) === "/") {
        values2[3] = values2[3].slice(1);
      }
      if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
        throw new Error((0, _formatMuiErrorMessage2.default)(10, colorSpace));
      }
    } else {
      values2 = values2.split(",");
    }
    values2 = values2.map((value) => parseFloat(value));
    return {
      type,
      values: values2,
      colorSpace
    };
  }
  const colorChannel = (color2) => {
    const decomposedColor = decomposeColor2(color2);
    return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.indexOf("hsl") !== -1 && idx !== 0 ? `${val}%` : val).join(" ");
  };
  colorManipulator.colorChannel = colorChannel;
  const private_safeColorChannel = (color2, warning) => {
    try {
      return colorChannel(color2);
    } catch (error) {
      return color2;
    }
  };
  colorManipulator.private_safeColorChannel = private_safeColorChannel;
  function recomposeColor2(color2) {
    const {
      type,
      colorSpace
    } = color2;
    let {
      values: values2
    } = color2;
    if (type.indexOf("rgb") !== -1) {
      values2 = values2.map((n, i) => i < 3 ? parseInt(n, 10) : n);
    } else if (type.indexOf("hsl") !== -1) {
      values2[1] = `${values2[1]}%`;
      values2[2] = `${values2[2]}%`;
    }
    if (type.indexOf("color") !== -1) {
      values2 = `${colorSpace} ${values2.join(" ")}`;
    } else {
      values2 = `${values2.join(", ")}`;
    }
    return `${type}(${values2})`;
  }
  function rgbToHex(color2) {
    if (color2.indexOf("#") === 0) {
      return color2;
    }
    const {
      values: values2
    } = decomposeColor2(color2);
    return `#${values2.map((n, i) => intToHex(i === 3 ? Math.round(255 * n) : n)).join("")}`;
  }
  function hslToRgb(color2) {
    color2 = decomposeColor2(color2);
    const {
      values: values2
    } = color2;
    const h = values2[0];
    const s = values2[1] / 100;
    const l = values2[2] / 100;
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    let type = "rgb";
    const rgb2 = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
    if (color2.type === "hsla") {
      type += "a";
      rgb2.push(values2[3]);
    }
    return recomposeColor2({
      type,
      values: rgb2
    });
  }
  function getLuminance(color2) {
    color2 = decomposeColor2(color2);
    let rgb2 = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor2(hslToRgb(color2)).values : color2.values;
    rgb2 = rgb2.map((val) => {
      if (color2.type !== "color") {
        val /= 255;
      }
      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb2[0] + 0.7152 * rgb2[1] + 0.0722 * rgb2[2]).toFixed(3));
  }
  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function alpha2(color2, value) {
    color2 = decomposeColor2(color2);
    value = clampWrapper2(value);
    if (color2.type === "rgb" || color2.type === "hsl") {
      color2.type += "a";
    }
    if (color2.type === "color") {
      color2.values[3] = `/${value}`;
    } else {
      color2.values[3] = value;
    }
    return recomposeColor2(color2);
  }
  function private_safeAlpha(color2, value, warning) {
    try {
      return alpha2(color2, value);
    } catch (error) {
      return color2;
    }
  }
  function darken(color2, coefficient) {
    color2 = decomposeColor2(color2);
    coefficient = clampWrapper2(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] *= 1 - coefficient;
    } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor2(color2);
  }
  function private_safeDarken(color2, coefficient, warning) {
    try {
      return darken(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function lighten(color2, coefficient) {
    color2 = decomposeColor2(color2);
    coefficient = clampWrapper2(coefficient);
    if (color2.type.indexOf("hsl") !== -1) {
      color2.values[2] += (100 - color2.values[2]) * coefficient;
    } else if (color2.type.indexOf("rgb") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (255 - color2.values[i]) * coefficient;
      }
    } else if (color2.type.indexOf("color") !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color2.values[i] += (1 - color2.values[i]) * coefficient;
      }
    }
    return recomposeColor2(color2);
  }
  function private_safeLighten(color2, coefficient, warning) {
    try {
      return lighten(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function emphasize(color2, coefficient = 0.15) {
    return getLuminance(color2) > 0.5 ? darken(color2, coefficient) : lighten(color2, coefficient);
  }
  function private_safeEmphasize(color2, coefficient, warning) {
    try {
      return emphasize(color2, coefficient);
    } catch (error) {
      return color2;
    }
  }
  function blend(background, overlay, opacity, gamma2 = 1) {
    const blendChannel = (b, o) => Math.round((b ** (1 / gamma2) * (1 - opacity) + o ** (1 / gamma2) * opacity) ** gamma2);
    const backgroundColor2 = decomposeColor2(background);
    const overlayColor = decomposeColor2(overlay);
    const rgb2 = [blendChannel(backgroundColor2.values[0], overlayColor.values[0]), blendChannel(backgroundColor2.values[1], overlayColor.values[1]), blendChannel(backgroundColor2.values[2], overlayColor.values[2])];
    return recomposeColor2({
      type: "rgb",
      values: rgb2
    });
  }
  return colorManipulator;
}
var colorManipulatorExports = /* @__PURE__ */ requireColorManipulator();
const common = {
  black: "#000",
  white: "#fff"
};
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const purple = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
};
const red = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
};
const orange = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
};
const blue = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
};
const lightBlue = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
};
const green = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
const _excluded$9 = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common.white,
    default: common.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = colorManipulatorExports.lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = colorManipulatorExports.darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue[200],
      light: blue[50],
      dark: blue[400]
    };
  }
  return {
    main: blue[700],
    light: blue[400],
    dark: blue[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple[200],
      light: purple[50],
      dark: purple[400]
    };
  }
  return {
    main: purple[500],
    light: purple[300],
    dark: purple[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red[500],
      light: red[300],
      dark: red[700]
    };
  }
  return {
    main: red[700],
    light: red[400],
    dark: red[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue[400],
      light: lightBlue[300],
      dark: lightBlue[700]
    };
  }
  return {
    main: lightBlue[700],
    light: lightBlue[500],
    dark: lightBlue[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green[400],
      light: green[300],
      dark: green[700]
    };
  }
  return {
    main: green[800],
    light: green[500],
    dark: green[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange[400],
      light: orange[300],
      dark: orange[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange[500],
    dark: orange[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$9);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = colorManipulatorExports.getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$2({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage$1(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage$1(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge$1(_extends$2({
    // A collection of common colors.
    common: _extends$2({}, common),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$8 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography) {
  const _ref = typeof typography === "function" ? typography(palette) : typography, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$8);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$2({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge$1(_extends$2({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const _excluded$7 = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant2 = height2 / 36;
  return Math.round((4 + 15 * constant2 ** 0.25 + constant2 / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$2({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$2({}, duration, inputTransitions.duration);
  const create2 = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose(options, _excluded$7);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$2({
    getAutoHeightDuration,
    create: create2
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const _excluded$6 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$6);
  if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateCssVars` is the closest identifier for checking that the `options` is a result of `extendTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  options.generateCssVars === void 0) {
    throw new Error(formatMuiErrorMessage$1(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$2(options);
  let muiTheme = deepmerge$1(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$2({}, zIndex)
  });
  muiTheme = deepmerge$1(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge$1(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$2({}, defaultSxConfig, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const defaultTheme = createTheme();
const THEME_ID = "$$material";
function slotShouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const rootShouldForwardProp = (prop) => slotShouldForwardProp(prop) && prop !== "classes";
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme,
  rootShouldForwardProp
});
function useDefaultProps(params2) {
  return useDefaultProps$1(params2);
}
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout: timeout2,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout2 === "number" ? timeout2 : timeout2[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function useTheme() {
  const theme = useTheme$1(defaultTheme);
  return theme[THEME_ID] || theme;
}
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$5 = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize$1(color2)}`, `fontSize${capitalize$1(fontSize)}`]
  };
  return composeClasses$1(slots, getSvgIconUtilityClass, classes);
};
const SvgIconRoot = styled("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize$1(ownerState.color)}`], styles2[`fontSize${capitalize$1(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // for example heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children: children2,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children2) && children2.type === "svg";
  const ownerState = _extends$2({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$2({
    as: component,
    className: clsx(classes.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, hasSvgAsChild && children2.props, {
    ownerState,
    children: [hasSvgAsChild ? children2.props.children : children2, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon$1(path2, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon, _extends$2({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path2
    }));
  }
  Component.muiName = SvgIcon.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
const unstable_ClassNameGenerator = {
  configure: (generator) => {
    ClassNameGenerator.configure(generator);
  }
};
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  capitalize: capitalize$1,
  createChainedFunction,
  createSvgIcon: createSvgIcon$1,
  debounce,
  deprecatedPropType,
  isMuiElement,
  ownerDocument,
  ownerWindow,
  requirePropFactory,
  setRef,
  unstable_ClassNameGenerator,
  unstable_useEnhancedEffect: useEnhancedEffect,
  unstable_useId: useId,
  unsupportedProp,
  useControlled,
  useEventCallback,
  useForkRef: useForkRef$1,
  useIsFocusVisible
}, Symbol.toStringTag, { value: "Module" }));
function getCollapseUtilityClass(slot) {
  return generateUtilityClass("MuiCollapse", slot);
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const _excluded$4 = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    orientation,
    classes
  } = ownerState;
  const slots = {
    root: ["root", `${orientation}`],
    entered: ["entered"],
    hidden: ["hidden"],
    wrapper: ["wrapper", `${orientation}`],
    wrapperInner: ["wrapperInner", `${orientation}`]
  };
  return composeClasses$1(slots, getCollapseUtilityClass, classes);
};
const CollapseRoot = styled("div", {
  name: "MuiCollapse",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends$2({
  height: 0,
  overflow: "hidden",
  transition: theme.transitions.create("height")
}, ownerState.orientation === "horizontal" && {
  height: "auto",
  width: 0,
  transition: theme.transitions.create("width")
}, ownerState.state === "entered" && _extends$2({
  height: "auto",
  overflow: "visible"
}, ownerState.orientation === "horizontal" && {
  width: "auto"
}), ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && {
  visibility: "hidden"
}));
const CollapseWrapper = styled("div", {
  name: "MuiCollapse",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => styles2.wrapper
})(({
  ownerState
}) => _extends$2({
  // Hack to get children with a negative margin to not falsify the height computation.
  display: "flex",
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const CollapseWrapperInner = styled("div", {
  name: "MuiCollapse",
  slot: "WrapperInner",
  overridesResolver: (props, styles2) => styles2.wrapperInner
})(({
  ownerState
}) => _extends$2({
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
  const props = useDefaultProps({
    props: inProps,
    name: "MuiCollapse"
  });
  const {
    addEndListener,
    children: children2,
    className,
    collapsedSize: collapsedSizeProp = "0px",
    component,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    orientation = "vertical",
    style: style2,
    timeout: timeout2 = duration.standard,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const ownerState = _extends$2({}, props, {
    orientation,
    collapsedSize: collapsedSizeProp
  });
  const classes = useUtilityClasses$2(ownerState);
  const theme = useTheme();
  const timer2 = useTimeout();
  const wrapperRef = reactExports.useRef(null);
  const autoTransitionDuration = reactExports.useRef();
  const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
  const isHorizontal = orientation === "horizontal";
  const size = isHorizontal ? "width" : "height";
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(ref, nodeRef);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0;
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "absolute";
    }
    node2.style[size] = collapsedSize;
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const wrapperSize = getWrapperSize();
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "";
    }
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "enter"
    });
    if (timeout2 === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = `${wrapperSize}px`;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
    node2.style[size] = "auto";
    if (onEntered) {
      onEntered(node2, isAppearing);
    }
  });
  const handleExit = normalizedTransitionCallback((node2) => {
    node2.style[size] = `${getWrapperSize()}px`;
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleExiting = normalizedTransitionCallback((node2) => {
    const wrapperSize = getWrapperSize();
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout: timeout2,
      easing: easing2
    }, {
      mode: "exit"
    });
    if (timeout2 === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = collapsedSize;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onExiting) {
      onExiting(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (timeout2 === "auto") {
      timer2.start(autoTransitionDuration.current || 0, next2);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$2({
    in: inProp,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    nodeRef,
    timeout: timeout2 === "auto" ? null : timeout2
  }, other, {
    children: (state, childProps) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseRoot, _extends$2({
      as: component,
      className: clsx(classes.root, className, {
        "entered": classes.entered,
        "exited": !inProp && collapsedSize === "0px" && classes.hidden
      }[state]),
      style: _extends$2({
        [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize
      }, style2),
      ref: handleRef
    }, childProps, {
      // `ownerState` is set after `childProps` to override any existing `ownerState` property in `childProps`
      // that might have been forwarded from the Transition component.
      ownerState: _extends$2({}, ownerState, {
        state
      }),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapper, {
        ownerState: _extends$2({}, ownerState, {
          state
        }),
        className: classes.wrapper,
        ref: wrapperRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapperInner, {
          ownerState: _extends$2({}, ownerState, {
            state
          }),
          className: classes.wrapperInner,
          children: children2
        })
      })
    }))
  }));
});
Collapse.muiSupportAuto = true;
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme,
    themeId: THEME_ID
  });
}
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return {
    ...otherProps,
    ownerState: {
      ...otherProps.ownerState,
      ...ownerState
    }
  };
}
function extractEventHandlers(object2, excludeKeys = []) {
  if (object2 === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object2).filter((prop) => prop.match(/^on[A-Z]/) && typeof object2[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object2[prop];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function useForkRef(...refs) {
  const cleanupRef = reactExports.useRef(void 0);
  const refEffect = reactExports.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return null;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function composeClasses(slots, getUtilityClass, classes = void 0) {
  const output = {};
  for (const slotName in slots) {
    const slot = slots[slotName];
    let buffer = "";
    let start2 = true;
    for (let i = 0; i < slot.length; i += 1) {
      const value = slot[i];
      if (value) {
        buffer += (start2 === true ? "" : " ") + getUtilityClass(value);
        start2 = false;
        if (classes && classes[value]) {
          buffer += " " + classes[value];
        }
      }
    }
    output[slotName] = buffer;
  }
  return output;
}
function omitEventHandlers(object2) {
  if (object2 === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object2).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object2[prop] === "function")).forEach((prop) => {
    result[prop] = object2[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle2 = {
      ...additionalProps == null ? void 0 : additionalProps.style,
      ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
      ...externalSlotProps == null ? void 0 : externalSlotProps.style
    };
    const props2 = {
      ...additionalProps,
      ...externalForwardedProps,
      ...externalSlotProps
    };
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers({
    ...externalForwardedProps,
    ...externalSlotProps
  });
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = {
    ...internalSlotProps == null ? void 0 : internalSlotProps.style,
    ...additionalProps == null ? void 0 : additionalProps.style,
    ...externalForwardedProps == null ? void 0 : externalForwardedProps.style,
    ...externalSlotProps == null ? void 0 : externalSlotProps.style
  };
  const props = {
    ...internalSlotProps,
    ...additionalProps,
    ...otherPropsWithoutEventHandlers,
    ...componentsPropsWithoutEventHandlers
  };
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
function useSlotProps(parameters) {
  var _a;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false,
    ...rest
  } = parameters;
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps({
    ...rest,
    externalSlotProps: resolvedComponentsProps
  });
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_a = parameters.additionalProps) == null ? void 0 : _a.ref);
  const props = appendOwnerState(elementType, {
    ...mergedProps,
    ref
  }, ownerState);
  return props;
}
const _excluded$3 = ["element"];
function findIndex(array2, comp) {
  for (let i = 0; i < array2.length; i += 1) {
    if (comp(array2[i])) {
      return i;
    }
  }
  return -1;
}
function binaryFindElement(array2, element) {
  let start2 = 0;
  let end = array2.length - 1;
  while (start2 <= end) {
    const middle = Math.floor((start2 + end) / 2);
    if (array2[middle].element === element) {
      return middle;
    }
    if (array2[middle].element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING) {
      end = middle - 1;
    } else {
      start2 = middle + 1;
    }
  }
  return start2;
}
const DescendantContext = /* @__PURE__ */ reactExports.createContext({});
function usePrevious$1(value) {
  const ref = reactExports.useRef(null);
  reactExports.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
const noop = () => {
};
function useDescendant(descendant) {
  const [, forceUpdate] = reactExports.useState();
  const {
    registerDescendant = noop,
    unregisterDescendant = noop,
    descendants = [],
    parentId = null
  } = reactExports.useContext(DescendantContext);
  const index = findIndex(descendants, (item) => item.element === descendant.element);
  const previousDescendants = usePrevious$1(descendants);
  const someDescendantsHaveChanged = descendants.some((newDescendant, position2) => {
    return previousDescendants && previousDescendants[position2] && previousDescendants[position2].element !== newDescendant.element;
  });
  useEnhancedEffect(() => {
    if (descendant.element) {
      registerDescendant(_extends$2({}, descendant, {
        index
      }));
      return () => {
        unregisterDescendant(descendant.element);
      };
    }
    forceUpdate({});
    return void 0;
  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);
  return {
    parentId,
    index
  };
}
function DescendantProvider(props) {
  const {
    children: children2,
    id: id2
  } = props;
  const [items, set2] = reactExports.useState([]);
  const registerDescendant = reactExports.useCallback((_ref) => {
    let {
      element
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$3);
    set2((oldItems) => {
      if (oldItems.length === 0) {
        return [_extends$2({}, other, {
          element,
          index: 0
        })];
      }
      const index = binaryFindElement(oldItems, element);
      let newItems;
      if (oldItems[index] && oldItems[index].element === element) {
        newItems = oldItems;
      } else {
        const newItem = _extends$2({}, other, {
          element,
          index
        });
        newItems = oldItems.slice();
        newItems.splice(index, 0, newItem);
      }
      newItems.forEach((item, position2) => {
        item.index = position2;
      });
      return newItems;
    });
  }, []);
  const unregisterDescendant = reactExports.useCallback((element) => {
    set2((oldItems) => oldItems.filter((item) => element !== item.element));
  }, []);
  const value = reactExports.useMemo(() => ({
    descendants: items,
    registerDescendant,
    unregisterDescendant,
    parentId: id2
  }), [items, registerDescendant, unregisterDescendant, id2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantContext.Provider, {
    value,
    children: children2
  });
}
const DEFAULT_TREE_VIEW_CONTEXT_VALUE = {
  instance: null,
  multiSelect: false,
  disabledItemsFocusable: false,
  treeId: void 0,
  icons: {
    defaultCollapseIcon: null,
    defaultExpandIcon: null,
    defaultParentIcon: null,
    defaultEndIcon: null
  }
};
const TreeViewContext = /* @__PURE__ */ reactExports.createContext(DEFAULT_TREE_VIEW_CONTEXT_VALUE);
const useTreeViewContext = () => reactExports.useContext(TreeViewContext);
function useTreeItem(nodeId) {
  const {
    instance,
    multiSelect
  } = useTreeViewContext();
  const expandable = instance ? instance.isNodeExpandable(nodeId) : false;
  const expanded = instance ? instance.isNodeExpanded(nodeId) : false;
  const focused = instance ? instance.isNodeFocused(nodeId) : false;
  const selected = instance ? instance.isNodeSelected(nodeId) : false;
  const disabled = instance ? instance.isNodeDisabled(nodeId) : false;
  const handleExpansion = (event) => {
    if (instance && !disabled) {
      if (!focused) {
        instance.focusNode(event, nodeId);
      }
      const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
      if (expandable && !(multiple && instance.isNodeExpanded(nodeId))) {
        instance.toggleNodeExpansion(event, nodeId);
      }
    }
  };
  const handleSelection = (event) => {
    if (instance && !disabled) {
      if (!focused) {
        instance.focusNode(event, nodeId);
      }
      const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
      if (multiple) {
        if (event.shiftKey) {
          instance.selectRange(event, {
            end: nodeId
          });
        } else {
          instance.selectNode(event, nodeId, true);
        }
      } else {
        instance.selectNode(event, nodeId);
      }
    }
  };
  const preventSelection = (event) => {
    if (event.shiftKey || event.ctrlKey || event.metaKey || disabled) {
      event.preventDefault();
    }
  };
  return {
    disabled,
    expanded,
    selected,
    focused,
    handleExpansion,
    handleSelection,
    preventSelection
  };
}
const _excluded$2 = ["classes", "className", "displayIcon", "expansionIcon", "icon", "label", "nodeId", "onClick", "onMouseDown"];
const TreeItemContent = /* @__PURE__ */ reactExports.forwardRef(function TreeItemContent2(props, ref) {
  const {
    classes,
    className,
    displayIcon,
    expansionIcon,
    icon: iconProp,
    label,
    nodeId,
    onClick,
    onMouseDown
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const {
    disabled,
    expanded,
    selected,
    focused,
    handleExpansion,
    handleSelection,
    preventSelection
  } = useTreeItem(nodeId);
  const icon = iconProp || expansionIcon || displayIcon;
  const handleMouseDown = (event) => {
    preventSelection(event);
    if (onMouseDown) {
      onMouseDown(event);
    }
  };
  const handleClick = (event) => {
    handleExpansion(event);
    handleSelection(event);
    if (onClick) {
      onClick(event);
    }
  };
  return (
    /* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions -- Key event is handled by the TreeView */
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", _extends$2({}, other, {
      className: clsx(className, classes.root, expanded && classes.expanded, selected && classes.selected, focused && classes.focused, disabled && classes.disabled),
      onClick: handleClick,
      onMouseDown: handleMouseDown,
      ref,
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: classes.iconContainer,
        children: icon
      }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        className: classes.label,
        children: label
      })]
    }))
  );
});
function getTreeItemUtilityClass(slot) {
  return generateUtilityClass("MuiTreeItem", slot);
}
const treeItemClasses = generateUtilityClasses("MuiTreeItem", ["root", "group", "content", "expanded", "selected", "focused", "disabled", "iconContainer", "label"]);
const _excluded$1 = ["children", "className", "collapseIcon", "ContentComponent", "ContentProps", "endIcon", "expandIcon", "disabled", "icon", "id", "label", "nodeId", "onClick", "onMouseDown", "TransitionComponent", "TransitionProps"];
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"],
    content: ["content"],
    expanded: ["expanded"],
    selected: ["selected"],
    focused: ["focused"],
    disabled: ["disabled"],
    iconContainer: ["iconContainer"],
    label: ["label"],
    group: ["group"]
  };
  return composeClasses(slots, getTreeItemUtilityClass, classes);
};
const TreeItemRoot = styled("li", {
  name: "MuiTreeItem",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  outline: 0
});
const StyledTreeItemContent = styled(TreeItemContent, {
  name: "MuiTreeItem",
  slot: "Content",
  overridesResolver: (props, styles2) => {
    return [styles2.content, styles2.iconContainer && {
      [`& .${treeItemClasses.iconContainer}`]: styles2.iconContainer
    }, styles2.label && {
      [`& .${treeItemClasses.label}`]: styles2.label
    }];
  }
})(({
  theme
}) => ({
  padding: "0 8px",
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  display: "flex",
  alignItems: "center",
  cursor: "pointer",
  WebkitTapHighlightColor: "transparent",
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${treeItemClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity,
    backgroundColor: "transparent"
  },
  [`&.${treeItemClasses.focused}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${treeItemClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    },
    [`&.${treeItemClasses.focused}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`& .${treeItemClasses.iconContainer}`]: {
    marginRight: 4,
    width: 15,
    display: "flex",
    flexShrink: 0,
    justifyContent: "center",
    "& svg": {
      fontSize: 18
    }
  },
  [`& .${treeItemClasses.label}`]: _extends$2({
    paddingLeft: 4,
    width: "100%",
    boxSizing: "border-box",
    // prevent width + padding to overflow
    // fixes overflow - see https://github.com/mui/material-ui/issues/27372
    minWidth: 0,
    position: "relative"
  }, theme.typography.body1)
}));
const TreeItemGroup = styled(Collapse, {
  name: "MuiTreeItem",
  slot: "Group",
  overridesResolver: (props, styles2) => styles2.group
})({
  margin: 0,
  padding: 0,
  marginLeft: 17
});
const TreeItem = /* @__PURE__ */ reactExports.forwardRef(function TreeItem2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTreeItem"
  });
  const {
    children: children2,
    className,
    collapseIcon,
    ContentComponent = TreeItemContent,
    ContentProps,
    endIcon,
    expandIcon,
    disabled: disabledProp,
    icon,
    id: idProp,
    label,
    nodeId,
    onClick,
    onMouseDown,
    TransitionComponent = Collapse,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const {
    icons: contextIcons,
    multiSelect,
    disabledItemsFocusable,
    treeId,
    instance
  } = useTreeViewContext();
  let id2;
  if (idProp != null) {
    id2 = idProp;
  } else if (treeId && nodeId) {
    id2 = `${treeId}-${nodeId}`;
  }
  const [treeItemElement, setTreeItemElement] = reactExports.useState(null);
  const contentRef = reactExports.useRef(null);
  const handleRef = useForkRef$1(setTreeItemElement, ref);
  const descendant = reactExports.useMemo(() => ({
    element: treeItemElement,
    id: nodeId
  }), [nodeId, treeItemElement]);
  const {
    index,
    parentId
  } = useDescendant(descendant);
  const expandable = Boolean(Array.isArray(children2) ? children2.length : children2);
  const expanded = instance ? instance.isNodeExpanded(nodeId) : false;
  const focused = instance ? instance.isNodeFocused(nodeId) : false;
  const selected = instance ? instance.isNodeSelected(nodeId) : false;
  const disabled = instance ? instance.isNodeDisabled(nodeId) : false;
  const ownerState = _extends$2({}, props, {
    expanded,
    focused,
    selected,
    disabled
  });
  const classes = useUtilityClasses$1(ownerState);
  let displayIcon;
  let expansionIcon;
  if (expandable) {
    if (!expanded) {
      expansionIcon = expandIcon || contextIcons.defaultExpandIcon;
    } else {
      expansionIcon = collapseIcon || contextIcons.defaultCollapseIcon;
    }
  }
  if (expandable) {
    displayIcon = contextIcons.defaultParentIcon;
  } else {
    displayIcon = endIcon || contextIcons.defaultEndIcon;
  }
  reactExports.useEffect(() => {
    if (instance && index !== -1) {
      instance.updateNode({
        id: nodeId,
        idAttribute: id2,
        index,
        parentId,
        expandable,
        disabled: disabledProp
      });
      return () => instance.removeNode(nodeId);
    }
    return void 0;
  }, [instance, parentId, index, nodeId, expandable, disabledProp, id2]);
  reactExports.useEffect(() => {
    if (instance && label) {
      var _contentRef$current$t, _contentRef$current;
      return instance.mapFirstChar(nodeId, ((_contentRef$current$t = (_contentRef$current = contentRef.current) == null ? void 0 : _contentRef$current.textContent) != null ? _contentRef$current$t : "").substring(0, 1).toLowerCase());
    }
    return void 0;
  }, [instance, nodeId, label]);
  let ariaSelected;
  if (multiSelect) {
    ariaSelected = selected;
  } else if (selected) {
    ariaSelected = true;
  }
  function handleFocus(event) {
    if (event.target === event.currentTarget) {
      let rootElement;
      if (typeof event.target.getRootNode === "function") {
        rootElement = event.target.getRootNode();
      } else {
        rootElement = ownerDocument(event.target);
      }
      rootElement.getElementById(treeId).focus({
        preventScroll: true
      });
    }
    const unfocusable = !disabledItemsFocusable && disabled;
    if (instance && !focused && event.currentTarget === event.target && !unfocusable) {
      instance.focusNode(event, nodeId);
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TreeItemRoot, _extends$2({
    className: clsx(classes.root, className),
    role: "treeitem",
    "aria-expanded": expandable ? expanded : void 0,
    "aria-selected": ariaSelected,
    "aria-disabled": disabled || void 0,
    id: id2,
    tabIndex: -1
  }, other, {
    ownerState,
    onFocus: handleFocus,
    ref: handleRef,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(StyledTreeItemContent, _extends$2({
      as: ContentComponent,
      ref: contentRef,
      classes: {
        root: classes.content,
        expanded: classes.expanded,
        selected: classes.selected,
        focused: classes.focused,
        disabled: classes.disabled,
        iconContainer: classes.iconContainer,
        label: classes.label
      },
      label,
      nodeId,
      onClick,
      onMouseDown,
      icon,
      expansionIcon,
      displayIcon,
      ownerState
    }, ContentProps)), children2 && /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantProvider, {
      id: nodeId,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeItemGroup, _extends$2({
        as: TransitionComponent,
        unmountOnExit: true,
        className: classes.group,
        in: expanded,
        component: "ul",
        role: "group"
      }, TransitionProps, {
        children: children2
      }))
    })]
  }));
});
function getTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiTreeView", slot);
}
generateUtilityClasses("MuiTreeView", ["root"]);
const useTreeViewModels = (plugins, props) => {
  const modelsRef = reactExports.useRef({});
  const [modelsState, setModelsState] = reactExports.useState(() => {
    const initialState = {};
    plugins.forEach((plugin) => {
      if (plugin.models) {
        Object.entries(plugin.models).forEach(([modelName, model]) => {
          modelsRef.current[modelName] = {
            controlledProp: model.controlledProp,
            defaultProp: model.defaultProp,
            isControlled: props[model.controlledProp] !== void 0
          };
          initialState[modelName] = props[model.defaultProp];
        });
      }
    });
    return initialState;
  });
  const models = Object.fromEntries(Object.entries(modelsRef.current).map(([modelName, model]) => {
    const value = model.isControlled ? props[model.controlledProp] : modelsState[modelName];
    return [modelName, {
      value,
      setValue: (newValue) => {
        if (!model.isControlled) {
          setModelsState((prevState) => _extends$2({}, prevState, {
            [modelName]: newValue
          }));
        }
      }
    }];
  }));
  return models;
};
class EventManager {
  constructor() {
    this.maxListeners = 20;
    this.warnOnce = false;
    this.events = {};
  }
  on(eventName, listener, options = {}) {
    let collection = this.events[eventName];
    if (!collection) {
      collection = {
        highPriority: /* @__PURE__ */ new Map(),
        regular: /* @__PURE__ */ new Map()
      };
      this.events[eventName] = collection;
    }
    if (options.isFirst) {
      collection.highPriority.set(listener, true);
    } else {
      collection.regular.set(listener, true);
    }
  }
  removeListener(eventName, listener) {
    if (this.events[eventName]) {
      this.events[eventName].regular.delete(listener);
      this.events[eventName].highPriority.delete(listener);
    }
  }
  removeAllListeners() {
    this.events = {};
  }
  emit(eventName, ...args) {
    const collection = this.events[eventName];
    if (!collection) {
      return;
    }
    const highPriorityListeners = Array.from(collection.highPriority.keys());
    const regularListeners = Array.from(collection.regular.keys());
    for (let i = highPriorityListeners.length - 1; i >= 0; i -= 1) {
      const listener = highPriorityListeners[i];
      if (collection.highPriority.has(listener)) {
        listener.apply(this, args);
      }
    }
    for (let i = 0; i < regularListeners.length; i += 1) {
      const listener = regularListeners[i];
      if (collection.regular.has(listener)) {
        listener.apply(this, args);
      }
    }
  }
  once(eventName, listener) {
    const that = this;
    this.on(eventName, function oneTimeListener(...args) {
      that.removeListener(eventName, oneTimeListener);
      listener.apply(that, args);
    });
  }
}
const getPreviousNode = (instance, nodeId) => {
  const node2 = instance.getNode(nodeId);
  const siblings = instance.getNavigableChildrenIds(node2.parentId);
  const nodeIndex = siblings.indexOf(nodeId);
  if (nodeIndex === 0) {
    return node2.parentId;
  }
  let currentNode = siblings[nodeIndex - 1];
  while (instance.isNodeExpanded(currentNode) && instance.getNavigableChildrenIds(currentNode).length > 0) {
    currentNode = instance.getNavigableChildrenIds(currentNode).pop();
  }
  return currentNode;
};
const getNextNode = (instance, nodeId) => {
  if (instance.isNodeExpanded(nodeId) && instance.getNavigableChildrenIds(nodeId).length > 0) {
    return instance.getNavigableChildrenIds(nodeId)[0];
  }
  let node2 = instance.getNode(nodeId);
  while (node2 != null) {
    const siblings = instance.getNavigableChildrenIds(node2.parentId);
    const nextSibling = siblings[siblings.indexOf(node2.id) + 1];
    if (nextSibling) {
      return nextSibling;
    }
    node2 = instance.getNode(node2.parentId);
  }
  return null;
};
const getLastNode = (instance) => {
  let lastNode = instance.getNavigableChildrenIds(null).pop();
  while (instance.isNodeExpanded(lastNode)) {
    lastNode = instance.getNavigableChildrenIds(lastNode).pop();
  }
  return lastNode;
};
const getFirstNode = (instance) => instance.getNavigableChildrenIds(null)[0];
const populateInstance = (instance, methods) => {
  Object.assign(instance, methods);
};
const isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
const useTreeViewInstanceEvents = ({
  instance
}) => {
  const [eventManager] = reactExports.useState(() => new EventManager());
  const publishEvent = reactExports.useCallback((...args) => {
    const [name, params2, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    eventManager.emit(name, params2, event);
  }, [eventManager]);
  const subscribeEvent = reactExports.useCallback((event, handler) => {
    eventManager.on(event, handler);
    return () => {
      eventManager.removeListener(event, handler);
    };
  }, [eventManager]);
  populateInstance(instance, {
    $$publishEvent: publishEvent,
    $$subscribeEvent: subscribeEvent
  });
};
const TREE_VIEW_CORE_PLUGINS = [useTreeViewInstanceEvents];
const useTreeView = (inParams) => {
  const plugins = [...TREE_VIEW_CORE_PLUGINS, ...inParams.plugins];
  const params2 = plugins.reduce((acc, plugin) => {
    if (plugin.getDefaultizedParams) {
      return plugin.getDefaultizedParams(acc);
    }
    return acc;
  }, inParams);
  const models = useTreeViewModels(plugins, params2);
  const instanceRef = reactExports.useRef({});
  const instance = instanceRef.current;
  const innerRootRef = reactExports.useRef(null);
  const handleRootRef = useForkRef$1(innerRootRef, inParams.rootRef);
  const [state, setState] = reactExports.useState(() => {
    const temp = {};
    plugins.forEach((plugin) => {
      if (plugin.getInitialState) {
        Object.assign(temp, plugin.getInitialState(params2));
      }
    });
    return temp;
  });
  const rootPropsGetters = [];
  let contextValue = DEFAULT_TREE_VIEW_CONTEXT_VALUE;
  const runPlugin = (plugin) => {
    const pluginResponse = plugin({
      instance,
      params: params2,
      state,
      setState,
      rootRef: innerRootRef,
      models
    }) || {};
    if (pluginResponse.getRootProps) {
      rootPropsGetters.push(pluginResponse.getRootProps);
    }
    if (pluginResponse.contextValue) {
      contextValue = pluginResponse.contextValue;
    }
  };
  plugins.forEach(runPlugin);
  const getRootProps = (otherHandlers = {}) => {
    const rootProps = _extends$2({
      role: "tree",
      tabIndex: 0
    }, otherHandlers, {
      ref: handleRootRef
    });
    rootPropsGetters.forEach((rootPropsGetter) => {
      Object.assign(rootProps, rootPropsGetter(otherHandlers));
    });
    return rootProps;
  };
  return {
    getRootProps,
    rootRef: handleRootRef,
    contextValue
  };
};
function TreeViewProvider(props) {
  const {
    value,
    children: children2
  } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewContext.Provider, {
    value,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(DescendantProvider, {
      children: children2
    })
  });
}
const publishTreeViewEvent = (instance, eventName, params2) => {
  instance.$$publishEvent(eventName, params2);
};
const useTreeViewNodes = ({
  instance,
  params: params2
}) => {
  const nodeMap = reactExports.useRef({});
  const getNode = reactExports.useCallback((nodeId) => nodeMap.current[nodeId], []);
  const insertNode = reactExports.useCallback((node2) => {
    nodeMap.current[node2.id] = node2;
  }, []);
  const removeNode = reactExports.useCallback((nodeId) => {
    const newMap = _extends$2({}, nodeMap.current);
    delete newMap[nodeId];
    nodeMap.current = newMap;
    publishTreeViewEvent(instance, "removeNode", {
      id: nodeId
    });
  }, [instance]);
  const isNodeDisabled = reactExports.useCallback((nodeId) => {
    if (nodeId == null) {
      return false;
    }
    let node2 = instance.getNode(nodeId);
    if (!node2) {
      return false;
    }
    if (node2.disabled) {
      return true;
    }
    while (node2.parentId != null) {
      node2 = instance.getNode(node2.parentId);
      if (node2.disabled) {
        return true;
      }
    }
    return false;
  }, [instance]);
  const getChildrenIds = useEventCallback((nodeId) => Object.values(nodeMap.current).filter((node2) => node2.parentId === nodeId).sort((a, b) => a.index - b.index).map((child) => child.id));
  const getNavigableChildrenIds = (nodeId) => {
    let childrenIds = instance.getChildrenIds(nodeId);
    if (!params2.disabledItemsFocusable) {
      childrenIds = childrenIds.filter((node2) => !instance.isNodeDisabled(node2));
    }
    return childrenIds;
  };
  populateInstance(instance, {
    getNode,
    updateNode: insertNode,
    removeNode,
    getChildrenIds,
    getNavigableChildrenIds,
    isNodeDisabled
  });
};
const useTreeViewExpansion = ({
  instance,
  params: params2,
  models
}) => {
  const isNodeExpanded = reactExports.useCallback((nodeId) => {
    return Array.isArray(models.expanded.value) ? models.expanded.value.indexOf(nodeId) !== -1 : false;
  }, [models.expanded.value]);
  const isNodeExpandable = reactExports.useCallback((nodeId) => {
    var _instance$getNode;
    return !!((_instance$getNode = instance.getNode(nodeId)) != null && _instance$getNode.expandable);
  }, [instance]);
  const toggleNodeExpansion = useEventCallback((event, nodeId) => {
    if (nodeId == null) {
      return;
    }
    let newExpanded;
    if (models.expanded.value.indexOf(nodeId) !== -1) {
      newExpanded = models.expanded.value.filter((id2) => id2 !== nodeId);
    } else {
      newExpanded = [nodeId].concat(models.expanded.value);
    }
    if (params2.onNodeToggle) {
      params2.onNodeToggle(event, newExpanded);
    }
    models.expanded.setValue(newExpanded);
  });
  const expandAllSiblings = (event, nodeId) => {
    const node2 = instance.getNode(nodeId);
    const siblings = instance.getChildrenIds(node2.parentId);
    const diff = siblings.filter((child) => instance.isNodeExpandable(child) && !instance.isNodeExpanded(child));
    const newExpanded = models.expanded.value.concat(diff);
    if (diff.length > 0) {
      models.expanded.setValue(newExpanded);
      if (params2.onNodeToggle) {
        params2.onNodeToggle(event, newExpanded);
      }
    }
  };
  populateInstance(instance, {
    isNodeExpanded,
    isNodeExpandable,
    toggleNodeExpansion,
    expandAllSiblings
  });
};
useTreeViewExpansion.models = {
  expanded: {
    controlledProp: "expanded",
    defaultProp: "defaultExpanded"
  }
};
const DEFAULT_EXPANDED = [];
useTreeViewExpansion.getDefaultizedParams = (params2) => {
  var _params$defaultExpand;
  return _extends$2({}, params2, {
    defaultExpanded: (_params$defaultExpand = params2.defaultExpanded) != null ? _params$defaultExpand : DEFAULT_EXPANDED
  });
};
const findOrderInTremauxTree = (instance, nodeAId, nodeBId) => {
  if (nodeAId === nodeBId) {
    return [nodeAId, nodeBId];
  }
  const nodeA = instance.getNode(nodeAId);
  const nodeB = instance.getNode(nodeBId);
  if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {
    return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];
  }
  const aFamily = [nodeA.id];
  const bFamily = [nodeB.id];
  let aAncestor = nodeA.parentId;
  let bAncestor = nodeB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = instance.getNode(aAncestor).parentId;
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = instance.getNode(bAncestor).parentId;
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = instance.getChildrenIds(commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];
};
const useTreeViewSelection = ({
  instance,
  params: params2,
  models
}) => {
  const lastSelectedNode = reactExports.useRef(null);
  const lastSelectionWasRange = reactExports.useRef(false);
  const currentRangeSelection = reactExports.useRef([]);
  const isNodeSelected = (nodeId) => Array.isArray(models.selected.value) ? models.selected.value.indexOf(nodeId) !== -1 : models.selected.value === nodeId;
  const selectNode = (event, nodeId, multiple = false) => {
    if (params2.disableSelection) {
      return;
    }
    if (multiple) {
      if (Array.isArray(models.selected.value)) {
        let newSelected;
        if (models.selected.value.indexOf(nodeId) !== -1) {
          newSelected = models.selected.value.filter((id2) => id2 !== nodeId);
        } else {
          newSelected = [nodeId].concat(models.selected.value);
        }
        if (params2.onNodeSelect) {
          params2.onNodeSelect(event, newSelected);
        }
        models.selected.setValue(newSelected);
      }
    } else {
      const newSelected = params2.multiSelect ? [nodeId] : nodeId;
      if (params2.onNodeSelect) {
        params2.onNodeSelect(event, newSelected);
      }
      models.selected.setValue(newSelected);
    }
    lastSelectedNode.current = nodeId;
    lastSelectionWasRange.current = false;
    currentRangeSelection.current = [];
  };
  const getNodesInRange = (nodeAId, nodeBId) => {
    const [first, last] = findOrderInTremauxTree(instance, nodeAId, nodeBId);
    const nodes = [first];
    let current = first;
    while (current !== last) {
      current = getNextNode(instance, current);
      nodes.push(current);
    }
    return nodes;
  };
  const handleRangeArrowSelect = (event, nodes) => {
    let base = models.selected.value.slice();
    const {
      start: start2,
      next: next2,
      current
    } = nodes;
    if (!next2 || !current) {
      return;
    }
    if (currentRangeSelection.current.indexOf(current) === -1) {
      currentRangeSelection.current = [];
    }
    if (lastSelectionWasRange.current) {
      if (currentRangeSelection.current.indexOf(next2) !== -1) {
        base = base.filter((id2) => id2 === start2 || id2 !== current);
        currentRangeSelection.current = currentRangeSelection.current.filter((id2) => id2 === start2 || id2 !== current);
      } else {
        base.push(next2);
        currentRangeSelection.current.push(next2);
      }
    } else {
      base.push(next2);
      currentRangeSelection.current.push(current, next2);
    }
    if (params2.onNodeSelect) {
      params2.onNodeSelect(event, base);
    }
    models.selected.setValue(base);
  };
  const handleRangeSelect = (event, nodes) => {
    let base = models.selected.value.slice();
    const {
      start: start2,
      end
    } = nodes;
    if (lastSelectionWasRange.current) {
      base = base.filter((id2) => currentRangeSelection.current.indexOf(id2) === -1);
    }
    let range2 = getNodesInRange(start2, end);
    range2 = range2.filter((node2) => !instance.isNodeDisabled(node2));
    currentRangeSelection.current = range2;
    let newSelected = base.concat(range2);
    newSelected = newSelected.filter((id2, i) => newSelected.indexOf(id2) === i);
    if (params2.onNodeSelect) {
      params2.onNodeSelect(event, newSelected);
    }
    models.selected.setValue(newSelected);
  };
  const selectRange = (event, nodes, stacked = false) => {
    if (params2.disableSelection) {
      return;
    }
    const {
      start: start2 = lastSelectedNode.current,
      end,
      current
    } = nodes;
    if (stacked) {
      handleRangeArrowSelect(event, {
        start: start2,
        next: end,
        current
      });
    } else if (start2 != null && end != null) {
      handleRangeSelect(event, {
        start: start2,
        end
      });
    }
    lastSelectionWasRange.current = true;
  };
  const rangeSelectToFirst = (event, nodeId) => {
    if (!lastSelectedNode.current) {
      lastSelectedNode.current = nodeId;
    }
    const start2 = lastSelectionWasRange.current ? lastSelectedNode.current : nodeId;
    instance.selectRange(event, {
      start: start2,
      end: getFirstNode(instance)
    });
  };
  const rangeSelectToLast = (event, nodeId) => {
    if (!lastSelectedNode.current) {
      lastSelectedNode.current = nodeId;
    }
    const start2 = lastSelectionWasRange.current ? lastSelectedNode.current : nodeId;
    instance.selectRange(event, {
      start: start2,
      end: getLastNode(instance)
    });
  };
  populateInstance(instance, {
    isNodeSelected,
    selectNode,
    selectRange,
    rangeSelectToLast,
    rangeSelectToFirst
  });
  return {
    getRootProps: () => ({
      "aria-multiselectable": params2.multiSelect
    })
  };
};
useTreeViewSelection.models = {
  selected: {
    controlledProp: "selected",
    defaultProp: "defaultSelected"
  }
};
const DEFAULT_SELECTED = [];
useTreeViewSelection.getDefaultizedParams = (params2) => {
  var _params$disableSelect, _params$multiSelect, _params$defaultSelect;
  return _extends$2({}, params2, {
    disableSelection: (_params$disableSelect = params2.disableSelection) != null ? _params$disableSelect : false,
    multiSelect: (_params$multiSelect = params2.multiSelect) != null ? _params$multiSelect : false,
    defaultSelected: (_params$defaultSelect = params2.defaultSelected) != null ? _params$defaultSelect : params2.multiSelect ? DEFAULT_SELECTED : null
  });
};
const CLEANUP_TIMER_LOOP_MILLIS = 1e3;
class TimerBasedCleanupTracking {
  constructor(timeout2 = CLEANUP_TIMER_LOOP_MILLIS) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
    this.cleanupTimeout = timeout2;
  }
  register(object2, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout2 = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout2);
  }
  unregister(unregisterToken) {
    const timeout2 = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout2) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout2);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key) => {
        this.unregister({
          cleanupToken: key
        });
      });
      this.timeouts = void 0;
    }
  }
}
class FinalizationRegistryBasedCleanupTracking {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object2, unsubscribe, unregisterToken) {
    this.registry.register(object2, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  // eslint-disable-next-line class-methods-use-this
  reset() {
  }
}
class ObjectToBeRetainedByReact {
}
function createUseInstanceEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return function useInstanceEventHandler2(instance, eventName, handler) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = reactExports.useState(new ObjectToBeRetainedByReact());
    const subscription = reactExports.useRef(null);
    const handlerRef = reactExports.useRef();
    handlerRef.current = handler;
    const cleanupTokenRef = reactExports.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params2, event) => {
        if (!event.defaultMuiPrevented) {
          var _handlerRef$current;
          (_handlerRef$current = handlerRef.current) == null || _handlerRef$current.call(handlerRef, params2, event);
        }
      };
      subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          var _subscription$current;
          (_subscription$current = subscription.current) == null || _subscription$current.call(subscription);
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    reactExports.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params2, event) => {
          if (!event.defaultMuiPrevented) {
            var _handlerRef$current2;
            (_handlerRef$current2 = handlerRef.current) == null || _handlerRef$current2.call(handlerRef, params2, event);
          }
        };
        subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _subscription$current2;
        (_subscription$current2 = subscription.current) == null || _subscription$current2.call(subscription);
        subscription.current = null;
      };
    }, [instance, eventName]);
  };
}
const registryContainer = {
  registry: null
};
const useInstanceEventHandler = createUseInstanceEventHandler(registryContainer);
const useTreeViewFocus = ({
  instance,
  params: params2,
  state,
  setState,
  models,
  rootRef
}) => {
  const setFocusedNodeId = useEventCallback((nodeId) => {
    const cleanNodeId = typeof nodeId === "function" ? nodeId(state.focusedNodeId) : nodeId;
    setState((prevState) => _extends$2({}, prevState, {
      focusedNodeId: cleanNodeId
    }));
  });
  const isNodeFocused = reactExports.useCallback((nodeId) => state.focusedNodeId === nodeId, [state.focusedNodeId]);
  const focusNode = useEventCallback((event, nodeId) => {
    if (nodeId) {
      setFocusedNodeId(nodeId);
      if (params2.onNodeFocus) {
        params2.onNodeFocus(event, nodeId);
      }
    }
  });
  populateInstance(instance, {
    isNodeFocused,
    focusNode
  });
  useInstanceEventHandler(instance, "removeNode", ({
    id: id2
  }) => {
    setFocusedNodeId((oldFocusedNodeId) => {
      if (oldFocusedNodeId === id2 && rootRef.current === ownerDocument(rootRef.current).activeElement) {
        return instance.getChildrenIds(null)[0];
      }
      return oldFocusedNodeId;
    });
  });
  const createHandleFocus = (otherHandlers) => (event) => {
    var _otherHandlers$onFocu;
    (_otherHandlers$onFocu = otherHandlers.onFocus) == null || _otherHandlers$onFocu.call(otherHandlers, event);
    if (event.target === event.currentTarget) {
      const isNodeVisible = (nodeId) => {
        const node2 = instance.getNode(nodeId);
        return node2 && (node2.parentId == null || instance.isNodeExpanded(node2.parentId));
      };
      let nodeToFocusId;
      if (Array.isArray(models.selected.value)) {
        nodeToFocusId = models.selected.value.find(isNodeVisible);
      } else if (models.selected.value != null && isNodeVisible(models.selected.value)) {
        nodeToFocusId = models.selected.value;
      }
      if (nodeToFocusId == null) {
        nodeToFocusId = instance.getNavigableChildrenIds(null)[0];
      }
      instance.focusNode(event, nodeToFocusId);
    }
  };
  const createHandleBlur = (otherHandlers) => (event) => {
    var _otherHandlers$onBlur;
    (_otherHandlers$onBlur = otherHandlers.onBlur) == null || _otherHandlers$onBlur.call(otherHandlers, event);
    setFocusedNodeId(null);
  };
  const focusedNode = instance.getNode(state.focusedNodeId);
  const activeDescendant = focusedNode ? focusedNode.idAttribute : null;
  return {
    getRootProps: (otherHandlers) => ({
      onFocus: createHandleFocus(otherHandlers),
      onBlur: createHandleBlur(otherHandlers),
      "aria-activedescendant": activeDescendant != null ? activeDescendant : void 0
    })
  };
};
useTreeViewFocus.getInitialState = () => ({
  focusedNodeId: null
});
useTreeViewFocus.getDefaultizedParams = (params2) => {
  var _params$disabledItems;
  return _extends$2({}, params2, {
    disabledItemsFocusable: (_params$disabledItems = params2.disabledItemsFocusable) != null ? _params$disabledItems : false
  });
};
function isPrintableCharacter(string) {
  return string && string.length === 1 && string.match(/\S/);
}
function findNextFirstChar(firstChars, startIndex, char2) {
  for (let i = startIndex; i < firstChars.length; i += 1) {
    if (char2 === firstChars[i]) {
      return i;
    }
  }
  return -1;
}
const useTreeViewKeyboardNavigation = ({
  instance,
  params: params2,
  state
}) => {
  const theme = useTheme();
  const isRtl = theme.direction === "rtl";
  const firstCharMap = reactExports.useRef({});
  const mapFirstChar = useEventCallback((nodeId, firstChar) => {
    firstCharMap.current[nodeId] = firstChar;
    return () => {
      const newMap = _extends$2({}, firstCharMap.current);
      delete newMap[nodeId];
      firstCharMap.current = newMap;
    };
  });
  populateInstance(instance, {
    mapFirstChar
  });
  const handleNextArrow = (event) => {
    if (state.focusedNodeId != null && instance.isNodeExpandable(state.focusedNodeId)) {
      if (instance.isNodeExpanded(state.focusedNodeId)) {
        instance.focusNode(event, getNextNode(instance, state.focusedNodeId));
      } else if (!instance.isNodeDisabled(state.focusedNodeId)) {
        instance.toggleNodeExpansion(event, state.focusedNodeId);
      }
    }
    return true;
  };
  const handlePreviousArrow = (event) => {
    if (state.focusedNodeId == null) {
      return false;
    }
    if (instance.isNodeExpanded(state.focusedNodeId) && !instance.isNodeDisabled(state.focusedNodeId)) {
      instance.toggleNodeExpansion(event, state.focusedNodeId);
      return true;
    }
    const parent = instance.getNode(state.focusedNodeId).parentId;
    if (parent) {
      instance.focusNode(event, parent);
      return true;
    }
    return false;
  };
  const focusByFirstCharacter = (event, nodeId, firstChar) => {
    let start2;
    let index;
    const lowercaseChar = firstChar.toLowerCase();
    const firstCharIds = [];
    const firstChars = [];
    Object.keys(firstCharMap.current).forEach((mapNodeId) => {
      const map = instance.getNode(mapNodeId);
      const visible = map.parentId ? instance.isNodeExpanded(map.parentId) : true;
      const shouldBeSkipped = params2.disabledItemsFocusable ? false : instance.isNodeDisabled(mapNodeId);
      if (visible && !shouldBeSkipped) {
        firstCharIds.push(mapNodeId);
        firstChars.push(firstCharMap.current[mapNodeId]);
      }
    });
    start2 = firstCharIds.indexOf(nodeId) + 1;
    if (start2 >= firstCharIds.length) {
      start2 = 0;
    }
    index = findNextFirstChar(firstChars, start2, lowercaseChar);
    if (index === -1) {
      index = findNextFirstChar(firstChars, 0, lowercaseChar);
    }
    if (index > -1) {
      instance.focusNode(event, firstCharIds[index]);
    }
  };
  const selectNextNode = (event, id2) => {
    if (!instance.isNodeDisabled(getNextNode(instance, id2))) {
      instance.selectRange(event, {
        end: getNextNode(instance, id2),
        current: id2
      }, true);
    }
  };
  const selectPreviousNode = (event, nodeId) => {
    if (!instance.isNodeDisabled(getPreviousNode(instance, nodeId))) {
      instance.selectRange(event, {
        end: getPreviousNode(instance, nodeId),
        current: nodeId
      }, true);
    }
  };
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    let flag = false;
    const key = event.key;
    if (event.altKey || event.currentTarget !== event.target || state.focusedNodeId == null) {
      return;
    }
    const ctrlPressed = event.ctrlKey || event.metaKey;
    switch (key) {
      case " ":
        if (!params2.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
          flag = true;
          if (params2.multiSelect && event.shiftKey) {
            instance.selectRange(event, {
              end: state.focusedNodeId
            });
          } else if (params2.multiSelect) {
            instance.selectNode(event, state.focusedNodeId, true);
          } else {
            instance.selectNode(event, state.focusedNodeId);
          }
        }
        event.stopPropagation();
        break;
      case "Enter":
        if (!instance.isNodeDisabled(state.focusedNodeId)) {
          if (instance.isNodeExpandable(state.focusedNodeId)) {
            instance.toggleNodeExpansion(event, state.focusedNodeId);
            flag = true;
          } else if (!params2.disableSelection) {
            flag = true;
            if (params2.multiSelect) {
              instance.selectNode(event, state.focusedNodeId, true);
            } else {
              instance.selectNode(event, state.focusedNodeId);
            }
          }
        }
        event.stopPropagation();
        break;
      case "ArrowDown":
        if (params2.multiSelect && event.shiftKey && !params2.disableSelection) {
          selectNextNode(event, state.focusedNodeId);
        }
        instance.focusNode(event, getNextNode(instance, state.focusedNodeId));
        flag = true;
        break;
      case "ArrowUp":
        if (params2.multiSelect && event.shiftKey && !params2.disableSelection) {
          selectPreviousNode(event, state.focusedNodeId);
        }
        instance.focusNode(event, getPreviousNode(instance, state.focusedNodeId));
        flag = true;
        break;
      case "ArrowRight":
        if (isRtl) {
          flag = handlePreviousArrow(event);
        } else {
          flag = handleNextArrow(event);
        }
        break;
      case "ArrowLeft":
        if (isRtl) {
          flag = handleNextArrow(event);
        } else {
          flag = handlePreviousArrow(event);
        }
        break;
      case "Home":
        if (params2.multiSelect && ctrlPressed && event.shiftKey && !params2.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
          instance.rangeSelectToFirst(event, state.focusedNodeId);
        }
        instance.focusNode(event, getFirstNode(instance));
        flag = true;
        break;
      case "End":
        if (params2.multiSelect && ctrlPressed && event.shiftKey && !params2.disableSelection && !instance.isNodeDisabled(state.focusedNodeId)) {
          instance.rangeSelectToLast(event, state.focusedNodeId);
        }
        instance.focusNode(event, getLastNode(instance));
        flag = true;
        break;
      default:
        if (key === "*") {
          instance.expandAllSiblings(event, state.focusedNodeId);
          flag = true;
        } else if (params2.multiSelect && ctrlPressed && key.toLowerCase() === "a" && !params2.disableSelection) {
          instance.selectRange(event, {
            start: getFirstNode(instance),
            end: getLastNode(instance)
          });
          flag = true;
        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {
          focusByFirstCharacter(event, state.focusedNodeId, key);
          flag = true;
        }
    }
    if (flag) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
  return {
    getRootProps: (otherHandlers) => ({
      onKeyDown: createHandleKeyDown(otherHandlers)
    })
  };
};
const useTreeViewContextValueBuilder = ({
  instance,
  params: params2
}) => {
  const treeId = useId(params2.id);
  return {
    getRootProps: () => ({
      id: treeId
    }),
    contextValue: {
      treeId,
      instance,
      multiSelect: params2.multiSelect,
      disabledItemsFocusable: params2.disabledItemsFocusable,
      icons: {
        defaultCollapseIcon: params2.defaultCollapseIcon,
        defaultEndIcon: params2.defaultEndIcon,
        defaultExpandIcon: params2.defaultExpandIcon,
        defaultParentIcon: params2.defaultParentIcon
      }
    }
  };
};
const DEFAULT_TREE_VIEW_PLUGINS = [useTreeViewNodes, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewContextValueBuilder];
const _excluded = ["disabledItemsFocusable", "expanded", "defaultExpanded", "onNodeToggle", "onNodeFocus", "disableSelection", "defaultSelected", "selected", "multiSelect", "onNodeSelect", "id", "defaultCollapseIcon", "defaultEndIcon", "defaultExpandIcon", "defaultParentIcon", "children"];
const useUtilityClasses = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses$1(slots, getTreeViewUtilityClass, classes);
};
const TreeViewRoot = styled("ul", {
  name: "MuiTreeView",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0
});
const TreeView = /* @__PURE__ */ reactExports.forwardRef(function TreeView2(inProps, ref) {
  const themeProps = useThemeProps({
    props: inProps,
    name: "MuiTreeView"
  });
  const ownerState = themeProps;
  const _ref = themeProps, {
    // Headless implementation
    disabledItemsFocusable,
    expanded,
    defaultExpanded,
    onNodeToggle,
    onNodeFocus,
    disableSelection,
    defaultSelected,
    selected,
    multiSelect,
    onNodeSelect,
    id: id2,
    defaultCollapseIcon,
    defaultEndIcon,
    defaultExpandIcon,
    defaultParentIcon,
    // Component implementation
    children: children2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded);
  const {
    getRootProps,
    contextValue
  } = useTreeView({
    disabledItemsFocusable,
    expanded,
    defaultExpanded,
    onNodeToggle,
    onNodeFocus,
    disableSelection,
    defaultSelected,
    selected,
    multiSelect,
    onNodeSelect,
    id: id2,
    defaultCollapseIcon,
    defaultEndIcon,
    defaultExpandIcon,
    defaultParentIcon,
    plugins: DEFAULT_TREE_VIEW_PLUGINS,
    rootRef: ref
  });
  const classes = useUtilityClasses(themeProps);
  const rootProps = useSlotProps({
    elementType: TreeViewRoot,
    externalSlotProps: {},
    externalForwardedProps: other,
    className: classes.root,
    getSlotProps: getRootProps,
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewProvider, {
    value: contextValue,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TreeViewRoot, _extends$2({}, rootProps, {
      children: children2
    }))
  });
});
var ExpandMore = {};
var createSvgIcon = {};
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(utils);
var hasRequiredCreateSvgIcon;
function requireCreateSvgIcon() {
  if (hasRequiredCreateSvgIcon) return createSvgIcon;
  hasRequiredCreateSvgIcon = 1;
  (function(exports) {
    "use client";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return _utils.createSvgIcon;
      }
    });
    var _utils = require$$0;
  })(createSvgIcon);
  return createSvgIcon;
}
var hasRequiredExpandMore;
function requireExpandMore() {
  if (hasRequiredExpandMore) return ExpandMore;
  hasRequiredExpandMore = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(ExpandMore, "__esModule", {
    value: true
  });
  ExpandMore.default = void 0;
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _jsxRuntime = requireJsxRuntime();
  ExpandMore.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
  }), "ExpandMore");
  return ExpandMore;
}
var ExpandMoreExports = /* @__PURE__ */ requireExpandMore();
const ExpandMoreIcon = /* @__PURE__ */ getDefaultExportFromCjs(ExpandMoreExports);
var ChevronRight = {};
var hasRequiredChevronRight;
function requireChevronRight() {
  if (hasRequiredChevronRight) return ChevronRight;
  hasRequiredChevronRight = 1;
  var _interopRequireDefault = requireInteropRequireDefault();
  Object.defineProperty(ChevronRight, "__esModule", {
    value: true
  });
  ChevronRight.default = void 0;
  var _createSvgIcon = _interopRequireDefault(/* @__PURE__ */ requireCreateSvgIcon());
  var _jsxRuntime = requireJsxRuntime();
  ChevronRight.default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
    d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
  }), "ChevronRight");
  return ChevronRight;
}
var ChevronRightExports = /* @__PURE__ */ requireChevronRight();
const ChevronRightIcon = /* @__PURE__ */ getDefaultExportFromCjs(ChevronRightExports);
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush(array2, values2) {
    var index = -1, length2 = values2.length, offset = array2.length;
    while (++index < length2) {
      array2[offset + index] = values2[index];
    }
    return array2;
  }
  _arrayPush = arrayPush;
  return _arrayPush;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable) return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten) return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index = -1, length2 = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index < length2) {
      var value = array2[index];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey) return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey = isKey;
  return _isKey;
}
var memoize_1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize) return memoize_1;
  hasRequiredMemoize = 1;
  var MapCache = require_MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache)();
    return memoized;
  }
  memoize2.Cache = MapCache;
  memoize_1 = memoize2;
  return memoize_1;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped) return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath) return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match2, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath) return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();
  function castPath(value, object2) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey) return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet) return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object2, path2) {
    path2 = castPath(path2, object2);
    var index = 0, length2 = path2.length;
    while (object2 != null && index < length2) {
      object2 = object2[toKey(path2[index++])];
    }
    return index && index == length2 ? object2 : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd) return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas) return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache) return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache();
    while (++index < length2) {
      this.add(values2[index]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome) return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index < length2) {
      if (predicate(array2[index], index, array2)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas) return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays) return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while (++index < arrLength) {
      var arrValue = array2[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray) return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray) return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set2) {
    var index = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag) return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol(), Uint8Array2 = require_Uint8Array(), eq = requireEq(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
        stack["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush = require_arrayPush(), isArray = requireIsArray();
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array2, predicate) {
    var index = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index < length2) {
      var value = array2[index];
      if (predicate(value, index, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto = Object.prototype;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol) {
      return propertyIsEnumerable.call(object2, symbol);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1 = keys;
  return keys_1;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys = requireKeys();
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects) return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack.get(object2);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var getNative = require_getNative(), root2 = require_root();
  var DataView2 = getNative(root2, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Promise2 = getNative(root2, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var getNative = require_getNative(), root2 = require_root();
  var Set2 = getNative(root2, "Set");
  _Set = Set2;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative = require_getNative(), root2 = require_root();
  var WeakMap2 = getNative(root2, "WeakMap");
  _WeakMap = WeakMap2;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag = require_baseGetTag(), toSource = require_toSource();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray = requireIsTypedArray();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object2)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual) return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike();
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch) return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object2, source, matchData, customizer) {
    var index = matchData.length, length2 = index, noCustomizer = !customizer;
    if (object2 == null) {
      return !length2;
    }
    object2 = Object(object2);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
        return false;
      }
    }
    while (++index < length2) {
      data = matchData[index];
      var key = data[0], objValue = object2[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object2, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable) return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject = requireIsObject();
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData) return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys = requireKeys();
  function getMatchData(object2) {
    var result = keys(object2), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object2[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches) return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet();
  function get2(object2, path2, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path2);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn) return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath) return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath(path2, object2);
    var index = -1, length2 = path2.length, result = false;
    while (++index < length2) {
      var key = toKey(path2[index]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index != length2) {
      return result;
    }
    length2 = object2 == null ? 0 : object2.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn) return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn(), isKey = require_isKey(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path2, srcValue) {
    if (isKey(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object2) {
      var objValue = get2(object2, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty) return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep) return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet();
  function basePropertyDeep(path2) {
    return function(object2) {
      return baseGet(object2, path2);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty) return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey(), toKey = require_toKey();
  function property(path2) {
    return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee) return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity(), isArray = requireIsArray(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity2;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn) return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys = requireKeys();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach) return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index-- : ++index < length2) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach) return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap) return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach(), isArrayLike = requireIsArrayLike();
  function baseMap(collection, iteratee) {
    var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy) return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array2, comparer) {
    var length2 = array2.length;
    array2.sort(comparer);
    while (length2--) {
      array2[length2] = array2[length2].value;
    }
    return array2;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending) return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple) return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object2, other, orders) {
    var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
    while (++index < length2) {
      var result = compareAscending(objCriteria[index], othCriteria[index]);
      if (result) {
        if (index >= ordersLength) {
          return result;
        }
        var order = orders[index];
        return result * (order == "desc" ? -1 : 1);
      }
    }
    return object2.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy) return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap(), baseGet = require_baseGet(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity(), isArray = requireIsArray();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity2];
    }
    var index = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index, "value": value };
    });
    return baseSortBy(result, function(object2, other) {
      return compareMultiple(object2, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy) return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest(), isIterateeCall = require_isIterateeCall();
  var sortBy2 = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length2 = iteratees.length;
    if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy2;
  return sortBy_1;
}
var sortByExports = requireSortBy();
const sortBy = /* @__PURE__ */ getDefaultExportFromCjs(sortByExports);
const getNodeIDs$1 = (state) => state.node.ids;
const getNodeType = (state) => state.node.type;
const getNodeTypeIDs = (state) => state.nodeType.ids;
const getNodeTypeName = (state) => state.nodeType.name;
const getNodeTypeDisabled = (state) => state.nodeType.disabled;
const isModularPipelineType = (type) => type === "modularPipeline";
const getTypeNodeCount = createSelector(
  [getNodeTypeIDs, getNodeIDs$1, getNodeType, getNodeDisabled],
  (types, nodeIDs, nodeType, nodeDisabled) => arrayToObject(types, (type) => {
    const typeNodeIDs = nodeIDs.filter((nodeID) => nodeType[nodeID] === type);
    const visibleTypeNodeIDs = typeNodeIDs.filter(
      (nodeID) => !nodeDisabled[nodeID]
    );
    return {
      total: typeNodeIDs.length,
      visible: visibleTypeNodeIDs.length
    };
  })
);
const getNodeTypes = createSelector(
  [getNodeTypeIDs, getNodeTypeName, getNodeTypeDisabled, getTypeNodeCount],
  (types, typeName, typeDisabled, typeNodeCount) => types.map((id2) => ({
    id: id2,
    name: typeName[id2],
    disabled: typeDisabled[id2],
    nodeCount: typeNodeCount[id2]
  }))
);
const VisibleIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M11.5 5.706c4.142 0 7.5 4.662 7.5 5.625 0 .963-3.358 5.625-7.5 5.625-4.142 0-7.5-4.632-7.5-5.625 0-.993 3.358-5.625 7.5-5.625zm0 1.875a3.75 3.75 0 100 7.5 3.75 3.75 0 000-7.5zm0 1.875a1.875 1.875 0 110 3.75 1.875 1.875 0 010-3.75z" }) });
const InvisibleIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M17.97 5.3L19 6.33l-2 2.01c1.24 1.23 2 2.53 2 3 0 .95-3.36 5.62-7.5 5.62-.9 0-1.76-.22-2.55-.57L6.33 19 5.3 17.97 17.97 5.3zm-2.88 4.94l-1.9 1.9c-.18.39-.5.7-.88.88l-1.9 1.9a3.74 3.74 0 004.84-3.59c0-.38-.06-.74-.16-1.09zM11.5 5.71c1 0 1.95.27 2.83.7l-1.45 1.44a3.74 3.74 0 00-4.87 4.86l-1.8 1.81C4.83 13.24 4 11.82 4 11.33c0-1 3.36-5.63 7.5-5.63zm-.24 3.76L9.64 11.1c.11-.84.77-1.5 1.61-1.62z" }) });
const FocusModeIcon = ({ className, checked }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    className,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M5 0L5 2 2 2 2 5 0 5 0 0z",
          transform: "translate(-258 -194) translate(258 194) translate(6 6)"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M12 0L12 2 9 2 9 5 7 5 7 0z",
          transform: "translate(-258 -194) translate(258 194) translate(6 6) rotate(90 9.5 2.5)"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M12 7L12 9 9 9 9 12 7 12 7 7z",
          transform: "translate(-258 -194) translate(258 194) translate(6 6) rotate(-180 9.5 9.5)"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "path",
        {
          d: "M5 7L5 9 2 9 2 12 0 12 0 7z",
          transform: "translate(-258 -194) translate(258 194) translate(6 6) rotate(-90 2.5 9.5)"
        }
      )
    ] })
  }
);
const NodeListRow = ({
  active,
  checked,
  children: children2,
  dataTest,
  disabled,
  faded,
  focused,
  focusModeIcon = FocusModeIcon,
  highlight,
  icon,
  id: id2,
  invisibleIcon = InvisibleIcon,
  isSlicingPipelineApplied,
  kind,
  label,
  name,
  onChange,
  onClick,
  onMouseEnter,
  onMouseLeave,
  onToggleHoveredFocusMode,
  parentClassName,
  rowType,
  selected,
  type,
  visibleIcon = VisibleIcon
}) => {
  const isModularPipeline = type === "modularPipeline";
  const FocusIcon = isModularPipeline ? focusModeIcon : null;
  const isChecked = isModularPipeline ? checked || focused : checked;
  const VisibilityIcon = isChecked ? visibleIcon : invisibleIcon;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "form",
    {
      className: classnames(
        "node-list-row kedro",
        `node-list-row--kind-${kind}`,
        parentClassName,
        {
          "node-list-row--active": active,
          "node-list-row--selected": selected || !isSlicingPipelineApplied && highlight,
          "node-list-row--overwrite": !(active || selected)
        }
      ),
      "data-test": dataTest,
      title: name,
      onMouseEnter,
      onMouseLeave,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NodeIcon,
          {
            className: classnames(
              "node-list-row__type-icon",
              "node-list-row__icon",
              {
                "node-list-row__type-icon--faded": faded,
                "node-list-row__type-icon--disabled": disabled,
                "node-list-row__type-icon--nested": !children2,
                "node-list-row__type-icon--active": active,
                "node-list-row__type-icon--selected": selected
              }
            ),
            icon
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RowText,
          {
            dataTest,
            disabled,
            faded,
            kind,
            label,
            name,
            onClick,
            onMouseEnter,
            onMouseLeave,
            rowType
          }
        ),
        VisibilityIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleControl,
          {
            className: "node-list-row__icon",
            disabled: isModularPipeline ? focused : disabled,
            focusChecked: isModularPipeline ? false : focused,
            IconComponent: VisibilityIcon,
            id: id2,
            isChecked,
            kind,
            name,
            onChange,
            selected
          }
        ),
        FocusIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ToggleControl,
          {
            className: "node-list-row__icon",
            disabled,
            focusChecked: focused,
            IconComponent: FocusIcon,
            id: id2 + "-focus",
            isChecked,
            kind,
            name,
            onChange,
            onToggleHoveredFocusMode,
            selected,
            dataIconType: "focus"
          }
        )
      ]
    }
  );
};
const arrowIconColor = "#8e8e90";
const NodeListTreeItem = ({
  data,
  onItemClick,
  onItemMouseEnter,
  onItemMouseLeave,
  onItemChange,
  onToggleHoveredFocusMode,
  children: children2,
  isSlicingPipelineApplied
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  TreeItem,
  {
    className: classnames("pipeline-treeItem__root--overwrite", {
      "pipeline-treeItem__root--overwrite--focused": data.focused,
      "pipeline-treeItem__root--overwrite--disabled": data.disabled
    }),
    nodeId: data.id,
    collapseIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandMoreIcon, { style: { color: arrowIconColor } }),
    expandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, { style: { color: arrowIconColor } }),
    label: /* @__PURE__ */ jsxRuntimeExports.jsx(
      NodeListRow,
      {
        active: data.active,
        checked: data.checked,
        dataTest: getDataTestAttribute("node-list-tree-item", "row"),
        disabled: data.disabled,
        faded: data.faded,
        focused: data.focused,
        focusModeIcon: data.focusModeIcon,
        highlight: data.highlight,
        icon: data.icon,
        id: data.id,
        invisibleIcon: data.invisibleIcon,
        isSlicingPipelineApplied,
        kind: "element",
        label: data.highlightedLabel || data.name,
        name: data.name,
        onChange: (e) => onItemChange(data, !e.target.checked, e.target.dataset.iconType),
        onClick: (e) => onItemClick(e, data),
        onMouseEnter: () => onItemMouseEnter(data),
        onMouseLeave: () => onItemMouseLeave(data),
        onToggleHoveredFocusMode,
        parentClassName: "node-list-tree-item-row",
        rowType: "tree",
        selected: data.selected,
        type: data.type,
        visible: data.visible,
        visibleIcon: data.visibleIcon
      },
      data.id
    ),
    children: children2
  },
  data.id
);
const GROUPED_NODES_DISPLAY_ORDER = {
  modularPipeline: 0,
  task: 1,
  data: 2,
  parameter: 3
};
const StyledTreeView = styled$1(TreeView)({
  root: {
    height: 110,
    flexGrow: 1,
    maxWidth: 400
  },
  padding: "0 0 0 20px"
});
const getModularPipelineRowData = ({
  id: id2,
  highlightedLabel,
  data,
  disabled,
  focused,
  focusModeIcon,
  highlight
}) => {
  const checked = !data.disabledModularPipeline;
  return {
    id: id2,
    name: highlightedLabel || data.name,
    type: "modularPipeline",
    icon: "modularPipeline",
    focusModeIcon,
    active: data.active,
    selected: false,
    faded: disabled || !checked,
    visible: !disabled && checked,
    enabled: true,
    disabled,
    focused,
    checked,
    highlight
  };
};
const getNodeRowData = (node2, disabled, hoveredNode, selected, highlight) => {
  const checked = !node2.disabledNode;
  return {
    ...node2,
    visibleIcon: VisibleIcon,
    invisibleIcon: InvisibleIcon,
    active: node2.active || hoveredNode === node2.id,
    selected,
    highlight,
    faded: disabled || !checked,
    visible: !disabled && checked,
    checked,
    disabled
  };
};
const TreeListProvider = ({
  hoveredNode,
  nodeSelected,
  modularPipelinesSearchResult,
  modularPipelinesTree,
  onItemChange,
  onItemMouseEnter,
  onItemMouseLeave,
  onToggleHoveredFocusMode,
  onItemClick,
  onNodeToggleExpanded,
  focusMode,
  expanded,
  onToggleNodeSelected,
  slicedPipeline,
  isSlicingPipelineApplied,
  isWorkflowView,
  nodesDisabledViaModularPipeline
}) => {
  const renderLeafNode = (node2) => {
    if (!node2 || Object.keys(node2).length === 0) {
      return null;
    }
    const disabled = node2.disabledTag || node2.disabledType || nodesDisabledViaModularPipeline[node2.id];
    const selected = nodeSelected[node2.id];
    const highlight = slicedPipeline.includes(node2.id);
    const data = getNodeRowData(
      node2,
      disabled,
      hoveredNode,
      selected,
      highlight
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NodeListTreeItem,
      {
        data,
        onItemMouseEnter,
        onItemMouseLeave,
        onItemChange,
        onToggleHoveredFocusMode,
        onItemClick,
        isSlicingPipelineApplied
      },
      uniqueId(node2.id)
    );
  };
  const renderTree = (tree, modularPipelineID) => {
    const node2 = tree[modularPipelineID];
    if (!node2) {
      return;
    }
    const allChildrenDataEmpty = node2.children.every(
      (child) => Object.keys(child.data).length === 0
    );
    if (allChildrenDataEmpty) {
      return;
    }
    const children2 = sortBy(
      node2.children,
      (child) => GROUPED_NODES_DISPLAY_ORDER[child.type],
      (child) => {
        var _a;
        return (_a = child == null ? void 0 : child.data) == null ? void 0 : _a.name;
      }
    ).map(
      (child) => isModularPipelineType(child.type) ? renderTree(tree, child.id) : renderLeafNode(child.data)
    );
    if (modularPipelineID === "__root__") {
      return children2;
    }
    const isFocusedModularPipeline = (focusMode == null ? void 0 : focusMode.id) === node2.id;
    let focusModeIcon;
    if (!focusMode) {
      focusModeIcon = FocusModeIcon;
    } else {
      focusModeIcon = isFocusedModularPipeline ? FocusModeIcon : null;
    }
    const isModularPipelineCollapsed = !expanded.includes(node2.id);
    const highlight = node2.children.some((child) => slicedPipeline.includes(child.id)) && isModularPipelineCollapsed;
    const data = getModularPipelineRowData({
      ...node2,
      focusModeIcon,
      disabled: nodesDisabledViaModularPipeline[node2.id],
      focused: isFocusedModularPipeline,
      highlight
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      NodeListTreeItem,
      {
        data,
        onItemMouseEnter,
        onItemMouseLeave,
        onItemChange,
        onToggleHoveredFocusMode,
        onItemClick,
        isSlicingPipelineApplied,
        children: children2
      },
      uniqueId(node2.id)
    );
  };
  const onItemExpandCollapseToggle = (event, expandedItemIds) => {
    onNodeToggleExpanded(expandedItemIds);
    if (expandedItemIds.length === 0) {
      onToggleNodeSelected(null);
    }
  };
  return modularPipelinesSearchResult ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    StyledTreeView,
    {
      expanded: Object.keys(modularPipelinesSearchResult),
      defaultCollapseIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandMoreIcon, {}),
      defaultExpandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, {}),
      children: renderTree(modularPipelinesSearchResult, "__root__")
    },
    "modularPipelinesSearchResult"
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    StyledTreeView,
    {
      expanded,
      defaultCollapseIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandMoreIcon, {}),
      defaultExpandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightIcon, {}),
      onNodeToggle: isWorkflowView ? null : onItemExpandCollapseToggle,
      children: renderTree(modularPipelinesTree, "__root__")
    },
    "modularPipelinesTree"
  );
};
const SplitPanel = ({
  splitDefault = 0.65,
  splitMin = 0,
  splitMax = 1,
  keyboardStep = 0.025,
  orientation = "vertical",
  children: children2
}) => {
  const containerRef = reactExports.useRef();
  const handleRef = reactExports.useRef();
  const getRects = () => {
    var _a, _b;
    return {
      container: (_a = containerRef.current) == null ? void 0 : _a.getBoundingClientRect(),
      handle: (_b = handleRef.current) == null ? void 0 : _b.getBoundingClientRect()
    };
  };
  const clamp2 = (splitValue) => {
    const rects = getRects();
    const handleSize = rects.handle ? rects.handle.height / rects.container.height : 0;
    if (splitValue < splitMin) {
      return splitMin;
    }
    if (splitValue > splitMax - handleSize) {
      return splitMax - handleSize;
    }
    return splitValue;
  };
  const [isResizing, setIsResizing] = reactExports.useState(false);
  const [split, setSplit] = reactExports.useState(clamp2(splitDefault));
  const onMouse = (event) => {
    if (event.type === "mouseup") {
      setIsResizing(false);
      return;
    }
    if (isResizing || event.type === "mousedown") {
      const rects = getRects();
      const mouseOffsetVertical = (event.clientY - rects.container.top - rects.handle.height * 0.5) / rects.container.height;
      setIsResizing(true);
      setSplit(clamp2(mouseOffsetVertical));
      event.preventDefault();
    }
  };
  const onKey = (event) => {
    const keyboardOffset = {
      ArrowUp: -keyboardStep,
      ArrowLeft: -keyboardStep,
      ArrowDown: keyboardStep,
      ArrowRight: keyboardStep
    }[event.key] || 0;
    if (keyboardOffset) {
      setSplit(clamp2(split + keyboardOffset));
      event.preventDefault();
    }
  };
  return children2({
    isResizing,
    split,
    props: {
      container: {
        ref: containerRef,
        onMouseMove: onMouse,
        onMouseUp: onMouse
      },
      panelA: { style: { height: split * 100 + "%" } },
      panelB: { style: { height: (1 - split) * 100 + "%" } },
      handle: {
        ref: handleRef,
        role: "separator",
        "aria-orientation": orientation,
        tabIndex: "0",
        onMouseUp: onMouse,
        onMouseDown: onMouse,
        onKeyDown: onKey
      }
    }
  });
};
const PartialIndicatorIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("rect", { x: "6.5", y: "10.5", width: "8", height: "1.5" }) });
const isTagType = (type) => type === "tag";
const isElementType = (type) => type === "elementType";
const getNodeIDs = (nodeGroups) => Object.values(nodeGroups).flatMap((nodes) => nodes.map((node2) => node2.id));
const getFiltersSearchResult = (nodeGroups, searchValue) => {
  const highlightedGroups = {};
  for (const type of Object.keys(nodeGroups)) {
    highlightedGroups[type] = nodeGroups[type].map((node2) => {
      if (node2.name.toLowerCase().includes(searchValue.toLowerCase())) {
        return {
          ...node2,
          highlightedLabel: getHighlightedText(node2.name, searchValue)
        };
      }
      return void 0;
    }).filter((node2) => node2 !== void 0);
  }
  return highlightedGroups;
};
const nodeMatchesSearch = (node2, searchValue) => {
  if (searchValue) {
    return new RegExp(escapeRegExp(searchValue), "gi").test(node2.name);
  }
  return true;
};
const filterNodeGroups = (nodeGroups, searchValue) => {
  const filteredGroups = {};
  for (const nodeGroupId of Object.keys(nodeGroups)) {
    filteredGroups[nodeGroupId] = nodeGroups[nodeGroupId].filter(
      (node2) => nodeMatchesSearch(node2, searchValue)
    );
  }
  return filteredGroups;
};
const getFilteredNodes = createSelector(
  [(state) => state.nodes, (state) => state.searchValue],
  (nodeGroups, searchValue) => {
    const filteredGroups = filterNodeGroups(nodeGroups, searchValue);
    return {
      filteredNodes: getFiltersSearchResult(filteredGroups, searchValue),
      nodeIDs: getNodeIDs(filteredGroups)
    };
  }
);
const getFilteredTags = createSelector(
  [(state) => state.tags, (state) => state.searchValue],
  (tags2, searchValue) => getFiltersSearchResult(
    filterNodeGroups({ tag: tags2 }, searchValue),
    searchValue
  )
);
const getFilteredTagItems = createSelector(
  [getFilteredTags, (state) => state.tagNodeCounts],
  (filteredTags, tagNodeCounts = {}) => ({
    tag: filteredTags.tag.map((tag) => ({
      ...tag,
      type: "tag",
      visibleIcon: IndicatorIcon,
      invisibleIcon: OffIndicatorIcon,
      active: false,
      selected: false,
      faded: false,
      visible: true,
      disabled: false,
      checked: tag.enabled,
      count: tagNodeCounts[tag.id] || 0
    }))
  })
);
const getFilteredElementTypes = createSelector(
  [(state) => state.searchValue],
  (searchValue) => getFiltersSearchResult(
    filterNodeGroups(
      {
        elementType: Object.entries(sidebarElementTypes).map(
          ([type, name]) => ({
            id: type,
            name
          })
        )
      },
      searchValue
    ),
    searchValue
  )
);
const getFilteredElementTypeItems = createSelector(
  [getFilteredElementTypes, (state) => state.nodeTypes],
  (filteredElementTypes, nodeTypes) => ({
    elementType: filteredElementTypes.elementType.map((elementType) => {
      const nodeType = nodeTypes.find((type) => type.id === elementType.id);
      return {
        ...elementType,
        type: "elementType",
        visibleIcon: IndicatorIcon,
        invisibleIcon: OffIndicatorIcon,
        active: false,
        selected: false,
        faded: false,
        visible: true,
        disabled: false,
        checked: nodeType.disabled === false,
        count: nodeType.nodeCount.total
      };
    })
  })
);
const compareEnabledThenAlpha = (itemA, itemB) => {
  const byEnabledTag = Number(itemA.disabledTag) - Number(itemB.disabledTag);
  const byAlpha = itemA.name.localeCompare(itemB.name);
  return byEnabledTag !== 0 ? byEnabledTag : byAlpha;
};
createSelector(
  [
    getFilteredNodes,
    (state) => state.nodeSelected,
    (state) => state.focusMode,
    (state) => state.inputOutputDataNodes
  ],
  ({ filteredNodes }, nodeSelected, focusMode, inputOutputDataNodes) => {
    const filteredNodeItems = {};
    for (const type of Object.keys(filteredNodes)) {
      filteredNodeItems[type] = filteredNodes[type].map((node2) => {
        const checked = !node2.disabledNode;
        const disabled = node2.disabledTag || node2.disabledType || focusMode !== null && !!inputOutputDataNodes[node2.id];
        return {
          ...node2,
          visibleIcon: VisibleIcon,
          invisibleIcon: InvisibleIcon,
          active: void 0,
          selected: nodeSelected[node2.id],
          faded: disabled || node2.disabledNode,
          visible: !disabled && checked,
          checked,
          disabled
        };
      }).sort(compareEnabledThenAlpha);
    }
    return filteredNodeItems;
  }
);
const getGroups = createSelector([(state) => state.items], (items) => {
  const groups = {};
  for (const [type, name] of Object.entries(sidebarGroups)) {
    const itemsOfType = items[type] || [];
    const allUnchecked = itemsOfType.every((item) => !item.checked);
    const allChecked = itemsOfType.every((item) => item.checked);
    groups[type] = {
      type,
      name,
      id: type,
      kind: "filter",
      allUnchecked: itemsOfType.every((item) => !item.checked),
      allChecked: itemsOfType.every((item) => item.checked),
      checked: !allUnchecked,
      visibleIcon: allChecked ? IndicatorIcon : PartialIndicatorIcon,
      invisibleIcon: OffIndicatorIcon
    };
  }
  return groups;
});
const getFilteredItems = createSelector(
  [getFilteredTagItems, getFilteredElementTypeItems],
  (filteredTagItems, filteredElementTypeItems) => ({
    ...filteredTagItems,
    ...filteredElementTypeItems
  })
);
const storedState = loadLocalStorage(localStorageName);
const useFiltersContextSelector = () => {
  const dispatch2 = useDispatch();
  const tags2 = useSelector(getTagData);
  const nodes = useSelector(getGroupedNodes);
  const nodeTypes = useSelector(getNodeTypes);
  const tagNodeCounts = useSelector(getTagNodeCounts);
  const nodeSelected = useSelector(getNodeSelected);
  const focusMode = useSelector(getFocusedModularPipeline);
  const inputOutputDataNodes = useSelector(
    getInputOutputNodesForFocusedModularPipeline
  );
  const onToggleTypeDisabled = (typeID, disabled) => {
    dispatch2(toggleTypeDisabled(typeID, disabled));
  };
  const onToggleTagFilter = (tagIDs, enabled) => {
    dispatch2(toggleTagFilter(tagIDs, enabled));
  };
  const onToggleNodeSelected = (nodeID) => {
    dispatch2(loadNodeData(nodeID));
  };
  const onToggleNodeHovered = (nodeID) => {
    dispatch2(toggleNodeHovered(nodeID));
  };
  return {
    tags: tags2,
    nodes,
    nodeTypes,
    tagNodeCounts,
    nodeSelected,
    focusMode,
    inputOutputDataNodes,
    onToggleTypeDisabled,
    onToggleTagFilter,
    onToggleNodeSelected,
    onToggleNodeHovered
  };
};
const FiltersContext = reactExports.createContext();
const FiltersContextProvider = ({ children: children2 }) => {
  const {
    tags: tags2,
    nodes,
    nodeTypes,
    tagNodeCounts,
    nodeSelected,
    focusMode,
    inputOutputDataNodes,
    onToggleTypeDisabled,
    onToggleTagFilter,
    onToggleNodeSelected,
    onToggleNodeHovered
  } = useFiltersContextSelector();
  const [groupCollapsed, setGroupCollapsed] = reactExports.useState(
    storedState.groupsCollapsed || {}
  );
  const [isResetFilterActive, setIsResetFilterActive] = reactExports.useState(false);
  const hasModifiedNodeTypes = (nodeTypes2) => {
    return nodeTypes2.some(
      (item) => {
        var _a;
        return ((_a = NODE_TYPES[item.id]) == null ? void 0 : _a.defaultState) !== item.disabled;
      }
    );
  };
  reactExports.useEffect(() => {
    const isNodeTypeModified = hasModifiedNodeTypes(nodeTypes);
    const isNodeTagModified = tags2.some((tag) => tag.enabled);
    setIsResetFilterActive(isNodeTypeModified || isNodeTagModified);
  }, [tags2, nodeTypes]);
  const {
    toUpdateUrlParamsOnResetFilter,
    toUpdateUrlParamsOnFilter,
    toSetQueryParam
  } = useGeneratePathname();
  const handleResetFilter = () => {
    onToggleTypeDisabled({ task: false, data: false, parameters: true });
    onToggleTagFilter(
      tags2.map((item) => item.id),
      false
    );
    toUpdateUrlParamsOnResetFilter();
  };
  const handleToggleGroupCollapsed = (groupID) => {
    const updatedGroupCollapsed = {
      ...groupCollapsed,
      [groupID]: !groupCollapsed[groupID]
    };
    setGroupCollapsed(updatedGroupCollapsed);
    saveLocalStorage(localStorageName, {
      groupsCollapsed: updatedGroupCollapsed
    });
  };
  const items = getFilteredItems({
    nodes,
    tags: tags2,
    nodeTypes,
    tagNodeCounts,
    nodeSelected,
    searchValue: "",
    focusMode,
    inputOutputDataNodes
  });
  const groups = getGroups({ items });
  const getExistingValuesFromUrlQueryParams = (paramName, searchParams) => {
    const paramValues = searchParams.get(paramName);
    return new Set(paramValues ? paramValues.split(",") : []);
  };
  const handleUrlParamsUpdateOnFilter = (item) => {
    const searchParams = new URLSearchParams(window.location.search);
    const paramName = isElementType(item.type) ? params.types : params.tags;
    const existingValues = getExistingValuesFromUrlQueryParams(
      paramName,
      searchParams
    );
    toUpdateUrlParamsOnFilter(item, paramName, existingValues);
  };
  const handleUrlParamsUpdateOnGroupFilter = (groupType, groupItems, groupItemsDisabled) => {
    if (groupItemsDisabled) {
      groupItems.forEach((item) => {
        handleUrlParamsUpdateOnFilter(item);
      });
    } else {
      const paramName = isElementType(groupType) ? params.types : params.tags;
      toSetQueryParam(paramName, []);
    }
  };
  const handleGroupToggleChanged = (groupType) => {
    const groupItems = items[groupType] || [];
    const groupItemsDisabled = groupItems.every(
      (groupItem) => !groupItem.checked
    );
    handleUrlParamsUpdateOnGroupFilter(
      groupType,
      groupItems,
      groupItemsDisabled
    );
    if (isTagType(groupType)) {
      onToggleTagFilter(
        groupItems.map((item) => item.id),
        groupItemsDisabled
      );
    } else if (isElementType(groupType)) {
      onToggleTypeDisabled(
        groupItems.reduce(
          (state, item) => ({ ...state, [item.id]: !groupItemsDisabled }),
          {}
        )
      );
    }
  };
  const onGroupItemChange = (item, wasChecked) => {
    if (isTagType(item.type)) {
      onToggleTagFilter(item.id, !wasChecked);
    } else if (isElementType(item.type)) {
      onToggleTypeDisabled({ [item.id]: wasChecked });
    }
    onToggleNodeSelected(null);
    onToggleNodeHovered(null);
  };
  const handleFiltersRowClicked = (event, item) => {
    onGroupItemChange(item, item.checked);
    handleUrlParamsUpdateOnFilter(item);
    event.preventDefault();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    FiltersContext.Provider,
    {
      value: {
        groupCollapsed,
        groups,
        isResetFilterActive,
        items,
        handleGroupToggleChanged,
        handleResetFilter,
        handleToggleGroupCollapsed,
        handleFiltersRowClicked
      },
      children: children2
    }
  );
};
const useNodeListContextSelector = () => {
  const dispatch2 = useDispatch();
  const hoveredNode = useSelector((state) => state.node.hovered);
  const selectedNodes = useSelector(getNodeSelected);
  const nodesDisabledViaModularPipeline = useSelector(
    getnodesDisabledViaModularPipeline
  );
  const expanded = useSelector((state) => state.modularPipeline.expanded);
  const slicedPipeline = useSelector(getSlicedPipeline);
  const modularPipelinesTree = useSelector(getModularPipelinesTree$1);
  const isSlicingPipelineApplied = useSelector((state) => state.slice.apply);
  const focusMode = useSelector(getFocusedModularPipeline);
  const disabledModularPipeline = useSelector(
    (state) => state.modularPipeline.disabled
  );
  const view = useSelector((state) => state.view);
  const onToggleFocusMode = (modularPipeline) => {
    dispatch2(toggleFocusMode(modularPipeline));
  };
  const onToggleHoveredFocusMode = (active) => {
    dispatch2(toggleHoveredFocusMode(active));
  };
  const onToggleNodeSelected = (nodeID) => {
    dispatch2(loadNodeData(nodeID));
  };
  const onToggleNodeHovered = (nodeID) => {
    dispatch2(toggleNodeHovered(nodeID));
  };
  const onToggleNodesDisabled = (nodeIDs, disabled) => {
    dispatch2(toggleNodesDisabled(nodeIDs, disabled));
  };
  const onToggleModularPipelineExpanded = (expanded2) => {
    dispatch2(toggleModularPipelinesExpanded(expanded2));
  };
  const onToggleModularPipelineDisabled = (modularPipelineIDs, disabled) => {
    dispatch2(toggleModularPipelineDisabled(modularPipelineIDs, disabled));
  };
  const onToggleModularPipelineActive = (modularPipelineIDs, active) => {
    dispatch2(toggleModularPipelineActive(modularPipelineIDs, active));
  };
  const onResetSlicePipeline = () => {
    dispatch2(resetSlicePipeline());
  };
  return {
    disabledModularPipeline,
    expanded,
    focusMode,
    hoveredNode,
    isSlicingPipelineApplied,
    modularPipelinesTree,
    selectedNodes,
    slicedPipeline,
    nodesDisabledViaModularPipeline,
    view,
    onResetSlicePipeline,
    onToggleFocusMode,
    onToggleHoveredFocusMode,
    onToggleModularPipelineActive,
    onToggleModularPipelineDisabled,
    onToggleModularPipelineExpanded,
    onToggleNodeHovered,
    onToggleNodesDisabled,
    onToggleNodeSelected
  };
};
const NodeListContext = reactExports.createContext();
const NodeListContextProvider = ({ children: children2 }) => {
  const {
    disabledModularPipeline,
    expanded,
    focusMode,
    hoveredNode,
    isSlicingPipelineApplied,
    modularPipelinesTree,
    selectedNodes,
    slicedPipeline,
    nodesDisabledViaModularPipeline,
    view,
    onResetSlicePipeline,
    onToggleFocusMode,
    onToggleHoveredFocusMode,
    onToggleModularPipelineActive,
    onToggleModularPipelineDisabled,
    onToggleModularPipelineExpanded,
    onToggleNodeHovered,
    onToggleNodesDisabled,
    onToggleNodeSelected
  } = useNodeListContextSelector();
  const { toSelectedPipeline, toSelectedNode, toFocusedModularPipeline } = useGeneratePathname();
  const handleNodeListRowClicked = (event, item) => {
    if (isModularPipelineType(item.type)) {
      onToggleNodeSelected(null);
    } else {
      if (item.faded || item.selected) {
        onToggleNodeSelected(null);
        toSelectedPipeline();
      } else {
        onToggleNodeSelected(item.id);
        toSelectedNode(item);
        if (!isSlicingPipelineApplied) {
          onResetSlicePipeline();
        }
      }
    }
    event.preventDefault();
  };
  const handleNodeListRowChanged = (item, checked, clickedIconType) => {
    if (isModularPipelineType(item.type)) {
      if (clickedIconType === "focus") {
        if (focusMode === null) {
          onToggleFocusMode(item);
          toFocusedModularPipeline(item);
          if (disabledModularPipeline[item.id]) {
            onToggleModularPipelineDisabled([item.id], checked);
          }
        } else {
          onToggleFocusMode(null);
          toSelectedPipeline();
        }
      } else {
        onToggleModularPipelineDisabled([item.id], checked);
        onToggleModularPipelineActive([item.id], false);
      }
    } else {
      if (checked) {
        onToggleNodeHovered(null);
      }
      onToggleNodesDisabled([item.id], checked);
    }
    onToggleNodeSelected(null);
    onToggleNodeHovered(null);
  };
  const handleItemMouseEnter = (item) => {
    if (isModularPipelineType(item.type)) {
      onToggleModularPipelineActive(item.id, true);
      return;
    }
    if (item.visible) {
      onToggleNodeHovered(item.id);
    }
  };
  const handleItemMouseLeave = (item) => {
    if (isModularPipelineType(item.type)) {
      onToggleModularPipelineActive(item.id, false);
      return;
    }
    if (item.visible) {
      onToggleNodeHovered(null);
    }
  };
  const handleToggleHoveredFocusMode = (active) => {
    onToggleHoveredFocusMode(active);
  };
  const handleKeyDown2 = (event) => {
    if (event.keyCode === 27) {
      onToggleNodeSelected(null);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    NodeListContext.Provider,
    {
      value: {
        expanded,
        focusMode,
        hoveredNode,
        isSlicingPipelineApplied,
        modularPipelinesTree,
        selectedNodes,
        slicedPipeline,
        nodesDisabledViaModularPipeline,
        isWorkflowView: view === VIEW.WORKFLOW,
        handleModularPipelineToggleExpanded: onToggleModularPipelineExpanded,
        handleNodeListRowClicked,
        handleNodeListRowChanged,
        handleItemMouseEnter,
        handleItemMouseLeave,
        handleToggleHoveredFocusMode,
        handleKeyDown: handleKeyDown2
      },
      children: children2
    }
  );
};
const NodesPanel = ({ visible, faded }) => {
  const [searchValue, updateSearchValue] = reactExports.useState("");
  const {
    groupCollapsed,
    groups,
    isResetFilterActive,
    items,
    handleGroupToggleChanged,
    handleResetFilter,
    handleToggleGroupCollapsed,
    handleFiltersRowClicked
  } = reactExports.useContext(FiltersContext);
  const {
    hoveredNode,
    expanded,
    focusMode,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown: handleKeyDown2,
    handleModularPipelineToggleExpanded,
    handleNodeListRowChanged,
    handleNodeListRowClicked,
    handleToggleHoveredFocusMode,
    isSlicingPipelineApplied,
    isWorkflowView,
    modularPipelinesTree,
    selectedNodes,
    slicedPipeline,
    nodesDisabledViaModularPipeline
  } = reactExports.useContext(NodeListContext);
  const modularPipelinesSearchResult = searchValue ? getModularPipelinesSearchResult(modularPipelinesTree, searchValue) : null;
  const filtersSearchResult = searchValue ? getFiltersSearchResult(items, searchValue) : null;
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleKeyDown2);
    return () => window.removeEventListener("keydown", handleKeyDown2);
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("pipeline-nodelist", {
        "pipeline-nodelist--fade": faded
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SearchList$1,
          {
            onUpdateSearchValue: debounce$1(updateSearchValue, 250),
            searchValue
          }
        ),
        visible ? /* @__PURE__ */ jsxRuntimeExports.jsx(SplitPanel, { children: ({ isResizing, props: { container, panelA, panelB, handle } }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: classnames("pipeline-nodelist__split", {
              "pipeline-nodelist__split--resizing": isResizing
            }),
            ...container,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-nodelist__elements-panel", ...panelA, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                libExports.Scrollbars,
                {
                  className: "pipeline-nodelist-scrollbars",
                  style: { width: "auto" },
                  autoHide: true,
                  hideTracksWhenNotNeeded: true,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-nodelist-section", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    TreeListProvider,
                    {
                      hoveredNode,
                      expanded,
                      faded,
                      focusMode,
                      isSlicingPipelineApplied,
                      modularPipelinesSearchResult,
                      isWorkflowView,
                      modularPipelinesTree,
                      nodeSelected: selectedNodes,
                      onItemChange: handleNodeListRowChanged,
                      onItemClick: handleNodeListRowClicked,
                      onItemMouseEnter: handleItemMouseEnter,
                      onItemMouseLeave: handleItemMouseLeave,
                      onNodeToggleExpanded: handleModularPipelineToggleExpanded,
                      onToggleHoveredFocusMode: handleToggleHoveredFocusMode,
                      searchValue,
                      slicedPipeline,
                      nodesDisabledViaModularPipeline
                    }
                  ) })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-nodelist__filter-panel", ...panelB, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-nodelist__split-handle", ...handle }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  libExports.Scrollbars,
                  {
                    className: "pipeline-nodelist-scrollbars",
                    style: { width: "auto" },
                    autoHide: true,
                    hideTracksWhenNotNeeded: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Filters,
                      {
                        groupCollapsed,
                        groups,
                        isResetFilterActive,
                        items: searchValue.length > 0 ? filtersSearchResult : items,
                        onGroupToggleChanged: handleGroupToggleChanged,
                        onItemChange: handleFiltersRowClicked,
                        onResetFilter: handleResetFilter,
                        onToggleGroupCollapsed: handleToggleGroupCollapsed,
                        searchValue
                      }
                    )
                  }
                )
              ] })
            ]
          }
        ) }) : null
      ]
    }
  );
};
const NodesPanelContextProvider = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NodeListContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiltersContextProvider, { children: children2 }) });
};
const NodesPanelProvider = ({ faded, visible = true }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NodesPanelContextProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NodesPanel, { visible, faded }) });
};
class EventController {
  /**
   * Manages the attachment of the event listener when body is clicked.
   * @param {Object} eventHandler - event handler which will be added
   */
  static addBodyListener(eventHandler) {
    if (typeof window.__bodyEventHandlers === "undefined") {
      window.__bodyEventHandlers = [];
    }
    window.__bodyEventHandlers.push(eventHandler);
    document.body.addEventListener("click", eventHandler);
    window.__bodyListenerAttached = true;
  }
  /**
   * Manages the removal of the event listeners when body is clicked - all event listeners added
   * by dropdown components are removed.
   * This method is static because it doesn't utilize 'this'.
   */
  static removeBodyListeners() {
    if (window.__bodyListenerAttached) {
      window.__bodyEventHandlers.forEach((handler) => {
        document.body.removeEventListener("click", handler);
      });
      window.__bodyEventHandlers = [];
      window.__bodyListenerAttached = false;
    }
  }
}
const usePrevious = (value) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
const KEYS = {
  13: "enter",
  27: "escape",
  38: "up",
  40: "down"
};
const handleKeyEvent = (keyCode, keyActions) => {
  const handleSingleKey = (keyName, callback) => {
    if (keyCode in KEYS && KEYS[keyCode] === keyName.toLowerCase()) {
      return callback();
    }
    return void 0;
  };
  if (keyActions) {
    return Object.keys(keyActions).map(
      (key) => handleSingleKey(key, keyActions[key])
    );
  }
  return (key, callback) => {
    if (key.includes(",")) {
      return key.split(/\s*,\s*/).map((k) => handleSingleKey(k, callback));
    }
    return handleSingleKey(key, callback);
  };
};
const DropdownArrow = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M15.572 15.35L17 13.936l-4.997-4.953L7 13.93l1.432 1.417 3.586-3.55z" }) });
const DropdownRenderer = ({
  children: children2,
  defaultText = "Please select...",
  disabled = false,
  focusedOption,
  handleRef,
  haveSelectedValues = false,
  onApplyAndClose,
  onCancel,
  onLabelClicked,
  onOptionSelected,
  onSelectChanged,
  open = false,
  selectedOption,
  showCancelApplyBtns,
  title,
  width: width2 = 160,
  placeholderText,
  dataTest
}) => {
  const wrapperClasses = classnames("kedro", "dropdown", {
    "dropdown--open": open,
    "dropdown--disabled": disabled
  });
  let optionIndex = 0;
  const _extendMenuOption = (element, id2, index) => {
    const extraProps = {
      id: id2,
      onSelected: onOptionSelected,
      focused: focusedOption === index,
      selected: selectedOption.id === id2 || !selectedOption.id && element.props.selected
    };
    optionIndex += 1;
    return React.cloneElement(element, extraProps);
  };
  const _handleKeyDown = (e) => {
    if (open) {
      handleKeyEvent(e.keyCode, {
        escape: onLabelClicked,
        up: onSelectChanged.bind(void 0, -1),
        down: onSelectChanged.bind(void 0, 1)
      });
    } else {
      handleKeyEvent(e.keyCode, {
        up: onLabelClicked,
        down: onLabelClicked
      });
    }
    handleKeyEvent(e.keyCode)("escape, up, down", () => e.preventDefault());
  };
  const childElements = React.Children.toArray(children2);
  const sectionWrapRequired = childElements[0] && typeof childElements[0].type === "function";
  const options = React.Children.map(childElements, (child, i) => {
    switch (child.type) {
      case "section":
        return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { children: React.Children.map(child.props.children, (sectionChild, j) => {
          switch (sectionChild.type) {
            case "span":
              return sectionChild;
            default:
              return _extendMenuOption(
                sectionChild,
                `menu-option-${i}.${j}`,
                optionIndex
              );
          }
        }) }, `menu-section-${uniqueId(i)}`);
      case "span":
        return child;
      case "div":
        return child;
      default:
        return _extendMenuOption(child, `menu-option-${i}`, optionIndex);
    }
  });
  const optionsNode = sectionWrapRequired ? /* @__PURE__ */ jsxRuntimeExports.jsx("section", { children: options }) : options;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      "aria-expanded": open.toString(),
      "data-test": dataTest,
      "aria-haspopup": "true",
      className: wrapperClasses,
      onKeyDown: _handleKeyDown,
      ref: handleRef,
      style: { width: `${width2}px` },
      title,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "button",
          {
            type: "button",
            disabled,
            className: "dropdown__label",
            onClick: onLabelClicked,
            children: [
              placeholderText ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dropdown__placeholder", children: placeholderText }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: selectedOption.label || defaultText }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "dropdown__icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownArrow, {}) })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "dropdown__options", children: [
          optionsNode,
          showCancelApplyBtns && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "select-dropdown__btn-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { mode: "secondary", onClick: onCancel, size: "small", children: "Cancel" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: !haveSelectedValues,
                dataTest: `${dataTest}-apply-btn`,
                onClick: onApplyAndClose,
                mode: "primary",
                size: "small",
                children: "Apply and Close"
              }
            )
          ] })
        ] })
      ]
    }
  );
};
DropdownRenderer.propTypes = {
  /**
   * Child items. The nodes which React will pass down, defined inside the DropdownRenderer tag.
   */
  children: PropTypes.node,
  /**
   * Default text to show in a closed unselected state
   */
  defaultText: PropTypes.string,
  /**
   * Whether to disable the dropdown
   */
  disabled: PropTypes.bool,
  /**
   * The index of the currently-focused menu option
   */
  focusedOption: PropTypes.number,
  /**
   * Retrieve a reference to the dropdown DOM node
   */
  handleRef: PropTypes.func,
  /**
   * Whether user has selected any value from the dropdown
   */
  haveSelectedValues: PropTypes.bool,
  /**
   * Callback function to be excecuted when a Apply and Close button is clicked
   */
  onApplyAndClose: PropTypes.func,
  /**
   * Callback function to be excecuted when a Cancel button is clicked
   */
  onCancel: PropTypes.func,
  /**
   * Callback to be executed when the main label is clicked
   */
  onLabelClicked: PropTypes.func,
  /**
   * Callback to be executed when an option is selected
   */
  onOptionSelected: PropTypes.func,
  /**
   * Callback to be executed when the focused option changes
   */
  onSelectChanged: PropTypes.func,
  /**
   * Whether the dropdown is in an open state
   */
  open: PropTypes.bool,
  /**
   * An object containing selected option details.
   * This will be created based on the id, primaryText, value of a selected Menu Option.
   */
  selectedOption: PropTypes.shape({
    id: PropTypes.string,
    label: PropTypes.string,
    value: PropTypes.any
  }),
  /**
   * Title text for native tooltip
   */
  title: PropTypes.string,
  /**
   * The width for the component. Both the label and options are the same width
   */
  width: PropTypes.number,
  /**
   * Placeholder text when value from dropdown is not selected
   */
  placeholderText: PropTypes.string
};
const Dropdown = (props) => {
  const {
    children: children2,
    defaultText = "Please select...",
    disabled = false,
    haveSelectedValues = false,
    onApplyAndClose,
    onCancel,
    onChanged,
    onClosed,
    onOpened,
    showCancelApplyBtns,
    width: width2 = 160,
    placeholderText,
    dataTest
  } = props;
  const _findSelectedOption = reactExports.useCallback((props2) => {
    const selectedOptionElement = _findSelectedOptionElement(props2);
    if (selectedOptionElement) {
      const { id: id2, primaryText, value } = selectedOptionElement.props;
      return {
        id: id2,
        label: primaryText,
        value
      };
    }
    return {
      id: null,
      label: null,
      value: null
    };
  }, []);
  const _findSelectedOptionElement = (props2) => {
    const children22 = React.Children.toArray(props2.children);
    if (!children22.length) {
      return null;
    }
    if (children22[0].type === "section") {
      return fpExports.flow(
        fpExports.map((x2) => x2.props.children),
        fpExports.flatten,
        fpExports.find((x2) => x2.props.selected)
      )(children22);
    }
    return fpExports.find((child) => child.props.selected)(children22);
  };
  const prevProps = usePrevious(props);
  const [focusedOption, setFocusedOption] = reactExports.useState(null);
  const [haveClicked, setHaveClicked] = reactExports.useState(false);
  const [selectedOption, setSelectedOption] = reactExports.useState(
    _findSelectedOption(props)
  );
  const [open, setOpen] = reactExports.useState(false);
  const [selectedObject, setSelectedObject] = reactExports.useState(null);
  const dropdownRef = reactExports.useRef();
  const handleOptionSelectedRef = reactExports.useRef({ open, selectedOption });
  const selectedObjRef = reactExports.useRef(selectedObject);
  const mounted = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const _childrenHaveChanged = (nextProps) => {
      const children22 = [props, nextProps].map(
        (props2) => React.Children.toArray(props2.children)
      );
      return !fpExports.isEqual(...children22);
    };
    if (!mounted.current) {
      mounted.current = true;
    } else if (prevProps && _childrenHaveChanged(prevProps)) {
      setSelectedOption(_findSelectedOption(prevProps));
    }
  }, [_findSelectedOption, prevProps, props]);
  reactExports.useEffect(() => {
    if (haveClicked === true) {
      if (typeof onOpened === "function" && open) {
        onOpened();
      } else if (typeof onClosed === "function" && !open) {
        onClosed();
      }
      setHaveClicked(false);
    }
  }, [haveClicked, onOpened, onClosed, open]);
  reactExports.useEffect(() => {
    if (selectedObjRef.current !== selectedObject) {
      if (!open && handleOptionSelectedRef.current.handleOptionSelectedRef !== selectedOption) {
        if (typeof onChanged === "function") {
          onChanged(selectedObject);
        }
      }
      if (!open && typeof onClosed === "function") {
        onClosed();
      }
    }
  }, [selectedObject, selectedObjRef]);
  reactExports.useEffect(() => {
    return () => EventController.removeBodyListeners();
  }, []);
  reactExports.useEffect(() => {
    const focusClass = focusedOption !== null ? ".menu-option--focused" : ".dropdown__label";
    dropdownRef.current.querySelector(focusClass).focus();
  }, [focusedOption]);
  reactExports.useEffect(() => {
    if (open) {
      document.addEventListener("click", _handleBodyClicked);
    }
    return () => document.removeEventListener("click", _handleBodyClicked);
  }, [open]);
  const _handleBodyClicked = (e) => {
    if (dropdownRef.current && !dropdownRef.current.contains(e.target) && open) {
      _handleClose();
    }
  };
  const _handleLabelClicked = () => {
    if (open) {
      EventController.removeBodyListeners();
    } else {
      EventController.addBodyListener(_handleBodyClicked);
    }
    setOpen(!open);
    setHaveClicked(true);
    _focusLabel();
  };
  const _getOptionsList = () => {
    const getSectionChildren = (previous, current) => {
      if (current.props.primaryText) {
        return previous.concat(current);
      }
      if (current.type === "section") {
        return previous.concat(
          current.props.children.reduce(getSectionChildren, [])
        );
      }
      return previous;
    };
    return React.Children.toArray(props.children).reduce(
      getSectionChildren,
      []
    );
  };
  const _focusLabel = () => {
    dropdownRef.current.querySelector(".dropdown__label").focus();
    setFocusedOption(null);
  };
  const _handleFocusChange = (direction) => {
    let newFocusedOption = focusedOption;
    const optionsLength = _getOptionsList().length;
    if (focusedOption === null) {
      newFocusedOption = direction > 0 ? 0 : optionsLength - 1;
    } else {
      newFocusedOption += direction;
    }
    if (newFocusedOption >= optionsLength || newFocusedOption < 0) {
      newFocusedOption = null;
    }
    setFocusedOption(newFocusedOption);
  };
  const _handleOptionSelected = (obj) => {
    const { label, id: id2, value } = obj;
    setSelectedObject(obj);
    const hasChanged = value !== selectedOption.value;
    if (hasChanged) {
      const newSelectedOption = { label, value, id: id2 };
      setOpen(false);
      setSelectedOption(newSelectedOption);
    } else {
      setOpen(false);
    }
    _focusLabel();
  };
  const _handleRef = (el) => {
    dropdownRef.current = el;
  };
  const _handleClose = () => {
    setOpen(false);
    EventController.removeBodyListeners();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownRenderer,
    {
      defaultText,
      disabled,
      focusedOption,
      handleRef: _handleRef,
      haveSelectedValues,
      placeholderText,
      onApplyAndClose: () => {
        setOpen(false);
        onApplyAndClose();
      },
      onCancel: () => {
        setOpen(false);
        onCancel();
      },
      onLabelClicked: _handleLabelClicked,
      onOptionSelected: _handleOptionSelected,
      onSelectChanged: _handleFocusChange,
      open,
      selectedOption,
      showCancelApplyBtns,
      width: width2,
      dataTest,
      children: children2
    }
  );
};
Dropdown.propTypes = {
  /**
   * Child items. The nodes which React will pass down, defined inside the DropdownRenderer tag
   */
  children: PropTypes.node.isRequired,
  /**
   * Default text to show in a closed unselected state
   */
  defaultText: PropTypes.string,
  /**
   * Whether to disable the dropdown
   */
  disabled: PropTypes.bool,
  /**
   * Whether user has selected any value from the dropdown
   */
  haveSelectedValues: PropTypes.bool,
  /**
   * Callback function to be excecuted when a Apply and Close button is clicked
   */
  onApplyAndClose: PropTypes.func,
  /**
   * Callback function to be excecuted when a Cancel button is clicked
   */
  onCancel: PropTypes.func,
  /**
   * Callback function to be executed when a menu item is clicked, other than the one currently selected.
   */
  onChanged: PropTypes.func,
  /**
   * Callback to be executed after menu opens
   */
  onOpened: PropTypes.func,
  /**
   * Callback to be executed after menu closed
   */
  onClosed: PropTypes.func,
  /**
   * The width for the component. Both the label and options are the same width
   */
  width: PropTypes.number,
  /**
   * Placeholder text when value from dropdown is not selected
   */
  placeholderText: PropTypes.string
};
const MenuOption = ({
  className,
  focused = false,
  id: id2,
  onSelected,
  primaryText,
  selected = false,
  value
}) => {
  const wrapperClasses = classnames("kedro", "menu-option", className, {
    "menu-option--focused": focused,
    "menu-option--selected": selected
  });
  const _handleClicked = (e) => onSelected({
    event: e,
    id: id2,
    label: primaryText,
    value
  });
  const _handleKeyDown = (e) => handleKeyEvent(e.keyCode)("enter, space", () => {
    _handleClicked(e);
    e.preventDefault();
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      "aria-selected": selected.toString(),
      className: wrapperClasses,
      onClick: _handleClicked,
      onKeyDown: _handleKeyDown,
      role: "option",
      tabIndex: "-1",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "menu-option__content", title: primaryText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: primaryText }) })
    }
  );
};
MenuOption.propTypes = {
  /**
   * Container class
   */
  className: PropTypes.string,
  /**
   * Whether the option is focused
   */
  focused: PropTypes.bool,
  /**
   * A unique key for this element, which will be set by the parent menu component.
   * This is used by the parent menu component to determine which option is selected.
   */
  id: PropTypes.string,
  /**
   * A callback which is automatically implemented by a parent menu component
   */
  onSelected: PropTypes.func,
  /**
   * The main label displayed
   */
  primaryText: PropTypes.string.isRequired,
  /**
   * Whether the option is selected
   */
  selected: PropTypes.bool,
  /**
   * The value to send to the parent menu component when this item is selected
   */
  value: PropTypes.any
};
const PipelineList = ({
  asyncDataSource,
  onUpdateActivePipeline,
  pipeline,
  isPrettyName,
  onToggleOpen,
  isWorkflowView
}) => {
  const { toSelectedPipeline } = useGeneratePathname();
  if (!pipeline.ids.length && !asyncDataSource) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-list", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dropdown,
    {
      disabled: isWorkflowView || !pipeline.ids.length,
      onOpened: () => onToggleOpen(true),
      onClosed: () => onToggleOpen(false),
      width: null,
      dataTest: "kedro-pipeline-selector",
      onChanged: (selectedPipeline) => {
        onUpdateActivePipeline(selectedPipeline);
        toSelectedPipeline(selectedPipeline.value);
      },
      defaultText: isPrettyName ? pipeline.name[pipeline.active] : pipeline.active || "Default",
      children: pipeline.ids.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuOption,
        {
          className: classnames({
            "pipeline-list__option--active": pipeline.active === id2
          }),
          value: id2,
          primaryText: isPrettyName ? pipeline.name[id2] : id2
        },
        `pipeline-${id2}`
      ))
    }
  ) });
};
const mapStateToProps$a = (state) => ({
  asyncDataSource: state.dataSource === "json",
  pipeline: state.pipeline,
  isPrettyName: state.isPrettyName
});
const mapDispatchToProps$6 = (dispatch2) => ({
  onUpdateActivePipeline: (event) => {
    dispatch2(loadPipelineData(event.value));
    dispatch2(toggleFocusMode(null));
  }
});
const PipelineList$1 = connect(mapStateToProps$a, mapDispatchToProps$6)(PipelineList);
const FilterIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    className,
    width: "18",
    height: "16",
    viewBox: "0 0 18 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.50002 15.5V8.82688L0.950073 0.5H17.0499L10.5 8.82688V15.5H7.50002ZM9 6.99997L12.5 2.49997H5.5L9 6.99997Z" })
  }
);
const ToolbarFilterButton = ({
  displayFilterBtn,
  onTogglePipelineFilter
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-toolbar--filter-container", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      IconButton,
      {
        ariaLabel: `Select pipeline view`,
        className: "pipeline-menu-button--labels",
        dataTest: `sidebar-flowchart-filter-btn-${displayFilterBtn}`,
        icon: FilterIcon,
        labelText: `Select pipeline view`,
        onClick: () => onTogglePipelineFilter(),
        visible: displayFilterBtn,
        container: "div"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "pipeline-toolbar--divider" })
  ] });
};
const mapStateToProps$9 = (state) => ({
  displayFilterBtn: state.display.filterBtn
});
const mapDispatchToProps$5 = (dispatch2) => ({
  onTogglePipelineFilter: () => {
    dispatch2(togglePipelineFilter());
  }
});
const ToolbarFilterButton$1 = connect(
  mapStateToProps$9,
  mapDispatchToProps$5
)(ToolbarFilterButton);
const Sidebar = ({
  displayGlobalNavigation,
  visible,
  displayFilterBtn,
  view,
  isRunStatusAvailable: isRunStatusAvailable2
}) => {
  const [pipelineIsOpen, togglePipeline] = reactExports.useState(false);
  const isFlowchartView = view === VIEW.FLOWCHART;
  const isWorkflowView = view === VIEW.WORKFLOW;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("pipeline-sidebar", {
        "pipeline-sidebar--visible": visible,
        "pipeline-sidebar--no-global-toolbar": !displayGlobalNavigation
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-ui", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            PipelineList$1,
            {
              onToggleOpen: togglePipeline,
              isWorkflowView
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            NodesPanelProvider,
            {
              visible: !isWorkflowView || isWorkflowView && isRunStatusAvailable2,
              faded: pipelineIsOpen
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: "pipeline-toolbar", children: [
          displayFilterBtn && /* @__PURE__ */ jsxRuntimeExports.jsx(ToolbarFilterButton$1, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FlowchartPrimaryToolbar$1, { isFlowchartView }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MiniMapToolbar$1, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MiniMap$1, {})
      ]
    }
  ) });
};
const mapStateToProps$8 = (state) => ({
  displayGlobalNavigation: state.display.globalNavigation,
  displaySidebar: state.display.sidebar,
  displayFilterBtn: state.display.filterBtn,
  visible: state.visible.sidebar,
  view: state.view,
  isRunStatusAvailable: isRunStatusAvailable(state)
});
const Sidebar$1 = connect(mapStateToProps$8)(Sidebar);
const findMatchedPath = (pathname2, search) => {
  const matchedFlowchartMainPage = matchPath(pathname2 + search, {
    exact: false,
    path: [routes.flowchart.main]
  });
  const isQueryParamExist = (queryParam, queryString) => {
    const searchParams = new URLSearchParams(queryString);
    return searchParams.has(queryParam);
  };
  const hasQueryParam = (param) => {
    const hasPipelineId = isQueryParamExist(params.pipeline, search);
    const hasParam = isQueryParamExist(param, search);
    return param ? hasPipelineId && hasParam : hasPipelineId;
  };
  const matchedSelectedPipeline = () => hasQueryParam();
  const matchedSelectedNodeId = () => hasQueryParam(params.selected);
  const matchedSelectedNodeName = () => hasQueryParam(params.selectedName);
  const matchedFocusedNode = () => hasQueryParam(params.focused);
  return {
    matchedFlowchartMainPage,
    matchedSelectedPipeline,
    matchedSelectedNodeId,
    matchedSelectedNodeName,
    matchedFocusedNode
  };
};
const getKeyByValue = (object2, value) => {
  return Object.keys(object2).find((key) => object2[key] === value);
};
const getKeysByValue = (object2, value) => {
  return Object.keys(object2).filter((key) => object2[key] === value).join(",");
};
const Banner = ({
  icon = null,
  message,
  btnUrl = null,
  btnText = "Learn More",
  position: position2 = "top",
  onClose = null,
  dataTest
}) => {
  const [isVisible, setIsVisible] = reactExports.useState(true);
  const handleClose = () => {
    setIsVisible(false);
    if (onClose) {
      onClose();
    }
  };
  if (!isVisible) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("banner", `banner-${position2}`),
      "data-test": dataTest,
      children: [
        icon && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "banner-icon", children: icon }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "banner-message", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "banner-message-title", children: message.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "banner-message-body", children: message.body })
        ] }),
        btnUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { rel: "noreferrer", target: "_blank", href: btnUrl, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { mode: "primary", size: "small", children: btnText }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "banner-close", onClick: handleClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) })
      ]
    }
  );
};
Banner.propTypes = {
  icon: PropTypes.node,
  message: PropTypes.shape({
    title: PropTypes.string.isRequired,
    body: PropTypes.string.isRequired
  }).isRequired,
  learnMoreUrl: PropTypes.string,
  theme: PropTypes.oneOf(["light", "dark"]),
  position: PropTypes.oneOf(["top", "bottom"]),
  onClose: PropTypes.func
};
const FlowChartWrapper = ({
  fullNodeNames,
  displaySidebar,
  graph: graph2,
  loading,
  modularPipelinesTree,
  nodes,
  onToggleFocusMode,
  onToggleModularPipelineActive,
  onToggleModularPipelineExpanded,
  onToggleNodeSelected,
  onUpdateActivePipeline,
  pipelines,
  sidebarVisible,
  activePipeline,
  tag,
  nodeType,
  expandAllPipelines,
  displayMetadataPanel,
  displayExportBtn,
  displayBanner,
  setView: setView2
}) => {
  const { pathname: pathname2, search } = useLocation();
  const searchParams = new URLSearchParams(search);
  const { toSetQueryParam } = useGeneratePathname();
  const [errorMessage, setErrorMessage] = reactExports.useState({});
  const [isInvalidUrl, setIsInvalidUrl] = reactExports.useState(false);
  const [usedNavigationBtn, setUsedNavigationBtn] = reactExports.useState(false);
  const graphRef = reactExports.useRef(null);
  const {
    matchedFlowchartMainPage,
    matchedSelectedPipeline,
    matchedSelectedNodeId,
    matchedSelectedNodeName,
    matchedFocusedNode
  } = findMatchedPath(pathname2, search);
  const setParamsFromLocalStorage = (activePipeline2) => {
    const localStorageParams = loadLocalStorage(localStorageName);
    if (localStorageParams) {
      const paramActions = {
        pipeline: (value) => {
          if (activePipeline2) {
            toSetQueryParam(params.pipeline, value.active || activePipeline2);
          }
        },
        tag: (value) => {
          const enabledKeys = getKeysByValue(value.enabled, true);
          enabledKeys && toSetQueryParam(params.tags, enabledKeys);
        },
        nodeType: (value) => {
          const disabledKeys = getKeysByValue(value.disabled, false);
          const mappedDisabledNodes = mapNodeTypes(disabledKeys);
          disabledKeys && toSetQueryParam(params.types, mappedDisabledNodes);
        },
        expandAllPipelines: (value) => toSetQueryParam(params.expandAll, value)
      };
      for (const [key, value] of Object.entries(localStorageParams)) {
        if (paramActions[key]) {
          paramActions[key](value);
        }
      }
    }
  };
  reactExports.useEffect(() => {
    setView2(VIEW.FLOWCHART);
  }, [setView2]);
  reactExports.useEffect(() => {
    setParamsFromLocalStorage(activePipeline);
  }, [activePipeline, tag, nodeType, expandAllPipelines]);
  const resetErrorMessage = () => {
    setErrorMessage({});
    setIsInvalidUrl(false);
  };
  const checkIfPipelineExists = () => {
    const pipelineId = searchParams.get(params.pipeline);
    const foundPipeline = pipelines.find((id2) => id2 === pipelineId);
    if (!foundPipeline) {
      setErrorMessage(errorMessages.pipeline);
      setIsInvalidUrl(true);
    }
  };
  const redirectSelectedPipeline = () => {
    const pipelineId = searchParams.get(params.pipeline);
    const foundPipeline = pipelines.find((id2) => id2 === pipelineId);
    if (foundPipeline) {
      onUpdateActivePipeline(foundPipeline);
      onToggleNodeSelected(null);
      onToggleFocusMode(null);
    } else {
      setErrorMessage(errorMessages.pipeline);
      setIsInvalidUrl(true);
    }
  };
  const redirectToSelectedNode = () => {
    var _a;
    const node2 = searchParams.get(params.selected) || searchParams.get(params.selectedName);
    const nodeId = getKeyByValue(fullNodeNames, node2) || Object.keys(nodes).find((nodeId2) => nodeId2 === node2);
    if (nodeId) {
      const modularPipeline = nodes[nodeId];
      const modularPipelineTree = modularPipelinesTree[modularPipeline];
      const isModularPipelineChild = (_a = modularPipelineTree == null ? void 0 : modularPipelineTree.children) == null ? void 0 : _a.includes(nodeId);
      const isParameterType = graph2.nodes && graph2.nodes.find(
        (node22) => node22.id === nodeId && node22.type === "parameters"
      );
      if (isModularPipelineChild && !isParameterType) {
        onToggleModularPipelineExpanded(modularPipeline);
      }
      onToggleNodeSelected(nodeId);
      if (isInvalidUrl) {
        resetErrorMessage();
      }
    } else {
      setErrorMessage(errorMessages.node);
      setIsInvalidUrl(true);
    }
    checkIfPipelineExists();
  };
  const redirectToFocusedNode = () => {
    const focusedId = searchParams.get(params.focused);
    const foundModularPipeline = modularPipelinesTree[focusedId];
    if (foundModularPipeline) {
      onToggleModularPipelineActive(focusedId, true);
      onToggleFocusMode(foundModularPipeline.data);
      if (isInvalidUrl) {
        resetErrorMessage();
      }
    } else {
      setErrorMessage(errorMessages.modularPipeline);
      setIsInvalidUrl(true);
    }
    checkIfPipelineExists();
  };
  const handlePopState = reactExports.useCallback(() => {
    setUsedNavigationBtn((usedNavigationBtn2) => !usedNavigationBtn2);
  }, []);
  reactExports.useEffect(() => {
    window.addEventListener("popstate", handlePopState);
    return () => {
      window.removeEventListener("popstate", handlePopState);
    };
  }, [handlePopState]);
  reactExports.useEffect(() => {
    const isGraphEmpty = Object.keys(graph2).length === 0;
    if ((graphRef.current === null || usedNavigationBtn || isInvalidUrl) && !isGraphEmpty) {
      if (matchedFlowchartMainPage) {
        onToggleNodeSelected(null);
        onToggleFocusMode(null);
        resetErrorMessage();
      }
      if (matchedSelectedPipeline()) {
        redirectSelectedPipeline();
      }
      if (matchedSelectedNodeName() || matchedSelectedNodeId()) {
        redirectToSelectedNode();
      }
      if (matchedFocusedNode()) {
        redirectToFocusedNode();
      }
      graphRef.current = graph2;
      setUsedNavigationBtn(false);
    }
  }, [graph2, usedNavigationBtn, isInvalidUrl]);
  const handleBannerClose = (bannerKey) => {
    saveLocalStorage(localStorageBannerStatus, { [bannerKey]: false });
  };
  const showBanner = (bannerKey) => {
    const bannerStatus = loadLocalStorage(localStorageBannerStatus);
    const shouldShowBanner = displayBanner[bannerKey] && (bannerStatus[bannerKey] || bannerStatus[bannerKey] === void 0);
    return shouldShowBanner;
  };
  if (isInvalidUrl) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kedro-pipeline", children: [
      displaySidebar && /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar$1, {}),
      displayMetadataPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(MetaData$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PipelineWarning$1,
        {
          errorMessage,
          invalidUrl: isInvalidUrl,
          onResetClick: () => setIsInvalidUrl(false)
        }
      )
    ] });
  } else {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kedro-pipeline", children: [
      displaySidebar && /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar$1, {}),
      displayMetadataPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(MetaData$1, {}),
      showBanner(BANNER_KEYS.LITE) && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Banner,
        {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(InfoBannerIcon, {}),
          message: {
            title: BANNER_METADATA.liteModeWarning.title,
            body: BANNER_METADATA.liteModeWarning.body
          },
          btnUrl: BANNER_METADATA.liteModeWarning.docsLink,
          onClose: () => handleBannerClose(BANNER_KEYS.LITE),
          dataTest: getDataTestAttribute("flowchart-wrapper", "lite-banner")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(PipelineWarning$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FlowChart2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PipelineLoading, { loading, sidebarVisible }),
        isRunningLocally() ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(ShareableUrlMetadata, {})
      ] }),
      displayExportBtn && /* @__PURE__ */ jsxRuntimeExports.jsx(ExportModal$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MetadataModal$1, {})
    ] });
  }
};
const mapStateToProps$7 = (state) => ({
  fullNodeNames: getNodeFullName(state),
  displaySidebar: state.display.sidebar,
  graph: state.graph,
  loading: isLoading(state),
  metadataVisible: getVisibleMetaSidebar(state),
  modularPipelinesTree: getModularPipelinesTree(state),
  nodes: state.node.modularPipelines,
  pipelines: state.pipeline.ids,
  activePipeline: state.pipeline.active,
  sidebarVisible: state.visible.sidebar,
  tag: state.tag.enabled,
  nodeType: state.nodeType.disabled,
  expandAllPipelines: state.expandAllPipelines,
  displayMetadataPanel: state.display.metadataPanel,
  displayExportBtn: state.display.exportBtn,
  displayBanner: state.showBanner
});
const mapDispatchToProps$4 = (dispatch2) => ({
  onToggleFocusMode: (modularPipeline) => {
    dispatch2(toggleFocusMode(modularPipeline));
  },
  onToggleNodeSelected: (nodeID) => {
    dispatch2(loadNodeData(nodeID));
  },
  onToggleModularPipelineActive: (modularPipelineIDs, active) => {
    dispatch2(toggleModularPipelineActive(modularPipelineIDs, active));
  },
  onToggleModularPipelineExpanded: (expanded) => {
    dispatch2(toggleModularPipelinesExpanded(expanded));
  },
  onUpdateActivePipeline: (pipelineId) => {
    dispatch2(loadPipelineData(pipelineId));
  },
  setView: (view) => dispatch2(setView(view))
});
const FlowChartWrapper$1 = connect(mapStateToProps$7, mapDispatchToProps$4)(FlowChartWrapper);
const SuccessIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M10.5808 16.2538L17.3038 9.53075L16.25 8.47693L10.5808 14.1462L7.73075 11.2962L6.67693 12.35L10.5808 16.2538ZM12.0016 21.5C10.6877 21.5 9.45268 21.2506 8.29655 20.752C7.1404 20.2533 6.13472 19.5765 5.2795 18.7217C4.42427 17.8669 3.74721 16.8616 3.24833 15.706C2.74944 14.5504 2.5 13.3156 2.5 12.0017C2.5 10.6877 2.74933 9.45268 3.248 8.29655C3.74667 7.1404 4.42342 6.13472 5.27825 5.2795C6.1331 4.42427 7.13834 3.74721 8.29398 3.24833C9.44959 2.74944 10.6844 2.5 11.9983 2.5C13.3122 2.5 14.5473 2.74933 15.7034 3.248C16.8596 3.74667 17.8652 4.42342 18.7205 5.27825C19.5757 6.1331 20.2527 7.13834 20.7516 8.29398C21.2505 9.44959 21.5 10.6844 21.5 11.9983C21.5 13.3122 21.2506 14.5473 20.752 15.7034C20.2533 16.8596 19.5765 17.8652 18.7217 18.7205C17.8669 19.5757 16.8616 20.2527 15.706 20.7516C14.5504 21.2505 13.3156 21.5 12.0016 21.5ZM12 20C14.2333 20 16.125 19.225 17.675 17.675C19.225 16.125 20 14.2333 20 12C20 9.76664 19.225 7.87498 17.675 6.32498C16.125 4.77498 14.2333 3.99998 12 3.99998C9.76664 3.99998 7.87498 4.77498 6.32498 6.32498C4.77498 7.87498 3.99998 9.76664 3.99998 12C3.99998 14.2333 4.77498 16.125 6.32498 17.675C7.87498 19.225 9.76664 20 12 20Z",
        fill: "#26BF56"
      }
    )
  }
);
const FailureIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "path",
      {
        d: "M8.39998 16.6538L12 13.0538L15.6 16.6538L16.6538 15.6L13.0538 12L16.6538 8.39998L15.6 7.34615L12 10.9462L8.39998 7.34615L7.34615 8.39998L10.9461 12L7.34615 15.6L8.39998 16.6538ZM12.0016 21.5C10.6877 21.5 9.45268 21.2506 8.29655 20.752C7.1404 20.2533 6.13472 19.5765 5.2795 18.7217C4.42427 17.8669 3.74721 16.8616 3.24833 15.706C2.74944 14.5504 2.5 13.3156 2.5 12.0017C2.5 10.6877 2.74933 9.45268 3.248 8.29655C3.74667 7.1404 4.42342 6.13472 5.27825 5.2795C6.1331 4.42427 7.13834 3.74721 8.29398 3.24833C9.44959 2.74944 10.6844 2.5 11.9983 2.5C13.3122 2.5 14.5473 2.74933 15.7034 3.248C16.8596 3.74667 17.8652 4.42342 18.7205 5.27825C19.5757 6.1331 20.2527 7.13834 20.7516 8.29398C21.2505 9.44959 21.5 10.6844 21.5 11.9983C21.5 13.3122 21.2506 14.5473 20.752 15.7034C20.2533 16.8596 19.5765 17.8652 18.7217 18.7205C17.8669 19.5757 16.8616 20.2527 15.706 20.7516C14.5504 21.2505 13.3156 21.5 12.0016 21.5ZM12 20C14.2333 20 16.125 19.225 17.675 17.675C19.225 16.125 20 14.2333 20 12C20 9.76664 19.225 7.87498 17.675 6.32498C16.125 4.77498 14.2333 3.99998 12 3.99998C9.76664 3.99998 7.87498 4.77498 6.32498 6.32498C4.77498 7.87498 3.99998 9.76664 3.99998 12C3.99998 14.2333 4.77498 16.125 6.32498 17.675C7.87498 19.225 9.76664 20 12 20Z",
        fill: "#F56565"
      }
    )
  }
);
const STATUS_CONFIG = {
  success: {
    icon: SuccessIcon,
    text: "Run execution completed successfully",
    timestampLabel: "Completed on"
  },
  failed: {
    icon: FailureIcon,
    text: "Run execution failed",
    timestampLabel: "Failed on"
  }
};
const RunStatusNotification = ({
  timestamp,
  visibleSidebar,
  visibleMetaSidebar,
  status,
  duration: duration2 = 0
}) => {
  const config2 = STATUS_CONFIG[status] || {};
  const Icon = config2.icon;
  const statusText = config2.text;
  const timestampLabel = config2.timestampLabel;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames(
        "run-status-notification",
        `run-status-notification--${status}`,
        {
          "run-status-notification--no-sidebar": !visibleSidebar,
          "run-status-notification--with-meta-sidebar": visibleMetaSidebar
        }
      ),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "run-status-notification__status", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "run-status-notification__icon", children: Icon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "run-status-notification__text", children: [
            statusText,
            status === "success" && duration2 > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              " in ",
              formatDuration(duration2)
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "run-status-notification__divider" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "run-status-notification__timestamp", children: [
          timestampLabel,
          " ",
          timestamp
        ] })
      ]
    }
  );
};
class Workflow extends reactExports.Component {
  constructor(props) {
    super(props);
    /**
     * Handle window resize
     */
    __publicField(this, "handleWindowResize", () => {
      this.updateChartSize();
    });
    /**
     * Add viewBox on window print so that the SVG can be scaled to fit
     */
    __publicField(this, "handleBeforePrint", () => {
      const graphSize = this.props.graphSize;
      const width2 = graphSize.width + graphSize.marginx * 2;
      const height2 = graphSize.height + graphSize.marginy * 2;
      select(this.svgRef.current).attr("viewBox", `0 0 ${width2} ${height2}`);
    });
    /**
     * Remove viewBox once printing is done
     */
    __publicField(this, "handleAfterPrint", () => {
      select(this.svgRef.current).attr("viewBox", null);
    });
    /**
     * Returns parameter count when there are more
     * than one parameters and parameter name if there's a single parameter
     * @param {Array} parameterNames
     * @returns {String}
     */
    __publicField(this, "getHoveredParameterLabel", (parameterNames) => parameterNames.length > 1 ? `Parameters:${parameterNames.length}` : parameterNames[0]);
    /**
     * Enable a node's focus state and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeClick", (event, node2) => {
      const { type, id: id2 } = node2;
      const { onClickToExpandModularPipeline } = this.props;
      if (type === "modularPipeline") {
        onClickToExpandModularPipeline(id2);
      } else {
        this.handleSingleNodeClick(node2);
      }
      event.stopPropagation();
    });
    __publicField(this, "handleSingleNodeClick", (node2) => {
      const { id: id2, type } = node2;
      const {
        displayMetadataPanel,
        onLoadNodeData,
        onToggleNodeClicked,
        tasksStatus,
        datasetsStatus
      } = this.props;
      const statusSource = type === "data" ? datasetsStatus : tasksStatus;
      const runStatus = getNodeStatusKey(statusSource, node2, workFlowStatuses);
      if (displayMetadataPanel) {
        onLoadNodeData(id2);
        getHeap().track(
          getDataTestAttribute("workflow", "run-status--clicked", runStatus),
          {
            status: runStatus,
            nodeId: id2
          }
        );
      } else {
        onToggleNodeClicked(id2);
      }
    });
    /**
     * Determines the correct order of nodes based on their positions.
     * @param {string} fromNodeId - 'From' node ID.
     * @param {string} toNodeId - 'To' node ID.
     * @returns {Object} - Object containing updatedFromNodeId and updatedToNodeId.
     */
    __publicField(this, "determineNodesOrder", (fromNodeId, toNodeId) => {
      const fromNodeElement = document.querySelector(`[data-id="${fromNodeId}"]`);
      const toNodeElement = document.querySelector(`[data-id="${toNodeId}"]`);
      if (!fromNodeElement || !toNodeElement) {
        return {
          updatedFromNodeId: null,
          updatedToNodeId: null
        };
      }
      const fromNodeRect = fromNodeElement.getBoundingClientRect();
      const toNodeRect = toNodeElement.getBoundingClientRect();
      return fromNodeRect.y < toNodeRect.y ? { updatedFromNodeId: fromNodeId, updatedToNodeId: toNodeId } : { updatedFromNodeId: toNodeId, updatedToNodeId: fromNodeId };
    });
    /**
     * Remove a node's focus state and dim linked nodes
     */
    __publicField(this, "handleChartClick", (event) => {
      if (this.props.clickedNode) {
        this.props.onLoadNodeData(null);
      }
    });
    /**
     * Enable a node's active state, show tooltip, and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeMouseOver", (event, node2) => {
      if (node2.type === "modularPipeline") {
        this.props.onToggleModularPipelineActive(node2.id, true);
      } else {
        this.props.onToggleNodeHovered(node2.id);
      }
      node2 && this.showTooltip(event, node2.fullName);
    });
    /**
     * Enable a layer's active state when hovering it, update labelName's active className accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleLayerMouseOver", (event, node2) => {
      if (!node2) {
        return;
      }
      const layerName = document.querySelector(
        `[data-id="layer-label--${node2.name}"]`
      );
      if (layerName) {
        layerName.classList.add("pipeline-layer-name--active");
      }
    });
    /**
     * Remove the current labelName's active className when not hovering, and update layer's active state accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleLayerMouseOut", (event, node2) => {
      if (!node2) {
        return;
      }
      const layerName = document.querySelector(
        `[data-id="layer-label--${node2.name}"]`
      );
      if (layerName) {
        layerName.classList.remove("pipeline-layer-name--active");
      }
      this.setState({
        activeLayer: void 0
      });
    });
    /**
     * Shows tooltip when the parameter indicator is hovered on
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleParamsIndicatorMouseOver", (event, node2) => {
      const parameterNames = this.props.nodesWithInputParams[node2.id];
      if (parameterNames) {
        const label = this.getHoveredParameterLabel(parameterNames);
        this.showTooltip(event, label);
      }
      event.stopPropagation();
    });
    /**
     * Remove a node's active state, hide tooltip, and dim linked nodes
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeMouseOut", (event, node2) => {
      if (node2.type === "modularPipeline") {
        this.props.onToggleModularPipelineActive(node2.id, false);
      } else {
        this.props.onToggleNodeHovered(null);
      }
      this.hideTooltip();
    });
    /**
     * Handle keydown event when a node is focused
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    __publicField(this, "handleNodeKeyDown", (event, node2) => {
      const ENTER = 13;
      const ESCAPE = 27;
      if (event.keyCode === ENTER) {
        this.handleNodeClick(event, node2);
      }
      if (event.keyCode === ESCAPE) {
        this.handleChartClick(event);
        this.handleNodeMouseOut();
      }
    });
    this.state = {
      tooltip: { visible: false },
      activeLayer: void 0
    };
    this.onViewChange = this.onViewChange.bind(this);
    this.onViewChangeEnd = this.onViewChangeEnd.bind(this);
    this.containerRef = React.createRef();
    this.svgRef = React.createRef();
    this.wrapperRef = React.createRef();
    this.layersRef = React.createRef();
    this.layerNamesRef = React.createRef();
  }
  componentDidMount() {
    this.updateChartSize();
    this.view = viewing({
      container: this.svgRef,
      wrapper: this.wrapperRef,
      onViewChanged: this.onViewChange,
      onViewEnd: this.onViewChangeEnd
    });
    this.updateViewExtents();
    this.addGlobalEventListeners();
    this.update();
    if (this.props.tooltip) {
      this.showTooltip(null, null, this.props.tooltip);
    } else {
      this.hideTooltip();
    }
  }
  componentWillUnmount() {
    this.removeGlobalEventListeners();
  }
  componentDidUpdate(prevProps) {
    this.update(prevProps);
  }
  /**
   * Updates drawing and zoom if props have changed
   */
  update(prevProps = {}) {
    const { chartZoom } = this.props;
    const changed = (...names) => this.changed(names, prevProps, this.props);
    const preventZoom = this.props.visibleMetaSidebar;
    if (changed("visibleSidebar", "visibleCode", "visibleMetaSidebar")) {
      this.updateChartSize();
    }
    if (changed("edges", "nodes", "layers", "chartSize", "clickedNode")) {
      const metaSidebarViewChanged = prevProps.visibleMetaSidebar !== this.props.visibleMetaSidebar;
      const codeViewChangedWithoutMetaSidebar = prevProps.visibleCode !== this.props.visibleCode && !this.props.visibleMetaSidebar;
      const clickedNodeChangedWithoutReFocus = prevProps.clickedNode !== this.props.clickedNode && !this.props.nodeReFocus;
      if (metaSidebarViewChanged || codeViewChangedWithoutMetaSidebar || clickedNodeChangedWithoutReFocus) {
        return;
      }
      this.resetView(preventZoom);
    } else {
      this.onChartZoomChanged(chartZoom);
    }
  }
  /**
   * Returns true if any of the given props are different between given objects.
   * Only shallow changes are detected.
   */
  changed(props, objectA, objectB) {
    return objectA && objectB && props.some((prop) => objectA[prop] !== objectB[prop]);
  }
  /**
   * Update the chart size in state from chart container bounds.
   * This is emulated in tests with a constant fixed size.
   */
  updateChartSize() {
    if (typeof jest !== "undefined") {
      this.props.onUpdateChartSize(chartSizeTestFallback);
    } else {
      this.props.onUpdateChartSize(
        this.containerRef.current.getBoundingClientRect()
      );
    }
  }
  /**
   * Add window event listeners on mount
   */
  addGlobalEventListeners() {
    if (window.ResizeObserver) {
      this.resizeObserver = this.resizeObserver || new window.ResizeObserver(this.handleWindowResize);
      this.resizeObserver.observe(this.containerRef.current);
    } else {
      window.addEventListener("resize", this.handleWindowResize);
    }
    window.addEventListener("beforeprint", this.handleBeforePrint);
    window.addEventListener("afterprint", this.handleAfterPrint);
  }
  /**
   * Remove window event listeners on unmount
   */
  removeGlobalEventListeners() {
    if (window.ResizeObserver) {
      this.resizeObserver.unobserve(this.containerRef.current);
    } else {
      window.removeEventListener("resize", this.handleWindowResize);
    }
    window.removeEventListener("beforeprint", this.handleBeforePrint);
    window.removeEventListener("afterprint", this.handleAfterPrint);
  }
  /**
   * On every frame of every view transform change (from reset, pan, zoom etc.)
   * @param {Object} transform The current view transform
   */
  onViewChange(transform2) {
    var _a;
    const { k: scale, x: x2, y: y2 } = transform2;
    select(this.wrapperRef.current).classed(
      ".pipeline-workflow__zoom-wrapper--animating",
      true
    );
    if ((_a = this.layerNamesRef) == null ? void 0 : _a.current) {
      const layerNames = this.layerNamesRef.current.querySelectorAll(
        ".pipeline-layer-name"
      );
      if (layerNames.length !== this.props.layers.length) {
        setTimeout(() => this.onViewChange(transform2), 0);
        return;
      }
      this.props.layers.forEach((layer, i) => {
        const el = layerNames[i];
        if (!el) {
          return;
        }
        if (this.props.orientation === "vertical") {
          const updateY = y2 + (layer.y + (layer.height || 0) / 2) * scale;
          el.style.transform = `translateY(${updateY}px)`;
        } else {
          const updateX = x2 + (layer.x + (layer.width || 0) / 2) * scale;
          el.style.transform = `translateX(${updateX}px) translateX(-50%)`;
        }
      });
    }
    this.updateViewExtents(transform2);
    const extents = getViewExtents(this.view);
    this.props.onUpdateZoom({
      scale,
      x: x2,
      y: y2,
      applied: true,
      transition: false,
      relative: false,
      minScale: extents.scale.minK,
      maxScale: extents.scale.maxK
    });
  }
  /**
   * Called when the view changes have ended (i.e. after transition ends)
   */
  onViewChangeEnd() {
    select(this.wrapperRef.current).classed(
      "pipeline-flowchart__zoom-wrapper--animating",
      false
    );
  }
  /**
   * Updates view extents based on the current view transform.
   * Offsets the extents considering any open sidebars.
   * Allows additional margin for user panning within limits.
   * Zoom scale is limited to a practical range for usability.
   * @param {?Object} transform Current transform override
   */
  updateViewExtents(transform2) {
    const { k: scale } = transform2 || getViewTransform(this.view);
    const {
      sidebarWidth: sidebarWidth2 = 0,
      metaSidebarWidth: metaSidebarWidth2 = 0,
      codeSidebarWidth: codeSidebarWidth2 = 0,
      width: chartWidth = 0,
      height: chartHeight = 0
    } = this.props.chartSize;
    const { width: graphWidth = 0, height: graphHeight = 0 } = this.props.graphSize;
    const leftSidebarOffset = sidebarWidth2 / scale;
    const rightSidebarOffset = (metaSidebarWidth2 + codeSidebarWidth2) / scale;
    const margin2 = MARGIN;
    const minScale = Math.min(
      chartWidth / (graphWidth || 1),
      chartHeight / (graphHeight || 1)
    );
    setViewExtents(this.view, {
      translate: {
        minX: -leftSidebarOffset - margin2,
        maxX: graphWidth + margin2 + rightSidebarOffset,
        minY: -margin2,
        maxY: graphHeight + margin2
      },
      scale: {
        minK: MIN_SCALE * minScale,
        maxK: MAX_SCALE
      }
    });
  }
  /**
   * Applies the given zoom state as necessary
   * @param {Object} chartZoom The new zoom state
   */
  onChartZoomChanged(chartZoom) {
    if (chartZoom.applied) {
      return;
    }
    if (chartZoom.reset === true) {
      this.resetView(true);
      return;
    }
    setViewTransform(
      this.view,
      { x: chartZoom.x, y: chartZoom.y, k: chartZoom.scale },
      chartZoom.transition ? DURATION * 0.3 : 0,
      chartZoom.relative
    );
  }
  /**
   * Zoom and scale to fit graph and any selected node in view
   */
  resetView(preventZoom) {
    const { chartSize, graphSize, clickedNode, nodes, orientation } = this.props;
    const { width: chartWidth, height: chartHeight } = chartSize;
    const { width: graphWidth, height: graphHeight } = graphSize;
    if (!chartWidth || !graphWidth) {
      return;
    }
    const offset = { x: chartSize.sidebarWidth, y: 0 };
    const focus = clickedNode ? nodes.find((node2) => node2.id === clickedNode) : null;
    const transform2 = viewTransformToFit({
      offset,
      focus,
      viewWidth: chartWidth,
      viewHeight: chartHeight,
      objectWidth: graphWidth,
      objectHeight: graphHeight,
      sidebarWidth: chartSize.sidebarWidth,
      minScaleX: 0.05,
      minScaleFocus: this.props.visibleMetaSidebar ? this.props.chartZoom.scale : 0.1,
      focusOffset: 0,
      preventZoom
    });
    const isFirstTransform = isOrigin(getViewTransform(this.view));
    setViewTransformExact(
      this.view,
      transform2,
      isFirstTransform ? 0 : DURATION
    );
  }
  /**
   * Show, fill and and position the tooltip
   * @param {Object} event Event object
   * @param {Object} text Text to show on the tooltip
   * @param {?Object} options Options for the tooltip if required
   */
  showTooltip(event, text, options = {}) {
    this.setState({
      tooltip: {
        targetRect: event && event.target.getBoundingClientRect(),
        text,
        visible: true,
        ...options
      }
    });
  }
  /**
   * Hide the tooltip
   */
  hideTooltip() {
    if (this.state.tooltip.visible) {
      this.setState({
        tooltip: {
          ...this.state.tooltip,
          visible: false
        }
      });
    }
  }
  /**
   * Render React elements
   */
  render() {
    const {
      chartSize,
      displayGlobalNavigation,
      displaySidebar,
      loading,
      sidebarVisible,
      displayMetadataPanel,
      displayExportBtn,
      layers,
      visibleGraph,
      visibleSidebar,
      visibleMetaSidebar,
      clickedNode,
      nodes,
      nodeActive,
      nodeSelected,
      nodeTypeDisabled,
      hoveredParameters,
      hoveredFocusMode,
      nodesWithInputParams,
      inputOutputDataNodes,
      focusMode,
      orientation,
      edges,
      linkedNodes,
      inputOutputDataEdges,
      tasksStatus,
      datasetsStatus,
      pipelineStatus
    } = this.props;
    const { outerWidth = 0, outerHeight = 0 } = chartSize;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kedro-pipeline", children: [
      displaySidebar && /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar$1, {}),
      displayMetadataPanel && /* @__PURE__ */ jsxRuntimeExports.jsx(MetaData$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: "pipeline-workflow kedro",
            ref: this.containerRef,
            onClick: this.handleChartClick,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                GraphSVG,
                {
                  width: outerWidth,
                  height: outerHeight,
                  svgRef: this.svgRef,
                  wrapperRef: this.wrapperRef,
                  visibleGraph,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DrawLayersGroup,
                      {
                        layers,
                        layersRef: this.layersRef,
                        onLayerMouseOver: this.handleLayerMouseOver,
                        onLayerMouseOut: this.handleLayerMouseOut
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DrawEdges,
                      {
                        edges,
                        clickedNode,
                        linkedNodes,
                        focusMode,
                        inputOutputDataEdges
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      DrawNodes,
                      {
                        nodes,
                        nodeActive,
                        nodeSelected,
                        nodeTypeDisabled,
                        hoveredParameters,
                        hoveredFocusMode,
                        nodesWithInputParams,
                        inputOutputDataNodes,
                        focusMode,
                        orientation,
                        onNodeClick: this.handleNodeClick,
                        onNodeMouseOver: this.handleNodeMouseOver,
                        onNodeMouseOut: this.handleNodeMouseOut,
                        onNodeFocus: this.handleNodeMouseOver,
                        onNodeBlur: this.handleNodeMouseOut,
                        onNodeKeyDown: this.handleNodeKeyDown,
                        onParamsIndicatorMouseOver: this.handleParamsIndicatorMouseOver,
                        clickedNode,
                        linkedNodes,
                        showRunStatus: true,
                        tasksStatus,
                        datasetsStatus
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DrawLayerNamesGroup,
                {
                  layers,
                  displayGlobalNavigation,
                  displaySidebar,
                  chartSize,
                  orientation,
                  layerNamesRef: this.layerNamesRef
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                RunStatusNotification,
                {
                  status: pipelineStatus.status,
                  timestamp: formatTimestamp(pipelineStatus.endTime),
                  duration: pipelineStatus.duration,
                  visibleSidebar,
                  visibleMetaSidebar
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Tooltip,
                {
                  chartSize,
                  ...this.state.tooltip,
                  style: { fontSize: "1.5em" }
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PipelineLoading, { loading, sidebarVisibl: sidebarVisible }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(PipelineWarning$1, {})
      ] }),
      displayExportBtn && /* @__PURE__ */ jsxRuntimeExports.jsx(ExportModal$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MetadataModal$1, {})
    ] });
  }
}
const chartSizeTestFallback = {
  left: 0,
  top: 0,
  right: 1280,
  bottom: 1024,
  width: 1280,
  height: 1024
};
const emptyEdges = [];
const emptyNodes = [];
const emptyGraphSize = {};
const mapStateToProps$6 = (state, ownProps) => ({
  clickedNode: state.node.clicked,
  chartSize: getChartSize(state),
  chartZoom: getChartZoom(state),
  displayGlobalNavigation: state.display.globalNavigation,
  displaySidebar: state.display.sidebar,
  displayMetadataPanel: state.display.metadataPanel,
  loading: isLoading(state),
  sidebarVisible: state.visible.sidebar,
  displayExportBtn: state.display.exportBtn,
  edges: state.graph.edges || emptyEdges,
  focusMode: state.visible.modularPipelineFocusMode,
  graphSize: state.graph.size || emptyGraphSize,
  hoveredParameters: state.hoveredParameters,
  hoveredFocusMode: state.hoveredFocusMode,
  layers: getLayers(state),
  linkedNodes: getLinkedNodes(state),
  nodes: state.graph.nodes || emptyNodes,
  nodeTypeDisabled: state.nodeType.disabled,
  nodeActive: getNodeActive(state),
  nodeSelected: getNodeSelected(state),
  nodesWithInputParams: getNodesWithInputParams(state),
  modularPipelineIds: state.modularPipeline.ids,
  orientation: state.orientation,
  inputOutputDataNodes: getInputOutputNodesForFocusedModularPipeline(state),
  inputOutputDataEdges: getInputOutputDataEdges(state),
  visibleGraph: state.visible.graph,
  visibleSidebar: state.visible.sidebar,
  visibleCode: state.visible.code,
  visibleMetaSidebar: getVisibleMetaSidebar(state),
  nodeReFocus: state.behaviour.reFocus,
  runCommand: getRunCommand(state),
  tasksStatus: getNodesStatus(state),
  datasetsStatus: getDatasetsStatus(state),
  isRunStatusAvailable: isRunStatusAvailable(state),
  pipelineStatus: state.runStatus.pipeline
});
const mapDispatchToProps$3 = (dispatch2, ownProps) => ({
  onClickToExpandModularPipeline: (modularPipelineId) => {
    dispatch2(toggleSingleModularPipelineExpanded(modularPipelineId));
  },
  onLoadNodeData: (nodeClicked) => {
    dispatch2(loadNodeData(nodeClicked));
  },
  onToggleNodeClicked: (id2) => {
    dispatch2(toggleNodeClicked(id2));
  },
  onToggleModularPipelineActive: (modularPipelineIDs, active) => {
    dispatch2(toggleModularPipelineActive(modularPipelineIDs, active));
  },
  onToggleNodeHovered: (nodeHovered) => {
    dispatch2(toggleNodeHovered(nodeHovered));
  },
  onUpdateChartSize: (chartSize) => {
    dispatch2(updateChartSize(chartSize));
  },
  onUpdateZoom: (transform2) => {
    dispatch2(updateZoom(transform2));
  }
});
const Workflow$1 = connect(mapStateToProps$6, mapDispatchToProps$3)(Workflow);
const RunNotFoundWarning = ({ displaySidebar, sidebarVisible }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "kedro-pipeline", children: [
    displaySidebar && /* @__PURE__ */ jsxRuntimeExports.jsx(Sidebar$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      PipelineWarningContent,
      {
        isVisible: true,
        title: "Kedro run not found",
        subtitle: "Please view CLI logs for more details.",
        sidebarVisible
      }
    )
  ] });
};
const mapStateToProps$5 = (state) => ({
  displaySidebar: state.display.sidebar,
  sidebarVisible: state.visible.sidebar
});
const RunNotFoundWarning$1 = connect(mapStateToProps$5)(RunNotFoundWarning);
const WorkflowWrapper = ({
  onSetView,
  onResetState,
  isRunStatusAvailable: isRunStatusAvailable2,
  nodeIds
}) => {
  reactExports.useEffect(() => {
    onSetView(VIEW.WORKFLOW);
    if (nodeIds.length > 0) {
      onResetState();
    }
  }, [onSetView, onResetState, nodeIds]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isRunStatusAvailable2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Workflow$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(RunNotFoundWarning$1, {}) });
};
const mapStateToProps$4 = (state) => ({
  isRunStatusAvailable: isRunStatusAvailable(state),
  nodeIds: state.node.ids
});
const mapDispatchToProps$2 = (dispatch2) => ({
  onSetView: (view) => dispatch2(setView(view)),
  onResetState: () => {
    dispatch2(resetStateForWorkflowView());
    dispatch2(loadPipelineData(PIPELINE.DEFAULT));
  }
});
const WorkflowWrapper$1 = connect(mapStateToProps$4, mapDispatchToProps$2)(WorkflowWrapper);
const SettingsModalRow = ({
  id: id2,
  name,
  toggleValue,
  description,
  onToggleChange
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-settings-modal__column", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-settings-modal__name", children: name }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Toggle,
    {
      id: id2,
      className: "pipeline-settings-modal__state",
      dataTest: `settings-modal-toggle-${id2}-${toggleValue}`,
      title: toggleValue ? "On" : "Off",
      checked: toggleValue,
      onChange: onToggleChange
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-settings-modal__description", children: description })
] }, id2);
const SettingsModal = ({
  flags: flags2,
  showFeatureHints,
  isOutdated,
  isPrettyName,
  showDatasetPreviews,
  latestVersion,
  onToggleFlag,
  onToggleShowFeatureHints,
  onToggleIsPrettyName,
  onToggleShowDatasetPreviews,
  showSettingsModal,
  visible
}) => {
  const flagData = getFlagsState();
  const [hasNotInteracted, setHasNotInteracted] = reactExports.useState(true);
  const [hasClickedApplyAndClose, setHasClickApplyAndClose] = reactExports.useState(false);
  const [isPrettyNameValue, setIsPrettyName] = reactExports.useState(isPrettyName);
  const [showFeatureHintsValue, setShowFeatureHintsValue] = reactExports.useState(showFeatureHints);
  const [showDatasetPreviewsValue, setShowDatasetPreviewsValue] = reactExports.useState(showDatasetPreviews);
  const [toggleFlags, setToggleFlags] = reactExports.useState(flags2);
  reactExports.useEffect(() => {
    setShowFeatureHintsValue(showFeatureHints);
  }, [showFeatureHints]);
  reactExports.useEffect(() => {
    setShowDatasetPreviewsValue(showDatasetPreviews);
  }, [showDatasetPreviews]);
  reactExports.useEffect(() => {
    let modalTimeout, resetTimeout;
    if (hasClickedApplyAndClose) {
      modalTimeout = setTimeout(() => {
        showSettingsModal(false);
      }, 1500);
      resetTimeout = setTimeout(() => {
        const updatedFlags = Object.entries(toggleFlags);
        updatedFlags.map((each) => {
          const [name, value] = each;
          return onToggleFlag(name, value);
        });
        onToggleIsPrettyName(isPrettyNameValue);
        onToggleShowFeatureHints(showFeatureHintsValue);
        onToggleShowDatasetPreviews(showDatasetPreviewsValue);
        setHasNotInteracted(true);
        setHasClickApplyAndClose(false);
        window.location.reload();
      }, 2e3);
    }
    return () => {
      clearTimeout(modalTimeout);
      clearTimeout(resetTimeout);
    };
  }, [
    hasClickedApplyAndClose,
    showFeatureHintsValue,
    isPrettyNameValue,
    showDatasetPreviewsValue,
    onToggleFlag,
    onToggleShowFeatureHints,
    onToggleIsPrettyName,
    onToggleShowDatasetPreviews,
    showSettingsModal,
    toggleFlags
  ]);
  const resetStateCloseModal = () => {
    showSettingsModal(false);
    setHasNotInteracted(true);
    setToggleFlags(flags2);
    setIsPrettyName(isPrettyName);
    setShowFeatureHintsValue(showFeatureHints);
    setShowDatasetPreviewsValue(showDatasetPreviews);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-settings-modal", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      closeModal: resetStateCloseModal,
      title: "Settings",
      visible: visible.settingsModal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-settings-modal__content", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-settings-modal__group", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsModalRow,
            {
              id: "isPrettyName",
              name: settings["isPrettyName"].name,
              toggleValue: isPrettyNameValue,
              description: settings["isPrettyName"].description,
              onToggleChange: (event) => {
                setIsPrettyName(event.target.checked);
                setHasNotInteracted(false);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsModalRow,
            {
              id: "showFeatureHints",
              name: settings["showFeatureHints"].name,
              toggleValue: showFeatureHintsValue,
              description: settings["showFeatureHints"].description,
              onToggleChange: (event) => {
                setShowFeatureHintsValue(event.target.checked);
                setHasNotInteracted(false);
                if (event.target.checked === false) {
                  saveLocalStorage(localStorageName, {
                    [localStorageKeyFeatureHintsStep]: 0
                  });
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsModalRow,
            {
              id: "showDatasetPreviews",
              name: settings["showDatasetPreviews"].name,
              toggleValue: showDatasetPreviewsValue,
              description: settings["showDatasetPreviews"].description,
              onToggleChange: (event) => {
                setShowDatasetPreviewsValue(event.target.checked);
                setHasNotInteracted(false);
              }
            }
          ),
          flagData.map(({ name, value, description }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsModalRow,
            {
              description,
              id: value,
              name,
              onToggleChange: (event) => {
                setToggleFlags({
                  ...toggleFlags,
                  [value]: event.target.checked
                });
                setHasNotInteracted(false);
              },
              toggleValue: toggleFlags[value]
            },
            value
          ))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "version-reminder-and-run-details-button-wrapper", children: [
          isRunningLocally() ? isOutdated ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-settings-modal__upgrade-reminder", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " Kedro-Viz ",
              latestVersion,
              " is here! "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "a",
              {
                href: "https://github.com/kedro-org/kedro-viz/releases",
                target: "_blank",
                rel: "noopener noreferrer",
                children: "View release notes"
              }
            )
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "pipeline-settings-modal__already-latest", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
            " You are on the latest version of Kedro-Viz (",
            latestVersion,
            ")"
          ] }) }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pipeline-settings-modal-buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                dataTest: "settings-modal-close-btn",
                mode: "secondary",
                onClick: resetStateCloseModal,
                size: "small",
                children: "Cancel"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                dataTest: "settings-modal-apply-btn",
                disabled: hasNotInteracted,
                onClick: () => {
                  setHasClickApplyAndClose(true);
                },
                mode: hasClickedApplyAndClose ? "success" : "primary",
                size: "small",
                children: hasClickedApplyAndClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  "Changes applied",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "success-check-mark", children: "" })
                ] }) : "Save and apply"
              }
            )
          ] })
        ] })
      ] })
    }
  ) });
};
const mapStateToProps$3 = (state) => ({
  flags: state.flags,
  showFeatureHints: state.showFeatureHints,
  isPrettyName: state.isPrettyName,
  showDatasetPreviews: state.showDatasetPreviews,
  visible: state.visible
});
const mapDispatchToProps$1 = (dispatch2) => ({
  showSettingsModal: (value) => {
    dispatch2(toggleSettingsModal(value));
  },
  onToggleFlag: (name, value) => {
    dispatch2(changeFlag(name, value));
  },
  onToggleIsPrettyName: (value) => {
    dispatch2(toggleIsPrettyName(value));
  },
  onToggleShowFeatureHints: (value) => {
    dispatch2(toggleShowFeatureHints(value));
  },
  onToggleShowDatasetPreviews: (value) => {
    dispatch2(toggleShowDatasetPreviews(value));
  }
});
const SettingsModal$1 = connect(mapStateToProps$3, mapDispatchToProps$1)(SettingsModal);
const updateContent = {
  date: "9 September 2025",
  features: [
    {
      title: "Render boolean values in table previews",
      image: "",
      copy: "Fixed an issue where boolean values (True/False) in datasets were showing as empty columns in the Table Preview.",
      buttonLink: "",
      buttonText: ""
    },
    {
      title: "Add llms.txt with MkDocs",
      image: "",
      copy: "Introduced an auto-generated llms.txt file using mkdocs-llmstxt to improve LLM discoverability of Kedro-Viz documentation.",
      buttonLink: "",
      buttonText: ""
    },
    {
      title: "Log CycleError and layer dependencies",
      image: "",
      copy: "When a circular dependency is detected, Kedro-Viz now logs the CycleError and shows which layers are involved, making it easier to identify and fix the issue.",
      buttonLink: "",
      buttonText: ""
    },
    {
      title: "Migrate Kedro-Viz to Vite",
      image: "",
      copy: "Migrated Kedro-Viz to use Vite as the build tool, improving development speed and enabling modern JavaScript features.",
      buttonLink: "",
      buttonText: ""
    }
  ]
};
function replaceBackticksWithCodeBlocks(text) {
  const regex = /`([^`]+)`/g;
  return text.replace(regex, "<code>$1</code>");
}
const UpdateReminder = ({ isOutdated, version, visibleMetaSidebar }) => {
  const [dismissed, setDismissed] = reactExports.useState(false);
  const [expand, setExpand] = reactExports.useState(false);
  const { latest, installed } = version;
  const command = "pip install -U kedro-viz";
  const handleKeyDown2 = (event) => {
    if (event.keyCode === 27) {
      setExpand(false);
    }
  };
  reactExports.useEffect(() => {
    window.addEventListener("keydown", handleKeyDown2);
    return () => window.removeEventListener("keydown", handleKeyDown2);
  }, []);
  reactExports.useEffect(() => {
    if (visibleMetaSidebar) {
      setExpand(false);
      setDismissed(true);
    }
  }, [visibleMetaSidebar]);
  if (expand) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "update-reminder", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: classnames("update-reminder-expanded-header", {
            "update-reminder-expanded-header--up-to-date": !isOutdated
          }),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "close-button-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            IconButton,
            {
              ariaLabel: "Close Upgrade Reminder Panel",
              className: "close-button",
              container: React.Fragment,
              icon: CloseIcon,
              onClick: () => setExpand(false)
            }
          ) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          className: classnames("update-reminder-expanded-detail", {
            "update-reminder-expanded-detail--up-to-date": !isOutdated
          }),
          children: isOutdated ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("h3", { children: [
              "Kedro-Viz ",
              latest,
              " is here!"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "Were excited to announce Kedro-Viz ",
              latest,
              " has been released. To update Kedro Viz, copy and paste the following update command into your terminal.",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "a",
                {
                  href: "https://github.com/kedro-org/kedro-viz/releases",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  children: "View full changelog."
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "subtext", children: "Update command" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "command-copier", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CommandCopier,
              {
                command,
                isCommand: true,
                dataTest: "update-reminder-copy-command"
              }
            ) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: "You're up to date" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              "Kedro-Viz ",
              latest
            ] })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: classnames("update-reminder-expanded-content", {
            "update-reminder-expanded-content--up-to-date": !isOutdated
          }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: isOutdated ? "What's new" : "Release highlights" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: updateContent.date }),
            updateContent.features.map((feature) => {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: "update-reminder-expanded-content--feature",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "h4",
                      {
                        dangerouslySetInnerHTML: {
                          __html: replaceBackticksWithCodeBlocks(feature.title)
                        }
                      }
                    ),
                    feature.image.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { alt: feature.title, src: feature.image }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "p",
                      {
                        dangerouslySetInnerHTML: {
                          __html: replaceBackticksWithCodeBlocks(feature.copy)
                        }
                      }
                    ),
                    feature.buttonLink.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: feature.buttonLink, rel: "noreferrer", target: "_blank", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", children: feature.buttonText }) })
                  ]
                },
                feature.title
              );
            })
          ]
        }
      )
    ] });
  }
  if (isOutdated && dismissed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        className: "update-reminder-version-tag update-reminder-version-tag--outdated",
        onClick: () => setExpand(true),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", {}),
          "Kedro-Viz ",
          installed
        ]
      }
    );
  } else if (!isOutdated) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        className: "update-reminder-version-tag update-reminder-version-tag--up-to-date",
        onClick: () => setExpand(true),
        children: [
          "Kedro-Viz ",
          installed
        ]
      }
    );
  }
  if (isOutdated && !dismissed) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "update-reminder-unexpanded", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        "Kedro-Viz ",
        latest,
        " is here! "
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons-container", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "kedro", onClick: () => setExpand(true), children: "Expand" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "kedro", onClick: () => setDismissed(true), children: "Dismiss" })
      ] })
    ] });
  }
};
const mapStateToProps$2 = (state) => ({
  visibleMetaSidebar: getVisibleMetaSidebar(state)
});
const UpdateReminder$1 = connect(mapStateToProps$2)(UpdateReminder);
const UrlBox = ({
  className,
  url,
  onCopyClick,
  href,
  showCopiedText,
  dataTest
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "div",
  {
    className: classnames("url-box__wrapper", {
      [`${className}`]: className
    }),
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "url-box__result-url-wrapper", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          className: "url-box__result-url",
          href,
          target: "_blank",
          rel: "noopener noreferrer",
          children: url
        }
      ) }),
      window.navigator.clipboard && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: classnames("url-box___button", {
            "url-box__button-copied": showCopiedText
          }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: () => onCopyClick(url),
                size: "small",
                dataTest,
                children: "Copy link"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Tooltip,
              {
                text: "Copied!",
                visible: showCopiedText,
                noDelay: true,
                centerArrow: true,
                arrowSize: "small"
              }
            )
          ]
        }
      )
    ]
  }
);
const getFilteredPlatforms = (hostingPlatforms2, platformsKeys) => {
  const filteredPlatforms = {};
  platformsKeys.forEach((key) => {
    if (hostingPlatforms2.hasOwnProperty(key)) {
      filteredPlatforms[key] = hostingPlatforms2[key];
    }
  });
  return filteredPlatforms;
};
const getDeploymentStateByType = (type, deploymentState, compatibilityData, modalMessages) => {
  if (deploymentState === "default" || deploymentState === "published") {
    return null;
  }
  if (type === "title") {
    return deploymentState === "success" ? "Kedro-Viz successfully hosted and published" : "Publish and Share Kedro-Viz";
  }
  if (type === "message") {
    return modalMessages(deploymentState, compatibilityData.package_version);
  }
};
const handleResponseUrl = (responseUrl, platform) => {
  if (!/^https?:\/\//.test(responseUrl) && platform === "gcp") {
    const url = "http://" + responseUrl;
    return url;
  }
  return responseUrl;
};
const PublishedView = ({
  hostingPlatformLocalStorageVal,
  hostingPlatforms: hostingPlatforms2,
  onChange,
  onCopyClick,
  onRepublishClick,
  platform,
  showCopied
}) => {
  const platformsKeysFromLocalStorage = Object.keys(
    hostingPlatformLocalStorageVal
  );
  const platformsValFromLocalStorage = Object.values(
    hostingPlatformLocalStorageVal
  );
  const url = platform ? hostingPlatformLocalStorageVal[platform]["endpoint"] : platformsValFromLocalStorage[0]["endpoint"];
  const filteredPlatforms = getFilteredPlatforms(
    hostingPlatforms2,
    platformsKeysFromLocalStorage
  );
  const href = handleResponseUrl(
    url,
    platform || platformsValFromLocalStorage[0]["platform"]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__published", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__content-title", children: "Publish and Share Kedro-Viz" }),
      platformsKeysFromLocalStorage.length === 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        UrlBox,
        {
          url,
          onCopyClick,
          href,
          showCopiedText: showCopied
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__published-dropdown-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dropdown,
          {
            dataTest: "shareable-url-modal-republish-dropdown-hosting-platform",
            defaultText: platform && filteredPlatforms[platform] || Object.values(filteredPlatforms)[0],
            onChanged: onChange,
            width: null,
            children: Object.entries(filteredPlatforms).map(([value, label]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              MenuOption,
              {
                className: classnames({
                  "pipeline-list__option--active": platform === value
                }),
                primaryText: label,
                value
              },
              value
            ))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          UrlBox,
          {
            className: "url-box__wrapper--half-width",
            url,
            onCopyClick,
            href,
            showCopiedText: showCopied
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__published-action", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "shareable-url-modal__published-action-text", children: [
        "Republish Kedro-Viz to push new updates,",
        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
        "or publish and host Kedro-Viz with a new link."
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { mode: "secondary", onClick: onRepublishClick, size: "small", children: "Republish" })
    ] })
  ] });
};
const CompatibilityErrorView = ({ onClick }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__button-wrapper shareable-url-modal__button-wrapper--right", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { mode: "secondary", onClick, size: "small", children: "Cancel" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "a",
    {
      href: "https://docs.kedro.org/projects/kedro-viz/en/stable/share_kedro_viz.html",
      rel: "noreferrer",
      target: "_blank",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { size: "small", children: "View documentation" })
    }
  )
] });
const InfoIcon = ({ className }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className, viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M7.4001 11.4496H8.6001V7.44961H7.4001V11.4496ZM7.99658 6.24961C8.16559 6.24961 8.30843 6.19245 8.4251 6.07813C8.54176 5.96379 8.6001 5.82213 8.6001 5.65313C8.6001 5.48412 8.54294 5.34128 8.42862 5.22461C8.31428 5.10794 8.17262 5.04961 8.00361 5.04961C7.8346 5.04961 7.69176 5.10677 7.5751 5.22109C7.45843 5.33543 7.4001 5.47709 7.4001 5.64609C7.4001 5.8151 7.45726 5.95794 7.57158 6.07461C7.68591 6.19128 7.82758 6.24961 7.99658 6.24961ZM8.0047 14.6496C7.12385 14.6496 6.29454 14.4829 5.51676 14.1496C4.73899 13.8163 4.05843 13.3579 3.4751 12.7746C2.89176 12.1913 2.43343 11.511 2.1001 10.7336C1.76676 9.95632 1.6001 9.12577 1.6001 8.24198C1.6001 7.35818 1.76676 6.53017 2.1001 5.75794C2.43343 4.98572 2.89176 4.30794 3.4751 3.72461C4.05843 3.14128 4.73875 2.68294 5.51606 2.34961C6.29339 2.01628 7.12394 1.84961 8.00773 1.84961C8.89153 1.84961 9.71954 2.01628 10.4918 2.34961C11.264 2.68294 11.9418 3.14128 12.5251 3.72461C13.1084 4.30794 13.5668 4.98696 13.9001 5.76168C14.2334 6.5364 14.4001 7.36418 14.4001 8.24501C14.4001 9.12585 14.2334 9.95516 13.9001 10.7329C13.5668 11.5107 13.1084 12.1913 12.5251 12.7746C11.9418 13.3579 11.2627 13.8163 10.488 14.1496C9.71331 14.4829 8.88553 14.6496 8.0047 14.6496ZM8.0001 13.4496C9.44454 13.4496 10.6723 12.9441 11.6834 11.9329C12.6945 10.9218 13.2001 9.69405 13.2001 8.24961C13.2001 6.80516 12.6945 5.57739 11.6834 4.56628C10.6723 3.55517 9.44454 3.04961 8.0001 3.04961C6.55565 3.04961 5.32788 3.55517 4.31676 4.56628C3.30565 5.57739 2.8001 6.80516 2.8001 8.24961C2.8001 9.69405 3.30565 10.9218 4.31676 11.9329C5.32788 12.9441 6.55565 13.4496 8.0001 13.4496Z" }) });
const MIN_HEIGHT = 20;
const Input = ({
  characterLimit = false,
  defaultValue = "",
  onChange,
  placeholder: placeholder2,
  resetValueTrigger,
  size = "large",
  dataTest,
  type
}) => {
  const isLimitSet = characterLimit > 0;
  const ref = reactExports.useRef(null);
  const [value, setValue] = reactExports.useState(defaultValue);
  reactExports.useEffect(() => {
    setValue(defaultValue);
  }, [defaultValue]);
  reactExports.useEffect(() => {
    setValue(defaultValue);
  }, [defaultValue, resetValueTrigger]);
  reactExports.useLayoutEffect(() => {
    ref.current.style.height = "inherit";
    ref.current.style.height = `${Math.max(
      ref.current.scrollHeight,
      MIN_HEIGHT
    )}px`;
  }, [value]);
  const handleChange = (e) => {
    const value2 = e.target.value;
    if (isLimitSet) {
      setValue(value2.slice(0, characterLimit));
      onChange && onChange(value2.slice(0, characterLimit));
    } else {
      setValue(value2.slice(0));
      onChange && onChange(value2.slice(0));
    }
  };
  const inputElement = type === "textarea" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "textarea",
    {
      className: `input input--${size}`,
      onChange: handleChange,
      placeholder: placeholder2,
      ref,
      rows: 1,
      value,
      "data-test": dataTest
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type,
      className: `input input--${size}`,
      onChange: handleChange,
      placeholder: placeholder2,
      ref,
      value,
      "data-test": dataTest
    }
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    inputElement,
    isLimitSet ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "input-character-count", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "input-number-characters", children: value.length }),
      "/",
      characterLimit,
      " characters"
    ] }) }) : null
  ] });
};
const renderTextContent = (isPreviewEnabled, setIsPreviewEnabled) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__content-wrapper", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__content-title", children: "Publish and Share Kedro-Viz" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "shareable-url-modal__content-description-title", children: [
      "Prerequisites",
      " "
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "shareable-url-modal__content-description", children: [
      "Deploying and hosting Kedro-Viz requires access keys or user credentials, depending on the chosen service provider. To use this feature, please add your access keys or credentials as environment variables in your project. More information can be found in the",
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "a",
        {
          target: "_blank",
          rel: "noopener noreferrer",
          href: KEDRO_VIZ_PUBLISH_DOCS_URL,
          children: "documentation"
        }
      ),
      "."
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: "shareable-url-modal__content-description-title shareable-url-modal__content-description-title--disclaimer", children: [
      "Disclaimer",
      " "
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "shareable-url-modal__content-description", children: "Kedro-Viz contains preview data for multiple datasets. You can enable or disable all previews when publishing Kedro-Viz." }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__content-preview-dataset", children: [
      "All dataset previews",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          className: "shareable-url-modal__content-toggle",
          dataTest: `shareable-url-modal-preview-dataset-${isPreviewEnabled}`,
          title: isPreviewEnabled ? "On" : "Off",
          checked: isPreviewEnabled,
          onChange: () => setIsPreviewEnabled((prev2) => !prev2)
        }
      )
    ] })
  ] });
};
const MainView = ({
  handleModalClose,
  handleSubmit,
  inputValues,
  isFormDirty,
  onPlatformChange,
  onBuckNameChange,
  onEndpointChange,
  setIsPreviewEnabled,
  isPreviewEnabled,
  visible
}) => {
  const { platform, bucket_name, endpoint } = inputValues || {};
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__content-form-wrapper", children: [
      renderTextContent(isPreviewEnabled, setIsPreviewEnabled),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__form-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "shareable-url-modal__form-wrapper-title", children: "Please enter the required information below." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__input-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__input-label", children: "Hosting platform" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dropdown,
            {
              defaultText: platform && hostingPlatforms[platform],
              placeholderText: !platform ? "Select a hosting platform" : null,
              onChanged: onPlatformChange,
              dataTest: "shareable-url-modal-dropdown-hosting-platform",
              width: null,
              children: Object.entries(hostingPlatforms).map(([value, label]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                MenuOption,
                {
                  className: classnames({
                    "pipeline-list__option--active": platform === value
                  }),
                  primaryText: label,
                  value
                },
                value
              ))
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__input-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__input-label", children: "Bucket name" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              defaultValue: bucket_name,
              onChange: onBuckNameChange,
              placeholder: "Enter name",
              resetValueTrigger: visible,
              size: "small",
              type: "input",
              dataTest: "shareable-url-modal-input-bucket-name"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__input-wrapper", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__endpoint-url-wrapper", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__input-label", children: "Endpoint URL" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              IconButton,
              {
                ariaLabel: "The endpoint URL information",
                className: "shareable-url-modal__information-icon",
                labelText: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "shareable-url-modal__information-text", children: [
                  "The endpoint URL is the link to where your Kedro-Viz will be hosted. For information on obtaining the endpoint URL, please refer to the documentation for",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "a",
                    {
                      className: "shareable-url-modal__input-label-text",
                      href: KEDRO_VIZ_PUBLISH_AWS_DOCS_URL,
                      rel: "noreferrer",
                      target: "_blank",
                      children: "AWS"
                    }
                  ),
                  ",",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "a",
                    {
                      className: "shareable-url-modal__input-label-text",
                      href: KEDRO_VIZ_PUBLISH_AZURE_DOCS_URL,
                      rel: "noreferrer",
                      target: "_blank",
                      children: "Azure"
                    }
                  ),
                  ",",
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    "a",
                    {
                      className: "shareable-url-modal__input-label-text",
                      href: KEDRO_VIZ_PUBLISH_GCP_DOCS_URL,
                      rel: "noreferrer",
                      target: "_blank",
                      children: "GCP"
                    }
                  )
                ] }),
                icon: InfoIcon
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              defaultValue: endpoint,
              onChange: onEndpointChange,
              placeholder: "Enter url",
              resetValueTrigger: visible,
              size: "small",
              type: "input",
              dataTest: "shareable-url-modal-input-endpoint"
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__button-wrapper", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          mode: "secondary",
          onClick: handleModalClose,
          size: "small",
          dataTest: "shareable-url-modal-cancel-btn",
          children: "Cancel"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          disabled: !Object.values(isFormDirty).every((value) => value),
          size: "small",
          onClick: handleSubmit,
          dataTest: "shareable-url-modal-publish-publish-btn",
          children: "Publish"
        }
      )
    ] })
  ] });
};
const LoadingView = ({ isLoading: isLoading2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__loading", children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, { visible: isLoading2 }) });
const ErrorView = ({ onClick, responseError }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "shareable-url-modal__error", children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
    "Error message: ",
    responseError
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button,
    {
      mode: "primary",
      onClick,
      size: "small",
      dataTest: "shareable-url-modal-publish-fail",
      children: "Go back"
    }
  )
] });
const SuccessView = ({
  handleResponseUrl: handleResponseUrl2,
  onClick,
  responseUrl,
  showCopied
}) => {
  return responseUrl ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "shareable-url-modal__result", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    UrlBox,
    {
      url: responseUrl,
      onCopyClick: onClick,
      href: handleResponseUrl2,
      showCopiedText: showCopied,
      dataTest: "shareable-url-modal-publish-success"
    }
  ) }) : null;
};
const ShareableUrlModal = ({ onToggleModal, onSetBanner, visible }) => {
  const [deploymentState, setDeploymentState] = reactExports.useState("default");
  const [inputValues, setInputValues] = reactExports.useState({});
  const [isFormDirty, setIsFormDirty] = reactExports.useState({
    hasBucketName: false,
    hasPlatform: false,
    hasEndpoint: false
  });
  const [isLoading2, setIsLoading] = reactExports.useState(false);
  const [responseUrl, setResponseUrl] = reactExports.useState(null);
  const [responseError, setResponseError] = reactExports.useState(null);
  const [showCopied, setShowCopied] = reactExports.useState(false);
  const [compatibilityData, setCompatibilityData] = reactExports.useState({});
  const [isCompatible, setIsCompatible] = reactExports.useState(true);
  const [showPublishedView, setShowPublishedView] = reactExports.useState(false);
  const [hostingPlatformLocalStorageVal, setHostingPlatformLocalStorageVal] = reactExports.useState(loadLocalStorage(localStorageShareableUrl) || {});
  const [publishedPlatformKey, setPublishedPlatformKey] = reactExports.useState(void 0);
  const [isPreviewEnabled, setIsPreviewEnabled] = reactExports.useState(false);
  reactExports.useEffect(() => {
    async function checkPackageCompatibility() {
      try {
        const request = await fetchMetadata();
        const response = await request.json();
        if (request.ok) {
          onSetBanner(
            BANNER_KEYS.LITE,
            Boolean(response.has_missing_dependencies)
          );
          const packageCompatibilityInfo = response.package_compatibilities;
          const fsspecPackage = packageCompatibilityInfo.find(
            (pckg) => pckg.package_name === PACKAGE_FSSPEC
          );
          setCompatibilityData(fsspecPackage);
          setIsCompatible((fsspecPackage == null ? void 0 : fsspecPackage.is_compatible) || false);
          if (!fsspecPackage.is_compatible) {
            setDeploymentState(!fsspecPackage.is_compatible && "incompatible");
          }
        }
      } catch (error) {
        console.error("metadata fetch error: ", error);
      }
    }
    checkPackageCompatibility();
  }, [onSetBanner]);
  const setStateForPublishedView = () => {
    if (Object.keys(hostingPlatformLocalStorageVal).length > 0) {
      setDeploymentState("published");
      setShowPublishedView(true);
      setPublishedPlatformKey(Object.keys(hostingPlatformLocalStorageVal)[0]);
    }
  };
  const setStateForMainViewWithPublishedContent = () => {
    if (Object.keys(hostingPlatformLocalStorageVal).length > 0) {
      setShowPublishedView(false);
      setDeploymentState("default");
      const populatedContent = hostingPlatformLocalStorageVal[publishedPlatformKey];
      setInputValues(populatedContent);
      setIsFormDirty({
        hasBucketName: true,
        hasPlatform: true,
        hasEndpoint: true
      });
    }
  };
  reactExports.useEffect(() => {
    setStateForPublishedView();
  }, []);
  const onChange = (key, value) => {
    setIsFormDirty((prevState) => ({
      ...prevState,
      [inputKeyToStateKeyMap[key]]: !!value
    }));
    setInputValues(
      Object.assign({}, inputValues, {
        [key]: value
      })
    );
  };
  const updateFormWithLocalStorageData = (platformKey) => {
    if (hostingPlatformLocalStorageVal[platformKey]) {
      const populatedContent = hostingPlatformLocalStorageVal[platformKey];
      setInputValues(populatedContent);
      setIsFormDirty({
        hasBucketName: true,
        hasPlatform: true,
        hasEndpoint: true
      });
    } else {
      const emptyContent = {
        platform: platformKey,
        bucket_name: "",
        endpoint: ""
      };
      setInputValues(emptyContent);
      setIsFormDirty({
        hasBucketName: false,
        hasPlatform: true,
        hasEndpoint: false
      });
    }
  };
  const updateLocalStorageState = () => {
    const selectedHostingPlatformVal = {};
    if (hostingPlatforms.hasOwnProperty(inputValues.platform)) {
      selectedHostingPlatformVal[inputValues.platform] = { ...inputValues };
    }
    saveLocalStorage(localStorageShareableUrl, selectedHostingPlatformVal);
    const localStorageExcludingSelectedPlatform = Object.fromEntries(
      Object.entries(hostingPlatformLocalStorageVal).filter(
        ([key]) => !(key in selectedHostingPlatformVal)
      )
    );
    const newState = {
      ...selectedHostingPlatformVal,
      ...localStorageExcludingSelectedPlatform
    };
    setHostingPlatformLocalStorageVal(newState);
  };
  const handleSubmit = async () => {
    setDeploymentState("loading");
    setIsLoading(true);
    setShowPublishedView(false);
    try {
      const request = await deployViz({
        ...inputValues,
        is_all_previews_enabled: isPreviewEnabled
      });
      const response = await request.json();
      if (request.ok) {
        setResponseUrl(response.url);
        setDeploymentState("success");
        updateLocalStorageState();
      } else {
        setResponseUrl(null);
        setResponseError(response.message || "Error occurred!");
        setDeploymentState("failure");
      }
    } catch (error) {
      console.error(error);
      setResponseError(error.message || "Error occurred!");
      setDeploymentState("failure");
    } finally {
      setIsLoading(false);
    }
  };
  const onCopyClick = (url) => {
    window.navigator.clipboard.writeText(url);
    setShowCopied(true);
    setTimeout(() => {
      setShowCopied(false);
    }, 1500);
  };
  const handleModalClose = () => {
    onToggleModal(false);
    if (deploymentState !== "incompatible") {
      if (Object.keys(hostingPlatformLocalStorageVal).length === 0) {
        setDeploymentState("default");
      }
      setStateForPublishedView();
    }
    setResponseError(null);
    setIsLoading(false);
    setResponseUrl(null);
    setInputValues({});
    setIsFormDirty({
      hasBucketName: false,
      hasPlatform: false,
      hasEndpoint: false
    });
    setIsPreviewEnabled(false);
  };
  const { platform } = inputValues || {};
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Modal,
    {
      className: classnames("shareable-url-modal", {
        "shareable-url-modal__non-default-wrapper": deploymentState !== "default",
        "shareable-url-modal__published-wrapper": deploymentState === "published",
        "shareable-url-modal__success-wrapper": deploymentState === "success"
      }),
      closeModal: handleModalClose,
      message: getDeploymentStateByType(
        "message",
        deploymentState,
        compatibilityData,
        shareableUrlMessages
      ),
      title: getDeploymentStateByType(
        "title",
        deploymentState,
        compatibilityData,
        shareableUrlMessages
      ),
      visible: visible.shareableUrlModal,
      children: !isCompatible ? /* @__PURE__ */ jsxRuntimeExports.jsx(CompatibilityErrorView, { onClick: handleModalClose }) : showPublishedView ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        PublishedView,
        {
          hostingPlatformLocalStorageVal,
          hostingPlatforms,
          onChange: (selectedPlatform) => {
            onChange("platform", selectedPlatform.value);
            setPublishedPlatformKey(selectedPlatform.value);
          },
          onCopyClick,
          onRepublishClick: setStateForMainViewWithPublishedContent,
          platform,
          showCopied
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !isLoading2 && !responseUrl && !responseError && /* @__PURE__ */ jsxRuntimeExports.jsx(
          MainView,
          {
            handleModalClose,
            handleSubmit,
            inputValues,
            isFormDirty,
            onPlatformChange: (selectedPlatform) => {
              updateFormWithLocalStorageData(selectedPlatform.value);
            },
            onBuckNameChange: (value) => onChange("bucket_name", value),
            onEndpointChange: (value) => onChange("endpoint", value),
            setIsPreviewEnabled,
            isPreviewEnabled,
            visible
          }
        ),
        isLoading2 && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingView, { isLoading: isLoading2 }),
        responseError && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ErrorView,
          {
            onClick: () => {
              setDeploymentState("default");
              setIsLoading(false);
              setResponseUrl(null);
              setResponseError(null);
            },
            responseError
          }
        ),
        responseUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(
          SuccessView,
          {
            handleResponseUrl: handleResponseUrl(responseUrl, platform),
            onClick: onCopyClick,
            responseUrl,
            showCopied
          }
        )
      ] })
    }
  );
};
const mapStateToProps$1 = (state) => ({
  visible: state.visible
});
const mapDispatchToProps = (dispatch2) => ({
  onToggleModal: (value) => {
    dispatch2(toggleShareableUrlModal(value));
  },
  onSetBanner: (name, value) => {
    dispatch2(setBanner(name, value));
  }
});
const ShareableUrlModal$1 = connect(mapStateToProps$1, mapDispatchToProps)(ShareableUrlModal);
const Wrapper = ({ displayGlobalNavigation, theme }) => {
  const [isOutdated, setIsOutdated] = reactExports.useState(false);
  const [latestVersion, setLatestVersion] = reactExports.useState(null);
  const [version, setVersion] = reactExports.useState(null);
  reactExports.useEffect(() => {
    async function checkKedroVizVersion() {
      try {
        const request = await getVersion();
        const response = await request.json();
        if (request.ok) {
          setIsOutdated(response.is_outdated);
          setLatestVersion(response.latest);
          setVersion(response);
        }
      } catch (error) {
        console.error("Error fetching Kedro-Viz version:", error);
      }
    }
    checkKedroVizVersion();
  }, []);
  const allKedroVizRoutes = /* @__PURE__ */ jsxRuntimeExports.jsxs(Switch, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { exact: true, path: sanitizedPathname(), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FlowChartWrapper$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FeatureHints$1, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: `${sanitizedPathname()}workflow`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(WorkflowWrapper$1, {}) })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classnames("kedro-pipeline kedro", {
        "kui-theme--dark": theme === "dark",
        "kui-theme--light": theme === "light"
      }),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "pipeline-title", children: "Kedro-Viz" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: displayGlobalNavigation ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalToolbar$1, { isOutdated }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SettingsModal$1,
            {
              isOutdated,
              latestVersion
            }
          ),
          isRunningLocally() ? /* @__PURE__ */ jsxRuntimeExports.jsx(ShareableUrlModal$1, {}) : null,
          version && /* @__PURE__ */ jsxRuntimeExports.jsx(UpdateReminder$1, { isOutdated, version }),
          allKedroVizRoutes
        ] }) : allKedroVizRoutes })
      ]
    }
  );
};
const mapStateToProps = (state) => ({
  displayGlobalNavigation: state.display.globalNavigation,
  theme: state.theme
});
const Wrapper$1 = connect(mapStateToProps, null)(Wrapper);
class App extends React.Component {
  constructor(props) {
    super(props);
    const initialState = getInitialState(props);
    this.store = configureStore(
      initialState,
      this.props.data,
      this.props.onActionCallback
    );
  }
  componentDidMount() {
    if (this.props.data === "json") {
      this.store.dispatch(loadInitialPipelineData());
    }
    if (!this.props.runData) {
      this.store.dispatch(loadInitialRunStatusData());
    }
    this.announceFlags(this.store.getState().flags);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.data !== this.props.data) {
      this.updatePipelineData();
    }
    if (this.props.runData && prevProps.runData !== this.props.runData) {
      const processedData = processRunStatus(this.props.runData);
      this.store.dispatch(updateRunStatusData(processedData));
    }
    if (!fpExports.isEqual(prevProps.options, this.props.options)) {
      this.store.dispatch(updateStateFromOptions(this.props.options));
    }
    if (this.props.data && this.props.data.selected_pipeline !== prevProps.data.selected_pipeline) {
      this.store.dispatch(loadPipelineData(this.props.data.selected_pipeline));
    }
  }
  /**
   * Shows a console message regarding the given flags
   */
  announceFlags(flags2) {
    const message = getFlagsMessage(flags2);
    if (message && typeof jest === "undefined") {
      console.info(message);
    }
  }
  /**
   * Dispatch an action to update the store with new pipeline data
   */
  updatePipelineData() {
    const newState = preparePipelineState(this.props.data, true);
    this.store.dispatch(resetData(newState));
  }
  render() {
    return this.props.data ? /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store: this.store, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Wrapper$1, {}) }) : null;
  }
}
App.propTypes = {
  /**
   * Determines what pipeline data will be displayed on the chart.
   * You can supply an object containing lists of edges, nodes, tags -
   * See /src/utils/data for examples of the expected data format.
   * Alternatively, the string 'json' indicates that data is being
   * loaded asynchronously from /public/api/nodes.json
   */
  data: PropTypes.oneOfType([
    PropTypes.oneOf(["json"]),
    PropTypes.shape({
      edges: PropTypes.array.isRequired,
      layers: PropTypes.array,
      nodes: PropTypes.array.isRequired,
      tags: PropTypes.array
    })
  ]),
  /**
   * Determines what run status data will be displayed on the chart.
   * You can supply an object with run status information -
   * Alternatively, the string 'json' indicates that data is being
   * loaded asynchronously from /api/run-status
   */
  runData: PropTypes.oneOfType([PropTypes.oneOf(["json"]), PropTypes.object]),
  options: PropTypes.shape({
    /**
     * Specify the theme: Either 'light' or 'dark'.
     * If set, this will override the localStorage value.
     */
    theme: PropTypes.oneOf(["dark", "light"]),
    /**
     * Determines if certain elements are displayed, e.g globalNavigation, sidebar
     */
    display: PropTypes.shape({
      globalNavigation: PropTypes.bool,
      sidebar: PropTypes.bool,
      miniMap: PropTypes.bool,
      expandPipelinesBtn: PropTypes.bool,
      exportBtn: PropTypes.bool,
      labelBtn: PropTypes.bool,
      layerBtn: PropTypes.bool,
      zoomToolBar: PropTypes.bool,
      metadataPanel: PropTypes.bool,
      filterBtn: PropTypes.bool
    }),
    /**
     * Override the default enabled/disabled tags
     */
    tag: PropTypes.shape({
      enabled: PropTypes.objectOf(PropTypes.bool)
    }),
    /**
     * Whether to re-focus the graph when a node is clicked
     */
    behaviour: PropTypes.shape({
      reFocus: PropTypes.bool
    }),
    /**
     * Override the default enabled/disabled node types
     */
    nodeType: PropTypes.shape({
      disabled: PropTypes.shape({
        parameters: PropTypes.bool,
        task: PropTypes.bool,
        data: PropTypes.bool
      })
    })
  }),
  expandAllPipelines: PropTypes.bool
};
const createRoot = clientExports.createRoot;
export {
  App as KedroViz,
  React,
  createRoot
};
