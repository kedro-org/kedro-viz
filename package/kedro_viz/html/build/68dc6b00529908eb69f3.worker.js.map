{"version":3,"sources":["../webpack/bootstrap","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","utils/graph/common.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../node_modules/kiwi.js/es/maptype.js","../node_modules/kiwi.js/es/variable.js","../node_modules/kiwi.js/es/expression.js","../node_modules/kiwi.js/es/strength.js","../node_modules/kiwi.js/es/constraint.js","../node_modules/kiwi.js/es/solver.js","utils/graph/solver.js","utils/graph/constraints.js","utils/graph/layout.js","utils/graph/routing.js","utils/graph/graph.js","utils/graph/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_defineProperty","obj","configurable","writable","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","_arrayLikeToArray","arr","len","arr2","Array","_unsupportedIterableToArray","minLen","toString","slice","constructor","from","test","_createForOfIteratorHelper","allowArrayLike","it","iterator","isArray","F","done","e","_e","f","TypeError","err","normalCompletion","didErr","step","next","_e2","HALF_PI","Math","PI","snap","unit","round","angle","a","b","atan2","y","x","nodeLeft","node","width","nodeRight","nodeTop","height","nodeBottom","groupByRow","nodes","rows","rowNumbers","map","row","parseFloat","sort","sortedRows","compare","id","delta","localeCompare","values","offsetNode","offset","order","offsetEdge","edge","points","point","nearestOnLine","ax","ay","bx","by","min","max","dx","dy","positionClamped","_toConsumableArray","iter","createMap","IndexedMap","this","index","array","size","empty","itemAt","contains","undefined","find","setDefault","factory","pair","Pair","insert","erase","last","pop","first","copy","second","Variable","_value","_context","_id","VarId","_name","setName","context","setContext","setValue","plus","Expression","minus","multiply","coefficient","divide","toJSON","parsed","parseArgs","_terms","terms","_constant","constant","result","isConstant","join","args","item","j","k","terms2","termPair","Error","value2","Operator","Strength","w","clip","required","strong","medium","weak","SymbolType","Constraint","expression","operator","rhs","strength","CnId","_operator","_strength","_expression","op","Solver","_cnMap","_rowMap","_varMap","_editMap","_infeasibleRows","_objective","Row","_artificial","_idTick","createConstraint","lhs","cn","addConstraint","constraint","data","_createRow","tag","subject","_chooseSubject","type","Invalid","allDummies","nearZero","marker","_addWithArtificialVariable","solveFor","_substitute","_optimize","removeConstraint","cnPair","_removeConstraintEffects","rowPair","leaving","_getMarkerLeavingSymbol","solveForEx","hasConstraint","addEditVariable","variable","expr","Eq","info","removeEditVariable","editPair","hasEditVariable","suggestValue","add","_dualOptimize","other","rowPair_1","coeff","coefficientFor","External","updateVariables","vars","_getVarSymbol","_this","_makeSymbol","symbol","basicPair","insertRow","insertSymbol","objective","INVALID_SYMBOL","Le","Ge","slack","Slack","error","errplus","errminus","dummy","Dummy","reverseSign","cells","art","success","basicRow","entering","_anyPivotableSymbol","removeSymbol","substitute","_getEnteringSymbol","_getLeavingSymbol","infeasible","_getDualEnteringSymbol","ratio","Number","MAX_VALUE","found","temp","temp_ratio","dmax","r1","r2","invalid","third","_removeMarkerEffects","_type","_cellMap","theCopy","solveLoose","constraints","iterations","constants","base","solve","solveStrict","solver","variables","variableId","addVariable","unsolvableCount","strict","console","warn","rowConstraint","variableA","variableB","spaceY","layerConstraint","layerSpace","parallelConstraint","resolve","crossingConstraint","edgeA","edgeB","separationA","separationB","resolveSource","sourceNode","resolveTarget","targetNode","separationConstraint","separation","layout","edges","layers","spaceX","spreadX","layerSpaceY","rowConstraints","createRowConstraints","layerConstraints","createLayerConstraints","crossingConstraints","createCrossingConstraints","parallelConstraints","createParallelConstraints","separationConstraints","createSeparationConstraints","expandDenseRows","layerGroups","nearestLayer","layerNodes","nextLayerNodes","intermediary","sourceA","targetA","edgeADegree","sources","targets","sourceB","targetB","edgeBDegree","rowNodes","nodeA","nodeB","degreeA","degreeB","spread","space","scale","densities","rowDensity","spaceYUnit","currentOffsetY","density","offsetY","edgeAngle","abs","sourceRow","targetRow","routing","minPassageGap","stemUnit","stemMinSource","stemMinTarget","stemMax","stemSpaceSource","stemSpaceTarget","sourceOffsetX","indexOf","currentPoint","firstNode","nearestPoint","nearestDistance","Infinity","rowExtended","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","nextNode","nodeGap","offsetX","candidatePoint","distance","sourceSeparation","targetSeparation","sourceEdgeDistance","targetEdgeDistance","targetOffsetX","sourceOffsetY","targetOffsetY","sourceStem","targetStem","pointYMax","defaultOptions","padding","addEdgeLinks","nodeById","addNearestLayers","validLayers","layer","hasValidLayer","Boolean","lastLayer","layerNode","findNodeBy","targetNodes","orderRankAscending","rank","successors","accept","visited","successor","bounds","graphNew","options","graph","marginx","marginy"],"mappings":"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","file":"68dc6b00529908eb69f3.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","/* eslint-disable id-length */\n\n/**\n * PI / 2 constant\n */\n\nexport const HALF_PI = Math.PI * 0.5;\n\n/**\n * Clamps the value between min and max\n * @param {number} value The number to clamp\n * @param {number} min The minimum value\n * @param {number} max The maximum value\n * @returns {number} The value clamped\n */\nexport const clamp = (value, min, max) =>\n  value < min ? min : value > max ? max : value;\n\n/**\n * Rounds the value to the nearest unit value\n * @param {number} value The value to snap\n * @param {number} unit The unit\n * @returns {number} The value snapped\n */\nexport const snap = (value, unit) => Math.round(value / unit) * unit;\n\n/**\n * Returns the distance between two values\n * @param {number} a The first value\n * @param {number} b The second value\n * @returns {number} The distance\n */\nexport const distance1d = (a, b) => Math.abs(a - b);\n\n/**\n * Returns the angle in radians between the points a and b relative to the X-axis about the origin\n * @param {object} a The first point\n * @param {object} b The second point\n * @returns {number} The angle\n */\nexport const angle = (a, b) => Math.atan2(a.y - b.y, a.x - b.x);\n\n/**\n * Returns the left edge x-position of the node\n * @param {object} node The node\n * @returns {number} The left edge position\n */\nexport const nodeLeft = (node) => node.x - node.width * 0.5;\n\n/**\n * Returns the right edge x-position of the node\n * @param {object} node The node\n * @returns {number} The right edge position\n */\nexport const nodeRight = (node) => node.x + node.width * 0.5;\n\n/**\n * Returns the top edge y-position of the node\n * @param {object} node The node\n * @returns {number} The top edge position\n */\nexport const nodeTop = (node) => node.y - node.height * 0.5;\n\n/**\n * Returns the bottom edge y-position of the node\n * @param {object} node The node\n * @returns {number} The bottom edge position\n */\nexport const nodeBottom = (node) => node.y + node.height * 0.5;\n\n/**\n * Finds the rows formed by nodes given the their positions in Y.\n * The result is sorted in X and Y.\n * Adds a `row` property to each node in-place\n * @param {array} nodes The input nodes\n * @returns {array} The sorted rows of nodes\n */\nexport const groupByRow = (nodes) => {\n  const rows = {};\n\n  // Create rows using node Y values\n  for (const node of nodes) {\n    rows[node.y] = rows[node.y] || [];\n    rows[node.y].push(node);\n  }\n\n  // Sort the set of rows accounting for keys being strings\n  const rowNumbers = Object.keys(rows).map((row) => parseFloat(row));\n  rowNumbers.sort((a, b) => a - b);\n\n  // Sort rows in order of X position if set. Break ties with ids for stability\n  const sortedRows = rowNumbers.map((row) => rows[row]);\n  for (let i = 0; i < sortedRows.length; i += 1) {\n    sortedRows[i].sort((a, b) => compare(a.x, b.x, a.id, b.id));\n\n    for (const node of sortedRows[i]) {\n      node.row = i;\n    }\n  }\n\n  return sortedRows;\n};\n\n/**\n * Generalised comparator function for sorting\n * If values are strings then `localeCompare` is used, otherwise values are subtracted\n * Compares the first pair of values and returns the difference if non equal,\n * otherwise ties are broken by comparing the subsequent pairs of values\n * @param {number|string} a Value to compare with `b`\n * @param {number|string} b Value to compare with `a`\n * @param {...number|string} values Any number of further pairs of values to compare as tie-breakers\n * @returns {number} A standard signed comparator result\n */\nexport const compare = (a, b, ...values) => {\n  const delta = typeof a === 'string' ? a.localeCompare(b) : a - b;\n  return delta !== 0 || values.length === 0 ? delta : compare(...values);\n};\n\n/**\n * Returns the node with the position translated in-place\n * @param {object} node The node\n * @param {object} offset The translation vector\n * @returns {object} The node\n */\nexport const offsetNode = (node, offset) => {\n  node.x = node.x - offset.x;\n  node.y = node.y - offset.y;\n  // Node sort order for tabindex:\n  node.order = node.x + node.y * 9999;\n  return node;\n};\n\n/**\n * Returns the edge with each point translated in-place\n * @param {object} edge The edge\n * @param {object} offset The translation vector\n * @returns {object} The edge\n */\nexport const offsetEdge = (edge, offset) => {\n  edge.points.forEach((point) => {\n    point.x = point.x - offset.x;\n    point.y = point.y - offset.y;\n  });\n  return edge;\n};\n\n/**\n * Returns the point on the line segment `ax, ay, bx, by` closest to point `x, y`\n * @param {number} x The test point x\n * @param {number} y The test point y\n * @param {number} ax The start of the line segement x point\n * @param {number} ay The start of the line segement y point\n * @param {number} bx The end of the line segement x point\n * @param {number} by The end of the line segement y point\n * @returns {object} An object with the closest point and both line segment points\n */\nexport const nearestOnLine = (x, y, ax, ay, bx, by) => {\n  const dx = bx - ax;\n  const dy = by - ay;\n  const position = ((x - ax) * dx + (y - ay) * dy) / (dx * dx + dy * dy || 1);\n  const positionClamped = clamp(position, 0, 1);\n\n  return {\n    x: ax + dx * positionClamped,\n    y: ay + dy * positionClamped,\n    ax,\n    ay,\n    bx,\n    by,\n  };\n};\n","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nexport function createMap() {\n    return new IndexedMap();\n}\nvar IndexedMap = /** @class */ (function () {\n    function IndexedMap() {\n        this.index = {};\n        this.array = [];\n    }\n    /**\n     * Returns the number of items in the array.\n     */\n    IndexedMap.prototype.size = function () {\n        return this.array.length;\n    };\n    /**\n     * Returns true if the array is empty.\n     */\n    IndexedMap.prototype.empty = function () {\n        return this.array.length === 0;\n    };\n    /**\n     * Returns the item at the given array index.\n     *\n     * @param index The integer index of the desired item.\n     */\n    IndexedMap.prototype.itemAt = function (index) {\n        return this.array[index];\n    };\n    /**\n     * Returns true if the key is in the array, false otherwise.\n     *\n     * @param key The key to locate in the array.\n     */\n    IndexedMap.prototype.contains = function (key) {\n        return this.index[key.id()] !== undefined;\n    };\n    /**\n     * Returns the pair associated with the given key, or undefined.\n     *\n     * @param key The key to locate in the array.\n     */\n    IndexedMap.prototype.find = function (key) {\n        var i = this.index[key.id()];\n        return i === undefined ? undefined : this.array[i];\n    };\n    /**\n     * Returns the pair associated with the key if it exists.\n     *\n     * If the key does not exist, a new pair will be created and\n     * inserted using the value created by the given factory.\n     *\n     * @param key The key to locate in the array.\n     * @param factory The function which creates the default value.\n     */\n    IndexedMap.prototype.setDefault = function (key, factory) {\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            var pair = new Pair(key, factory());\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n            return pair;\n        }\n        else {\n            return this.array[i];\n        }\n    };\n    /**\n     * Insert the pair into the array and return the pair.\n     *\n     * This will overwrite any existing entry in the array.\n     *\n     * @param key The key portion of the pair.\n     * @param value The value portion of the pair.\n     */\n    IndexedMap.prototype.insert = function (key, value) {\n        var pair = new Pair(key, value);\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            this.index[key.id()] = this.array.length;\n            this.array.push(pair);\n        }\n        else {\n            this.array[i] = pair;\n        }\n        return pair;\n    };\n    /**\n     * Removes and returns the pair for the given key, or undefined.\n     *\n     * @param key The key to remove from the map.\n     */\n    IndexedMap.prototype.erase = function (key) {\n        var i = this.index[key.id()];\n        if (i === undefined) {\n            return undefined;\n        }\n        this.index[key.id()] = undefined;\n        var pair = this.array[i];\n        var last = this.array.pop();\n        if (pair !== last) {\n            this.array[i] = last;\n            this.index[last.first.id()] = i;\n        }\n        return pair;\n    };\n    /**\n     * Create a copy of this associative array.\n     */\n    IndexedMap.prototype.copy = function () {\n        var copy = new IndexedMap();\n        for (var i = 0; i < this.array.length; i++) {\n            var pair = this.array[i].copy();\n            copy.array[i] = pair;\n            copy.index[pair.first.id()] = i;\n        }\n        return copy;\n    };\n    return IndexedMap;\n}());\n/**\n * A class which defines a generic pair object.\n * @private\n */\n// tslint:disable: max-classes-per-file\nvar Pair = /** @class */ (function () {\n    /**\n     * Construct a new Pair object.\n     *\n     * @param first The first item of the pair.\n     * @param second The second item of the pair.\n     */\n    function Pair(first, second) {\n        this.first = first;\n        this.second = second;\n    }\n    /**\n     * Create a copy of the pair.\n     */\n    Pair.prototype.copy = function () { return new Pair(this.first, this.second); };\n    return Pair;\n}());\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Expression } from \"./expression\";\n/**\n * The primary user constraint variable.\n *\n * @class\n * @param {String} [name=\"\"] The name to associated with the variable.\n */\nvar Variable = /** @class */ (function () {\n    function Variable(name) {\n        if (name === void 0) { name = \"\"; }\n        this._value = 0.0;\n        this._context = null;\n        this._id = VarId++;\n        this._name = name;\n    }\n    /**\n     * Returns the unique id number of the variable.\n     * @private\n     */\n    Variable.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the name of the variable.\n     *\n     * @return {String} name of the variable\n     */\n    Variable.prototype.name = function () {\n        return this._name;\n    };\n    /**\n     * Set the name of the variable.\n     *\n     * @param {String} name Name of the variable\n     */\n    Variable.prototype.setName = function (name) {\n        this._name = name;\n    };\n    /**\n     * Returns the user context object of the variable.\n     * @private\n     */\n    Variable.prototype.context = function () {\n        return this._context;\n    };\n    /**\n     * Set the user context object of the variable.\n     * @private\n     */\n    Variable.prototype.setContext = function (context) {\n        this._context = context;\n    };\n    /**\n     * Returns the value of the variable.\n     *\n     * @return {Number} Calculated value\n     */\n    Variable.prototype.value = function () {\n        return this._value;\n    };\n    /**\n     * Set the value of the variable.\n     * @private\n     */\n    Variable.prototype.setValue = function (value) {\n        this._value = value;\n    };\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    Variable.prototype.plus = function (value) {\n        return new Expression(this, value);\n    };\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the variable.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    Variable.prototype.minus = function (value) {\n        return new Expression(this, typeof value === \"number\" ? -value : [-1, value]);\n    };\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    Variable.prototype.multiply = function (coefficient) {\n        return new Expression([coefficient, this]);\n    };\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    Variable.prototype.divide = function (coefficient) {\n        return new Expression([1 / coefficient, this]);\n    };\n    /**\n     * Returns the JSON representation of the variable.\n     * @private\n     */\n    Variable.prototype.toJSON = function () {\n        return {\n            name: this._name,\n            value: this._value,\n        };\n    };\n    Variable.prototype.toString = function () {\n        return this._context + \"[\" + this._name + \":\" + this._value + \"]\";\n    };\n    return Variable;\n}());\nexport { Variable };\n/**\n * The internal variable id counter.\n * @private\n */\nvar VarId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { createMap } from \"./maptype\";\nimport { Variable } from \"./variable\";\n/**\n * An expression of variable terms and a constant.\n *\n * The constructor accepts an arbitrary number of parameters,\n * each of which must be one of the following types:\n *  - number\n *  - Variable\n *  - Expression\n *  - 2-tuple of [number, Variable|Expression]\n *\n * The parameters are summed. The tuples are multiplied.\n *\n * @class\n * @param {...(number|Variable|Expression|Array)} args\n */\nvar Expression = /** @class */ (function () {\n    function Expression() {\n        var parsed = parseArgs(arguments);\n        this._terms = parsed.terms;\n        this._constant = parsed.constant;\n    }\n    /**\n     * Returns the mapping of terms in the expression.\n     *\n     * This *must* be treated as const.\n     * @private\n     */\n    Expression.prototype.terms = function () {\n        return this._terms;\n    };\n    /**\n     * Returns the constant of the expression.\n     * @private\n     */\n    Expression.prototype.constant = function () {\n        return this._constant;\n    };\n    /**\n     * Returns the computed value of the expression.\n     *\n     * @private\n     * @return {Number} computed value of the expression\n     */\n    Expression.prototype.value = function () {\n        var result = this._constant;\n        for (var i = 0, n = this._terms.size(); i < n; i++) {\n            var pair = this._terms.itemAt(i);\n            result += pair.first.value() * pair.second;\n        }\n        return result;\n    };\n    /**\n     * Creates a new Expression by adding a number, variable or expression\n     * to the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to add.\n     * @return {Expression} expression\n     */\n    Expression.prototype.plus = function (value) {\n        return new Expression(this, value);\n    };\n    /**\n     * Creates a new Expression by substracting a number, variable or expression\n     * from the expression.\n     *\n     * @param {Number|Variable|Expression} value Value to substract.\n     * @return {Expression} expression\n     */\n    Expression.prototype.minus = function (value) {\n        return new Expression(this, typeof value === \"number\" ? -value : [-1, value]);\n    };\n    /**\n     * Creates a new Expression by multiplying with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to multiply with.\n     * @return {Expression} expression\n     */\n    Expression.prototype.multiply = function (coefficient) {\n        return new Expression([coefficient, this]);\n    };\n    /**\n     * Creates a new Expression by dividing with a fixed number.\n     *\n     * @param {Number} coefficient Coefficient to divide by.\n     * @return {Expression} expression\n     */\n    Expression.prototype.divide = function (coefficient) {\n        return new Expression([1 / coefficient, this]);\n    };\n    Expression.prototype.isConstant = function () {\n        return this._terms.size() == 0;\n    };\n    Expression.prototype.toString = function () {\n        var result = this._terms.array.map(function (pair) {\n            return (pair.second + \"*\" + pair.first.toString());\n        }).join(\" + \");\n        if (!this.isConstant() && this._constant !== 0) {\n            result += \" + \";\n        }\n        result += this._constant;\n        return result;\n    };\n    return Expression;\n}());\nexport { Expression };\n/**\n * An internal argument parsing function.\n * @private\n */\nfunction parseArgs(args) {\n    var constant = 0.0;\n    var factory = function () { return 0.0; };\n    var terms = createMap();\n    for (var i = 0, n = args.length; i < n; ++i) {\n        var item = args[i];\n        if (typeof item === \"number\") {\n            constant += item;\n        }\n        else if (item instanceof Variable) {\n            terms.setDefault(item, factory).second += 1.0;\n        }\n        else if (item instanceof Expression) {\n            constant += item.constant();\n            var terms2 = item.terms();\n            for (var j = 0, k = terms2.size(); j < k; j++) {\n                var termPair = terms2.itemAt(j);\n                terms.setDefault(termPair.first, factory).second += termPair.second;\n            }\n        }\n        else if (item instanceof Array) {\n            if (item.length !== 2) {\n                throw new Error(\"array must have length 2\");\n            }\n            var value = item[0];\n            var value2 = item[1];\n            if (typeof value !== \"number\") {\n                throw new Error(\"array item 0 must be a number\");\n            }\n            if (value2 instanceof Variable) {\n                terms.setDefault(value2, factory).second += value;\n            }\n            else if (value2 instanceof Expression) {\n                constant += (value2.constant() * value);\n                var terms2 = value2.terms();\n                for (var j = 0, k = terms2.size(); j < k; j++) {\n                    var termPair = terms2.itemAt(j);\n                    terms.setDefault(termPair.first, factory).second += (termPair.second * value);\n                }\n            }\n            else {\n                throw new Error(\"array item 1 must be a variable or expression\");\n            }\n        }\n        else {\n            throw new Error(\"invalid Expression argument: \" + item);\n        }\n    }\n    return { terms: terms, constant: constant };\n}\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @class Strength\n */\nvar Strength = /** @class */ (function () {\n    function Strength() {\n    }\n    /**\n     * Create a new symbolic strength.\n     *\n     * @param a strong\n     * @param b medium\n     * @param c weak\n     * @param [w] weight\n     * @return strength\n    */\n    Strength.create = function (a, b, c, w) {\n        if (w === void 0) { w = 1.0; }\n        var result = 0.0;\n        result += Math.max(0.0, Math.min(1000.0, a * w)) * 1000000.0;\n        result += Math.max(0.0, Math.min(1000.0, b * w)) * 1000.0;\n        result += Math.max(0.0, Math.min(1000.0, c * w));\n        return result;\n    };\n    /**\n     * Clip a symbolic strength to the allowed min and max.\n     * @private\n     */\n    Strength.clip = function (value) {\n        return Math.max(0.0, Math.min(Strength.required, value));\n    };\n    /**\n     * The 'required' symbolic strength.\n     */\n    Strength.required = Strength.create(1000.0, 1000.0, 1000.0);\n    /**\n     * The 'strong' symbolic strength.\n     */\n    Strength.strong = Strength.create(1.0, 0.0, 0.0);\n    /**\n     * The 'medium' symbolic strength.\n     */\n    Strength.medium = Strength.create(0.0, 1.0, 0.0);\n    /**\n     * The 'weak' symbolic strength.\n     */\n    Strength.weak = Strength.create(0.0, 0.0, 1.0);\n    return Strength;\n}());\nexport { Strength };\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Expression } from \"./expression\";\nimport { Strength } from \"./strength\";\n/**\n * An enum defining the linear constraint operators.\n *\n * |Value|Operator|Description|\n * |----|-----|-----|\n * |`Le`|<=|Less than equal|\n * |`Ge`|>=|Greater than equal|\n * |`Eq`|==|Equal|\n *\n * @enum {Number}\n */\nexport var Operator;\n(function (Operator) {\n    Operator[Operator[\"Le\"] = 0] = \"Le\";\n    Operator[Operator[\"Ge\"] = 1] = \"Ge\";\n    Operator[Operator[\"Eq\"] = 2] = \"Eq\";\n})(Operator || (Operator = {}));\n/**\n * A linear constraint equation.\n *\n * A constraint equation is composed of an expression, an operator,\n * and a strength. The RHS of the equation is implicitly zero.\n *\n * @class\n * @param {Expression} expression The constraint expression (LHS).\n * @param {Operator} operator The equation operator.\n * @param {Expression} [rhs] Right hand side of the expression.\n * @param {Number} [strength=Strength.required] The strength of the constraint.\n */\nvar Constraint = /** @class */ (function () {\n    function Constraint(expression, operator, rhs, strength) {\n        if (strength === void 0) { strength = Strength.required; }\n        this._id = CnId++;\n        this._operator = operator;\n        this._strength = Strength.clip(strength);\n        if ((rhs === undefined) && (expression instanceof Expression)) {\n            this._expression = expression;\n        }\n        else {\n            this._expression = expression.minus(rhs);\n        }\n    }\n    /**\n     * Returns the unique id number of the constraint.\n     * @private\n     */\n    Constraint.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the expression of the constraint.\n     *\n     * @return {Expression} expression\n     */\n    Constraint.prototype.expression = function () {\n        return this._expression;\n    };\n    /**\n     * Returns the relational operator of the constraint.\n     *\n     * @return {Operator} linear constraint operator\n     */\n    Constraint.prototype.op = function () {\n        return this._operator;\n    };\n    /**\n     * Returns the strength of the constraint.\n     *\n     * @return {Number} strength\n     */\n    Constraint.prototype.strength = function () {\n        return this._strength;\n    };\n    Constraint.prototype.toString = function () {\n        return this._expression.toString() + \" \" + [\"<=\", \">=\", \"=\"][this._operator] + \" 0 (\" + this._strength.toString() + \")\";\n    };\n    return Constraint;\n}());\nexport { Constraint };\n/**\n * The internal constraint id counter.\n * @private\n */\nvar CnId = 0;\n","/*-----------------------------------------------------------------------------\n| Copyright (c) 2014, Nucleic Development Team.\n|\n| Distributed under the terms of the Modified BSD License.\n|\n| The full license is in the file COPYING.txt, distributed with this software.\n|----------------------------------------------------------------------------*/\nimport { Constraint, Operator } from \"./constraint\";\nimport { Expression } from \"./expression\";\nimport { createMap } from \"./maptype\";\nimport { Strength } from \"./strength\";\n/**\n * The constraint solver class.\n *\n * @class\n */\nvar Solver = /** @class */ (function () {\n    /**\n     * Construct a new Solver.\n     */\n    function Solver() {\n        this._cnMap = createCnMap();\n        this._rowMap = createRowMap();\n        this._varMap = createVarMap();\n        this._editMap = createEditMap();\n        this._infeasibleRows = [];\n        this._objective = new Row();\n        this._artificial = null;\n        this._idTick = 0;\n    }\n    /**\n     * Creates and add a constraint to the solver.\n     *\n     * @param {Expression|Variable} lhs Left hand side of the expression\n     * @param {Operator} operator Operator\n     * @param {Expression|Variable|Number} rhs Right hand side of the expression\n     * @param {Number} [strength=Strength.required] Strength\n     */\n    Solver.prototype.createConstraint = function (lhs, operator, rhs, strength) {\n        if (strength === void 0) { strength = Strength.required; }\n        var cn = new Constraint(lhs, operator, rhs, strength);\n        this.addConstraint(cn);\n        return cn;\n    };\n    /**\n     * Add a constraint to the solver.\n     *\n     * @param {Constraint} constraint Constraint to add to the solver\n     */\n    Solver.prototype.addConstraint = function (constraint) {\n        var cnPair = this._cnMap.find(constraint);\n        if (cnPair !== undefined) {\n            throw new Error(\"duplicate constraint\");\n        }\n        // Creating a row causes symbols to be reserved for the variables\n        // in the constraint. If this method exits with an exception,\n        // then its possible those variables will linger in the var map.\n        // Since its likely that those variables will be used in other\n        // constraints and since exceptional conditions are uncommon,\n        // i'm not too worried about aggressive cleanup of the var map.\n        var data = this._createRow(constraint);\n        var row = data.row;\n        var tag = data.tag;\n        var subject = this._chooseSubject(row, tag);\n        // If chooseSubject couldnt find a valid entering symbol, one\n        // last option is available if the entire row is composed of\n        // dummy variables. If the constant of the row is zero, then\n        // this represents redundant constraints and the new dummy\n        // marker can enter the basis. If the constant is non-zero,\n        // then it represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid && row.allDummies()) {\n            if (!nearZero(row.constant())) {\n                throw new Error(\"unsatisfiable constraint\");\n            }\n            else {\n                subject = tag.marker;\n            }\n        }\n        // If an entering symbol still isn't found, then the row must\n        // be added using an artificial variable. If that fails, then\n        // the row represents an unsatisfiable constraint.\n        if (subject.type() === SymbolType.Invalid) {\n            if (!this._addWithArtificialVariable(row)) {\n                throw new Error(\"unsatisfiable constraint\");\n            }\n        }\n        else {\n            row.solveFor(subject);\n            this._substitute(subject, row);\n            this._rowMap.insert(subject, row);\n        }\n        this._cnMap.insert(constraint, tag);\n        // Optimizing after each constraint is added performs less\n        // aggregate work due to a smaller average system size. It\n        // also ensures the solver remains in a consistent state.\n        this._optimize(this._objective);\n    };\n    /**\n     * Remove a constraint from the solver.\n     *\n     * @param {Constraint} constraint Constraint to remove from the solver\n     */\n    Solver.prototype.removeConstraint = function (constraint) {\n        var cnPair = this._cnMap.erase(constraint);\n        if (cnPair === undefined) {\n            throw new Error(\"unknown constraint\");\n        }\n        // Remove the error effects from the objective function\n        // *before* pivoting, or substitutions into the objective\n        // will lead to incorrect solver results.\n        this._removeConstraintEffects(constraint, cnPair.second);\n        // If the marker is basic, simply drop the row. Otherwise,\n        // pivot the marker into the basis and then drop the row.\n        var marker = cnPair.second.marker;\n        var rowPair = this._rowMap.erase(marker);\n        if (rowPair === undefined) {\n            var leaving = this._getMarkerLeavingSymbol(marker);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"failed to find leaving row\");\n            }\n            rowPair = this._rowMap.erase(leaving);\n            rowPair.second.solveForEx(leaving, marker);\n            this._substitute(marker, rowPair.second);\n        }\n        // Optimizing after each constraint is removed ensures that the\n        // solver remains consistent. It makes the solver api easier to\n        // use at a small tradeoff for speed.\n        this._optimize(this._objective);\n    };\n    /**\n     * Test whether the solver contains the constraint.\n     *\n     * @param {Constraint} constraint Constraint to test for\n     * @return {Bool} true or false\n     */\n    Solver.prototype.hasConstraint = function (constraint) {\n        return this._cnMap.contains(constraint);\n    };\n    /**\n     * Add an edit variable to the solver.\n     *\n     * @param {Variable} variable Edit variable to add to the solver\n     * @param {Number} strength Strength, should be less than `Strength.required`\n     */\n    Solver.prototype.addEditVariable = function (variable, strength) {\n        var editPair = this._editMap.find(variable);\n        if (editPair !== undefined) {\n            throw new Error(\"duplicate edit variable\");\n        }\n        strength = Strength.clip(strength);\n        if (strength === Strength.required) {\n            throw new Error(\"bad required strength\");\n        }\n        var expr = new Expression(variable);\n        var cn = new Constraint(expr, Operator.Eq, undefined, strength);\n        this.addConstraint(cn);\n        var tag = this._cnMap.find(cn).second;\n        var info = { tag: tag, constraint: cn, constant: 0.0 };\n        this._editMap.insert(variable, info);\n    };\n    /**\n     * Remove an edit variable from the solver.\n     *\n     * @param {Variable} variable Edit variable to remove from the solver\n     */\n    Solver.prototype.removeEditVariable = function (variable) {\n        var editPair = this._editMap.erase(variable);\n        if (editPair === undefined) {\n            throw new Error(\"unknown edit variable\");\n        }\n        this.removeConstraint(editPair.second.constraint);\n    };\n    /**\n     * Test whether the solver contains the edit variable.\n     *\n     * @param {Variable} variable Edit variable to test for\n     * @return {Bool} true or false\n     */\n    Solver.prototype.hasEditVariable = function (variable) {\n        return this._editMap.contains(variable);\n    };\n    /**\n     * Suggest the value of an edit variable.\n     *\n     * @param {Variable} variable Edit variable to suggest a value for\n     * @param {Number} value Suggested value\n     */\n    Solver.prototype.suggestValue = function (variable, value) {\n        var editPair = this._editMap.find(variable);\n        if (editPair === undefined) {\n            throw new Error(\"unknown edit variable\");\n        }\n        var rows = this._rowMap;\n        var info = editPair.second;\n        var delta = value - info.constant;\n        info.constant = value;\n        // Check first if the positive error variable is basic.\n        var marker = info.tag.marker;\n        var rowPair = rows.find(marker);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(-delta) < 0.0) {\n                this._infeasibleRows.push(marker);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Check next if the negative error variable is basic.\n        var other = info.tag.other;\n        rowPair = rows.find(other);\n        if (rowPair !== undefined) {\n            if (rowPair.second.add(delta) < 0.0) {\n                this._infeasibleRows.push(other);\n            }\n            this._dualOptimize();\n            return;\n        }\n        // Otherwise update each row where the error variables exist.\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var rowPair_1 = rows.itemAt(i);\n            var row = rowPair_1.second;\n            var coeff = row.coefficientFor(marker);\n            if (coeff !== 0.0 && row.add(delta * coeff) < 0.0 &&\n                rowPair_1.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(rowPair_1.first);\n            }\n        }\n        this._dualOptimize();\n    };\n    /**\n     * Update the values of the variables.\n     */\n    Solver.prototype.updateVariables = function () {\n        var vars = this._varMap;\n        var rows = this._rowMap;\n        for (var i = 0, n = vars.size(); i < n; ++i) {\n            var pair = vars.itemAt(i);\n            var rowPair = rows.find(pair.second);\n            if (rowPair !== undefined) {\n                pair.first.setValue(rowPair.second.constant());\n            }\n            else {\n                pair.first.setValue(0.0);\n            }\n        }\n    };\n    /**\n     * Get the symbol for the given variable.\n     *\n     * If a symbol does not exist for the variable, one will be created.\n     * @private\n     */\n    Solver.prototype._getVarSymbol = function (variable) {\n        var _this = this;\n        var factory = function () { return _this._makeSymbol(SymbolType.External); };\n        return this._varMap.setDefault(variable, factory).second;\n    };\n    /**\n     * Create a new Row object for the given constraint.\n     *\n     * The terms in the constraint will be converted to cells in the row.\n     * Any term in the constraint with a coefficient of zero is ignored.\n     * This method uses the `_getVarSymbol` method to get the symbol for\n     * the variables added to the row. If the symbol for a given cell\n     * variable is basic, the cell variable will be substituted with the\n     * basic row.\n     *\n     * The necessary slack and error variables will be added to the row.\n     * If the constant for the row is negative, the sign for the row\n     * will be inverted so the constant becomes positive.\n     *\n     * Returns the created Row and the tag for tracking the constraint.\n     * @private\n     */\n    Solver.prototype._createRow = function (constraint) {\n        var expr = constraint.expression();\n        var row = new Row(expr.constant());\n        // Substitute the current basic variables into the row.\n        var terms = expr.terms();\n        for (var i = 0, n = terms.size(); i < n; ++i) {\n            var termPair = terms.itemAt(i);\n            if (!nearZero(termPair.second)) {\n                var symbol = this._getVarSymbol(termPair.first);\n                var basicPair = this._rowMap.find(symbol);\n                if (basicPair !== undefined) {\n                    row.insertRow(basicPair.second, termPair.second);\n                }\n                else {\n                    row.insertSymbol(symbol, termPair.second);\n                }\n            }\n        }\n        // Add the necessary slack, error, and dummy variables.\n        var objective = this._objective;\n        var strength = constraint.strength();\n        var tag = { marker: INVALID_SYMBOL, other: INVALID_SYMBOL };\n        switch (constraint.op()) {\n            case Operator.Le:\n            case Operator.Ge:\n                {\n                    var coeff = constraint.op() === Operator.Le ? 1.0 : -1.0;\n                    var slack = this._makeSymbol(SymbolType.Slack);\n                    tag.marker = slack;\n                    row.insertSymbol(slack, coeff);\n                    if (strength < Strength.required) {\n                        var error = this._makeSymbol(SymbolType.Error);\n                        tag.other = error;\n                        row.insertSymbol(error, -coeff);\n                        objective.insertSymbol(error, strength);\n                    }\n                    break;\n                }\n            case Operator.Eq:\n                {\n                    if (strength < Strength.required) {\n                        var errplus = this._makeSymbol(SymbolType.Error);\n                        var errminus = this._makeSymbol(SymbolType.Error);\n                        tag.marker = errplus;\n                        tag.other = errminus;\n                        row.insertSymbol(errplus, -1.0); // v = eplus - eminus\n                        row.insertSymbol(errminus, 1.0); // v - eplus + eminus = 0\n                        objective.insertSymbol(errplus, strength);\n                        objective.insertSymbol(errminus, strength);\n                    }\n                    else {\n                        var dummy = this._makeSymbol(SymbolType.Dummy);\n                        tag.marker = dummy;\n                        row.insertSymbol(dummy);\n                    }\n                    break;\n                }\n        }\n        // Ensure the row has a positive constant.\n        if (row.constant() < 0.0) {\n            row.reverseSign();\n        }\n        return { row: row, tag: tag };\n    };\n    /**\n     * Choose the subject for solving for the row.\n     *\n     * This method will choose the best subject for using as the solve\n     * target for the row. An invalid symbol will be returned if there\n     * is no valid target.\n     *\n     * The symbols are chosen according to the following precedence:\n     *\n     * 1) The first symbol representing an external variable.\n     * 2) A negative slack or error tag variable.\n     *\n     * If a subject cannot be found, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    Solver.prototype._chooseSubject = function (row, tag) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() === SymbolType.External) {\n                return pair.first;\n            }\n        }\n        var type = tag.marker.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.marker) < 0.0) {\n                return tag.marker;\n            }\n        }\n        type = tag.other.type();\n        if (type === SymbolType.Slack || type === SymbolType.Error) {\n            if (row.coefficientFor(tag.other) < 0.0) {\n                return tag.other;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Add the row to the tableau using an artificial variable.\n     *\n     * This will return false if the constraint cannot be satisfied.\n     *\n     * @private\n     */\n    Solver.prototype._addWithArtificialVariable = function (row) {\n        // Create and add the artificial variable to the tableau.\n        var art = this._makeSymbol(SymbolType.Slack);\n        this._rowMap.insert(art, row.copy());\n        this._artificial = row.copy();\n        // Optimize the artificial objective. This is successful\n        // only if the artificial objective is optimized to zero.\n        this._optimize(this._artificial);\n        var success = nearZero(this._artificial.constant());\n        this._artificial = null;\n        // If the artificial variable is basic, pivot the row so that\n        // it becomes non-basic. If the row is constant, exit early.\n        var pair = this._rowMap.erase(art);\n        if (pair !== undefined) {\n            var basicRow = pair.second;\n            if (basicRow.isConstant()) {\n                return success;\n            }\n            var entering = this._anyPivotableSymbol(basicRow);\n            if (entering.type() === SymbolType.Invalid) {\n                return false; // unsatisfiable (will this ever happen?)\n            }\n            basicRow.solveForEx(art, entering);\n            this._substitute(entering, basicRow);\n            this._rowMap.insert(entering, basicRow);\n        }\n        // Remove the artificial variable from the tableau.\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            rows.itemAt(i).second.removeSymbol(art);\n        }\n        this._objective.removeSymbol(art);\n        return success;\n    };\n    /**\n     * Substitute the parametric symbol with the given row.\n     *\n     * This method will substitute all instances of the parametric symbol\n     * in the tableau and the objective function with the given row.\n     *\n     * @private\n     */\n    Solver.prototype._substitute = function (symbol, row) {\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            pair.second.substitute(symbol, row);\n            if (pair.second.constant() < 0.0 &&\n                pair.first.type() !== SymbolType.External) {\n                this._infeasibleRows.push(pair.first);\n            }\n        }\n        this._objective.substitute(symbol, row);\n        if (this._artificial) {\n            this._artificial.substitute(symbol, row);\n        }\n    };\n    /**\n     * Optimize the system for the given objective function.\n     *\n     * This method performs iterations of Phase 2 of the simplex method\n     * until the objective function reaches a minimum.\n     *\n     * @private\n     */\n    Solver.prototype._optimize = function (objective) {\n        while (true) {\n            var entering = this._getEnteringSymbol(objective);\n            if (entering.type() === SymbolType.Invalid) {\n                return;\n            }\n            var leaving = this._getLeavingSymbol(entering);\n            if (leaving.type() === SymbolType.Invalid) {\n                throw new Error(\"the objective is unbounded\");\n            }\n            // pivot the entering symbol into the basis\n            var row = this._rowMap.erase(leaving).second;\n            row.solveForEx(leaving, entering);\n            this._substitute(entering, row);\n            this._rowMap.insert(entering, row);\n        }\n    };\n    /**\n     * Optimize the system using the dual of the simplex method.\n     *\n     * The current state of the system should be such that the objective\n     * function is optimal, but not feasible. This method will perform\n     * an iteration of the dual simplex method to make the solution both\n     * optimal and feasible.\n     *\n     * @private\n     */\n    Solver.prototype._dualOptimize = function () {\n        var rows = this._rowMap;\n        var infeasible = this._infeasibleRows;\n        while (infeasible.length !== 0) {\n            var leaving = infeasible.pop();\n            var pair = rows.find(leaving);\n            if (pair !== undefined && pair.second.constant() < 0.0) {\n                var entering = this._getDualEnteringSymbol(pair.second);\n                if (entering.type() === SymbolType.Invalid) {\n                    throw new Error(\"dual optimize failed\");\n                }\n                // pivot the entering symbol into the basis\n                var row = pair.second;\n                rows.erase(leaving);\n                row.solveForEx(leaving, entering);\n                this._substitute(entering, row);\n                rows.insert(entering, row);\n            }\n        }\n    };\n    /**\n     * Compute the entering variable for a pivot operation.\n     *\n     * This method will return first symbol in the objective function which\n     * is non-dummy and has a coefficient less than zero. If no symbol meets\n     * the criteria, it means the objective function is at a minimum, and an\n     * invalid symbol is returned.\n     *\n     * @private\n     */\n    Solver.prototype._getEnteringSymbol = function (objective) {\n        var cells = objective.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            if (pair.second < 0.0 && symbol.type() !== SymbolType.Dummy) {\n                return symbol;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Compute the entering symbol for the dual optimize operation.\n     *\n     * This method will return the symbol in the row which has a positive\n     * coefficient and yields the minimum ratio for its respective symbol\n     * in the objective function. The provided row *must* be infeasible.\n     * If no symbol is found which meats the criteria, an invalid symbol\n     * is returned.\n     *\n     * @private\n     */\n    Solver.prototype._getDualEnteringSymbol = function (row) {\n        var ratio = Number.MAX_VALUE;\n        var entering = INVALID_SYMBOL;\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var symbol = pair.first;\n            var c = pair.second;\n            if (c > 0.0 && symbol.type() !== SymbolType.Dummy) {\n                var coeff = this._objective.coefficientFor(symbol);\n                var r = coeff / c;\n                if (r < ratio) {\n                    ratio = r;\n                    entering = symbol;\n                }\n            }\n        }\n        return entering;\n    };\n    /**\n     * Compute the symbol for pivot exit row.\n     *\n     * This method will return the symbol for the exit row in the row\n     * map. If no appropriate exit symbol is found, an invalid symbol\n     * will be returned. This indicates that the objective function is\n     * unbounded.\n     *\n     * @private\n     */\n    Solver.prototype._getLeavingSymbol = function (entering) {\n        var ratio = Number.MAX_VALUE;\n        var found = INVALID_SYMBOL;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var symbol = pair.first;\n            if (symbol.type() !== SymbolType.External) {\n                var row = pair.second;\n                var temp = row.coefficientFor(entering);\n                if (temp < 0.0) {\n                    var temp_ratio = -row.constant() / temp;\n                    if (temp_ratio < ratio) {\n                        ratio = temp_ratio;\n                        found = symbol;\n                    }\n                }\n            }\n        }\n        return found;\n    };\n    /**\n     * Compute the leaving symbol for a marker variable.\n     *\n     * This method will return a symbol corresponding to a basic row\n     * which holds the given marker variable. The row will be chosen\n     * according to the following precedence:\n     *\n     * 1) The row with a restricted basic varible and a negative coefficient\n     *    for the marker with the smallest ratio of -constant / coefficient.\n     *\n     * 2) The row with a restricted basic variable and the smallest ratio\n     *    of constant / coefficient.\n     *\n     * 3) The last unrestricted row which contains the marker.\n     *\n     * If the marker does not exist in any row, an invalid symbol will be\n     * returned. This indicates an internal solver error since the marker\n     * *should* exist somewhere in the tableau.\n     *\n     * @private\n     */\n    Solver.prototype._getMarkerLeavingSymbol = function (marker) {\n        var dmax = Number.MAX_VALUE;\n        var r1 = dmax;\n        var r2 = dmax;\n        var invalid = INVALID_SYMBOL;\n        var first = invalid;\n        var second = invalid;\n        var third = invalid;\n        var rows = this._rowMap;\n        for (var i = 0, n = rows.size(); i < n; ++i) {\n            var pair = rows.itemAt(i);\n            var row = pair.second;\n            var c = row.coefficientFor(marker);\n            if (c === 0.0) {\n                continue;\n            }\n            var symbol = pair.first;\n            if (symbol.type() === SymbolType.External) {\n                third = symbol;\n            }\n            else if (c < 0.0) {\n                var r = -row.constant() / c;\n                if (r < r1) {\n                    r1 = r;\n                    first = symbol;\n                }\n            }\n            else {\n                var r = row.constant() / c;\n                if (r < r2) {\n                    r2 = r;\n                    second = symbol;\n                }\n            }\n        }\n        if (first !== invalid) {\n            return first;\n        }\n        if (second !== invalid) {\n            return second;\n        }\n        return third;\n    };\n    /**\n     * Remove the effects of a constraint on the objective function.\n     *\n     * @private\n     */\n    Solver.prototype._removeConstraintEffects = function (cn, tag) {\n        if (tag.marker.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.marker, cn.strength());\n        }\n        if (tag.other.type() === SymbolType.Error) {\n            this._removeMarkerEffects(tag.other, cn.strength());\n        }\n    };\n    /**\n     * Remove the effects of an error marker on the objective function.\n     *\n     * @private\n     */\n    Solver.prototype._removeMarkerEffects = function (marker, strength) {\n        var pair = this._rowMap.find(marker);\n        if (pair !== undefined) {\n            this._objective.insertRow(pair.second, -strength);\n        }\n        else {\n            this._objective.insertSymbol(marker, -strength);\n        }\n    };\n    /**\n     * Get the first Slack or Error symbol in the row.\n     *\n     * If no such symbol is present, an invalid symbol will be returned.\n     *\n     * @private\n     */\n    Solver.prototype._anyPivotableSymbol = function (row) {\n        var cells = row.cells();\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            var type = pair.first.type();\n            if (type === SymbolType.Slack || type === SymbolType.Error) {\n                return pair.first;\n            }\n        }\n        return INVALID_SYMBOL;\n    };\n    /**\n     * Returns a new Symbol of the given type.\n     *\n     * @private\n     */\n    Solver.prototype._makeSymbol = function (type) {\n        return new Symbol(type, this._idTick++);\n    };\n    return Solver;\n}());\nexport { Solver };\n/**\n * Test whether a value is approximately zero.\n * @private\n */\nfunction nearZero(value) {\n    var eps = 1.0e-8;\n    return value < 0.0 ? -value < eps : value < eps;\n}\n/**\n * An internal function for creating a constraint map.\n * @private\n */\nfunction createCnMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a row map.\n * @private\n */\nfunction createRowMap() {\n    return createMap();\n}\n/**\n * An internal function for creating a variable map.\n * @private\n */\nfunction createVarMap() {\n    return createMap();\n}\n/**\n * An internal function for creating an edit map.\n * @private\n */\nfunction createEditMap() {\n    return createMap();\n}\n/**\n * An enum defining the available symbol types.\n * @private\n */\nvar SymbolType;\n(function (SymbolType) {\n    SymbolType[SymbolType[\"Invalid\"] = 0] = \"Invalid\";\n    SymbolType[SymbolType[\"External\"] = 1] = \"External\";\n    SymbolType[SymbolType[\"Slack\"] = 2] = \"Slack\";\n    SymbolType[SymbolType[\"Error\"] = 3] = \"Error\";\n    SymbolType[SymbolType[\"Dummy\"] = 4] = \"Dummy\";\n})(SymbolType || (SymbolType = {}));\n/**\n * An internal class representing a symbol in the solver.\n * @private\n */\nvar Symbol = /** @class */ (function () {\n    /**\n     * Construct a new Symbol\n     *\n     * @param [type] The type of the symbol.\n     * @param [id] The unique id number of the symbol.\n     */\n    function Symbol(type, id) {\n        this._id = id;\n        this._type = type;\n    }\n    /**\n     * Returns the unique id number of the symbol.\n     */\n    Symbol.prototype.id = function () {\n        return this._id;\n    };\n    /**\n     * Returns the type of the symbol.\n     */\n    Symbol.prototype.type = function () {\n        return this._type;\n    };\n    return Symbol;\n}());\n/**\n * A static invalid symbol\n * @private\n */\nvar INVALID_SYMBOL = new Symbol(SymbolType.Invalid, -1);\n/**\n * An internal row class used by the solver.\n * @private\n */\nvar Row = /** @class */ (function () {\n    /**\n     * Construct a new Row.\n     */\n    function Row(constant) {\n        if (constant === void 0) { constant = 0.0; }\n        this._cellMap = createMap();\n        this._constant = constant;\n    }\n    /**\n     * Returns the mapping of symbols to coefficients.\n     */\n    Row.prototype.cells = function () {\n        return this._cellMap;\n    };\n    /**\n     * Returns the constant for the row.\n     */\n    Row.prototype.constant = function () {\n        return this._constant;\n    };\n    /**\n     * Returns true if the row is a constant value.\n     */\n    Row.prototype.isConstant = function () {\n        return this._cellMap.empty();\n    };\n    /**\n     * Returns true if the Row has all dummy symbols.\n     */\n    Row.prototype.allDummies = function () {\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            if (pair.first.type() !== SymbolType.Dummy) {\n                return false;\n            }\n        }\n        return true;\n    };\n    /**\n     * Create a copy of the row.\n     */\n    Row.prototype.copy = function () {\n        var theCopy = new Row(this._constant);\n        theCopy._cellMap = this._cellMap.copy();\n        return theCopy;\n    };\n    /**\n     * Add a constant value to the row constant.\n     *\n     * Returns the new value of the constant.\n     */\n    Row.prototype.add = function (value) {\n        return this._constant += value;\n    };\n    /**\n     * Insert the symbol into the row with the given coefficient.\n     *\n     * If the symbol already exists in the row, the coefficient\n     * will be added to the existing coefficient. If the resulting\n     * coefficient is zero, the symbol will be removed from the row.\n     */\n    Row.prototype.insertSymbol = function (symbol, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        var pair = this._cellMap.setDefault(symbol, function () { return 0.0; });\n        if (nearZero(pair.second += coefficient)) {\n            this._cellMap.erase(symbol);\n        }\n    };\n    /**\n     * Insert a row into this row with a given coefficient.\n     *\n     * The constant and the cells of the other row will be\n     * multiplied by the coefficient and added to this row. Any\n     * cell with a resulting coefficient of zero will be removed\n     * from the row.\n     */\n    Row.prototype.insertRow = function (other, coefficient) {\n        if (coefficient === void 0) { coefficient = 1.0; }\n        this._constant += other._constant * coefficient;\n        var cells = other._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            this.insertSymbol(pair.first, pair.second * coefficient);\n        }\n    };\n    /**\n     * Remove a symbol from the row.\n     */\n    Row.prototype.removeSymbol = function (symbol) {\n        this._cellMap.erase(symbol);\n    };\n    /**\n     * Reverse the sign of the constant and cells in the row.\n     */\n    Row.prototype.reverseSign = function () {\n        this._constant = -this._constant;\n        var cells = this._cellMap;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            var pair = cells.itemAt(i);\n            pair.second = -pair.second;\n        }\n    };\n    /**\n     * Solve the row for the given symbol.\n     *\n     * This method assumes the row is of the form\n     * a * x + b * y + c = 0 and (assuming solve for x) will modify\n     * the row to represent the right hand side of\n     * x = -b/a * y - c / a. The target symbol will be removed from\n     * the row, and the constant and other cells will be multiplied\n     * by the negative inverse of the target coefficient.\n     *\n     * The given symbol *must* exist in the row.\n     */\n    Row.prototype.solveFor = function (symbol) {\n        var cells = this._cellMap;\n        var pair = cells.erase(symbol);\n        var coeff = -1.0 / pair.second;\n        this._constant *= coeff;\n        for (var i = 0, n = cells.size(); i < n; ++i) {\n            cells.itemAt(i).second *= coeff;\n        }\n    };\n    /**\n     * Solve the row for the given symbols.\n     *\n     * This method assumes the row is of the form\n     * x = b * y + c and will solve the row such that\n     * y = x / b - c / b. The rhs symbol will be removed from the\n     * row, the lhs added, and the result divided by the negative\n     * inverse of the rhs coefficient.\n     *\n     * The lhs symbol *must not* exist in the row, and the rhs\n     * symbol must* exist in the row.\n     */\n    Row.prototype.solveForEx = function (lhs, rhs) {\n        this.insertSymbol(lhs, -1.0);\n        this.solveFor(rhs);\n    };\n    /**\n     * Returns the coefficient for the given symbol.\n     */\n    Row.prototype.coefficientFor = function (symbol) {\n        var pair = this._cellMap.find(symbol);\n        return pair !== undefined ? pair.second : 0.0;\n    };\n    /**\n     * Substitute a symbol with the data from another row.\n     *\n     * Given a row of the form a * x + b and a substitution of the\n     * form x = 3 * y + c the row will be updated to reflect the\n     * expression 3 * a * y + a * c + b.\n     *\n     * If the symbol does not exist in the row, this is a no-op.\n     */\n    Row.prototype.substitute = function (symbol, row) {\n        var pair = this._cellMap.erase(symbol);\n        if (pair !== undefined) {\n            this.insertRow(row, pair.second);\n        }\n    };\n    return Row;\n}());\n","/** @license kiwi.js v1.1.2\n * #------------------------------------------------------------------------------\n * # Copyright (c) 2013, Nucleic Development Team & H. Rutjes.\n * #\n * # Distributed under the terms of the Modified BSD License.\n * #\n * # The full license is in the file COPYING.txt, distributed with this software.\n * #------------------------------------------------------------------------------\n **/\nimport { Solver, Variable } from 'kiwi.js';\n\n/**\n * Applies the given constraints to the objects in-place.\n * A solution is approximated iteratively.\n * Refer to LAYOUT_ENGINE.md for further details.\n * @param {array} constraints The constraints\n * @param {function} constraint.base.solve A function that solves the constraint in-place\n * @param {number} iterations The number of iterations\n * @param {?object} constants The constants used by constraints\n */\nexport const solveLoose = (constraints, iterations, constants) => {\n  for (let i = 0; i < iterations; i += 1) {\n    for (const constraint of constraints) {\n      constraint.base.solve(constraint, constants);\n    }\n  }\n};\n\n/**\n * Applies the given constraints to the objects in-place.\n * A solution is found exactly for the constraints that are solvable.\n * Any unsolvable constraints will be skipped and a warning logged in the console.\n * Refer to LAYOUT_ENGINE.md for further details.\n * @param {array} constraints The constraints\n * @param {string} constraint.base.property The property name on `a` and `b` to constrain\n * @param {function} constraint.base.strict A function returns the constraint in strict form\n * @param {object} constraint.a The first object to constrain\n * @param {object} constraint.b The second object to constrain\n * @param {object} constraint.a.id A unique id for the first object\n * @param {object} constraint.b.id A unique id for the second object\n * @param {?object} constants The constants used by constraints\n */\nexport const solveStrict = (constraints, constants) => {\n  const solver = new Solver();\n  const variables = {};\n\n  const variableId = (obj, property) => `${obj.id}_${property}`;\n\n  const addVariable = (obj, property) => {\n    const id = variableId(obj, property);\n\n    if (!variables[id]) {\n      const variable = (variables[id] = new Variable());\n      variable.property = property;\n      variable.obj = obj;\n    }\n  };\n\n  for (const constraint of constraints) {\n    addVariable(constraint.a, constraint.base.property);\n    addVariable(constraint.b, constraint.base.property);\n  }\n\n  let unsolvableCount = 0;\n\n  for (const constraint of constraints) {\n    try {\n      solver.addConstraint(\n        constraint.base.strict(\n          constraint,\n          constants,\n          variables[variableId(constraint.a, constraint.base.property)],\n          variables[variableId(constraint.b, constraint.base.property)]\n        )\n      );\n    } catch (err) {\n      unsolvableCount += 1;\n    }\n  }\n\n  if (unsolvableCount > 0) {\n    console.warn(`Skipped ${unsolvableCount} unsolvable constraints`);\n  }\n\n  solver.updateVariables();\n\n  const variablesList = Object.values(variables);\n\n  for (const variable of variablesList) {\n    variable.obj[variable.property] = variable.value();\n  }\n};\n","/**\n * Constraint base definitions.\n *\n * Refer to LAYOUT_ENGINE.md for descriptions of each constraint.\n *\n * See `solve` function of `solver.js` for constraint specification.\n */\n\nimport { Constraint, Operator, Strength } from 'kiwi.js';\n\n/**\n * Layout constraint in Y for separating rows\n */\nexport const rowConstraint = {\n  property: 'y',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Ge,\n      constants.spaceY,\n      Strength.required\n    ),\n};\n\n/**\n * Layout constraint in Y for separating layers\n */\nexport const layerConstraint = {\n  property: 'y',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Ge,\n      constants.layerSpace,\n      Strength.required\n    ),\n};\n\n/**\n * Layout constraint in X for minimising distance from source to target for straight edges\n */\nexport const parallelConstraint = {\n  property: 'x',\n\n  solve: (constraint) => {\n    const { a, b, strength } = constraint;\n    const resolve = strength * (a.x - b.x);\n    a.x -= resolve;\n    b.x += resolve;\n  },\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableA.minus(variableB),\n      Operator.Eq,\n      0,\n      Strength.create(1, 0, 0, constraint.strength)\n    ),\n};\n\n/**\n * Crossing constraint in X for minimising edge crossings\n */\nexport const crossingConstraint = {\n  property: 'x',\n\n  solve: (constraint) => {\n    const { edgeA, edgeB, separationA, separationB, strength } = constraint;\n\n    // Amount to move each node towards required separation\n    const resolveSource =\n      strength *\n      ((edgeA.sourceNode.x - edgeB.sourceNode.x - separationA) / separationA);\n\n    const resolveTarget =\n      strength *\n      ((edgeA.targetNode.x - edgeB.targetNode.x - separationB) / separationB);\n\n    // Apply the resolve each node\n    edgeA.sourceNode.x -= resolveSource;\n    edgeB.sourceNode.x += resolveSource;\n    edgeA.targetNode.x -= resolveTarget;\n    edgeB.targetNode.x += resolveTarget;\n  },\n};\n\n/**\n * Layout constraint in X for minimum node separation\n */\nexport const separationConstraint = {\n  property: 'x',\n\n  strict: (constraint, constants, variableA, variableB) =>\n    new Constraint(\n      variableB.minus(variableA),\n      Operator.Ge,\n      constraint.separation,\n      Strength.required\n    ),\n};\n","import { HALF_PI, snap, angle, compare, groupByRow } from './common';\nimport { solveLoose, solveStrict } from './solver';\nimport {\n  rowConstraint,\n  layerConstraint,\n  parallelConstraint,\n  crossingConstraint,\n  separationConstraint,\n} from './constraints';\n\n/**\n * Finds positions for the given nodes relative to their edges.\n * Input nodes and edges are updated in-place.\n * Results are stored in the `x, y` properties on nodes.\n * @param {object} params The layout parameters\n * @param {array} params.nodes The input nodes\n * @param {array} params.edges The input edges\n * @param {object=} params.layers The node layers if specified\n * @param {number} params.spaceX The minimum gap between nodes in X\n * @param {number} params.spaceY The minimum gap between nodes in Y\n * @param {number} params.spreadX Adjusts the gap for each node in X based on the number of connected edges it has\n * @param {number} params.layerSpaceY The additional gap between nodes in Y between layers\n * @param {number} params.iterations The number of solver iterations to perform\n * @returns {void}\n */\nexport const layout = ({\n  nodes,\n  edges,\n  layers,\n  spaceX,\n  spaceY,\n  spreadX,\n  layerSpaceY,\n  iterations,\n}) => {\n  // Set initial positions for nodes\n  for (const node of nodes) {\n    node.x = 0;\n    node.y = 0;\n  }\n\n  // Constants used by constraints\n  const constants = {\n    spaceX,\n    spaceY,\n    spreadX,\n    layerSpace: (spaceY + layerSpaceY) * 0.5,\n  };\n\n  // Constraints to separate nodes into rows and layers\n  const rowConstraints = createRowConstraints(edges);\n  const layerConstraints = createLayerConstraints(nodes, layers);\n\n  // Find the node positions given these constraints\n  solveStrict([...rowConstraints, ...layerConstraints], constants, 1);\n\n  // Find the solved rows using the node positions after solving\n  const rows = groupByRow(nodes);\n\n  // Constraints to avoid edges crossing and maintain parallel vertical edges\n  const crossingConstraints = createCrossingConstraints(edges, constants);\n  const parallelConstraints = createParallelConstraints(edges, constants);\n\n  // Solve these constraints iteratively\n  for (let i = 0; i < iterations; i += 1) {\n    solveLoose(crossingConstraints, 1, constants);\n    solveLoose(parallelConstraints, 50, constants);\n  }\n\n  // Constraints to maintain a minimum horizontal node spacing\n  const separationConstraints = createSeparationConstraints(rows, constants);\n\n  // Find the final node positions given these strict constraints\n  solveStrict([...separationConstraints, ...parallelConstraints], constants, 1);\n\n  // Adjust vertical spacing between rows for legibility\n  expandDenseRows(edges, rows, spaceY);\n};\n\n/**\n * Creates row constraints for the given edges.\n * @param {array} edges The input edges\n * @returns {array} The constraints\n */\nconst createRowConstraints = (edges) =>\n  edges.map((edge) => ({\n    base: rowConstraint,\n    a: edge.targetNode,\n    b: edge.sourceNode,\n  }));\n\n/**\n * Creates layer constraints for the given nodes and layers.\n * @param {array} nodes The input nodes\n * @param {array=} layers The input layers if any\n * @returns {array} The constraints\n */\nconst createLayerConstraints = (nodes, layers) => {\n  const layerConstraints = [];\n\n  // Early out if no layers defined\n  if (!layers) {\n    return layerConstraints;\n  }\n\n  // Group the nodes for each layer\n  const layerGroups = layers.map((name) =>\n    nodes.filter((node) => node.nearestLayer === name)\n  );\n\n  // For each layer of nodes\n  for (let i = 0; i < layerGroups.length - 1; i += 1) {\n    const layerNodes = layerGroups[i];\n    const nextLayerNodes = layerGroups[i + 1];\n\n    // Create a temporary intermediary node for the layer\n    const intermediary = { id: `layer-${i}`, x: 0, y: 0 };\n\n    // Constrain each node in the layer to above the intermediary\n    for (const node of layerNodes) {\n      layerConstraints.push({\n        base: layerConstraint,\n        a: intermediary,\n        b: node,\n      });\n    }\n\n    // Constrain each node in the next layer to below the intermediary\n    for (const node of nextLayerNodes) {\n      layerConstraints.push({\n        base: layerConstraint,\n        a: node,\n        b: intermediary,\n      });\n    }\n  }\n\n  return layerConstraints;\n};\n\n/**\n * Creates crossing constraints for the given edges.\n * @param {array} edges The input edges\n * @param {object} constants The constraint constants\n * @param {number} constants.spaceX The minimum gap between nodes in X\n * @returns {array} The constraints\n */\nconst createCrossingConstraints = (edges, constants) => {\n  const { spaceX } = constants;\n  const crossingConstraints = [];\n\n  // For every pair of edges\n  for (let i = 0; i < edges.length; i += 1) {\n    const edgeA = edges[i];\n    const { sourceNode: sourceA, targetNode: targetA } = edgeA;\n\n    // Count the connected edges\n    const edgeADegree =\n      sourceA.sources.length +\n      sourceA.targets.length +\n      targetA.sources.length +\n      targetA.targets.length;\n\n    for (let j = i + 1; j < edges.length; j += 1) {\n      const edgeB = edges[j];\n      const { sourceNode: sourceB, targetNode: targetB } = edgeB;\n\n      // Skip if edges are not intersecting by row so can't cross\n      if (sourceA.row >= targetB.row || targetA.row <= sourceB.row) {\n        continue;\n      }\n\n      // Count the connected edges\n      const edgeBDegree =\n        sourceB.sources.length +\n        sourceB.targets.length +\n        targetB.sources.length +\n        targetB.targets.length;\n\n      crossingConstraints.push({\n        base: crossingConstraint,\n        edgeA: edgeA,\n        edgeB: edgeB,\n        // The required horizontal spacing between connected nodes\n        separationA: sourceA.width * 0.5 + spaceX + sourceB.width * 0.5,\n        separationB: targetA.width * 0.5 + spaceX + targetB.width * 0.5,\n        // Evenly distribute the constraint\n        strength: 1 / Math.max(1, (edgeADegree + edgeBDegree) / 4),\n      });\n    }\n  }\n\n  return crossingConstraints;\n};\n\n/**\n * Creates parallel constraints for the given edges.\n * Returns object with additional arrays that identify these special cases:\n * - edges connected to single-degree nodes at either end\n * - edges connected to single-degree nodes at both ends\n * @param {array} edges The input edges\n * @returns {object} An object containing the constraints\n */\nconst createParallelConstraints = (edges) =>\n  edges.map(({ sourceNode, targetNode }) => ({\n    base: parallelConstraint,\n    a: sourceNode,\n    b: targetNode,\n    // Evenly distribute the constraint\n    strength:\n      0.6 /\n      Math.max(1, sourceNode.targets.length + targetNode.sources.length - 2),\n  }));\n\n/**\n * Creates horizontal separation constraints for the given rows of nodes.\n * @param {array} rows The rows containing nodes\n * @returns {array} The constraints\n */\nconst createSeparationConstraints = (rows, constants) => {\n  const { spaceX } = constants;\n  const separationConstraints = [];\n\n  // For each row of nodes\n  for (let i = 0; i < rows.length; i += 1) {\n    const rowNodes = rows[i];\n\n    // Stable sort row nodes horizontally, breaks ties with ids\n    rowNodes.sort((a, b) => compare(a.x, b.x, a.id, b.id));\n\n    // Update constraints given updated row node order\n    for (let j = 0; j < rowNodes.length - 1; j += 1) {\n      const nodeA = rowNodes[j];\n      const nodeB = rowNodes[j + 1];\n\n      // Count the connected edges\n      const degreeA = Math.max(\n        1,\n        nodeA.targets.length + nodeA.sources.length - 2\n      );\n      const degreeB = Math.max(\n        1,\n        nodeB.targets.length + nodeB.sources.length - 2\n      );\n\n      // Allow more spacing for nodes with more edges\n      const spread = Math.min(10, degreeA * degreeB * constants.spreadX);\n      const space = snap(spread * spaceX, spaceX);\n\n      separationConstraints.push({\n        base: separationConstraint,\n        a: nodeA,\n        b: nodeB,\n        separation: nodeA.width * 0.5 + space + nodeB.width * 0.5,\n      });\n    }\n  }\n\n  return separationConstraints;\n};\n\n/**\n * Adds additional spacing in Y relative to row density, see function `rowDensity` for definition.\n * Node positions are updated in-place\n * @param {array} edges The input edges\n * @param {array} rows The input rows of nodes\n * @param {number} spaceY The spacing between nodes in Y\n * @param {number} [scale=1.25] The amount of expansion to apply relative to row density\n * @param {number} [unit=0.25] The unit size for rounding expansion relative to spaceY\n */\nconst expandDenseRows = (edges, rows, spaceY, scale = 1.25, unit = 0.25) => {\n  const densities = rowDensity(edges);\n  const spaceYUnit = Math.round(spaceY * unit);\n  let currentOffsetY = 0;\n\n  // Add spacing based relative to row density\n  for (let i = 0; i < rows.length - 1; i += 1) {\n    const density = densities[i] || 0;\n\n    // Round offset to a common unit amount to improve vertical rhythm\n    const offsetY = snap(density * scale * spaceY, spaceYUnit);\n    currentOffsetY += offsetY;\n\n    // Apply offset to all nodes following the current node\n    for (const node of rows[i + 1]) {\n      node.y += currentOffsetY;\n    }\n  }\n};\n\n/**\n * Estimates an average 'density' for each row based on average edge angle at that row.\n * Rows with edges close to horizontal are more 'dense' than rows with straight vertical edges.\n * Rows are determined by each edge's source and target node Y positions.\n * Intermediate row edges are assumed always vertical as a simplification, only the start end rows are measured.\n * Returns a list of values in `(0, 1)` where `0` means all edges on that row are vertical and `1` means all horizontal\n * @param {array} edges The input edges\n * @returns {array} The density of each row\n */\nconst rowDensity = (edges) => {\n  const rows = {};\n\n  for (const edge of edges) {\n    // Find the normalized angle of the edge source and target nodes, relative to the X axis\n    const edgeAngle =\n      Math.abs(angle(edge.targetNode, edge.sourceNode) - HALF_PI) / HALF_PI;\n\n    const sourceRow = edge.sourceNode.row;\n    const targetRow = edge.targetNode.row - 1;\n\n    // Add angle to the source row total\n    rows[sourceRow] = rows[sourceRow] || [0, 0];\n    rows[sourceRow][0] += edgeAngle;\n    rows[sourceRow][1] += 1;\n\n    if (targetRow !== sourceRow) {\n      // Add angle to the target row total\n      rows[targetRow] = rows[targetRow] || [0, 0];\n      rows[targetRow][0] += edgeAngle;\n      rows[targetRow][1] += 1;\n    }\n  }\n\n  // Find the average angle for each row\n  for (const row in rows) {\n    rows[row] = rows[row][0] / (rows[row][1] || 1);\n  }\n\n  return Object.values(rows);\n};\n","import {\n  compare,\n  distance1d,\n  angle,\n  nearestOnLine,\n  groupByRow,\n  nodeLeft,\n  nodeRight,\n  nodeTop,\n  nodeBottom,\n} from './common';\n\n/**\n * Finds positions for the given edges relative to their nodes.\n * Input nodes and edges are updated in-place.\n * Results are stored in the `points` property on edges.\n * @param {object} params The layout parameters\n * @param {array} params.nodes The input nodes\n * @param {array} params.edges The input edges\n * @param {number} params.spaceX The minimum gap between a node and passing edges in X\n * @param {number} params.spaceY The minimum gap between a node and passing edges in Y\n * @param {number} params.minPassageGap The minimum gap between two nodes in which an edge can pass in X\n * @param {number} params.stemUnit The unit length for edge stems at anchors\n * @param {number} params.stemMax The maximum length of edge stems at anchors\n * @param {number} params.stemMinSource The minimum length for edge stems at source anchors\n * @param {number} params.stemMinTarget The minimum length for edge stems at target anchors\n * @param {number} params.stemSpaceSource The ideal spacing between edge stems at source anchors\n * @param {number} params.stemSpaceTarget The ideal spacing between edge stems at target anchors\n * @returns {void}\n */\nexport const routing = ({\n  nodes,\n  edges,\n  spaceX,\n  spaceY,\n  minPassageGap,\n  stemUnit,\n  stemMinSource,\n  stemMinTarget,\n  stemMax,\n  stemSpaceSource,\n  stemSpaceTarget,\n}) => {\n  // Find the rows formed by nodes\n  const rows = groupByRow(nodes);\n\n  // For each node\n  for (const node of nodes) {\n    // Sort the node's target edges by the angle between source and target nodes\n    node.targets.sort((a, b) =>\n      compare(\n        angle(b.sourceNode, b.targetNode),\n        angle(a.sourceNode, a.targetNode)\n      )\n    );\n  }\n\n  // For each edge\n  for (const edge of edges) {\n    const source = edge.sourceNode;\n    const target = edge.targetNode;\n\n    // Initialise result container\n    edge.points = [];\n\n    // Find the ideal gap between edge source anchors\n    const sourceSeparation = Math.min(\n      (source.width - stemSpaceSource) / source.targets.length,\n      stemSpaceSource\n    );\n\n    const sourceEdgeDistance =\n      source.targets.indexOf(edge) - (source.targets.length - 1) * 0.5;\n\n    const sourceOffsetX = sourceSeparation * sourceEdgeDistance;\n\n    // Start at source node offset\n    const startPoint = { x: source.x + sourceOffsetX, y: source.y };\n    let currentPoint = startPoint;\n\n    // For each row between the source and target rows exclusive\n    for (let i = source.row + 1; i < target.row; i += 1) {\n      const firstNode = rows[i][0];\n\n      // Initialise search for next point\n      let nearestPoint = { x: nodeLeft(firstNode) - spaceX, y: firstNode.y };\n      let nearestDistance = Infinity;\n\n      // Extend the row 'to infinity' on each side in X\n      const rowExtended = [\n        { ...firstNode, x: Number.MIN_SAFE_INTEGER },\n        ...rows[i],\n        { ...firstNode, x: Number.MAX_SAFE_INTEGER },\n      ];\n\n      // For each gap between each nodes on the row\n      for (let i = 0; i < rowExtended.length - 1; i += 1) {\n        const node = rowExtended[i];\n        const nextNode = rowExtended[i + 1];\n        const nodeGap = nodeLeft(nextNode) - nodeRight(node);\n\n        // Avoid routing through small gaps, increase bundling\n        if (nodeGap < minPassageGap) {\n          continue;\n        }\n\n        const offsetX = Math.min(spaceX, nodeGap * 0.5);\n\n        // Find the next potential point. Include offset to reduce overlapping edges\n        const candidatePoint = nearestOnLine(\n          currentPoint.x,\n          currentPoint.y,\n          nodeRight(node) + offsetX,\n          nodeTop(node) - spaceY,\n          nodeLeft(nextNode) - offsetX,\n          nodeTop(nextNode) - spaceY\n        );\n\n        const distance = distance1d(currentPoint.x, candidatePoint.x);\n\n        // Early out if diverging\n        if (distance > nearestDistance) {\n          break;\n        }\n\n        // Keep the nearest point\n        if (distance < nearestDistance) {\n          nearestDistance = distance;\n          nearestPoint = candidatePoint;\n        }\n      }\n\n      // Pass the node at nearest point\n      const offsetY = firstNode.height + spaceY;\n      edge.points.push({\n        x: nearestPoint.x + sourceOffsetX,\n        y: nearestPoint.y,\n      });\n      edge.points.push({\n        x: nearestPoint.x + sourceOffsetX,\n        y: nearestPoint.y + offsetY,\n      });\n\n      currentPoint = {\n        x: nearestPoint.x,\n        y: nearestPoint.y + offsetY,\n      };\n    }\n  }\n\n  // For each node\n  for (const node of nodes) {\n    // Sort the node's outgoing edges by the starting angle of the edge path\n    node.targets.sort((a, b) =>\n      compare(\n        angle(b.sourceNode, b.points[0] || b.targetNode),\n        angle(a.sourceNode, a.points[0] || a.targetNode)\n      )\n    );\n    // Sort the node's incoming edges by the ending angle of the edge path\n    node.sources.sort((a, b) =>\n      compare(\n        angle(a.points[a.points.length - 1] || a.sourceNode, a.targetNode),\n        angle(b.points[b.points.length - 1] || b.sourceNode, b.targetNode)\n      )\n    );\n  }\n\n  // For each edge\n  for (const edge of edges) {\n    const source = edge.sourceNode;\n    const target = edge.targetNode;\n\n    // Find the ideal gap between edge source and target anchors\n    const sourceSeparation = Math.min(\n      (source.width - stemSpaceSource) / source.targets.length,\n      stemSpaceSource\n    );\n\n    const targetSeparation = Math.min(\n      (target.width - stemSpaceTarget) / target.sources.length,\n      stemSpaceTarget\n    );\n\n    const sourceEdgeDistance =\n      source.targets.indexOf(edge) - (source.targets.length - 1) * 0.5;\n    const targetEdgeDistance =\n      target.sources.indexOf(edge) - (target.sources.length - 1) * 0.5;\n\n    const sourceOffsetX = sourceSeparation * sourceEdgeDistance;\n    const targetOffsetX = targetSeparation * targetEdgeDistance;\n\n    // Decrease stem length outwards from the middle stem\n    const sourceOffsetY =\n      stemUnit *\n      source.targets.length *\n      (1 - Math.abs(sourceEdgeDistance) / source.targets.length);\n\n    const targetOffsetY =\n      stemUnit *\n      target.sources.length *\n      (1 - Math.abs(targetEdgeDistance) / target.sources.length);\n\n    // Build the source stem for the edge\n    const sourceStem = [\n      {\n        x: source.x + sourceOffsetX,\n        y: nodeBottom(source),\n      },\n      {\n        x: source.x + sourceOffsetX,\n        y: nodeBottom(source) + stemMinSource,\n      },\n      {\n        x: source.x + sourceOffsetX,\n        y:\n          nodeBottom(source) + stemMinSource + Math.min(sourceOffsetY, stemMax),\n      },\n    ];\n\n    // Build the target stem for the edge\n    const targetStem = [\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target) - stemMinTarget - Math.min(targetOffsetY, stemMax),\n      },\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target) - stemMinTarget,\n      },\n      {\n        x: target.x + targetOffsetX,\n        y: nodeTop(target),\n      },\n    ];\n\n    // Combine all points\n    const points = [...sourceStem, ...edge.points, ...targetStem];\n\n    // Fix any invalid points caused by invalid layouts\n    let pointYMax = points[0].y;\n\n    for (const point of points) {\n      // Ensure increasing Y values for each point\n      if (point.y < pointYMax) {\n        point.y = pointYMax;\n      } else {\n        pointYMax = point.y;\n      }\n    }\n\n    // Assign finished points to edge\n    edge.points = points;\n  }\n};\n","/*\n * The Kedro-Viz Graph Layout Engine\n *\n * Refer to LAYOUT_ENGINE.md for description of the approach.\n */\n\nimport { offsetNode, offsetEdge } from './common';\nimport { layout } from './layout';\nimport { routing } from './routing';\n\nconst defaultOptions = {\n  layout: {\n    spaceX: 14,\n    spaceY: 110,\n    layerSpaceY: 55,\n    spreadX: 2.2,\n    padding: 100,\n    iterations: 25,\n  },\n  routing: {\n    spaceX: 26,\n    spaceY: 28,\n    minPassageGap: 40,\n    stemUnit: 8,\n    stemMinSource: 5,\n    stemMinTarget: 5,\n    stemMax: 20,\n    stemSpaceSource: 6,\n    stemSpaceTarget: 10,\n  },\n};\n\n/**\n * Generates a diagram of the given DAG.\n * Input nodes and edges are updated in-place.\n * Results are stored as `x, y` properties on nodes\n * and `points` properties on edges.\n * @param {array} nodes The input nodes\n * @param {array} edges The input edges\n * @param {object=} layers The node layers if specified\n * @param {object=} options The graph options\n * @returns {object} The generated graph\n */\nexport const graph = (nodes, edges, layers, options = defaultOptions) => {\n  addEdgeLinks(nodes, edges);\n  addNearestLayers(nodes, layers);\n\n  layout({ nodes, edges, layers, ...options.layout });\n  routing({ nodes, edges, layers, ...options.routing });\n\n  const size = bounds(nodes, options.layout.padding);\n  nodes.forEach((node) => offsetNode(node, size.min));\n  edges.forEach((edge) => offsetEdge(edge, size.min));\n\n  return {\n    nodes,\n    edges,\n    layers,\n    size,\n  };\n};\n\n/**\n * Adds lists of source edges and target edges to each node in-place\n * @param {array} nodes The input nodes\n * @param {array} edges The input edges\n */\nexport const addEdgeLinks = (nodes, edges) => {\n  const nodeById = {};\n\n  for (const node of nodes) {\n    nodeById[node.id] = node;\n    node.targets = [];\n    node.sources = [];\n  }\n\n  for (const edge of edges) {\n    edge.sourceNode = nodeById[edge.source];\n    edge.targetNode = nodeById[edge.target];\n    edge.sourceNode.targets.push(edge);\n    edge.targetNode.sources.push(edge);\n  }\n};\n\n/**\n * Adds the nearest valid layer to each node whilst maintaining the correct layer order\n * @param {array} nodes The input nodes\n * @param {?array} layers The input layers\n */\nconst addNearestLayers = (nodes, layers) => {\n  if (layers && layers.length > 0) {\n    // Create the set of valid layers for lookup\n    const validLayers = {};\n    for (const layer of layers) {\n      validLayers[layer] = true;\n    }\n\n    const hasValidLayer = (node) => Boolean(node && node.layer in validLayers);\n    const lastLayer = layers[layers.length - 1];\n\n    // For each node\n    for (const node of nodes) {\n      // Find first descendant node that has a valid layer following rank order (including itself)\n      const layerNode = findNodeBy(\n        // Starting node\n        node,\n        // Next connected nodes to search\n        targetNodes,\n        // Lowest rank first\n        orderRankAscending,\n        // Acceptance criteria\n        hasValidLayer\n      );\n\n      // Assign the nearest layer if found otherwise must be the last layer\n      node.nearestLayer = layerNode ? layerNode.layer : lastLayer;\n    }\n  }\n};\n\n/**\n * Returns the list of target nodes directly connected to the given node\n * @param {object} node The input node\n * @returns {array} The target nodes\n */\nconst targetNodes = (node) => node.targets.map((edge) => edge.targetNode);\n\n/**\n * Comparator function for sorting nodes rank ascending\n * @param {object} nodeA The first input node\n * @param {object} nodeB The second input node\n * @returns {number} The signed difference\n */\nconst orderRankAscending = (nodeA, nodeB) => nodeA.rank - nodeB.rank;\n\n/**\n * Starting at the given node and expanding successors, returns the first node accepted in order\n * @param {object} node The starting node\n * @param {function} successors A function returning the next nodes to expand\n * @param {function} order A comparator function used for prioritising successors\n * @param {function} accept A function that returns true if the current node fits the criteria\n * @param {object=} visited An object keeping track of nodes already searched\n * @returns {?object} The first node accepted in order, or undefined if none\n */\nconst findNodeBy = (node, successors, order, accept, visited) => {\n  // If the current node is accepted then return it without further search\n  if (accept(node)) {\n    return node;\n  }\n\n  // Keep track of visited nodes\n  visited = visited || {};\n  visited[node.id] = true;\n\n  const results = successors(node)\n    // Remove successors already visited\n    .filter((successor) => !visited[successor.id])\n    // Order unvisited successors\n    .sort(order)\n    // Search the unvisited successors recursively\n    .map((successor) =>\n      findNodeBy(successor, successors, order, accept, visited)\n    )\n    // Keep only the accepted resulting nodes if any\n    .filter(accept)\n    // Order resulting nodes\n    .sort(order);\n\n  // Return the first node accepted in order, or undefined if none\n  return results[0];\n};\n\n/**\n * Finds the region bounding the given nodes\n * @param {array} nodes The input nodes\n * @param {number} padding Additional padding around the bounds\n * @returns {object} The bounds\n */\nconst bounds = (nodes, padding) => {\n  const size = {\n    min: { x: Infinity, y: Infinity },\n    max: { x: -Infinity, y: -Infinity },\n  };\n\n  for (const node of nodes) {\n    const x = node.x;\n    const y = node.y;\n\n    if (x < size.min.x) {\n      size.min.x = x;\n    }\n    if (x > size.max.x) {\n      size.max.x = x;\n    }\n    if (y < size.min.y) {\n      size.min.y = y;\n    }\n    if (y > size.max.y) {\n      size.max.y = y;\n    }\n  }\n\n  size.width = size.max.x - size.min.x + 2 * padding;\n  size.height = size.max.y - size.min.y + 2 * padding;\n  size.min.x -= padding;\n  size.min.y -= padding;\n\n  return size;\n};\n","import { graph } from './graph';\n\n/**\n * Calculate chart layout with experimental new graphing algorithm\n * This is an extremely expensive operation so we want it to run as infrequently\n * as possible, and keep it separate from other properties (like node.active)\n * which don't affect layout.\n */\nexport const graphNew = ({ nodes, edges, layers }) => {\n  const result = graph(nodes, edges, layers);\n  return {\n    ...result,\n    size: { ...result.size, marginx: 100, marginy: 100 },\n  };\n};\n"],"sourceRoot":""}